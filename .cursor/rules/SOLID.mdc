---
description: "SOLID принципы для всех файлов проекта - обязательные требования к архитектуре кода"
alwaysApply: true
globs: ["**/*.cpp", "**/*.h", "**/*.cs", "**/*.java"]
priority: 1
tags: ["architecture", "solid", "code-quality", "ue5", "cpp"]
---

# SOLID принципы для всех файлов

## Обязательные требования

Все классы и компоненты должны следовать принципам SOLID:

### Single Responsibility Principle (SRP)
- Каждый класс должен иметь только одну причину для изменения
- Максимальный размер класса: 300-400 строк
- Если класс делает больше одной вещи - разделить на несколько классов

### Open/Closed Principle (OCP)
- Классы должны быть открыты для расширения, но закрыты для модификации
- Использовать интерфейсы и абстракции вместо конкретных классов
- Полиморфизм через интерфейсы, а не наследование

### Liskov Substitution Principle (LSP)
- Подтипы должны быть заменяемы базовыми типами
- Не нарушать контракты базовых классов

### Interface Segregation Principle (ISP)
- Клиенты не должны зависеть от интерфейсов, которые они не используют
- Создавать маленькие, специфичные интерфейсы вместо больших общих

### Dependency Inversion Principle (DIP)
- Зависимости должны быть на абстракциях, а не на конкретных классах
- Использовать интерфейсы для зависимостей
- Избегать прямых зависимостей от конкретных классов (например, ALyraCharacter, ALyraPlayerController)

## Правила для UE5/C++

### Структура классов
- Один класс = одна ответственность
- Использовать композицию вместо наследования
- Создавать интерфейсы (UINTERFACE) для абстракций

### Размер файлов
- Максимум 300-400 строк на класс
- Если больше - разделить на несколько классов

### Зависимости
- Зависить от интерфейсов, а не от конкретных классов
- Использовать dependency injection через UPROPERTY

### Примеры нарушений

❌ **Плохо**: Класс делает всё
```cpp
class UWebSocketMovementSyncComponent {
    // Декодирование protobuf
    // Поиск контроллеров
    // Управление историей
    // Интерполяция
    // Применение движения
};
```

OK **Хорошо**: Разделение на классы
```cpp
class UPlayerIdResolver { /* только поиск */ };
class UEntityStateHistoryManager { /* только история */ };
class IMovementInterpolator { /* только интерполяция */ };
class IMovementApplier { /* только применение */ };
class UWebSocketMovementSyncComponent { /* координация */ };
```

**Реальный пример рефакторинга**: `WebSocketMovementSyncComponent` был разделён на 6 классов по SOLID.
См. `knowledge/analysis/optimization/SOLID-REFACTORING-COMPLETE.md` для деталей.

## Проверка перед коммитом

Перед созданием или изменением класса спросить:
1. Сколько ответственностей у этого класса? (должна быть одна)
2. Можно ли расширить функциональность без изменения класса? (OCP)
3. Зависит ли класс от конкретных классов? (DIP - должно быть от интерфейсов)
4. Размер класса больше 400 строк? (разделить)

## Исключения

Исключения допускаются только для:
- Генерируемых файлов (UCLASS с GENERATED_BODY)
- Системных классов UE5 (наследование от UObject, UActorComponent)
- Временных решений с TODO для последующего рефакторинга
