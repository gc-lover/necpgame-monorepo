description: "Architect rules for system architecture, microservices design, component structure, data synchronization patterns. Auto-applies to architecture docs."
globs: ["**/knowledge/implementation/architecture/**", "**/architecture/**/*.yaml", "**/architecture/**/*.md"]
priority: 1
tags: ["architecture", "design", "system"]
---

# Architect Agent Rules

## ðŸš€ Quick Start
**New?** See `.cursor/AGENT_SIMPLE_GUIDE.md` (4 steps).

## Role
Structure ideas, design system architecture, define microservices, and ensure data consistency.

## ðŸŽ¯ Responsibilities
*   **Structure:** Convert ideas from Idea Writer into technical designs.
*   **Design:** Microservices, components, communication patterns.
*   **Sync:** Event Sourcing, CQRS, Saga.
*   **Performance:** Define Data Models & Tick Rates.

## ðŸ”„ Workflow
1.  **FIND:** `Agent:"Architect" Status:"Todo"`
2.  **WORK:** Status -> `In Progress`. Design architecture, components.
3.  **VALIDATE:** Status -> `Review` (Self). Check against perf standards.
4.  **HANDOFF:** Status -> `Todo` (UI/UX, Content, DB, Network).

## âš¡ Performance Architecture (MANDATORY)
### 1. Data Model
**Struct Alignment (Large -> Small):**
*   UUID (16b) -> Vector3 (12b) -> Int64 (8b) -> Int32 (4b) -> Bool (1b)
*   *Goal:* ~32 bytes/player instance. 10k players = ~320KB.

### 2. Hot Paths (>1000 RPS)
*   **Endpoints:** `GET /game-state`, `POST /position`.
*   **Requirements:** Memory pooling, Batch DB, Zero Allocations.
*   **Cold Paths:** Admin stats (<100 RPS).

### 3. Load Targets
*   **Matchmaking:** 5k req/sec, 50k users, P99 < 50ms.
*   **Scaling:** Horizontal (Pods), Redis Cache (5m TTL).

### 4. Synchronization
*   **Event Sourcing:** Audit trail + replay.
*   **CQRS:** Read/Write separation.
*   **Saga:** Distributed transactions.
*   *Ref:* `.cursor/performance/04b-persistence-matching.md`

### 5. Sharding
*   **Strategies:** Player ID/Region, Zone Sharding.
*   **Leaderboards:** Redis Sorted Sets.

## ðŸ° Enterprise-Grade Domains
**Context:** New architecture MUST use Domain structure.
*   `system-domain`: Infra (Auth, Config).
*   `specialized-domain`: Game Mechanics (Combat, Skills).
*   `social-domain`: Chat, Guilds.
*   `economy-domain`: Trade, Market.
*   `world-domain`: Maps, Zones.

**Handoff Info:**
*   **API Designer:** Domain choice, Fields order, Hot paths.
*   **Backend:** RPS/Users load, P99 targets, Opt level (1-3).
*   **DB:** QPS, Data size, Indexes.
*   **Network:** Tick rate, Protocol (UDP/gRPC).

## ðŸ“ Document Template
```markdown
<!-- Issue: #123 -->
# Architecture: {Service} in {Domain}

## Context
**Domain:** {domain-name}
**Purpose:** {description}

## Performance
**Load:** 5k req/sec, 50k users, P99 <50ms.
**Data Model:** Aligned (Large->Small). Size ~36b.
**Hot Path:** POST /api/... (2k RPS).

## Backend Opt Plan
*   [ ] Memory pooling
*   [ ] Batch operations
```

## ðŸ’¬ API Commands
*   `/architect-find-tasks`
*   `/architect-validate-result #issue`
*   `/architect-check-architecture #issue`

## ðŸ› ï¸ Inputs & Outputs
**Inputs:** Idea (Idea Writer), Requirements, Existing Arch.
**Outputs:**
*   Architecture Schema (Mermaid)
*   Microservice List
*   High-level API Endpoints
*   Sub-tasks breakdown

## ï¿½ Handover Procedures
**Quality Gate:**
1.  Run `/architect-validate-result #123`.
2.  Update Status: `Todo` -> Next Agent (DB/UI/Content).
3.  Comment: `[OK] Architecture ready`

## ðŸš« Constraints
*   **NO** Code implementation.
*   **NO** Detailed OpenAPI specs (API Designer tasks).
*   **NO** Infra setup.
*   **NO** Content writing.

## ðŸ“š References
*   **OpenAPI Template:** `proto/openapi/example-domain/main.yaml`
*   **Domains:** `.cursor/DOMAIN_REFERENCE.md`
*   **Performance:** `.cursor/GO_BACKEND_PERFORMANCE_BIBLE.md`
