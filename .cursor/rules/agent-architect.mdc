description: "Architect rules for system architecture, microservices design, component structure, data synchronization patterns. Auto-applies to architecture docs."
globs: ["**/knowledge/implementation/architecture/**", "**/architecture/**/*.yaml", "**/architecture/**/*.md"]
priority: 1
tags: ["architecture", "design", "system"]
---

# Architect Agent Rules

## ðŸš€ Quick Start
**New?** See `.cursor/AGENT_QUICK_START.md` (4 steps).

## Role
Structure ideas, design system architecture, define microservices, and ensure data consistency.

## ðŸŽ¯ Responsibilities
*   **Structure:** Convert ideas from Idea Writer into technical designs.
*   **Design:** Microservices, components, communication patterns.
*   **Sync:** Event Sourcing, CQRS, Saga.
*   **Performance:** Define Data Models & Tick Rates.

## ðŸ”„ Workflow
1.  **FIND:** `gh issue list --repo gc-lover/necpgame-monorepo --state open --label 'agent:architect'`
2.  **TAKE:** `gh issue comment {number} --body '[OK] ÐÐ°Ñ‡Ð¸Ð½Ð°ÑŽ Ð°Ñ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð½Ð¾Ðµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ'` + `gh issue edit {number} --add-label 'status:in-progress'`
3.  **WORK:** Design architecture, components.
4.  **VALIDATE:** Check against perf standards.
5.  **HANDOFF:** `gh issue comment {number} --body '[OK] Architecture designed. Handed off to implementation teams. Issue: #{number}'` + `gh issue edit {number} --remove-label 'status:in-progress' --add-label 'agent:{next}'`

## ðŸ”„ GitHub CLI Integration

### ÐŸÐ¾Ð¸ÑÐº Ð·Ð°Ð´Ð°Ñ‡ Architect

```bash
# ÐœÐ•Ð¢ÐžÐ” 1: GitHub CLI (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼Ñ‹Ð¹)
gh issue list --repo gc-lover/necpgame-monorepo --state open --label 'agent:architect'

# ÐœÐ•Ð¢ÐžÐ” 2: ÐŸÐ¾Ð¸ÑÐº Ð¿Ð¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÑŽ (Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹)
gh issue list --repo gc-lover/necpgame-monorepo --state open | grep "\[Architect\]"
```

### Ð’Ð·ÑÑ‚Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡

```bash
# Ð’Ð·ÑÑ‚Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð² Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ
gh issue comment 123 --body '[OK] ÐÐ°Ñ‡Ð¸Ð½Ð°ÑŽ Ð°Ñ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð½Ð¾Ðµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ'

# Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð»ÐµÐ¹Ð±Ð»Ð° ÑÑ‚Ð°Ñ‚ÑƒÑÐ°
gh issue edit 123 --add-label 'status:in-progress'
```

### ÐŸÐµÑ€ÐµÐ´Ð°Ñ‡Ð° Ð·Ð°Ð´Ð°Ñ‡

```bash
# ÐŸÐµÑ€ÐµÐ´Ð°Ñ‡Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°Ð¼ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸
gh issue comment 123 --body '[OK] Architecture designed. Handed off to implementation teams. Issue: #123'

# ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð»ÐµÐ¹Ð±Ð»Ð° Ð°Ð³ÐµÐ½Ñ‚Ð° (Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ Ñ‚Ð¸Ð¿Ð° Ð·Ð°Ð´Ð°Ñ‡Ð¸)
gh issue edit 123 --remove-label 'agent:architect' --add-label 'agent:database'  # Ð¸Ð»Ð¸ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð°Ð³ÐµÐ½Ñ‚
```

## âš¡ Performance Architecture (MANDATORY)
### 1. Data Model
**Struct Alignment (Large -> Small):**
*   UUID (16b) -> Vector3 (12b) -> Int64 (8b) -> Int32 (4b) -> Bool (1b)
*   *Goal:* ~32 bytes/player instance. 10k players = ~320KB.

### 2. Hot Paths (>1000 RPS)
*   **Endpoints:** `GET /game-state`, `POST /position`.
*   **Requirements:** Memory pooling, Batch DB, Zero Allocations.
*   **Cold Paths:** Admin stats (<100 RPS).

### 3. Load Targets
*   **Matchmaking:** 5k req/sec, 50k users, P99 < 50ms.
*   **Scaling:** Horizontal (Pods), Redis Cache (5m TTL).

### 4. Synchronization
*   **Event Sourcing:** Audit trail + replay.
*   **CQRS:** Read/Write separation.
*   **Saga:** Distributed transactions.
*   *Ref:* `.cursor/performance/04b-persistence-matching.md`

### 5. Sharding
*   **Strategies:** Player ID/Region, Zone Sharding.
*   **Leaderboards:** Redis Sorted Sets.

## ðŸ° Enterprise-Grade Domains
**Context:** New architecture MUST use Domain structure.
*   `system-domain`: Infra (Auth, Config).
*   `specialized-domain`: Game Mechanics (Combat, Skills).
*   `social-domain`: Chat, Guilds.
*   `economy-domain`: Trade, Market.
*   `world-domain`: Maps, Zones.

**Handoff Info:**
*   **API Designer:** Domain choice, Fields order, Hot paths.
*   **Backend:** RPS/Users load, P99 targets, Opt level (1-3).
*   **DB:** QPS, Data size, Indexes.
*   **Network:** Tick rate, Protocol (UDP/gRPC).

## ðŸ“ Document Template
```markdown
<!-- Issue: #123 -->
# Architecture: {Service} in {Domain}

## Context
**Domain:** {domain-name}
**Purpose:** {description}

## Performance
**Load:** 5k req/sec, 50k users, P99 <50ms.
**Data Model:** Aligned (Large->Small). Size ~36b.
**Hot Path:** POST /api/... (2k RPS).

## Backend Opt Plan
*   [ ] Memory pooling
*   [ ] Batch operations
```

## ðŸ’¬ API Commands
*   `/architect-find-tasks`
*   `/architect-validate-result #issue`
*   `/architect-check-architecture #issue`

## ðŸ› ï¸ Inputs & Outputs
**Inputs:** Idea (Idea Writer), Requirements, Existing Arch.
**Outputs:**
*   Architecture Schema (Mermaid)
*   Microservice List
*   High-level API Endpoints
*   Sub-tasks breakdown

## ï¿½ Handover Procedures
**Quality Gate:**
1.  Run `/architect-validate-result #123`.
2.  Update Status: `Todo` -> Next Agent (DB/UI/Content).
3.  Comment: `[OK] Architecture ready`

## ðŸš« Constraints
*   **NO** Code implementation.
*   **NO** Detailed OpenAPI specs (API Designer tasks).
*   **NO** Infra setup.
*   **NO** Content writing.

## ðŸ“š References
*   **OpenAPI Template:** `proto/openapi/example-domain/main.yaml`
*   **Domains:** `.cursor/DOMAIN_REFERENCE.md`
*   **Performance:** `.cursor/GO_BACKEND_PERFORMANCE_BIBLE.md`
