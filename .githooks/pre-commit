#!/bin/bash

if ! command -v bash >/dev/null 2>&1; then
  exit 0
fi

ALLOWED_BRANCH="develop"
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "$ALLOWED_BRANCH" ]; then
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "[GIT_HOOK_ERROR] COMMIT_BLOCKED"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "ERROR_TYPE: commit_prohibited"
  echo "CURRENT_BRANCH: $CURRENT_BRANCH"
  echo "ALLOWED_BRANCH: $ALLOWED_BRANCH"
  echo "POLICY: Only 'develop' branch is allowed for commits"
  echo ""
  echo "RESTRICTIONS:"
  echo "  - Commits are restricted to: $ALLOWED_BRANCH"
  echo "  - Current branch '$CURRENT_BRANCH' is not allowed"
  echo "  - All work must be done in the '$ALLOWED_BRANCH' branch"
  echo ""
  echo "REQUIRED_ACTION: Switch to allowed branch before committing"
  echo "COMMAND: git checkout $ALLOWED_BRANCH"
  echo ""
echo "FOR_AI_AGENTS:"
echo "  WARNING CRITICAL: You MUST NEVER leave the '$ALLOWED_BRANCH' branch!"
echo "  WARNING FORBIDDEN: Committing in branch '$CURRENT_BRANCH' is PROHIBITED"
echo "  WARNING FORBIDDEN: You are NOT allowed to switch from '$ALLOWED_BRANCH'"
echo "  OK REQUIRED: You MUST be in '$ALLOWED_BRANCH' branch to commit"
echo "  OK REQUIRED: Never run 'git checkout -b' or 'git checkout <other-branch>'"
echo "  OK REQUIRED: Always work ONLY in '$ALLOWED_BRANCH' branch"
echo "  This repository enforces a strict policy: ONLY '$ALLOWED_BRANCH' branch is allowed."
echo "  You are currently on '$CURRENT_BRANCH' which violates this policy."
echo "  Switch to '$ALLOWED_BRANCH' immediately. Do NOT create or switch to other branches."
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

if [ ! -f "$PROJECT_ROOT/.github/file-size-config.sh" ]; then
  echo "Warning: file-size-config.sh not found, skipping pre-commit hook"
  exit 0
fi

if ! source "$PROJECT_ROOT/.github/file-size-config.sh" 2>/dev/null; then
  echo "Warning: Failed to source file-size-config.sh, skipping pre-commit hook"
  exit 0
fi

echo "ğŸ” Checking file sizes before commit..."
echo "Max lines per file: $MAX_LINES"
echo ""

FAILED_FILES=()
CHECKED_COUNT=0

if [ -n "$TMPDIR" ]; then
  TEMP_DIR="$TMPDIR"
elif [ -n "$TMP" ]; then
  TEMP_DIR="$TMP"
elif [ -d "/tmp" ]; then
  TEMP_DIR="/tmp"
else
  TEMP_DIR="."
fi

TEMP_FILE="$TEMP_DIR/git-diff-cached-$$"
trap "rm -f '$TEMP_FILE'" EXIT INT TERM

if ! git diff --cached --name-only --diff-filter=ACMRT > "$TEMP_FILE" 2>/dev/null; then
  echo "Warning: Failed to get staged files, skipping pre-commit hook"
  rm -f "$TEMP_FILE"
  exit 0
fi

while IFS= read -r file || [ -n "$file" ]; do
  if [ -z "$file" ] || [ ! -f "$file" ]; then
    continue
  fi
  
  if ! check_file_extension "$file"; then
    continue
  fi
  
  if is_excluded "$file"; then
    echo "â­ï¸  Skipping (excluded): $file"
    continue
  fi
  
  LINES=$(wc -l < "$file" 2>/dev/null || echo "0")
  if [ -z "$LINES" ] || [ "$LINES" = "" ]; then
    LINES="0"
  fi
  
  CHECKED_COUNT=$((CHECKED_COUNT + 1))
  
  if [ "$LINES" -gt "$MAX_LINES" ] 2>/dev/null; then
    FAILED_FILES+=("$file:$LINES")
    echo "âŒ $file has $LINES lines (max: $MAX_LINES)"
  else
    echo "OK $file has $LINES lines (OK)"
  fi
done < "$TEMP_FILE"

rm -f "$TEMP_FILE"

echo ""
echo "Files checked: $CHECKED_COUNT"

if [ ${#FAILED_FILES[@]} -gt 0 ]; then
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "[GIT_HOOK_ERROR] COMMIT_REJECTED_FILE_SIZE"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "ERROR_TYPE: file_size_exceeded"
  echo "MAX_LINES_ALLOWED: $MAX_LINES"
  echo "POLICY: Files must not exceed $MAX_LINES lines"
  echo ""
  echo "VIOLATING_FILES:"
  for entry in "${FAILED_FILES[@]}"; do
    IFS=':' read -r file lines <<< "$entry"
    EXCEED_BY=$((lines - MAX_LINES))
    echo "  - $file: $lines lines (exceeds by $EXCEED_BY lines)"
  done
  echo ""
  echo "REQUIRED_ACTION: Split files into smaller files"
  echo "RECOMMENDATION: ~300-400 lines per file for better maintainability"
  echo ""
  echo "FOR_AI_AGENTS:"
  echo "  This repository enforces a file size limit of $MAX_LINES lines per file."
  echo "  The following files exceed this limit and must be split:"
  for entry in "${FAILED_FILES[@]}"; do
    IFS=':' read -r file lines <<< "$entry"
    echo "    - $file ($lines lines)"
  done
  echo "  You must refactor these files into smaller files (max $MAX_LINES lines each)."
  echo "  Recommended approach: Split large files into multiple smaller files."
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  exit 1
else
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "OK All files are within the $MAX_LINES line limit"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
fi

# Issue: #1606 - Struct alignment check
echo ""
echo "ğŸ” Checking struct field alignment..."

if command -v fieldalignment >/dev/null 2>&1; then
  # Get staged Go files
  STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACMRT | grep '\.go$' || true)
  
  if [ -n "$STAGED_GO_FILES" ]; then
    # Check each staged Go file's directory
    for file in $STAGED_GO_FILES; do
      if [ -f "$file" ]; then
        DIR=$(dirname "$file")
        if [ -f "$DIR/go.mod" ] || [ -f "$PROJECT_ROOT/go.mod" ]; then
          # Run fieldalignment on the package
          if ! fieldalignment "$DIR/..." 2>/dev/null | grep -q "struct"; then
            # No alignment issues found
            :
          else
            echo "WARNING  Struct alignment issues found in $DIR"
            echo "   Run: fieldalignment -fix $DIR/..."
          fi
        fi
      fi
    done
  fi
else
  echo "WARNING  fieldalignment not installed. Run: go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest"
fi

# Issue: Run tests for all changed services (blocking)
# This hook runs tests for all services with changed Go files.
# Tests must pass before commit is allowed.
# Format: Same as file size check - clear error messages for AI agents.
# Skip: Set SKIP_TESTS=1 to bypass (emergency only).
if [ "$SKIP_TESTS" != "1" ]; then
  echo ""
  echo "ğŸ§ª Running tests for changed services..."

# Get changed services from staged files
CHANGED_SERVICES=$(git diff --cached --name-only --diff-filter=ACMRT | \
  grep -E '^services/([^/]+)/.*\.go$' | \
  sed 's|^services/\([^/]*\)/.*|\1|' | \
  sort -u || true)

FAILED_SERVICES=()
FAILED_TESTS=()
TESTED_COUNT=0

if [ -n "$CHANGED_SERVICES" ]; then
  for service in $CHANGED_SERVICES; do
    SERVICE_DIR="services/$service"
    
    if [ ! -d "$SERVICE_DIR" ]; then
      continue
    fi
    
    # Check if service has Go files
    if ! find "$SERVICE_DIR" -name "*.go" -type f | grep -q .; then
      continue
    fi
    
    echo "  ğŸƒ Testing $service..." | tr -d '\n'
    TESTED_COUNT=$((TESTED_COUNT + 1))
    
    cd "$SERVICE_DIR" || continue
    
    # Try Makefile test first, then fallback to go test
    if [ -f "Makefile" ] && grep -q "^test:" Makefile; then
      TEST_OUTPUT=$(make test 2>&1)
      TEST_EXIT=$?
    else
      # Check if there are any test files
      if find . -name "*_test.go" -type f | grep -q .; then
        TEST_OUTPUT=$(go test -v ./... 2>&1)
        TEST_EXIT=$?
      else
        echo " WARNING  (no tests)"
        cd - >/dev/null || continue
        continue
      fi
    fi
    
    if [ $TEST_EXIT -ne 0 ]; then
      echo " âŒ"
      FAILED_SERVICES+=("$service")
      
      # Extract failed test names from output
      # Pattern: --- FAIL: TestName (0.00s)
      # Pattern: FAIL    package/path    TestName    0.00s
      FAILED_TEST_NAMES=$(echo "$TEST_OUTPUT" | \
        grep -E "(--- FAIL:|FAIL\s+[^\s]+\s+[^\s]+)" | \
        sed -E 's/.*(FAIL|FAIL:)\s+([^\s\(]+).*/\2/' | \
        sed 's/://g' | \
        head -10 | \
        tr '\n' ',' | \
        sed 's/,$//' || echo "unknown")
      
      # Get error summary (first meaningful error line)
      ERROR_SUMMARY=$(echo "$TEST_OUTPUT" | \
        grep -E "(FAIL|panic|error|Error|assertion)" | \
        head -3 | \
        sed 's/^[[:space:]]*//' | \
        sed 's/[[:space:]]\+/ /g' | \
        tr '\n' '|' | \
        cut -c1-150 | \
        sed 's/|$//' || echo "test failure")
      
      FAILED_TESTS+=("$service:$FAILED_TEST_NAMES:$ERROR_SUMMARY")
    else
      echo " OK"
    fi
    
    cd - >/dev/null || continue
  done
  
  echo ""
  echo "Services tested: $TESTED_COUNT"
  
  if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "[GIT_HOOK_ERROR] COMMIT_REJECTED_TESTS_FAILED"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ERROR_TYPE: tests_failed"
    echo "POLICY: All tests must pass before commit"
    echo ""
    echo "FAILED_SERVICES:"
    for entry in "${FAILED_TESTS[@]}"; do
      IFS=':' read -r service tests error <<< "$entry"
      echo "  - Service: $service"
      if [ -n "$tests" ] && [ "$tests" != "unknown" ]; then
        echo "    Failed tests: $tests"
      fi
      if [ -n "$error" ]; then
        echo "    Error: $error"
      fi
      echo ""
    done
    echo "REQUIRED_ACTION: Fix failing tests before committing"
    echo "RECOMMENDATION: Run 'make test' or 'go test ./...' in each failed service directory"
    echo ""
    echo "NOTE: To skip tests (emergency only): SKIP_TESTS=1 git commit"
    echo ""
    echo "FOR_AI_AGENTS:"
    echo "  This repository enforces that all tests must pass before committing."
    echo "  The following services have failing tests:"
    for service in "${FAILED_SERVICES[@]}"; do
      echo "    - $service"
    done
    echo "  You must fix all failing tests before you can commit."
    echo "  Steps to fix:"
    echo "    1. Navigate to each failed service directory: cd services/<service-name>"
    echo "    2. Run tests: make test (or go test ./...)"
    echo "    3. Fix the failing tests"
    echo "    4. Verify tests pass: make test"
    echo "    5. Stage fixes: git add ."
    echo "    6. Try committing again"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    exit 1
  else
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "OK All tests passed ($TESTED_COUNT services)"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  fi
else
  echo "  â­ï¸  No changed services with Go files"
fi
else
  echo ""
  echo "â­ï¸  Skipping tests (SKIP_TESTS=1)"
fi

# Issue: Automatic benchmarks for changed services (optional, non-blocking)
if [ "$SKIP_BENCHMARKS" != "1" ]; then
  echo ""
  echo "ğŸ“Š Running quick benchmarks for changed services..."
  
  # Create results directory
  RESULTS_DIR=".benchmarks/results"
  mkdir -p "$RESULTS_DIR"
  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
  PRE_COMMIT_FILE="${RESULTS_DIR}/pre-commit_${TIMESTAMP}.json"
  
  # Get changed services from staged files
  CHANGED_SERVICES=$(git diff --cached --name-only --diff-filter=ACMRT | \
    grep -E '^services/([^/]+)/server/.*\.go$' | \
    sed 's|^services/\([^/]*\)/.*|\1|' | \
    sort -u || true)
  
  if [ -n "$CHANGED_SERVICES" ]; then
    # Start JSON output
    echo "{\"timestamp\":\"$TIMESTAMP\",\"source\":\"pre-commit\",\"services\":[" > "$PRE_COMMIT_FILE"
    
    FIRST=true
    BENCH_COUNT=0
    
    for service in $CHANGED_SERVICES; do
      SERVICE_DIR="services/$service"
      BENCH_FILE="$SERVICE_DIR/server/handlers_bench_test.go"
      
      if [ -f "$BENCH_FILE" ]; then
        echo "  ğŸƒ $service" | tr -d '\n'
        cd "$SERVICE_DIR" || continue
        
        # Run benchmarks with JSON output
        BENCH_OUTPUT=$(go test -run=^$$ -bench=. -benchmem -benchtime=100ms -json ./server 2>&1 || echo "")
        
        if [ -n "$BENCH_OUTPUT" ] && ! echo "$BENCH_OUTPUT" | grep -q "no test files"; then
          # Check if jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo " WARNING  (jq not found, skipping JSON save)"
            # Still run quick check
            if echo "$BENCH_OUTPUT" | grep -q '"Action":"bench"'; then
            echo " OK"
          else
              echo " WARNING  (failed)"
          fi
        else
            # Parse JSON and add to results
            if [ "$FIRST" = false ]; then
              echo "," >> "$PRE_COMMIT_FILE"
            fi
            FIRST=false
            
            echo -n "{\"service\":\"$service\",\"benchmarks\":[" >> "$PRE_COMMIT_FILE"
            
            # Extract benchmark lines and format JSON
            BENCH_JSON=$(echo "$BENCH_OUTPUT" | jq -r 'select(.Action=="bench") | "{\"name\":\"\(.Package)/\(.Test)\",\"ns_per_op\":\(.NsPerOp // 0),\"allocs_per_op\":\(.AllocsPerOp // 0),\"bytes_per_op\":\(.BytesPerOp // 0)}"' | tr '\n' ',' | sed 's/,$//')
            
            if [ -n "$BENCH_JSON" ]; then
              echo -n "$BENCH_JSON" >> "$PRE_COMMIT_FILE"
            fi
            
            echo "]}" >> "$PRE_COMMIT_FILE"
            
            # Count benchmarks from file
            if [ -f "$PRE_COMMIT_FILE" ]; then
              BENCH_COUNT=$(jq '[.services[].benchmarks | length] | add' "$PRE_COMMIT_FILE" 2>/dev/null || echo "0")
            fi
            
            echo " OK"
          fi
        else
          echo " WARNING  (no benchmarks)"
        fi
        
        cd - >/dev/null || continue
      fi
    done
    
    echo "]}" >> "$PRE_COMMIT_FILE"
    
    # Check if file has valid data
    if [ -f "$PRE_COMMIT_FILE" ] && [ -s "$PRE_COMMIT_FILE" ]; then
      FILE_BENCH_COUNT=$(jq '[.services[].benchmarks | length] | add' "$PRE_COMMIT_FILE" 2>/dev/null || echo "0")
      if [ "$FILE_BENCH_COUNT" != "0" ] && [ "$FILE_BENCH_COUNT" != "null" ]; then
        echo "  ğŸ’¾ Results saved to: $PRE_COMMIT_FILE ($FILE_BENCH_COUNT benchmarks)"
      else
        # Remove empty file
        rm -f "$PRE_COMMIT_FILE"
      fi
    fi
  else
    echo "  â­ï¸  No changed services with benchmarks"
  fi
fi

exit 0

