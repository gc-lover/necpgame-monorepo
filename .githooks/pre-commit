#!/bin/bash

if ! command -v bash >/dev/null 2>&1; then
  exit 0
fi

ALLOWED_BRANCH="develop"
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "$ALLOWED_BRANCH" ]; then
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "[GIT_HOOK_ERROR] COMMIT_BLOCKED"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "ERROR_TYPE: commit_prohibited"
  echo "CURRENT_BRANCH: $CURRENT_BRANCH"
  echo "ALLOWED_BRANCH: $ALLOWED_BRANCH"
  echo "POLICY: Only 'develop' branch is allowed for commits"
  echo ""
  echo "RESTRICTIONS:"
  echo "  - Commits are restricted to: $ALLOWED_BRANCH"
  echo "  - Current branch '$CURRENT_BRANCH' is not allowed"
  echo "  - All work must be done in the '$ALLOWED_BRANCH' branch"
  echo ""
  echo "REQUIRED_ACTION: Switch to allowed branch before committing"
  echo "COMMAND: git checkout $ALLOWED_BRANCH"
  echo ""
echo "FOR_AI_AGENTS:"
echo "  WARNING CRITICAL: You MUST NEVER leave the '$ALLOWED_BRANCH' branch!"
echo "  WARNING FORBIDDEN: Committing in branch '$CURRENT_BRANCH' is PROHIBITED"
echo "  WARNING FORBIDDEN: You are NOT allowed to switch from '$ALLOWED_BRANCH'"
echo "  OK REQUIRED: You MUST be in '$ALLOWED_BRANCH' branch to commit"
echo "  OK REQUIRED: Never run 'git checkout -b' or 'git checkout <other-branch>'"
echo "  OK REQUIRED: Always work ONLY in '$ALLOWED_BRANCH' branch"
echo "  This repository enforces a strict policy: ONLY '$ALLOWED_BRANCH' branch is allowed."
echo "  You are currently on '$CURRENT_BRANCH' which violates this policy."
echo "  Switch to '$ALLOWED_BRANCH' immediately. Do NOT create or switch to other branches."
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

if [ ! -f "$PROJECT_ROOT/.github/file-size-config.sh" ]; then
  echo "Warning: file-size-config.sh not found, skipping pre-commit hook"
  exit 0
fi

if ! source "$PROJECT_ROOT/.github/file-size-config.sh" 2>/dev/null; then
  echo "Warning: Failed to source file-size-config.sh, skipping pre-commit hook"
  exit 0
fi

echo "ğŸ” Checking file sizes before commit..."
echo "Max lines per file: $MAX_LINES"
echo ""

FAILED_FILES=()
CHECKED_COUNT=0

if [ -n "$TMPDIR" ]; then
  TEMP_DIR="$TMPDIR"
elif [ -n "$TMP" ]; then
  TEMP_DIR="$TMP"
elif [ -d "/tmp" ]; then
  TEMP_DIR="/tmp"
else
  TEMP_DIR="."
fi

TEMP_FILE="$TEMP_DIR/git-diff-cached-$$"
trap "rm -f '$TEMP_FILE'" EXIT INT TERM

if ! git diff --cached --name-only --diff-filter=ACMRT > "$TEMP_FILE" 2>/dev/null; then
  echo "Warning: Failed to get staged files, skipping pre-commit hook"
  rm -f "$TEMP_FILE"
  exit 0
fi

while IFS= read -r file || [ -n "$file" ]; do
  if [ -z "$file" ] || [ ! -f "$file" ]; then
    continue
  fi
  
  if ! check_file_extension "$file"; then
    continue
  fi
  
  if is_excluded "$file"; then
    echo "â­ï¸  Skipping (excluded): $file"
    continue
  fi
  
  LINES=$(wc -l < "$file" 2>/dev/null || echo "0")
  if [ -z "$LINES" ] || [ "$LINES" = "" ]; then
    LINES="0"
  fi
  
  CHECKED_COUNT=$((CHECKED_COUNT + 1))
  
  if [ "$LINES" -gt "$MAX_LINES" ] 2>/dev/null; then
    FAILED_FILES+=("$file:$LINES")
    echo "âŒ $file has $LINES lines (max: $MAX_LINES)"
  else
    echo "OK $file has $LINES lines (OK)"
  fi
done < "$TEMP_FILE"

rm -f "$TEMP_FILE"

echo ""
echo "Files checked: $CHECKED_COUNT"

if [ ${#FAILED_FILES[@]} -gt 0 ]; then
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "[GIT_HOOK_ERROR] COMMIT_REJECTED_FILE_SIZE"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "ERROR_TYPE: file_size_exceeded"
  echo "MAX_LINES_ALLOWED: $MAX_LINES"
  echo "POLICY: Files must not exceed $MAX_LINES lines"
  echo ""
  echo "VIOLATING_FILES:"
  for entry in "${FAILED_FILES[@]}"; do
    IFS=':' read -r file lines <<< "$entry"
    EXCEED_BY=$((lines - MAX_LINES))
    echo "  - $file: $lines lines (exceeds by $EXCEED_BY lines)"
  done
  echo ""
  echo "REQUIRED_ACTION: Split files into smaller files"
  echo "RECOMMENDATION: ~300-400 lines per file for better maintainability"
  echo ""
  echo "FOR_AI_AGENTS:"
  echo "  This repository enforces a file size limit of $MAX_LINES lines per file."
  echo "  The following files exceed this limit and must be split:"
  for entry in "${FAILED_FILES[@]}"; do
    IFS=':' read -r file lines <<< "$entry"
    echo "    - $file ($lines lines)"
  done
  echo "  You must refactor these files into smaller files (max $MAX_LINES lines each)."
  echo "  Recommended approach: Split large files into multiple smaller files."
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  exit 1
else
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "OK All files are within the $MAX_LINES line limit"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
fi

# Issue: #1606 - Struct alignment check
echo ""
echo "ğŸ” Checking struct field alignment..."

if command -v fieldalignment >/dev/null 2>&1; then
  # Get staged Go files
  STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACMRT | grep '\.go$' || true)
  
  if [ -n "$STAGED_GO_FILES" ]; then
    # Check each staged Go file's directory
    for file in $STAGED_GO_FILES; do
      if [ -f "$file" ]; then
        DIR=$(dirname "$file")
        if [ -f "$DIR/go.mod" ] || [ -f "$PROJECT_ROOT/go.mod" ]; then
          # Run fieldalignment on the package
          if ! fieldalignment "$DIR/..." 2>/dev/null | grep -q "struct"; then
            # No alignment issues found
            :
          else
            echo "WARNING  Struct alignment issues found in $DIR"
            echo "   Run: fieldalignment -fix $DIR/..."
          fi
        fi
      fi
    done
  fi
else
  echo "WARNING  fieldalignment not installed. Run: go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest"
fi

# Issue: Automatic benchmarks for changed services (optional, non-blocking)
if [ "$SKIP_BENCHMARKS" != "1" ]; then
  echo ""
  echo "ğŸ“Š Running quick benchmarks for changed services..."
  
  # Create results directory
  RESULTS_DIR=".benchmarks/results"
  mkdir -p "$RESULTS_DIR"
  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
  PRE_COMMIT_FILE="${RESULTS_DIR}/pre-commit_${TIMESTAMP}.json"
  
  # Get changed services from staged files
  CHANGED_SERVICES=$(git diff --cached --name-only --diff-filter=ACMRT | \
    grep -E '^services/([^/]+)/server/.*\.go$' | \
    sed 's|^services/\([^/]*\)/.*|\1|' | \
    sort -u || true)
  
  if [ -n "$CHANGED_SERVICES" ]; then
    # Start JSON output
    echo "{\"timestamp\":\"$TIMESTAMP\",\"source\":\"pre-commit\",\"services\":[" > "$PRE_COMMIT_FILE"
    
    FIRST=true
    BENCH_COUNT=0
    
    for service in $CHANGED_SERVICES; do
      SERVICE_DIR="services/$service"
      BENCH_FILE="$SERVICE_DIR/server/handlers_bench_test.go"
      
      if [ -f "$BENCH_FILE" ]; then
        echo "  ğŸƒ $service" | tr -d '\n'
        cd "$SERVICE_DIR" || continue
        
        # Run benchmarks with JSON output
        BENCH_OUTPUT=$(go test -run=^$$ -bench=. -benchmem -benchtime=100ms -json ./server 2>&1 || echo "")
        
        if [ -n "$BENCH_OUTPUT" ] && ! echo "$BENCH_OUTPUT" | grep -q "no test files"; then
          # Check if jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo " WARNING  (jq not found, skipping JSON save)"
            # Still run quick check
            if echo "$BENCH_OUTPUT" | grep -q '"Action":"bench"'; then
            echo " OK"
          else
              echo " WARNING  (failed)"
          fi
        else
            # Parse JSON and add to results
            if [ "$FIRST" = false ]; then
              echo "," >> "$PRE_COMMIT_FILE"
            fi
            FIRST=false
            
            echo -n "{\"service\":\"$service\",\"benchmarks\":[" >> "$PRE_COMMIT_FILE"
            
            # Extract benchmark lines and format JSON
            BENCH_JSON=$(echo "$BENCH_OUTPUT" | jq -r 'select(.Action=="bench") | "{\"name\":\"\(.Package)/\(.Test)\",\"ns_per_op\":\(.NsPerOp // 0),\"allocs_per_op\":\(.AllocsPerOp // 0),\"bytes_per_op\":\(.BytesPerOp // 0)}"' | tr '\n' ',' | sed 's/,$//')
            
            if [ -n "$BENCH_JSON" ]; then
              echo -n "$BENCH_JSON" >> "$PRE_COMMIT_FILE"
            fi
            
            echo "]}" >> "$PRE_COMMIT_FILE"
            
            # Count benchmarks from file
            if [ -f "$PRE_COMMIT_FILE" ]; then
              BENCH_COUNT=$(jq '[.services[].benchmarks | length] | add' "$PRE_COMMIT_FILE" 2>/dev/null || echo "0")
            fi
            
            echo " OK"
          fi
        else
          echo " WARNING  (no benchmarks)"
        fi
        
        cd - >/dev/null || continue
      fi
    done
    
    echo "]}" >> "$PRE_COMMIT_FILE"
    
    # Check if file has valid data
    if [ -f "$PRE_COMMIT_FILE" ] && [ -s "$PRE_COMMIT_FILE" ]; then
      FILE_BENCH_COUNT=$(jq '[.services[].benchmarks | length] | add' "$PRE_COMMIT_FILE" 2>/dev/null || echo "0")
      if [ "$FILE_BENCH_COUNT" != "0" ] && [ "$FILE_BENCH_COUNT" != "null" ]; then
        echo "  ğŸ’¾ Results saved to: $PRE_COMMIT_FILE ($FILE_BENCH_COUNT benchmarks)"
      else
        # Remove empty file
        rm -f "$PRE_COMMIT_FILE"
      fi
    fi
  else
    echo "  â­ï¸  No changed services with benchmarks"
  fi
fi

exit 0

