# Анализ работы QUIC подключения

## Проверка совместимости клиента и сервера

### OK ALPN протокол
- **Клиент**: использует `"h3"` (HTTP/3)
- **Сервер**: использует `"h3"` (HTTP/3)
- **Статус**: OK Совместимо

### OK Сертификаты
- **Сервер**: использует self-signed сертификат
- **Клиент**: использует `QUIC_CREDENTIAL_FLAG_NO_CERTIFICATE_VALIDATION`
- **Статус**: OK Совместимо для разработки

### OK Параметры подключения
- **Клиент**: IdleTimeout 30s, HandshakeTimeout 10s
- **Сервер**: maxIdleTimeout 30s
- **Статус**: OK Совместимо

## Обнаруженные проблемы

### 1. WARNING Управление стримами

**Проблема**: Клиент создает новый стрим для каждого сообщения и закрывает его флагом FIN, но не обрабатывает ответ в том же стриме.

**Текущий код**:
```cpp
Status = MsQuicApi->StreamSend(Stream, &Buffer, 1, QUIC_SEND_FLAG_FIN, nullptr);
```

**Решение**: 
- Вариант A: Не закрывать стрим сразу, дождаться ответа, затем закрыть
- Вариант B: Оставить как есть (каждый запрос = новый стрим), но убедиться, что ответ приходит в правильный стрим

**Рекомендация**: Вариант B проще для реализации, но нужно убедиться, что сервер отправляет ответ в тот же стрим.

### 2. WARNING Обработка ответов сервера

**Проблема**: Клиент получает данные через `QUIC_STREAM_EVENT_RECEIVE`, но сервер отправляет ответ в тот же стрим, который клиент уже закрыл флагом FIN.

**Проверка**: Сервер отправляет ответ через `stream.writeAndFlush(buffer)`, что должно работать даже если клиент закрыл стрим для записи.

**Статус**: Требует тестирования

### 3. WARNING Накопление буфера на сервере

**Проблема**: Сервер накапливает данные в буфере, но обработка может быть неполной, если сообщение приходит частями.

**Текущий код**:
```go
accumulatedBuffer.Write(msg)
// ...
try {
    sessionHandler.processMessage(data, stream)
    accumulatedBuffer.Reset()
} catch (Exception e) {
    // Ошибка - буфер не очищается
}
```

**Решение**: Улучшить обработку частичных сообщений или использовать длину сообщения.

### 4. WARNING Обработка ошибок подключения

**Проблема**: Если подключение не удается, клиент не вызывает `OnConnected.Broadcast(false)`.

**Текущий код**: Ошибки подключения логируются, но не передаются в UI.

**Решение**: Добавить обработку ошибок в `ConnectionCallback`.

### 5. OK Обработка peer stream

**Статус**: OK Правильно обрабатывается через `QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED`

## Рекомендации по исправлению

### Приоритет 1: Обработка ошибок подключения

Добавить обработку ошибок в `ConnectionCallback`:
```cpp
case QUIC_CONNECTION_EVENT_CONNECT_FAILED:
    AsyncTask(ENamedThreads::GameThread, [This]()
    {
        This->OnMsQuicDisconnected(TEXT("Connection failed"));
    });
    return QUIC_STATUS_SUCCESS;
```

### Приоритет 2: Улучшение обработки стримов

Убедиться, что ответы сервера правильно обрабатываются в закрытых стримах.

### Приоритет 3: Логирование

Добавить больше логирования для отладки:
- Время отправки сообщения
- Время получения ответа
- Размер сообщений
- Статус стримов

## Тестирование

### Тест 1: Базовое подключение
1. Запустить сервер
2. Запустить клиент
3. Проверить логи подключения

### Тест 2: Heartbeat
1. Отправить heartbeat
2. Проверить получение HeartbeatAck
3. Проверить обновление RTT

### Тест 3: PlayerInput
1. Отправить PlayerInput
2. Проверить обработку на сервере
3. Проверить получение GameState (если есть)

### Тест 4: Множественные сообщения
1. Отправить несколько сообщений подряд
2. Проверить, что все обрабатываются
3. Проверить порядок ответов

