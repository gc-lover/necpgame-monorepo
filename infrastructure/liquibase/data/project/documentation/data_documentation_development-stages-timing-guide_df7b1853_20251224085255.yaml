databaseChangeLog:
- changeSet:
    id: documentation-development-stages-timing-guide-df7b1853
    author: content-migration-generator
    changes:
    - insert:
        tableName: project.documentation
        columns:
        - column:
            name: id
            value: '-665772394076714'
        - column:
            name: doc_id
            value: development-stages-timing-guide
        - column:
            name: title
            value: Руководство по этапам работы с БД, синхронизацией и сетевыми оптимизациями
        - column:
            name: document_type
            value: architecture
        - column:
            name: category
            value: workflow
        - column:
            name: status
            value: draft
        - column:
            name: version
            value: 1.0.0
        - column:
            name: last_updated
            value: 2025-11-29 13:00:00+00:00
        - column:
            name: concept_approved
            value: false
        - column:
            name: concept_reviewed_at
            value: null
        - column:
            name: owners
            value: '[{"role": "architect", "contact": "architect@necp.game"}]'
        - column:
            name: tags
            value:
            - workflow
            - stages
            - database
            - synchronization
            - network
            - timing
        - column:
            name: topics
            value: []
        - column:
            name: related_systems
            value: []
        - column:
            name: related_documents
            value: '[{"id": "data-synchronization-consistency-guide", "relation":
              "extends"}, {"id": "hybrid-network-system-architecture", "relation":
              "extends"}]'
        - column:
            name: source
            value: ''
        - column:
            name: visibility
            value: internal
        - column:
            name: audience
            value:
            - architect
            - backend
            - database
            - network
        - column:
            name: risk_level
            value: ''
        - column:
            name: content
            value: '{"metadata": {"id": "development-stages-timing-guide", "title":
              "Руководство по этапам работы с БД, синхронизацией и сетевыми оптимизациями",
              "document_type": "architecture", "category": "workflow", "status": "draft",
              "version": "1.0.0", "last_updated": "2025-11-29T13:00:00+00:00", "owners":
              [{"role": "architect", "contact": "architect@necp.game"}], "tags": ["workflow",
              "stages", "database", "synchronization", "network", "timing"], "related_documents":
              [{"id": "data-synchronization-consistency-guide", "relation": "extends"},
              {"id": "hybrid-network-system-architecture", "relation": "extends"}],
              "visibility": "internal", "audience": ["architect", "backend", "database",
              "network"]}, "summary": {"problem": "Требуется определить оптимальные
              этапы разработки для работы с базами данных,\nсинхронизацией данных
              и сетевыми оптимизациями в контексте workflow агентов.\n", "goal": "Создать
              руководство по этапам работы с БД, синхронизацией и сетевыми оптимизациями\nдля
              правильной последовательности разработки.\n", "essence": "Определение
              оптимальных этапов для работы с БД (Database Engineer), синхронизацией\n(Architect)
              и сетевыми оптимизациями (Network Engineer) в контексте workflow агентов.\n"},
              "content": {"sections": [{"id": "database_development_stage", "title":
              "Этап работы с базами данных", "body": "## Когда заниматься базами данных\n\n###
              Оптимальный этап: После Architect, параллельно с API Designer\n\n**Почему:**\n-
              Database Engineer нужна архитектура от Architect (определение сущностей)\n-
              Database Engineer может работать параллельно с API Designer\n- API Designer
              описывает API схемы, Database Engineer проектирует БД схемы\n- Оба используют
              архитектуру от Architect как основу\n\n### Workflow\n\n```\n[Idea Writer]
              → [Architect]\n                   ↓\n            ┌──────┴──────┐\n            ↓              ↓\n    [Database
              Engineer]  [API Designer]\n            ↓              ↓\n            └──────┬──────┘\n                   ↓\n            [Backend
              Developer]\n```\n\n### Входные данные для Database Engineer\n\n**Обязательные:**\n-
              [OK] Архитектура от Architect (определяет сущности и их связи)\n- [OK]
              Требования к производительности\n\n**Желательные (но не обязательные):**\n-
              OpenAPI спецификация от API Designer (определяет поля API)\n- Существующие
              схемы БД\n\n**Важно:**\n- Database Engineer может начать работу сразу
              после Architect\n- OpenAPI спецификация помогает, но не обязательна\n-
              Database Engineer может скорректировать схемы после получения OpenAPI\n\n###
              Что делает Database Engineer\n\n**На этапе database-dev:**\n1. Проектирует
              детальные схемы БД (таблицы, связи, индексы)\n2. Создает Liquibase миграции
              в `infrastructure/liquibase/`\n3. Оптимизирует запросы и индексы\n4.
              Определяет стратегию миграций\n5. Работает с репликацией и партиционированием\n\n**Когда
              передается дальше:**\n- Схема БД спроектирована\n- Миграции созданы\n-
              Индексы определены\n- Constraints настроены\n- Готово к использованию
              Backend Developer\n"}, {"id": "synchronization_development_stage", "title":
              "Этап работы с синхронизацией", "body": "## Когда заниматься синхронизацией\n\n###
              Оптимальный этап: На этапе Architect\n\n**Почему:**\n- Синхронизация
              - это архитектурная задача\n- Требует проектирования компонентов системы\n-
              Определения паттернов взаимодействия\n- Проектирования Event Bus архитектуры\n-
              Определения стратегий консистентности\n\n### Workflow\n\n```\n[Idea
              Writer] → [Architect]\n                   ↓\n            (проектирует
              синхронизацию)\n                   ↓\n            ┌──────┴──────┐\n            ↓              ↓\n    [Database
              Engineer]  [API Designer]\n            ↓              ↓\n            └──────┬──────┘\n                   ↓\n            [Backend
              Developer]\n                   ↓\n            (использует архитектуру
              синхронизации)\n```\n\n### Что делает Architect на этапе синхронизации\n\n**На
              этапе architect:**\n1. Проектирует архитектуру синхронизации между слоями\n2.
              Определяет компоненты системы синхронизации\n3. Выбирает паттерны синхронизации
              (Event Sourcing, CQRS, Saga Pattern)\n4. Проектирует Event Bus архитектуру\n5.
              Определяет стратегии консистентности (Strong vs Eventual)\n6. Проектирует
              механизмы разрешения конфликтов\n7. Определяет взаимодействие между
              микросервисами\n\n**Выходные данные:**\n- Архитектурная схема системы
              синхронизации\n- Определение компонентов (Event Bus, Outbox Pattern,
              Saga Pattern)\n- Паттерны синхронизации для разных сценариев\n- Стратегии
              консистентности для разных типов данных\n- Техническое задание для реализации\n\n**Когда
              передается дальше:**\n- Архитектура синхронизации спроектирована\n-
              Компоненты определены\n- Паттерны выбраны\n- Разбиение на подзадачи
              готово\n- Готово к работе API Designer и Database Engineer\n\n### Важно\n\n-
              **Синхронизация проектируется на этапе Architect**, а не на этапе Backend\n-
              Backend Developer использует готовую архитектуру синхронизации\n- Database
              Engineer проектирует схемы БД с учетом архитектуры синхронизации\n-
              API Designer описывает API с учетом паттернов синхронизации\n"}, {"id":
              "network_optimization_stage", "title": "Этап работы с сетевыми оптимизациями",
              "body": "## Когда заниматься сетевыми оптимизациями\n\n### Оптимальный
              этап: Два этапа\n\n**1. Проектирование тикрейта и требований (на этапе
              Architect):**\n- Проектирование тикрейта для разных механик\n- Определение
              требований к сетевой нагрузке\n- Проектирование адаптивного тикрейта\n\n**2.
              Реализация и оптимизация (после Backend, перед UE5):**\n- Настройка
              Envoy proxy\n- Оптимизация Protocol Buffers\n- Оптимизация realtime
              синхронизации\n- Настройка сетевой безопасности\n\n### Workflow\n\n```\n[Idea
              Writer] → [Architect]\n                   ↓\n            (проектирует
              тикрейт и требования)\n                   ↓\n            [API Designer]
              → [Backend Developer]\n                                   ↓\n                            [Network
              Engineer]\n                            (реализует и оптимизирует)\n                                   ↓\n                            [UE5
              Developer]\n```\n\n### Этап 1: Проектирование (Architect)\n\n**На этапе
              architect:**\n1. Проектирует тикрейт для разных механик:\n   - PvE зоны:
              20-30 Hz (WebSocket)\n   - PvP small: 60-128 Hz (UDP)\n   - GvG 200:
              60-80 Hz (UDP)\n   - GvG 400: 40-60 Hz (UDP)\n   - Massive war: 20-40
              Hz (UDP)\n2. Определяет требования к сетевой нагрузке\n3. Проектирует
              адаптивный тикрейт\n4. Учитывает нагрузку на сеть в зависимости от типа
              активностей\n\n**Выходные данные:**\n- Спецификация тикрейта для разных
              механик\n- Требования к сетевой нагрузке\n- Документация требований
              к тикрейту\n\n### Этап 2: Реализация (Network Engineer)\n\n**На этапе
              network-dev:**\n1. Настраивает Envoy proxy\n2. Оптимизирует gRPC/WebSocket
              соединения\n3. Работает с Protocol Buffers для сети\n4. Оптимизирует
              realtime синхронизацию\n5. Настраивает сетевую безопасность\n6. Реализует
              адаптивный тикрейт согласно архитектуре\n\n**Входные данные:**\n- Требования
              к тикрейту от Architect\n- Готовый бекенд от Backend Developer\n- Существующие
              Protocol Buffers\n- Конфигурация Envoy\n\n**Выходные данные:**\n- Конфигурация
              Envoy в `infrastructure/envoy/`\n- Обновления Protocol Buffers в `proto/realtime/`\n-
              Оптимизации сетевого кода\n- Конфигурация адаптивного тикрейта\n- Документация
              сетевой архитектуры\n\n**Когда передается дальше:**\n- Envoy настроен\n-
              Протокол оптимизирован\n- Realtime синхронизация работает\n- Тикрейт
              реализован для всех типов активностей\n- Нагрузка на сеть рассчитана
              и учтена\n- Готово к интеграции с UE5 клиентом\n"}, {"id": "complete_workflow",
              "title": "Полный workflow с учетом всех этапов", "body": "## Рекомендуемая
              последовательность\n\n### Для системных задач (требуют архитектуры):\n\n```\n1.
              [Idea Writer]\n   ↓\n2. [Architect]\n   ├─ Проектирует архитектуру системы\n   ├─
              Проектирует синхронизацию данных ⭐\n   ├─ Проектирует тикрейт и сетевые
              требования ⭐\n   └─ Определяет компоненты и микросервисы\n   ↓\n3. [Database
              Engineer] (параллельно с API Designer)\n   ├─ Проектирует схемы БД\n   ├─
              Создает Liquibase миграции\n   └─ Учитывает архитектуру синхронизации\n   ↓\n4.
              [API Designer] (параллельно с Database Engineer)\n   ├─ Создает OpenAPI
              спецификации\n   ├─ Описывает API схемы\n   └─ Учитывает паттерны синхронизации\n   ↓\n5.
              [Backend Developer]\n   ├─ Реализует Go сервисы\n   ├─ Использует готовые
              миграции от Database Engineer\n   ├─ Реализует архитектуру синхронизации
              от Architect\n   └─ Использует OpenAPI спецификации\n   ↓\n6. [Network
              Engineer]\n   ├─ Реализует тикрейт согласно архитектуре\n   ├─ Настраивает
              Envoy\n   ├─ Оптимизирует Protocol Buffers\n   └─ Оптимизирует realtime
              синхронизацию\n   ↓\n7. [Security Agent]\n   ├─ Аудит безопасности\n   └─
              Валидация входных данных\n   ↓\n8. [DevOps]\n   ├─ Настраивает инфраструктуру\n   └─
              Настраивает observability\n   ↓\n9. [UE5 Developer] → [QA] → [Game Balance]
              → [Release]\n```\n\n### Ключевые моменты\n\n**Синхронизация:**\n- ⭐
              Проектируется на этапе **Architect**\n- Реализуется на этапе **Backend
              Developer**\n- Используется на всех последующих этапах\n\n**Базы данных:**\n-
              Проектируются на этапе **Database Engineer** (после Architect)\n- Могут
              работать параллельно с **API Designer**\n- Используются на этапе **Backend
              Developer**\n\n**Сетевые оптимизации:**\n- ⭐ Тикрейт проектируется на
              этапе **Architect**\n- Реализуется на этапе **Network Engineer** (после
              Backend)\n- Интегрируется с **UE5 Developer**\n"}, {"id": "timing_recommendations",
              "title": "Рекомендации по срокам", "body": "## Когда начинать работу\n\n###
              Базы данных\n\n**Начинать:** Сразу после Architect\n**Параллельно с:**
              API Designer\n**Завершать:** До начала Backend Developer\n\n**Приоритет:**\n-
              Высокий - миграции нужны Backend Developer\n- Можно начать до получения
              OpenAPI спецификации\n- Скорректировать после получения OpenAPI\n\n###
              Синхронизация\n\n**Начинать:** На этапе Architect\n**Завершать:** На
              этапе Architect (перед передачей API Designer)\n**Использовать:** На
              всех последующих этапах\n\n**Приоритет:**\n- Критичный - основа для
              всей системы\n- Должна быть спроектирована до Database Engineer и API
              Designer\n- Влияет на проектирование БД и API\n\n### Сетевые оптимизации\n\n**Проектирование
              тикрейта:**\n- Начинать: На этапе Architect\n- Завершать: На этапе Architect\n-
              Приоритет: Высокий (влияет на архитектуру)\n\n**Реализация и оптимизация:**\n-
              Начинать: После Backend Developer\n- Завершать: До UE5 Developer\n-
              Приоритет: Высокий (нужно для клиента)\n\n## Параллельная работа\n\n###
              Можно работать параллельно\n\n- **Database Engineer** и **API Designer**
              - после Architect\n- **Performance Engineer** - на любом этапе\n- **Security
              Agent** - после Backend/Network\n\n### Нельзя работать параллельно\n\n-
              **Backend Developer** требует готовые миграции и OpenAPI\n- **Network
              Engineer** требует готовый бекенд\n- **UE5 Developer** требует готовый
              бекенд и сетевую часть\n"}, {"id": "dependencies", "title": "Зависимости
              между этапами", "body": "## Граф зависимостей\n\n```\nIdea Writer\n   ↓\nArchitect\n   ├─→
              Database Engineer (нужна архитектура)\n   ├─→ API Designer (нужна архитектура)\n   └─→
              Backend Developer (нужна архитектура)\n        ↓\nDatabase Engineer
              ──┐\n                    ├─→ Backend Developer (нужны миграции)\nAPI
              Designer ───────┘\n        ↓\nBackend Developer\n   ↓\nNetwork Engineer
              (нужен бекенд)\n   ↓\nSecurity Agent\n   ↓\nDevOps\n   ↓\nUE5 Developer\n```\n\n##
              Критические зависимости\n\n### Database Engineer зависит от:\n- [OK]
              Architect (архитектура обязательна)\n- [WARNING] API Designer (желательно,
              но не обязательно)\n\n### API Designer зависит от:\n- [OK] Architect
              (архитектура обязательна)\n\n### Backend Developer зависит от:\n- [OK]
              Architect (архитектура обязательна)\n- [OK] Database Engineer (миграции
              обязательны)\n- [OK] API Designer (OpenAPI спецификация обязательна)\n\n###
              Network Engineer зависит от:\n- [OK] Architect (тикрейт и требования
              обязательны)\n- [OK] Backend Developer (бекенд желателен для оптимизации)\n\n###
              Синхронизация зависит от:\n- [OK] Architect (проектируется на этом этапе)\n-
              [WARNING] Database Engineer (использует схемы БД)\n- [WARNING] API Designer
              (использует API схемы)\n"}, {"id": "best_practices", "title": "Лучшие
              практики", "body": "## Рекомендации\n\n### 1. Синхронизация - на этапе
              Architect\n\n**Почему:**\n- Синхронизация влияет на всю архитектуру
              системы\n- Определяет паттерны взаимодействия между сервисами\n- Влияет
              на проектирование БД и API\n- Должна быть спроектирована до Database
              Engineer и API Designer\n\n**Что делать:**\n- Проектировать синхронизацию
              на этапе Architect\n- Определять паттерны (Event Sourcing, CQRS, Saga
              Pattern)\n- Проектировать Event Bus архитектуру\n- Определять стратегии
              консистентности\n\n### 2. Базы данных - после Architect, параллельно
              с API Designer\n\n**Почему:**\n- Database Engineer нужна архитектура
              от Architect\n- Может работать параллельно с API Designer\n- OpenAPI
              спецификация помогает, но не обязательна\n- Миграции нужны Backend Developer\n\n**Что
              делать:**\n- Начинать работу сразу после Architect\n- Работать параллельно
              с API Designer\n- Использовать архитектуру синхронизации от Architect\n-
              Скорректировать схемы после получения OpenAPI\n\n### 3. Сетевые оптимизации
              - два этапа\n\n**Почему:**\n- Тикрейт влияет на архитектуру (проектируется
              на Architect)\n- Реализация требует готовый бекенд (Network Engineer)\n-
              Интеграция с клиентом требует готовую сетевую часть\n\n**Что делать:**\n-
              Проектировать тикрейт на этапе Architect\n- Реализовывать и оптимизировать
              на этапе Network Engineer\n- Учитывать требования к тикрейту при проектировании
              архитектуры\n\n### 4. Не пропускать этапы\n\n**Почему:**\n- Каждый этап
              зависит от предыдущего\n- Пропуск этапов приводит к проблемам\n- Переделки
              дороже правильной последовательности\n\n**Что делать:**\n- Следовать
              workflow агентов\n- Не начинать Backend без миграций и OpenAPI\n- Не
              начинать Network без архитектуры тикрейта\n- Не начинать UE5 без готового
              бекенда и сетевой части\n"}]}, "appendix": {"glossary": [{"term": "Development
              Stage", "definition": "Этап разработки в workflow агентов (idea-writer,
              architect, database-dev, api-designer, backend-dev, network-dev, и т.д.)"},
              {"term": "Parallel Work", "definition": "Работа нескольких агентов одновременно
              над разными аспектами задачи"}, {"term": "Sequential Work", "definition":
              "Работа агентов последовательно, где каждый зависит от предыдущего"},
              {"term": "Critical Path", "definition": "Последовательность этапов,
              которые нельзя пропустить или выполнить параллельно"}], "references":
              [{"title": "Agent Workflow", "link": ".github/AGENT_WORKFLOW.md"}, {"title":
              "Data Synchronization Guide", "link": "knowledge/implementation/architecture/data-synchronization-consistency-guide.yaml"},
              {"title": "Hybrid Network Architecture", "link": "knowledge/implementation/architecture/hybrid-network-system-architecture.yaml"}],
              "decisions": [{"date": "2025-11-29", "decision": "Синхронизация проектируется
              на этапе Architect", "rationale": "Синхронизация влияет на всю архитектуру
              системы и должна быть спроектирована до Database Engineer и API Designer."},
              {"date": "2025-11-29", "decision": "Database Engineer работает после
              Architect, параллельно с API Designer", "rationale": "Database Engineer
              нужна архитектура, но может работать параллельно с API Designer для
              ускорения разработки."}, {"date": "2025-11-29", "decision": "Тикрейт
              проектируется на Architect, реализуется на Network Engineer", "rationale":
              "Тикрейт влияет на архитектуру, но реализация требует готовый бекенд."}]}}'
        - column:
            name: metadata
            value: '{"id": "development-stages-timing-guide", "title": "Руководство
              по этапам работы с БД, синхронизацией и сетевыми оптимизациями", "document_type":
              "architecture", "category": "workflow", "status": "draft", "version":
              "1.0.0", "last_updated": "2025-11-29T13:00:00+00:00", "owners": [{"role":
              "architect", "contact": "architect@necp.game"}], "tags": ["workflow",
              "stages", "database", "synchronization", "network", "timing"], "related_documents":
              [{"id": "data-synchronization-consistency-guide", "relation": "extends"},
              {"id": "hybrid-network-system-architecture", "relation": "extends"}],
              "visibility": "internal", "audience": ["architect", "backend", "database",
              "network"]}'
        - column:
            name: source_file
            value: knowledge\implementation\architecture\development-stages-timing-guide.yaml
