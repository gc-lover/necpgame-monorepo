<?xml version="1.0" encoding="UTF-8"?>
<!-- Issue: #479 -->
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.17.xsd">

    <property name="quest.branching.schema" value="quest_branching"/>

    <changeSet id="quest-branching-ext-pgcrypto" author="db">
        <comment>Enable pgcrypto for UUID generation in quest branching PoC. Issue #479</comment>
        <sql>CREATE EXTENSION IF NOT EXISTS pgcrypto;</sql>
        <rollback>DROP EXTENSION IF EXISTS pgcrypto;</rollback>
    </changeSet>

    <changeSet id="quest-branching-schema" author="db">
        <comment>Create isolated schema for quest branching PoC. Issue #479</comment>
        <sql>CREATE SCHEMA IF NOT EXISTS ${quest.branching.schema};</sql>
        <rollback>DROP SCHEMA IF EXISTS ${quest.branching.schema} CASCADE;</rollback>
    </changeSet>

    <changeSet id="quest-branching-table-quest-branches" author="db" runInTransaction="true">
        <comment>Core quest branch catalog with shadow-ready columns. Issue #479</comment>
        <sql>
            CREATE TABLE IF NOT EXISTS ${quest.branching.schema}.quest_branches (
                id BIGSERIAL PRIMARY KEY,
                quest_id VARCHAR(100) NOT NULL,
                branch_id VARCHAR(50) NOT NULL,
                branch_name VARCHAR(200) NOT NULL,
                description TEXT,
                reward_modifiers JSONB DEFAULT '{}'::jsonb,
                reputation_changes JSONB DEFAULT '{}'::jsonb,
                branch_rewards JSONB DEFAULT '{}'::jsonb,
                conditions JSONB DEFAULT '{}'::jsonb,
                sets_flags JSONB DEFAULT '[]'::jsonb,
                unsets_flags JSONB DEFAULT '[]'::jsonb,
                unlocks_quests JSONB DEFAULT '[]'::jsonb,
                locks_quests JSONB DEFAULT '[]'::jsonb,
                world_state_changes JSONB DEFAULT '{}'::jsonb,
                difficulty_modifier NUMERIC(4,2) DEFAULT 1.00,
                moral_weight VARCHAR(20),
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                CONSTRAINT uq_quest_branch UNIQUE(quest_id, branch_id),
                CONSTRAINT ck_difficulty_modifier CHECK (difficulty_modifier &gt;= 0.10 AND difficulty_modifier &lt;= 5.00),
                CONSTRAINT ck_moral_weight CHECK (moral_weight IS NULL OR moral_weight IN ('GOOD','EVIL','NEUTRAL','GREY'))
            );
            CREATE INDEX IF NOT EXISTS idx_qb_lookup ON ${quest.branching.schema}.quest_branches (quest_id, branch_id) INCLUDE (id, moral_weight);
            CREATE INDEX IF NOT EXISTS idx_qb_moral ON ${quest.branching.schema}.quest_branches (moral_weight) WHERE moral_weight IS NOT NULL;
            COMMENT ON TABLE ${quest.branching.schema}.quest_branches IS 'Ветви квестов для PoC ветвления (Issue #479)';
            COMMENT ON COLUMN ${quest.branching.schema}.quest_branches.conditions IS 'JSONB: условия активации {flags: [], reputation: {}, choices: []}';
            COMMENT ON COLUMN ${quest.branching.schema}.quest_branches.world_state_changes IS 'JSONB: изменения world state';
            COMMENT ON COLUMN ${quest.branching.schema}.quest_branches.difficulty_modifier IS 'Диапазон 0.10 - 5.00; влияет на расчёты наград/сложности';
        </sql>
        <rollback>
            DROP TABLE IF EXISTS ${quest.branching.schema}.quest_branches CASCADE;
        </rollback>
    </changeSet>

    <changeSet id="quest-branching-table-branch-events" author="db">
        <comment>Shadow-write target for branch choices with audit fields. Issue #479</comment>
        <sql>
            CREATE TABLE IF NOT EXISTS ${quest.branching.schema}.quest_branch_events (
                id BIGSERIAL PRIMARY KEY,
                player_id BIGINT NOT NULL,
                quest_id VARCHAR(100) NOT NULL,
                branch_id VARCHAR(50) NOT NULL,
                session_id UUID NOT NULL DEFAULT gen_random_uuid(),
                chosen_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                client_version VARCHAR(32),
                shadow_source VARCHAR(64) DEFAULT 'poc',
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                CONSTRAINT fk_event_branch FOREIGN KEY (quest_id, branch_id)
                    REFERENCES ${quest.branching.schema}.quest_branches (quest_id, branch_id) ON DELETE CASCADE
            );
            CREATE INDEX IF NOT EXISTS idx_qbe_player ON ${quest.branching.schema}.quest_branch_events (player_id, quest_id, branch_id);
            CREATE INDEX IF NOT EXISTS idx_qbe_branch ON ${quest.branching.schema}.quest_branch_events (quest_id, branch_id, chosen_at DESC);
        </sql>
        <rollback>
            DROP TABLE IF EXISTS ${quest.branching.schema}.quest_branch_events CASCADE;
        </rollback>
    </changeSet>

    <changeSet id="quest-branching-rls" author="db" runInTransaction="true">
        <comment>RLS policies for quest branching PoC tables. Issue #479</comment>
        <sql>
            CREATE ROLE quest_branching_app NOLOGIN;
            CREATE ROLE quest_branching_analytics NOLOGIN;

            CREATE OR REPLACE FUNCTION ${quest.branching.schema}.set_current_player(p_player_id BIGINT)
            RETURNS VOID
            LANGUAGE plpgsql
            SECURITY DEFINER
            AS $$
            BEGIN
                PERFORM set_config('quest_branching.current_player', p_player_id::TEXT, false);
            END;
            $$;

            ALTER TABLE ${quest.branching.schema}.quest_branch_events ENABLE ROW LEVEL SECURITY;
            ALTER TABLE ${quest.branching.schema}.quest_branches ENABLE ROW LEVEL SECURITY;

            CREATE POLICY quest_branch_events_player_isolation
                ON ${quest.branching.schema}.quest_branch_events
                FOR SELECT USING (
                    current_setting('quest_branching.current_player', true) IS NOT NULL
                    AND player_id = current_setting('quest_branching.current_player')::BIGINT
                )
                FOR UPDATE WITH CHECK (
                    current_setting('quest_branching.current_player', true) IS NOT NULL
                    AND player_id = current_setting('quest_branching.current_player')::BIGINT
                );

            CREATE POLICY quest_branch_events_analytics_read
                ON ${quest.branching.schema}.quest_branch_events
                FOR SELECT TO quest_branching_analytics
                USING (true);

            CREATE POLICY quest_branches_readonly
                ON ${quest.branching.schema}.quest_branches
                FOR SELECT TO PUBLIC
                USING (true);
        </sql>
        <rollback>
            DROP POLICY IF EXISTS quest_branch_events_player_isolation ON ${quest.branching.schema}.quest_branch_events;
            DROP POLICY IF EXISTS quest_branch_events_analytics_read ON ${quest.branching.schema}.quest_branch_events;
            DROP POLICY IF EXISTS quest_branches_readonly ON ${quest.branching.schema}.quest_branches;
            DROP FUNCTION IF EXISTS ${quest.branching.schema}.set_current_player(BIGINT);
            ALTER TABLE IF EXISTS ${quest.branching.schema}.quest_branch_events DISABLE ROW LEVEL SECURITY;
            ALTER TABLE IF EXISTS ${quest.branching.schema}.quest_branches DISABLE ROW LEVEL SECURITY;
            DROP ROLE IF EXISTS quest_branching_analytics;
            DROP ROLE IF EXISTS quest_branching_app;
        </rollback>
    </changeSet>

    <changeSet id="quest-branching-mview-popularity" author="db">
        <comment>Materialized view to track branch popularity. Issue #479</comment>
        <sql>
            CREATE MATERIALIZED VIEW IF NOT EXISTS ${quest.branching.schema}.quest_path_popularity AS
            SELECT
                quest_id,
                branch_id,
                COUNT(*) AS picks,
                MIN(chosen_at) AS first_seen_at,
                MAX(chosen_at) AS last_seen_at
            FROM ${quest.branching.schema}.quest_branch_events
            GROUP BY quest_id, branch_id;

            CREATE UNIQUE INDEX IF NOT EXISTS idx_qpp_pk ON ${quest.branching.schema}.quest_path_popularity (quest_id, branch_id);
        </sql>
        <rollback>
            DROP MATERIALIZED VIEW IF EXISTS ${quest.branching.schema}.quest_path_popularity;
        </rollback>
    </changeSet>

    <changeSet id="quest-branching-tag" author="db" runAlways="true">
        <comment>Mark database with quest-branching-v1 tag for PoC. Issue #479</comment>
        <tagDatabase tag="quest-branching-v1"/>
    </changeSet>

</databaseChangeLog>

