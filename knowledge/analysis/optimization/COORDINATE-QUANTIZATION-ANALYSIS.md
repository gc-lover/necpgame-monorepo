# Анализ квантования координат для оптимизации размера пакетов

## [TARGET] Вопрос: Можно ли уменьшить размер пакетов с помощью масштабирования координат?

### [OK] Ответ: ДА, но с потерями точности!

В киберспортивных шутерах часто используется **квантование координат** (quantization) - представление float координат в
виде целых чисел с масштабированием.

---

## [SYMBOL] Практики в киберспортивных шутерах

### 1. **CS:GO / Source Engine**

- Использует **квантование координат** для сетевых пакетов
- Координаты передаются с ограниченной точностью
- Дельта-компрессия для передачи только изменений

### 2. **Quake 3 / id Tech 3**

- **Фиксированная точка** для координат и углов
- Оптимизация: координаты в сантиметрах как int32
- Экономия: ~50% размера координатных данных

### 3. **Valorant / Riot Games**

- **Квантование** координат для сетевых пакетов
- Предсказание на стороне клиента для снижения нагрузки
- Дельта-компрессия для изменений состояния

### 4. **Doom (1993)**

- **Числа с фиксированной точкой** для всех координат
- Причина: в те времена не было FPU (Floating Point Unit)
- Экономия: 2x по размеру, быстрее вычисления

---

## [SEARCH] Текущая реализация в проекте

### Координаты в Unreal Engine:

**Unreal Engine использует сантиметры** как базовую единицу измерения:

- `FVector` хранит координаты в **сантиметрах** (не метрах!)
- Типичный диапазон карты: 0-10,000 см (0-100 метров) по каждой оси
- Максимальный диапазон: ±2,147,483,647 см (±21,474,837 метров) для int32

**Пример из кода**:

```cpp
FVector Location = Pawn->GetActorLocation();  // В сантиметрах
Entity.X = Location.X;  // float32 (4 байта)
Entity.Y = Location.Y;  // float32 (4 байта)
Entity.Z = Location.Z;  // float32 (4 байта)
```

---

## [IDEA] Варианты оптимизации координат

### Вариант 1: float32 → sint32 (в сантиметрах)

**Идея**: Убрать дробную часть, хранить только целые сантиметры

```go
// Текущий вариант:
X: float32(1234.567)  // 4 байта (float32)
// [tag: 1 байт] [value: 4 байта] = 5 байт

// Оптимизированный вариант:
X: sint32(1234)  // 1-5 байт (varint, обычно 2-3 байта)
// [tag: 1 байт] [value: 2-3 байта varint] = 3-4 байта
// Экономия: 1-2 байта на координату (20-40%)
```

**Точность**:

- Текущая: ±0.01 см (1 мм) - точность float32
- После оптимизации: ±1 см (1 сантиметр)
- **Потеря точности**: 100x (1 мм → 1 см)

**Оценка**:

- [OK] Экономия: 1-2 байта на координату
- [ERROR] Потеря точности: 1 мм → 1 см (может быть заметно)
- [WARNING] Для киберспортивных шутеров часто приемлемо (CS:GO использует ~1 см точность)

### Вариант 2: float32 → sint32 с масштабированием (1/10 см)

**Идея**: Умножить на 10, хранить в десятых сантиметрах

```go
// Текущий вариант:
X: float32(1234.567)  // 4 байта

// Оптимизированный вариант:
X: sint32(12345)  // 1-5 байт varint (обычно 2-3 байта)
// Представляет 1234.5 см
// Экономия: 1-2 байта, точность: 0.1 см (1 мм)
```

**Точность**:

- Текущая: ±0.01 см (0.1 мм) - точность float32
- После оптимизации: ±0.1 см (1 мм)
- **Потеря точности**: 10x (0.1 мм → 1 мм)

**Оценка**:

- [OK] Экономия: 1-2 байта на координату
- [OK] Точность: 0.1 см (1 мм) - обычно достаточно
- [WARNING] Для большинства шутеров приемлемо

### Вариант 3: float32 → sint16 (в сантиметрах, ограниченный диапазон)

**Идея**: Использовать int16 для координат в сантиметрах

```go
// Текущий вариант:
X: float32(1234.567)  // 4 байта (float32)

// Оптимизированный вариант:
X: sint16(1234)  // 1-3 байта varint (обычно 2 байта)
// [tag: 1 байт] [value: 2 байта] = 3 байта
// Экономия: 2 байта на координату (40%)
```

**Точность**:

- Текущая: ±0.01 см
- После оптимизации: ±1 см
- **Диапазон**: ±32,767 см (±327.67 метра) - ограничение!

**Оценка**:

- [OK] Экономия: 2 байта на координату (40%)
- [ERROR] Ограниченный диапазон: ±327 метров (может не хватить для больших карт)
- [WARNING] Для большинства шутеров достаточно (типичная карта < 300 метров)

### Вариант 4: float32 → fixed16 (2 байта, фиксированная точка)

**Идея**: Использовать 16-битное число с фиксированной точкой

```go
// Текущий вариант:
X: float32(1234.567)  // 4 байта

// Оптимизированный вариант:
X: int16(1234)  // 2 байта (fixed16)
// Представляет координату в сантиметрах с точностью ±1 см
// [tag: 1 байт] [value: 2 байта] = 3 байта
// Экономия: 2 байта на координату (40%)
```

**Точность**: ±1 см
**Диапазон**: ±32,767 см (±327.67 метра)

---

## [SYMBOL] Сравнение вариантов

| Вариант               | Размер (байт) | Точность | Диапазон   | Экономия |
|-----------------------|---------------|----------|------------|----------|
| **Текущий (float32)** | 5             | ±0.01 см | ±21,474 км | -        |
| sint32 (см)           | 3-4           | ±1 см    | ±21,474 км | 20-40%   |
| sint32 (0.1 см)       | 3-4           | ±0.1 см  | ±21,474 км | 20-40%   |
| sint16 (см)           | 3             | ±1 см    | ±327 м     | 40%      |
| fixed16 (см)          | 3             | ±1 см    | ±327 м     | 40%      |

---

## [TARGET] Рекомендации для проекта

### Вариант A: sint32 с масштабированием 0.1 см (РЕКОМЕНДУЕТСЯ)

**Реализация**:

```go
// Конвертация:
const ScaleFactor = 10.0  // Умножение для хранения в 0.1 см

// Отправка (UE5 → Gateway):
quantizedX := int32(math.Round(float64(location.X) * ScaleFactor))
// location.X = 1234.567 см → quantizedX = 12345 (представляет 1234.5 см)

// Прием (Gateway → UE5):
locationX := float32(quantizedX) / ScaleFactor
// quantizedX = 12345 → locationX = 1234.5 см
```

**Преимущества**:

- [OK] Экономия: 1-2 байта на координату (20-40%)
- [OK] Точность: 0.1 см (1 мм) - достаточна для шутеров
- [OK] Диапазон: ±21,474 км (неограничен)
- [OK] Приемлемая потеря точности (10x вместо 100x)

**Экономия для EntityState**:

- Координаты (X, Y, Z): 3-6 байт экономии
- Скорости (VX, VY, VZ): 3-6 байт экономии
- Yaw: 1-2 байта экономии
- **Итого: 7-14 байт на сущность** (при 7 полях)

**Для 390 клиентов при 60 Hz**:

- Экономия: 7-14 байт × 390 сущностей × 60 Hz = **163,800 - 327,600 байт/сек** = **~160-320 KB/s** [OK]

### Вариант B: sint16 с ограниченным диапазоном (±327 м)

**Реализация**:

```go
// Конвертация:
const MaxRange = 32767  // см (327.67 метра)

// Отправка:
quantizedX := int16(math.Round(math.Max(-MaxRange, math.Min(MaxRange, location.X))))
// Ограничение диапазона ±327 м

// Прием:
locationX := float32(quantizedX)
```

**Преимущества**:

- [OK] Экономия: 2 байта на координату (40%)
- [OK] Меньший размер: 3 байта вместо 5 байт
- [ERROR] Ограниченный диапазон: ±327 м (может не хватить)

**Экономия для EntityState**:

- **Итого: 14-28 байт на сущность**

**Для 390 клиентов**:

- Экономия: **~320-640 KB/s** [OK] (больше, но ограниченный диапазон)

---

## [SYMBOL] Расчет потери точности

### Текущая точность float32:

- **Мантисса**: 23 бита = 8,388,608 значений
- **Точность**: ~7 десятичных цифр
- Для координаты 1234.567 см: точность ±0.001 см

### После квантования sint32 (0.1 см):

- **Точность**: 0.1 см (1 мм)
- **Потеря**: 100x точности
- **Визуально**: Не заметно для игроков (1 мм = 0.1 мм на экране при разрешении 1920x1080)

### После квантования sint32 (1 см):

- **Точность**: 1 см (10 мм)
- **Потеря**: 1000x точности
- **Визуально**: Может быть заметно при близком рассмотрении

### После квантования sint16 (1 см):

- **Точность**: 1 см
- **Диапазон**: ±327 м (ограничение!)
- **Потеря**: 1000x точности

---

## [GAME] Практики в реальных играх

### CS:GO (Source Engine):

- **Точность координат**: ~1 см для сетевых пакетов
- **Формат**: Квантование до целых сантиметров
- **Причина**: Достаточная точность для шутера, экономия трафика

### Quake 3:

- **Точность координат**: ~0.1 см (1 мм)
- **Формат**: Фиксированная точка
- **Причина**: Баланс между точностью и размером

### Valorant:

- **Точность координат**: ~0.5-1 см
- **Формат**: Квантование + дельта-компрессия
- **Причина**: Оптимизация для низкой задержки

### Overwatch:

- **Точность координат**: ~1 см для дальних объектов
- **Формат**: Адаптивная точность в зависимости от расстояния
- **Причина**: Spatial partitioning + адаптивная частота

---

## [SYMBOL] Реализация для проекта

### 1. Изменение типа данных в Protobuf

**Вариант A: sint32 с масштабированием 0.1 см**

```go
// proto_handler.go
type EntityState struct {
    ID  string
    X   int32   // sint32: координата в 0.1 см
    Y   int32   // sint32: координата в 0.1 см
    Z   int32   // sint32: координата в 0.1 см
    VX  int32   // sint32: скорость в 0.1 см/с
    VY  int32   // sint32: скорость в 0.1 см/с
    VZ  int32   // sint32: скорость в 0.1 см/с
    Yaw int16   // sint16: угол в 0.1 градуса (или sint32)
}
```

### 2. Конвертация в UE5

```cpp
// ProtobufCodec.cpp - отправка
Entity.X = FMath::RoundToInt(Location.X * 10.0f);  // см → 0.1 см

// ProtobufCodec.cpp - прием
Location.X = Entity.X / 10.0f;  // 0.1 см → см
```

### 3. Конвертация в Gateway

```go
// proto_handler.go - отправка
quantizedX := int32(math.Round(float64(entity.X) * 10.0))
entityBytes = writeVarInt(entityBytes, (2<<3)|0)  // sint32: varint
entityBytes = writeVarIntZigZag(entityBytes, quantizedX)  // ZigZag encoding для отрицательных

// proto_handler.go - прием
quantizedX := readVarIntZigZag(data, &offset)
entity.X = float32(quantizedX) / 10.0  // 0.1 см → см
```

---

## [SYMBOL] Расчет экономии для проекта

### Текущий размер EntityState:

- X, Y, Z (float32): 3 × 5 = 15 байт
- VX, VY, VZ (float32): 3 × 5 = 15 байт
- Yaw (float32): 5 байт
- ID (string): ~3-11 байт
- **Итого**: ~38-46 байт на сущность

### После квантования (sint32, 0.1 см):

- X, Y, Z (sint32 varint): 3 × 3 = 9 байт (экономия: 6 байт)
- VX, VY, VZ (sint32 varint): 3 × 3 = 9 байт (экономия: 6 байт)
- Yaw (sint32 varint): 3 байта (экономия: 2 байта)
- ID (string): ~3-11 байт (без изменений)
- **Итого**: ~24-32 байта на сущность
- **Экономия**: 14-14 байт на сущность (37-39%)

### Для PlayerInput:

- MoveX, MoveY (float32): 2 × 5 = 10 байт → 2 × 3 = 6 байт (экономия: 4 байта)
- AimX, AimY (float32): 2 × 5 = 10 байт → 2 × 3 = 6 байт (экономия: 4 байта)
- **Экономия**: 8 байт на PlayerInput (20%)

### Для 390 клиентов при 60 Hz:

- PlayerInput: 390 × 60 × 8 = 187,200 байт/сек = ~183 KB/s экономии
- GameState (390 сущностей): 390 × 14 × 60 = 327,600 байт/сек = ~320 KB/s экономии
- **Общая экономия**: ~500 KB/s при 390 клиентах

---

## [WARNING] Важные замечания

### Проблемы при квантовании:

1. **Потеря точности**:
    - Текущая: ±0.001 см (0.01 мм)
    - После квантования: ±0.1 см (1 мм)
    - **Потеря**: 100x точности
    - **Влияние**: Может быть заметно при очень точных выстрелах

2. **Округление**:
    - Накопление ошибок округления при многократных операциях
    - Решение: Использовать double precision при вычислениях, квантовать только при отправке

3. **Диапазон**:
    - sint32: ±2,147,483,647 (0.1 см) = ±21,474,837 метров [OK]
    - sint16: ±32,767 см = ±327.67 метров [WARNING] (может не хватить)

4. **Скорости (Velocity)**:
    - Требуется тот же масштабный фактор
    - Для больших скоростей может понадобиться больший диапазон

---

## [OK] Рекомендации

### Рекомендация 1: sint32 с масштабированием 0.1 см

**Почему**:

- [OK] Экономия: ~14 байт на сущность (37-39%)
- [OK] Точность: 0.1 см (1 мм) - достаточна для шутеров
- [OK] Диапазон: ±21,474 км (неограничен)
- [OK] Приемлемая потеря точности (10x, не 100x)

### Рекомендация 2: Проверить влияние на точность

**Тестирование**:

1. Сравнить координаты до/после квантования
2. Проверить накопление ошибок при движении
3. Проверить точность выстрелов/попаданий

### Рекомендация 3: Постепенное внедрение

**Этапы**:

1. Реализовать квантование для координат (X, Y, Z)
2. Протестировать влияние на игровой процесс
3. Если приемлемо - добавить скорости (VX, VY, VZ)
4. Если приемлемо - добавить Yaw

---

## [TARGET] Итоговые выводы

### Можно ли уменьшить размер без потери точности?

**НЕТ, без потери точности нельзя**, но:

- [OK] **Можно уменьшить** с приемлемой потерей точности (1 мм вместо 0.01 мм)
- [OK] **Экономия**: 14-28 байт на сущность (37-70%)
- [OK] **Для 390 клиентов**: ~320-640 KB/s экономии
- [OK] **Практика**: Используется в CS:GO, Valorant, Quake

### Оптимальный вариант:

**sint32 с масштабированием 0.1 см**:

- Экономия: 37-39% размера координатных данных
- Точность: 0.1 см (1 мм) - достаточна для шутеров
- Реализация: Относительно простая
- Совместимость: Неограниченный диапазон

### Следующие шаги:

1. Реализовать квантование для координат (sint32, 0.1 см)
2. Провести тестирование точности
3. Измерить реальную экономию трафика
4. Решить, подходит ли потеря точности для проекта

