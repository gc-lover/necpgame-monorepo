# Оптимизация размера сообщений Protobuf

## [ERROR] Важное уточнение: Названия полей НЕ влияют на размер!

### Как работает Protobuf

В **Protobuf** названия полей (такие как `MoveX`, `X`, `PlayerID`) **НЕ отправляются** в бинарных сообщениях. Вместо этого используются **числовые идентификаторы полей** (field numbers), которые кодируются очень компактно.

### Пример из вашего кода

```go
// В коде вы пишете:
entityBytes = writeVarInt(entityBytes, (2<<3)|5)  // field 2, wire type 5 (float32)
entityBytes = writeFloat32(entityBytes, entity.X)  // значение координаты X

// В бинарном сообщении отправляется:
// [tag: 1 байт] [значение: 4 байта для float32]
// Где tag = (field_number << 3) | wire_type
// Для field 2, float32: tag = (2 << 3) | 5 = 21 (один байт)
```

### Что отправляется по сети:

**PlayerInput с полем `MoveX` (field 3):**
```
[tag: 1 байт] [значение: 4 байта]
  ^              ^
  |              +-- float32 значение (4 байта)
  +-- field 3, wire type 5 = (3<<3)|5 = 29 (1 байт)
```

**Итого: 5 байт** (независимо от названия поля: `MoveX`, `X`, `MovementVelocityX`, `MVX`)

**Для сравнения, в JSON:**
```json
{"MoveX": 0.5}  // 13 байт (название поля отправляется!)
{"X": 0.5}      // 8 байт (короче на 5 байт)
```

## [OK] Что ВЛИЯЕТ на размер сообщений Protobuf

### 1. Числовые идентификаторы полей (field numbers)

**Размер tag = varint(field_number << 3 | wire_type)**

- Field 1-15: **1 байт** (наиболее эффективно!)
- Field 16-2047: **2 байта**
- Field 2048+: **3+ байта**

**Рекомендация**: Используйте field numbers **1-15** для часто используемых полей!

### 2. Типы данных (wire types)

| Wire Type | Тип | Размер |
|-----------|-----|--------|
| 0 (Varint) | int32, int64, bool, enum | 1-10 байт (varint) |
| 1 (Fixed64) | double, fixed64, sfixed64 | 8 байт |
| 2 (Length-delimited) | string, bytes, embedded messages | varint(длина) + данные |
| 5 (Fixed32) | float, fixed32, sfixed32 | 4 байта |

**Оптимизация**: Используйте `fixed32` вместо `int32` для координат, если значения часто > 127 (varint для больших чисел занимает больше места).

### 3. Строковые значения

**Строки отправляются как есть** (в отличие от названий полей):

```go
// PlayerID отправляется как строка:
playerID := "p00000001"  // 9 байт данных
// В protobuf: [tag: 1 байт] [length: 1 байт] [data: 9 байт] = 11 байт

// Если бы PlayerID был короче:
playerID := "p1"  // 2 байта данных
// В protobuf: [tag: 1 байт] [length: 1 байт] [data: 2 байта] = 4 байта
// Экономия: 7 байт!
```

### 4. Дельта-компрессия

Отправка только измененных полей вместо всех полей:

```go
// Полное состояние (8 полей):
Entity: X, Y, Z, VX, VY, VZ, Yaw, ID = ~40 байт

// Дельта (только изменившиеся поля):
Entity: X, Y = ~10 байт
// Экономия: 75%!
```

## [SYMBOL] Примеры оптимизации

### Пример 1: PlayerID

**Проблема**: Длинные PlayerID занимают много места

```go
// Текущий формат:
PlayerID: "p00000001" = 9 байт данных

// Оптимизация 1: Короткие ID
PlayerID: "p1" = 2 байта данных  // Экономия: 7 байт на клиента!

// Оптимизация 2: Числовой ID (если возможно)
PlayerID: int32 = 1 байт varint  // Экономия: 8 байт на клиента!
```

### Пример 2: Field numbers

**Проблема**: Использование больших field numbers

```proto
// Текущий вариант (field 12):
message ClientMessage {
  PlayerInput player_input = 12;  // tag: 2 байта (field 12)
}

// Оптимизированный вариант (field 1):
message ClientMessage {
  PlayerInput player_input = 1;  // tag: 1 байт (field 1)
  // Экономия: 1 байт на каждое сообщение!
}
```

### Пример 3: Оптимальное использование field numbers 1-15

```proto
message PlayerInput {
  string player_id = 1;    // [OK] 1 байт tag (часто используемое)
  int64 tick = 2;          // [OK] 1 байт tag (часто используемое)
  float move_x = 3;        // [OK] 1 байт tag (часто используемое)
  float move_y = 4;        // [OK] 1 байт tag (часто используемое)
  bool shoot = 5;          // [OK] 1 байт tag (часто используемое)
  float aim_x = 6;         // [OK] 1 байт tag
  float aim_y = 7;         // [OK] 1 байт tag
  // Резерв: 8-15 для будущих полей
  // 16+ для редко используемых полей
}
```

## [TARGET] Рекомендации для оптимизации размера

### [OK] Что делать:

1. **Используйте field numbers 1-15** для часто используемых полей
   - Экономия: 1 байт на поле (field 1-15 vs field 16+)

2. **Минимизируйте длину строковых значений**
   - PlayerID: "p1" вместо "p00000001" (экономия: 7 байт)
   - Используйте числовые ID где возможно

3. **Используйте дельта-компрессию**
   - Отправляйте только измененные поля
   - Экономия: 60-90% размера сообщения

4. **Выбирайте правильные типы данных**
   - `fixed32` для координат (если значения часто > 127)
   - `bool` для флагов (1 байт varint)
   - `int32` для небольших чисел (1 байт varint для 0-127)

5. **Не отправляйте поля со значениями по умолчанию**
   - Protobuf автоматически пропускает: 0, false, "", null

### [ERROR] Что НЕ влияет:

1. **Названия полей** (`MoveX` vs `X` vs `MovementVelocityX`)
   - НЕ отправляются в бинарных сообщениях
   - Используются только в коде/схеме

2. **Комментарии в .proto файлах**
   - Полностью игнорируются при сериализации

3. **Порядок полей в .proto файле**
   - Не влияет на размер (только на порядок сериализации)

## [SYMBOL] Реальный пример из вашего кода

### Текущий PlayerInput (примерно 37-38 байт):

```
[tag field 12: 1 байт] [length: 1 байт] [
  [tag field 1: 1 байт] [length: 1 байт] [player_id: 9 байт],  // PlayerID
  [tag field 2: 1 байт] [tick: 1-9 байт varint],               // Tick
  [tag field 3: 1 байт] [move_x: 4 байта],                     // MoveX
  [tag field 4: 1 байт] [move_y: 4 байта],                     // MoveY
  [tag field 5: 1 байт] [shoot: 1 байт],                       // Shoot
  [tag field 6: 1 байт] [aim_x: 4 байта],                      // AimX
  [tag field 7: 1 байт] [aim_y: 4 байта]                       // AimY
]
```

### Потенциальная оптимизация:

1. **PlayerID: "p00000001" → "p1"**: Экономия **7 байт** (18%)
2. **Использование field 1 вместо field 12**: Экономия **1 байт** (3%)
3. **Итого**: С 37 байт до ~29 байт (экономия ~22%)

## [SEARCH] Как проверить размер сообщений

```go
// Текущий размер:
message := buildPlayerInputMessage("p00000001", 1, 0.5, 0.3, false, 0.0, 0.0)
fmt.Printf("Size: %d bytes\n", len(message))  // ~37 байт

// После оптимизации:
message2 := buildPlayerInputMessage("p1", 1, 0.5, 0.3, false, 0.0, 0.0)
fmt.Printf("Size: %d bytes\n", len(message2))  // ~30 байт
```

## [BOOK] Дополнительная информация

### Protobuf encoding format:

```
Message = Field1 Field2 Field3 ...
Field = Tag [Length] Value
Tag = (field_number << 3) | wire_type
```

### Varint encoding:

Числа кодируются переменным количеством байт:
- 0-127: 1 байт
- 128-16383: 2 байта
- 16384-2097151: 3 байта
- и т.д.

### Рекомендации по field numbers:

- **1-15**: Для часто используемых полей (экономия 1 байт)
- **16-2047**: Для редко используемых полей
- **19000-19999**: Зарезервировано для внутреннего использования Protobuf

## [WARNING] Важно помнить

**Названия полей в Protobuf НЕ влияют на размер бинарных сообщений!**

Влияют только:
- [OK] Числовые идентификаторы полей (field numbers)
- [OK] Типы данных (wire types)
- [OK] Длина строковых значений (данных, не названий)
- [OK] Дельта-компрессия (отправка только изменений)

