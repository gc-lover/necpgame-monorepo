# Тик и размеры данных в Protobuf

## [SYMBOL] Номер тика (Tick)

### Использование тика в проекте:

1. **Клиент** (`RealtimeWebSocketConnection.cpp`):
   - `ClientTick` сбрасывается при подключении: `ClientTick = 0` (строка 310)
   - Инкрементируется при каждой отправке: `ClientTick++` (строка 175)
   - Тип: `int64`

2. **Сервер** (`LyraGameMode.cpp`):
   - `ServerTick` начинается с 0: `static int64 ServerTick = 0` (строка 817)
   - Инкрементируется бесконечно: `ServerTick++` (строка 818)
   - Тип: `int64`

3. **Gateway** (`game_state.go`):
   - `tick` начинается с 0: `tick: 0` (строка 30)
   - Инкрементируется бесконечно: `gsm.tick++` (строка 70)
   - Тип: `int64`

### Вопрос: Сбрасывается ли тик?

**Ответ**: НЕТ, тик НЕ сбрасывается автоматически при достижении максимального значения!

**Исключения**:
- [OK] **Клиент**: Тик сбрасывается при переподключении (`ClientTick = 0` при подключении)
- [OK] **Сервер/Gateway**: Тик НЕ сбрасывается, инкрементируется бесконечно

### Риск переполнения:

**int64 максимальное значение**: `9,223,372,036,854,775,807`

**Расчет времени до переполнения при 60 Hz**:
- Тиков в секунду: 60
- Тиков в год: 60 × 3600 × 24 × 365 = **1,892,160,000**
- Время до переполнения: 9,223,372,036,854,775,807 / 1,892,160,000 = **4,875,611,716 лет** [OK]

**Вывод**: Переполнение int64 при 60 Hz **невозможно** в реальных условиях (потребуется 4.8 миллиарда лет!).

### Проблемы при переполнении (теоретически):

Если бы использовался `int32` (максимум: 2,147,483,647):
- Время до переполнения: 2,147,483,647 / 1,892,160,000 = **~1.13 года** [WARNING]
- Это было бы проблемой!

**Но используется `int64`** - проблемы нет [OK]

---

## [SYMBOL] Размер данных: Почему Move занимает 4 байта?

### Float32 в Protobuf

**MoveX** и **MoveY** имеют тип `float32`, который в Protobuf занимает **ровно 4 байта** (wire type 5 = Fixed32).

### Пример из вашего кода:

```go
// EntityState:
type EntityState struct {
    X   float32  // 4 байта
    Y   float32  // 4 байта
    Z   float32  // 4 байта
    VX  float32  // 4 байта
    VY  float32  // 4 байта
    VZ  float32  // 4 байта
    Yaw float32  // 4 байта
}

// В Protobuf:
entityBytes = writeVarInt(entityBytes, (2<<3)|5)  // tag: field 2, wire type 5 (Fixed32)
entityBytes = writeFloat32(entityBytes, entity.X)  // значение: 4 байта
// Итого: [tag: 1 байт] [значение: 4 байта] = 5 байт для каждого float32
```

### Почему 4 байта?

**float32** - это стандартный IEEE 754 формат:
- **32 бита** = **4 байта**
- Диапазон: от ~-3.4×10³⁸ до ~3.4×10³⁸
- Точность: ~7 десятичных цифр

Это **стандарт** для игр и координат - достаточная точность для позиций игроков.

### Альтернативы и их размеры:

| Тип | Размер | Точность | Использование |
|-----|--------|----------|---------------|
| **float32** | 4 байта | ~7 цифр | [OK] Текущий выбор (оптимально) |
| float64 | 8 байта | ~15 цифр | Избыточно для координат |
| fixed32 | 4 байта | Целое число | Не подходит для дробных координат |
| sfixed32 | 4 байта | Целое число со знаком | Не подходит для дробных координат |
| sint32 | 1-5 байт (varint) | Целое число | Не подходит для дробных координат |

**Вывод**: `float32` (4 байта) - **оптимальный выбор** для координат в играх!

---

## [SEARCH] Анализ текущей структуры данных

### PlayerInput (примерно 37-38 байт):

```
[tag field 12: 1 байт] [length: 1 байт] [
  [tag field 1: 1 байт] [length: 1 байт] [player_id: 9 байт],  // PlayerID: "p00000001"
  [tag field 2: 1 байт] [tick: 1-9 байт varint],               // Tick: int64 (varint)
  [tag field 3: 1 байт] [move_x: 4 байта],                     // MoveX: float32
  [tag field 4: 1 байт] [move_y: 4 байта],                     // MoveY: float32
  [tag field 5: 1 байт] [shoot: 1 байт],                       // Shoot: bool (varint)
  [tag field 6: 1 байт] [aim_x: 4 байта],                      // AimX: float32
  [tag field 7: 1 байт] [aim_y: 4 байта]                       // AimY: float32
]
```

### EntityState (примерно 35-40 байт на сущность):

```
[tag field 2: 1 байт] [length: 1 байт] [
  [tag field 1: 1 байт] [length: 1 байт] [id: N байт],         // ID: string
  [tag field 2: 1 байт] [x: 4 байта],                          // X: float32
  [tag field 3: 1 байт] [y: 4 байта],                          // Y: float32
  [tag field 4: 1 байт] [z: 4 байта],                          // Z: float32
  [tag field 5: 1 байт] [vx: 4 байта],                         // VX: float32
  [tag field 6: 1 байт] [vy: 4 байта],                         // VY: float32
  [tag field 7: 1 байт] [vz: 4 байта],                         // VZ: float32
  [tag field 8: 1 байт] [yaw: 4 байта]                         // Yaw: float32
]
```

### Почему float32 оптимален для координат:

1. **Достаточная точность**: ~7 десятичных цифр
   - Для координат в метрах: точность до 0.0001 метра (0.1 мм)
   - Достаточно для игр

2. **Размер**: 4 байта - минимальный размер для дробных чисел
   - Нельзя уменьшить без потери точности

3. **Производительность**: float32 быстрее float64
   - Меньше памяти
   - Быстрее операции

---

## [IDEA] Потенциальные оптимизации (если нужно)

### 1. Оптимизация Tick (если нужно уменьшить размер):

**Текущий вариант** (int64, varint):
```go
Tick: 1234567  // Занимает 3-4 байта (varint)
```

**Альтернатива** (int32, varint):
```go
Tick: int32(1234567)  // Занимает 2-3 байта (varint)
// Экономия: ~1 байт
// Но переполнится через ~1 год при 60 Hz (если не сбрасывать)
```

**Альтернатива** (uint32, fixed):
```go
Tick: uint32(1234567)  // Занимает 4 байта (fixed32)
// Не экономит место, но проще для сравнения
```

**Рекомендация**: Оставить `int64` - переполнение невозможно, размер varint оптимизируется автоматически.

### 2. Оптимизация координат (если нужна экономия):

**Текущий вариант** (float32, 4 байта):
```go
X: 123.456  // 4 байта
```

**Альтернатива** (sint32 в сантиметрах, varint):
```go
X: sint32(12345)  // 1-3 байта (varint) = координата в см
// Экономия: 1-3 байта на координату
// Но потеря точности и нужно конвертировать единицы измерения
```

**Альтернатива** (fixed16 - нестандартный):
```go
X: int16(12345)  // 2 байта, но очень ограниченный диапазон
// Не рекомендуется
```

**Рекомендация**: Оставить `float32` - оптимальный баланс размера и точности.

---

## [OK] Итоговые ответы на вопросы

### 1. Сбрасывается ли номер тика?

**НЕТ**, тик НЕ сбрасывается автоматически:
- [OK] Используется `int64` (переполнение через 4.8 миллиарда лет - невозможно)
- [OK] Сбрасывается только при переподключении клиента (ClientTick = 0)
- [OK] Сервер/Gateway: тик инкрементируется бесконечно

**Рекомендация**: Текущая реализация оптимальна, сброс не требуется.

### 2. Почему Move занимает 4 байта?

**float32 всегда занимает 4 байта** в Protobuf:
- [OK] Это стандартный размер для float32 (IEEE 754)
- [OK] Оптимальный баланс: точность vs размер
- [OK] Нельзя уменьшить без потери точности
- [OK] Стандарт для координат в играх

**Рекомендация**: Оставить `float32` - текущий выбор оптимален.

---

## [SYMBOL] Сравнение размеров (текущая реализация)

| Поле | Тип | Размер в Protobuf | Оптимизация |
|------|-----|-------------------|-------------|
| Tick | int64 (varint) | 1-9 байт | [OK] Оптимально |
| MoveX | float32 | 5 байт (tag + value) | [OK] Оптимально |
| MoveY | float32 | 5 байт (tag + value) | [OK] Оптимально |
| PlayerID | string | 2-11 байт (tag + length + data) | [WARNING] Можно оптимизировать ("p00000001" → "p1") |

**Главная оптимизация**: Уменьшить длину PlayerID (`"p00000001"` → `"p1"`) - экономия 7 байт на сообщение!

