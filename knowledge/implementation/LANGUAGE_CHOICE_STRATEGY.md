# Стратегия выбора языков для микросервисов NECPGAME

## Принцип: Right Tool for the Right Job + UE5 из коробки

Не нужно всё делать на Java. **Важно:** Проект использует UE5, и многие вещи лучше делать на UE5 Dedicated Server из
коробки, а не на отдельных микросервисах.

## Инфраструктура: НЕ требует изменения языка

**Вывод:** Инфраструктурные инструменты (ArgoCD, Docker, Envoy, Liquibase, Observability) **не зависят от языка
приложений** и работают с любыми сервисами.

**Текущий стек:**

- [OK] ArgoCD - GitOps (Kubernetes манифесты)
- [OK] Docker - контейнеризация (любые языки)
- [OK] Envoy - API Gateway (прокси на уровне сети)
- [OK] Liquibase - миграции БД (не зависит от языка)
- [OK] Prometheus/Grafana/Loki/Tempo - observability (метрики/логи из любых источников)

**Что нужно обновить:**

- [WARNING] Prometheus конфигурация (добавить scrape configs для Go сервисов) [OK] Уже обновлено
- [WARNING] Метрики в Go сервисах (Prometheus клиенты) - TODO
- [WARNING] Структурированное логирование в Go сервисах - TODO

**Подробнее:** См. `knowledge/implementation/INFRASTRUCTURE_ANALYSIS.md`

## UE5 Dedicated Server - что есть из коробки

UE5 предоставляет мощные инструменты для игрового сервера:

### [OK] Авторитетный сервер (Authoritative Server)

- Авторитетная симуляция физики и игровой логики
- Защита от читов на уровне движка
- Синхронизация состояния между клиентами

### [OK] Репликация (Replication)

- **ReplicationGraph** - оптимизированная репликация
- **Iris Replication** (UE 5.6+) - современная репликация, меньше трафика
- AOI (Area of Interest) - репликация только видимых объектов
- Адаптивная частота обновления

### [OK] Физика и симуляция

- Chaos Physics - физика из коробки
- Авторитетная симуляция на сервере
- Синхронизация физических объектов

### [OK] Network Prediction

- Предсказание и роллбек для движения/стрельбы
- Снижение видимой задержки для игроков
- Автоматическая коррекция рассинхронизаций

### [OK] Gameplay Ability System (GAS)

- Система способностей, ресурсов, эффектов
- Идеально для боёвки
- Сетевая синхронизация встроена

### [OK] Mass Entity (ECS)

- Симуляция толп/НПС в районах
- Высокая производительность для множества сущностей

### [OK] OnlineSubsystem

- Управление сессиями
- Интеграция с внешними системами (EOS опционально)

## Критерии выбора

1. **Производительность и задержка** - критично для realtime компонентов
2. **Сложность бизнес-логики** - для сложных доменных моделей лучше Java/Spring
3. **Простота развертывания** - для простых сервисов лучше Go
4. **Интеграция с экосистемой** - Spring Cloud, Kafka, PostgreSQL
5. **Опыт команды** - баланс между оптимальностью и скоростью разработки

## Рекомендации по сервисам

### [OK] Go (рекомендуется)

#### 1. Realtime Gateway (QUIC/UDP) ⭐ УЖЕ МИГРИРОВАНО

**Текущий статус:** [OK] Реализовано на Go

**Почему Go:**

- Низкая задержка критична
- Простая логика (маршрутизация пакетов)
- Отличная поддержка QUIC (quic-go)
- Статическая сборка, простой Docker
- Нет проблем с нативными библиотеками

**Альтернативы:**

- Rust + quinn - максимальная производительность, но сложнее
- C++ + MsQuic - максимальная производительность, но сложнее

#### 2. WebSocket Lobby (WSS) ⭐ РЕКОМЕНДУЕТСЯ МИГРАЦИЯ

**Текущий статус:** Java (Vert.x)

**Почему Go лучше:**

- Простая логика (эхо-комнаты, чат)
- Отличная поддержка WebSocket (gorilla/websocket)
- Низкая задержка для чата
- Простое развертывание
- Меньше памяти чем Java

**Когда оставить Java:**

- Если нужна сложная бизнес-логика (модерация, фильтры)
- Если уже есть интеграция с Spring Security

#### 3. Matchmaking (очереди Redis) ⭐ РЕКОМЕНДУЕТСЯ МИГРАЦИЯ

**Текущий статус:** Java

**Почему Go лучше:**

- Простая логика (очереди, матчинг)
- Отличная поддержка Redis (go-redis)
- Низкая задержка для матчмейкинга
- Простое развертывание
- Меньше памяти

**Когда оставить Java:**

- Если нужна сложная логика матчинга (ML, ранжирование)
- Если нужна интеграция с Spring Cloud

### [OK] Java (оставить)

#### 1. Gameplay Service

**Почему Java:**

- Сложная бизнес-логика
- Интеграция с Spring Boot, Spring Cloud
- Работа с PostgreSQL, сложные запросы
- Интеграция с Kafka для событий
- Валидация, транзакции, ACID

#### 2. World-State Service

**Почему Java:**

- Сложная доменная модель (районы, модификаторы)
- Интеграция с PostgreSQL
- События через Kafka
- Транзакции, консистентность

#### 3. Inventory/Loot Service

**Почему Java:**

- Сложная бизнес-логика (версионирование предметов)
- Транзакции PostgreSQL
- Интеграция с другими сервисами через gRPC
- Валидация, аудит

#### 4. Economy/Trade Service

**Почему Java:**

- Критична консистентность данных
- Сложные транзакции
- Интеграция с PostgreSQL
- Аудит, логирование

#### 5. Social/Chat/Party Service

**Почему Java:**

- Сложная бизнес-логика (группы, права)
- Интеграция с PostgreSQL
- Модерация, фильтры
- Интеграция с другими сервисами

#### 6. Romance/Relationships Service

**Почему Java:**

- Очень сложная доменная модель
- Сложные запросы к PostgreSQL
- Интеграция с другими сервисами
- Бизнес-правила, валидация

#### 7. Auth Service

**Почему Java:**

- Интеграция с Keycloak (Spring Security)
- JWT валидация
- Интеграция с Spring Cloud
- Сложная логика авторизации

#### 8. Notifications Service

**Почему Java:**

- Интеграция с внешними сервисами (push)
- Сложная маршрутизация
- Интеграция с Kafka
- Бизнес-логика каналов

### [OK] UE5 Dedicated Server (РЕКОМЕНДУЕТСЯ для Combat-Sim)

#### 1. Combat-Sim / Gameplay Loop ⭐ ИСПОЛЬЗОВАТЬ UE5

**Текущий статус:** Java (прототип)

**Стратегия:**

- **Tech demo:** Java (для быстрого прототипа логики)
- **Продакшен:** [OK] **UE5 Dedicated Server** (не отдельный сервис!)

**Что делать на UE5 Dedicated Server:**

- [OK] Физика стрельбы (Chaos Physics из коробки)
- [OK] Попадания (hit detection) - авторитетный сервер
- [OK] Позиции игроков (репликация)
- [OK] Тик-луп (60+ TPS) - встроен в UE5
- [OK] Игровая логика боя (GAS - Gameplay Ability System)
- [OK] Синхронизация состояния (Replication/Iris)
- [OK] Network Prediction (предсказание/роллбек)

**Почему UE5 Dedicated Server, а не отдельный сервис:**

- [OK] Всё из коробки - репликация, физика, сеть
- [OK] Авторитетный сервер встроен
- [OK] Защита от читов на уровне движка
- [OK] Синхронизация с клиентом автоматическая
- [OK] Network Prediction встроен
- [OK] GAS для способностей/эффектов
- [OK] Один код для клиента и сервера (C++/Blueprint)
- [OK] Интеграция с UE5 клиентом без дополнительных протоколов

**Что НЕ делать на UE5 (оставить в микросервисах):**

- [ERROR] Управление инстансами (оркестрация) - K8s/Agones
- [ERROR] Персистентность (сохранение прогресса) - PostgreSQL
- [ERROR] Экономика/инвентарь - Java микросервисы
- [ERROR] Матчмейкинг - Go микросервис
- [ERROR] Социальные системы - Java микросервисы

**Архитектура:**

```
Клиент (UE5) 
    ↓ QUIC/UDP
Realtime Gateway (Go) - маршрутизация
    ↓
UE5 Dedicated Server - авторитетная симуляция боя
    ↓ gRPC/REST
Backend Services (Java) - экономика, инвентарь, прогресс
```

**Рекомендация:** Использовать UE5 Dedicated Server для всей игровой логики боя, а не создавать отдельный Combat-Sim
сервис.

### [WARNING] Python (для аналитики/ML)

#### 1. Analytics Service (если нужен)

**Почему Python:**

- ML модели для матчинга
- Аналитика данных
- Интеграция с ClickHouse
- Data science инструменты

## Матрица решений

| Сервис                         | Текущий | Рекомендуемый                 | Причина                                        |
|--------------------------------|---------|-------------------------------|------------------------------------------------|
| Realtime Gateway               | Java    | [OK] **Go**                   | Низкая задержка, простота, маршрутизация       |
| WebSocket Lobby                | Java    | [OK] **Go**                   | Простая логика, низкая задержка                |
| Matchmaking                    | Java    | [OK] **Go**                   | Простая логика, очереди Redis                  |
| **Combat-Sim / Gameplay Loop** | Java    | [OK] **UE5 Dedicated Server** | **Всё из коробки: физика, репликация, GAS**    |
| World-State (районы)           | Java    | [OK] **Java**                 | Сложная доменная модель, персистентность       |
| Inventory/Loot                 | Java    | [OK] **Java**                 | Транзакции, версионирование, персистентность   |
| Economy/Trade                  | Java    | [OK] **Java**                 | Консистентность, транзакции, персистентность   |
| Social/Chat/Party              | Java    | [OK] **Java**                 | Сложная логика, модерация, персистентность     |
| Romance/Relationships          | Java    | [OK] **Java**                 | Очень сложная доменная модель, персистентность |
| Auth                           | Java    | [OK] **Java**                 | Интеграция с Keycloak                          |
| Notifications                  | Java    | [OK] **Java**                 | Интеграция с внешними сервисами                |

## Приоритеты миграции

### Высокий приоритет (уже сделано)

1. [OK] **Realtime Gateway** → Go (завершено)

### Средний приоритет (завершено)

2. [OK] **WebSocket Lobby** → Go (завершено)
3. [OK] **Matchmaking** → Go (завершено)

### Низкий приоритет (после MVP)

4. [WARNING] **Combat-Sim** → **UE5 Dedicated Server** (использовать встроенные возможности)

### Оставить Java

- Все остальные сервисы (сложная бизнес-логика)

## Преимущества полиглот-архитектуры

1. **Оптимальная производительность** - каждый сервис на оптимальном языке
2. **Простота развертывания** - Go сервисы = маленькие образы
3. **Скорость разработки** - простые сервисы на Go быстрее
4. **Масштабируемость** - критичные части на C++/Rust

## Недостатки полиглот-архитектуры

1. **Разные стеки** - нужно знать несколько языков
2. **Разные инструменты** - разные CI/CD пайплайны
3. **Сложнее отладка** - разные языки, разные инструменты

## Рекомендация

**Использовать полиглот-архитектуру + UE5:**

- [OK] **UE5 Dedicated Server** для игровой логики боя (физика, репликация, GAS)
- [OK] **Go** для простых realtime сервисов (Gateway, Lobby, Matchmaking)
- [OK] **Java** для сложных бизнес-сервисов (Economy, Social, Inventory)
- [ERROR] **НЕ создавать отдельный Combat-Sim сервис** - использовать UE5 Dedicated Server

**Ключевой принцип:** Использовать UE5 из коробки для всего, что связано с игровой логикой и симуляцией. Микросервисы
только для персистентности и бизнес-логики.

## Архитектура с UE5

```
┌─────────────────────────────────────────────────┐
│ Клиент (UE5)                                    │
└────────────┬────────────────────────────────────┘
             │ QUIC/UDP
             ↓
┌─────────────────────────────────────────────────┐
│ Realtime Gateway (Go)                           │
│ - Маршрутизация пакетов                        │
│ - Аутентификация                                │
└────────────┬────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────┐
│ UE5 Dedicated Server                            │
│ - Авторитетная симуляция боя                    │
│ - Физика (Chaos Physics)                       │
│ - Репликация (Iris/ReplicationGraph)           │
│ - GAS (способности, эффекты)                    │
│ - Network Prediction                            │
│ - 60+ TPS тик-луп                               │
└────────────┬────────────────────────────────────┘
             │ gRPC/REST
             ↓
┌─────────────────────────────────────────────────┐
│ Backend Services (Java)                         │
│ - Economy, Inventory, World-State              │
│ - Social, Romance, Auth                         │
│ - PostgreSQL, Kafka, Redis                      │
└─────────────────────────────────────────────────┘
```

**Не делать всё на Java** - использовать правильный инструмент для каждой задачи, включая UE5 из коробки.

