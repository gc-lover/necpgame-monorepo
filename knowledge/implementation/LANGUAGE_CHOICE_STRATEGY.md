# Стратегия выбора языков для микросервисов NECPGAME

## Принцип: Right Tool for the Right Job + UE5 из коробки

Не нужно всё делать на Java. **Важно:** Проект использует UE5, и многие вещи лучше делать на UE5 Dedicated Server из коробки, а не на отдельных микросервисах.

## Инфраструктура: НЕ требует изменения языка

**Вывод:** Инфраструктурные инструменты (ArgoCD, Docker, Envoy, Liquibase, Observability) **не зависят от языка приложений** и работают с любыми сервисами.

**Текущий стек:**
- ✅ ArgoCD - GitOps (Kubernetes манифесты)
- ✅ Docker - контейнеризация (любые языки)
- ✅ Envoy - API Gateway (прокси на уровне сети)
- ✅ Liquibase - миграции БД (не зависит от языка)
- ✅ Prometheus/Grafana/Loki/Tempo - observability (метрики/логи из любых источников)

**Что нужно обновить:**
- ⚠️ Prometheus конфигурация (добавить scrape configs для Go сервисов) ✅ Уже обновлено
- ⚠️ Метрики в Go сервисах (Prometheus клиенты) - TODO
- ⚠️ Структурированное логирование в Go сервисах - TODO

**Подробнее:** См. `knowledge/implementation/INFRASTRUCTURE_ANALYSIS.md`

## UE5 Dedicated Server - что есть из коробки

UE5 предоставляет мощные инструменты для игрового сервера:

### ✅ Авторитетный сервер (Authoritative Server)
- Авторитетная симуляция физики и игровой логики
- Защита от читов на уровне движка
- Синхронизация состояния между клиентами

### ✅ Репликация (Replication)
- **ReplicationGraph** - оптимизированная репликация
- **Iris Replication** (UE 5.6+) - современная репликация, меньше трафика
- AOI (Area of Interest) - репликация только видимых объектов
- Адаптивная частота обновления

### ✅ Физика и симуляция
- Chaos Physics - физика из коробки
- Авторитетная симуляция на сервере
- Синхронизация физических объектов

### ✅ Network Prediction
- Предсказание и роллбек для движения/стрельбы
- Снижение видимой задержки для игроков
- Автоматическая коррекция рассинхронизаций

### ✅ Gameplay Ability System (GAS)
- Система способностей, ресурсов, эффектов
- Идеально для боёвки
- Сетевая синхронизация встроена

### ✅ Mass Entity (ECS)
- Симуляция толп/НПС в районах
- Высокая производительность для множества сущностей

### ✅ OnlineSubsystem
- Управление сессиями
- Интеграция с внешними системами (EOS опционально)

## Критерии выбора

1. **Производительность и задержка** - критично для realtime компонентов
2. **Сложность бизнес-логики** - для сложных доменных моделей лучше Java/Spring
3. **Простота развертывания** - для простых сервисов лучше Go
4. **Интеграция с экосистемой** - Spring Cloud, Kafka, PostgreSQL
5. **Опыт команды** - баланс между оптимальностью и скоростью разработки

## Рекомендации по сервисам

### ✅ Go (рекомендуется)

#### 1. Realtime Gateway (QUIC/UDP) ⭐ УЖЕ МИГРИРОВАНО
**Текущий статус:** ✅ Реализовано на Go

**Почему Go:**
- Низкая задержка критична
- Простая логика (маршрутизация пакетов)
- Отличная поддержка QUIC (quic-go)
- Статическая сборка, простой Docker
- Нет проблем с нативными библиотеками

**Альтернативы:**
- Rust + quinn - максимальная производительность, но сложнее
- C++ + MsQuic - максимальная производительность, но сложнее

#### 2. WebSocket Lobby (WSS) ⭐ РЕКОМЕНДУЕТСЯ МИГРАЦИЯ
**Текущий статус:** Java (Vert.x)

**Почему Go лучше:**
- Простая логика (эхо-комнаты, чат)
- Отличная поддержка WebSocket (gorilla/websocket)
- Низкая задержка для чата
- Простое развертывание
- Меньше памяти чем Java

**Когда оставить Java:**
- Если нужна сложная бизнес-логика (модерация, фильтры)
- Если уже есть интеграция с Spring Security

#### 3. Matchmaking (очереди Redis) ⭐ РЕКОМЕНДУЕТСЯ МИГРАЦИЯ
**Текущий статус:** Java

**Почему Go лучше:**
- Простая логика (очереди, матчинг)
- Отличная поддержка Redis (go-redis)
- Низкая задержка для матчмейкинга
- Простое развертывание
- Меньше памяти

**Когда оставить Java:**
- Если нужна сложная логика матчинга (ML, ранжирование)
- Если нужна интеграция с Spring Cloud

### ✅ Java (оставить)

#### 1. Gameplay Service
**Почему Java:**
- Сложная бизнес-логика
- Интеграция с Spring Boot, Spring Cloud
- Работа с PostgreSQL, сложные запросы
- Интеграция с Kafka для событий
- Валидация, транзакции, ACID

#### 2. World-State Service
**Почему Java:**
- Сложная доменная модель (районы, модификаторы)
- Интеграция с PostgreSQL
- События через Kafka
- Транзакции, консистентность

#### 3. Inventory/Loot Service
**Почему Java:**
- Сложная бизнес-логика (версионирование предметов)
- Транзакции PostgreSQL
- Интеграция с другими сервисами через gRPC
- Валидация, аудит

#### 4. Economy/Trade Service
**Почему Java:**
- Критична консистентность данных
- Сложные транзакции
- Интеграция с PostgreSQL
- Аудит, логирование

#### 5. Social/Chat/Party Service
**Почему Java:**
- Сложная бизнес-логика (группы, права)
- Интеграция с PostgreSQL
- Модерация, фильтры
- Интеграция с другими сервисами

#### 6. Romance/Relationships Service
**Почему Java:**
- Очень сложная доменная модель
- Сложные запросы к PostgreSQL
- Интеграция с другими сервисами
- Бизнес-правила, валидация

#### 7. Auth Service
**Почему Java:**
- Интеграция с Keycloak (Spring Security)
- JWT валидация
- Интеграция с Spring Cloud
- Сложная логика авторизации

#### 8. Notifications Service
**Почему Java:**
- Интеграция с внешними сервисами (push)
- Сложная маршрутизация
- Интеграция с Kafka
- Бизнес-логика каналов

### ✅ UE5 Dedicated Server (РЕКОМЕНДУЕТСЯ для Combat-Sim)

#### 1. Combat-Sim / Gameplay Loop ⭐ ИСПОЛЬЗОВАТЬ UE5
**Текущий статус:** Java (прототип)

**Стратегия:**
- **Tech demo:** Java (для быстрого прототипа логики)
- **Продакшен:** ✅ **UE5 Dedicated Server** (не отдельный сервис!)

**Что делать на UE5 Dedicated Server:**
- ✅ Физика стрельбы (Chaos Physics из коробки)
- ✅ Попадания (hit detection) - авторитетный сервер
- ✅ Позиции игроков (репликация)
- ✅ Тик-луп (60+ TPS) - встроен в UE5
- ✅ Игровая логика боя (GAS - Gameplay Ability System)
- ✅ Синхронизация состояния (Replication/Iris)
- ✅ Network Prediction (предсказание/роллбек)

**Почему UE5 Dedicated Server, а не отдельный сервис:**
- ✅ Всё из коробки - репликация, физика, сеть
- ✅ Авторитетный сервер встроен
- ✅ Защита от читов на уровне движка
- ✅ Синхронизация с клиентом автоматическая
- ✅ Network Prediction встроен
- ✅ GAS для способностей/эффектов
- ✅ Один код для клиента и сервера (C++/Blueprint)
- ✅ Интеграция с UE5 клиентом без дополнительных протоколов

**Что НЕ делать на UE5 (оставить в микросервисах):**
- ❌ Управление инстансами (оркестрация) - K8s/Agones
- ❌ Персистентность (сохранение прогресса) - PostgreSQL
- ❌ Экономика/инвентарь - Java микросервисы
- ❌ Матчмейкинг - Go микросервис
- ❌ Социальные системы - Java микросервисы

**Архитектура:**
```
Клиент (UE5) 
    ↓ QUIC/UDP
Realtime Gateway (Go) - маршрутизация
    ↓
UE5 Dedicated Server - авторитетная симуляция боя
    ↓ gRPC/REST
Backend Services (Java) - экономика, инвентарь, прогресс
```

**Рекомендация:** Использовать UE5 Dedicated Server для всей игровой логики боя, а не создавать отдельный Combat-Sim сервис.

### ⚠️ Python (для аналитики/ML)

#### 1. Analytics Service (если нужен)
**Почему Python:**
- ML модели для матчинга
- Аналитика данных
- Интеграция с ClickHouse
- Data science инструменты

## Матрица решений

| Сервис | Текущий | Рекомендуемый | Причина |
|--------|---------|---------------|---------|
| Realtime Gateway | Java | ✅ **Go** | Низкая задержка, простота, маршрутизация |
| WebSocket Lobby | Java | ✅ **Go** | Простая логика, низкая задержка |
| Matchmaking | Java | ✅ **Go** | Простая логика, очереди Redis |
| **Combat-Sim / Gameplay Loop** | Java | ✅ **UE5 Dedicated Server** | **Всё из коробки: физика, репликация, GAS** |
| World-State (районы) | Java | ✅ **Java** | Сложная доменная модель, персистентность |
| Inventory/Loot | Java | ✅ **Java** | Транзакции, версионирование, персистентность |
| Economy/Trade | Java | ✅ **Java** | Консистентность, транзакции, персистентность |
| Social/Chat/Party | Java | ✅ **Java** | Сложная логика, модерация, персистентность |
| Romance/Relationships | Java | ✅ **Java** | Очень сложная доменная модель, персистентность |
| Auth | Java | ✅ **Java** | Интеграция с Keycloak |
| Notifications | Java | ✅ **Java** | Интеграция с внешними сервисами |

## Приоритеты миграции

### Высокий приоритет (уже сделано)
1. ✅ **Realtime Gateway** → Go (завершено)

### Средний приоритет (завершено)
2. ✅ **WebSocket Lobby** → Go (завершено)
3. ✅ **Matchmaking** → Go (завершено)

### Низкий приоритет (после MVP)
4. ⚠️ **Combat-Sim** → **UE5 Dedicated Server** (использовать встроенные возможности)

### Оставить Java
- Все остальные сервисы (сложная бизнес-логика)

## Преимущества полиглот-архитектуры

1. **Оптимальная производительность** - каждый сервис на оптимальном языке
2. **Простота развертывания** - Go сервисы = маленькие образы
3. **Скорость разработки** - простые сервисы на Go быстрее
4. **Масштабируемость** - критичные части на C++/Rust

## Недостатки полиглот-архитектуры

1. **Разные стеки** - нужно знать несколько языков
2. **Разные инструменты** - разные CI/CD пайплайны
3. **Сложнее отладка** - разные языки, разные инструменты

## Рекомендация

**Использовать полиглот-архитектуру + UE5:**
- ✅ **UE5 Dedicated Server** для игровой логики боя (физика, репликация, GAS)
- ✅ **Go** для простых realtime сервисов (Gateway, Lobby, Matchmaking)
- ✅ **Java** для сложных бизнес-сервисов (Economy, Social, Inventory)
- ❌ **НЕ создавать отдельный Combat-Sim сервис** - использовать UE5 Dedicated Server

**Ключевой принцип:** Использовать UE5 из коробки для всего, что связано с игровой логикой и симуляцией. Микросервисы только для персистентности и бизнес-логики.

## Архитектура с UE5

```
┌─────────────────────────────────────────────────┐
│ Клиент (UE5)                                    │
└────────────┬────────────────────────────────────┘
             │ QUIC/UDP
             ↓
┌─────────────────────────────────────────────────┐
│ Realtime Gateway (Go)                           │
│ - Маршрутизация пакетов                        │
│ - Аутентификация                                │
└────────────┬────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────┐
│ UE5 Dedicated Server                            │
│ - Авторитетная симуляция боя                    │
│ - Физика (Chaos Physics)                       │
│ - Репликация (Iris/ReplicationGraph)           │
│ - GAS (способности, эффекты)                    │
│ - Network Prediction                            │
│ - 60+ TPS тик-луп                               │
└────────────┬────────────────────────────────────┘
             │ gRPC/REST
             ↓
┌─────────────────────────────────────────────────┐
│ Backend Services (Java)                         │
│ - Economy, Inventory, World-State              │
│ - Social, Romance, Auth                         │
│ - PostgreSQL, Kafka, Redis                      │
└─────────────────────────────────────────────────┘
```

**Не делать всё на Java** - использовать правильный инструмент для каждой задачи, включая UE5 из коробки.

