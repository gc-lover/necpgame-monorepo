# Issue: #130

metadata:
  id: architecture-combat-session-system
  title: "Combat Session System Architecture"
  document_type: architecture
  category: implementation
  status: draft
  version: "1.0.0"
  last_updated: 2025-12-02T17:05:00Z
  concept_approved: false
  owners:
    - role: architect
      contact: architect@necp.game
  tags:
    - combat
    - sessions
    - gameplay
    - architecture
  topics:
    - combat-sessions
    - realtime-combat
    - session-management
  related_systems:
    - gameplay-service
    - character-service
    - economy-service
    - quest-service
    - analytics-service
    - security-service
  related_documents:
    - id: combat-session-backend
      relation: implements
    - id: combat-shooter-core
      relation: references
    - id: combat-pvp-pve
      relation: references
  source: knowledge/implementation/architecture/combat-session-system-architecture.yaml
  visibility: internal
  audience:
    - architects
    - backend
    - gameplay
  risk_level: high

review:
  chain:
    - role: architect
      reviewer: ""
      reviewed_at: ""
      status: pending
  next_actions:
    - Review by Backend Team
    - Review by Network Team
    - API Designer handoff

summary:
  problem: "Необходима стандартизованная архитектура для управления боевыми сессиями с поддержкой realtime-боя, античита, телеметрии и интеграций."
  goal: "Спроектировать полную микросервисную архитектуру системы боевых сессий для MMOFPS RPG."
  essence: "Архитектура описывает компоненты, API endpoints, потоки данных, структуру БД и интеграции для управления боевыми сессиями."
  key_points:
    - Микросервисная архитектура с gameplay-service как ядром
    - Event-driven интеграция через Kafka
    - Авторитативный сервер для валидации действий
    - Поддержка PvP/PvE режимов и экстракт-механик
    - Интеграция с античитом и телеметрией

content:
  sections:
    - id: system-overview
      title: "Обзор системы"
      body: |
        Combat Session System управляет полным жизненным циклом боевых сессий:
        - Создание и настройка боевых сессий (PvP арены, PvE рейды, экстракт-зоны)
        - Управление участниками и их состоянием
        - Обработка боевых действий в реальном времени
        - Расчет урона, хитов, статусных эффектов
        - Управление порядком ходов и событиями
        - Выдача наград и лута
        - Интеграция с квестами и прогрессией

        Система построена на принципах:
        - Авторитативный сервер (server-authoritative)
        - Event-driven архитектура
        - Микросервисная декомпозиция
        - Realtime синхронизация через WebSocket/UDP
        - Телеметрия и античит как первоклассные граждане

    - id: architecture-components
      title: "Компоненты архитектуры"
      body: |
        ## Микросервисы

        ### 1. gameplay-service (Core Combat Service)
        **Ответственность:** Управление боевыми сессиями, валидация действий, расчет урона
        **Технологии:** Go, PostgreSQL, Redis, Kafka
        **Масштабируемость:** Горизонтальная, stateless handlers + stateful session managers
        
        **Ключевые компоненты:**
        - `SessionManager` - управление жизненным циклом сессий
        - `CombatEngine` - расчет урона, хитов, статусных эффектов
        - `ActionValidator` - валидация действий игроков (античит)
        - `StateSync` - синхронизация состояния с клиентами
        - `EventPublisher` - публикация событий в Kafka

        ### 2. character-service
        **Ответственность:** Управление персонажами, атрибутами, имплантами, способностями
        **Интеграция:** Предоставляет данные о персонаже для боевых расчетов
        **API:** `GET /characters/{id}/combat-stats`, `GET /characters/{id}/loadout`

        ### 3. economy-service
        **Ответственность:** Управление лутом, наградами, экономикой
        **Интеграция:** Получает события `combat:ended` и выдает награды
        **API:** `POST /economy/combat-rewards`, `POST /economy/loot/generate`

        ### 4. quest-service
        **Ответственность:** Управление квестами и прогрессией
        **Интеграция:** Подписан на события `combat:*` для обновления квестов
        **API:** `POST /quests/progress/combat-event`

        ### 5. analytics-service
        **Ответственность:** Сбор и обработка телеметрии боев
        **Интеграция:** Подписан на все события `combat:*`
        **API:** `POST /analytics/combat-telemetry`

        ### 6. security-service (Anti-Cheat)
        **Ответственность:** Обнаружение читерства, валидация действий
        **Интеграция:** Анализирует события `combat:action` в реальном времени
        **API:** `POST /security/validate-action`, `POST /security/report-suspicious`

        ### 7. realtime-gateway-go
        **Ответственность:** WebSocket/UDP соединения с клиентами
        **Интеграция:** Проксирует события между клиентами и gameplay-service
        **Протоколы:** WebSocket (PvE), UDP (PvP)

        ## Инфраструктурные компоненты

        ### PostgreSQL
        **Назначение:** Хранение сессий, логов, статистики
        **Схемы:** `combat_sessions`, `combat_logs`, `combat_participants`

        ### Redis
        **Назначение:** Кэширование активных сессий, состояния игроков
        **TTL:** 1 час (активные сессии), 10 минут (кэш состояний)

        ### Kafka
        **Назначение:** Event bus для асинхронной интеграции
        **Топики:** `combat.session.created`, `combat.action.executed`, `combat.session.ended`

    - id: api-endpoints
      title: "API Endpoints (High-Level)"
      body: |
        ## Combat Session Management

        ### POST /api/v1/gameplay/combat/sessions
        Создание новой боевой сессии
        **Request:** 
        - `session_type` (pvp_arena, pve_raid, extract_zone)
        - `participants` (player_ids)
        - `settings` (zone_id, difficulty, rules)
        **Response:** `session_id`, `session_state`
        **Events:** `combat.session.created`

        ### GET /api/v1/gameplay/combat/sessions/{session_id}
        Получение состояния боевой сессии
        **Response:** `session_state`, `participants`, `current_turn`

        ### DELETE /api/v1/gameplay/combat/sessions/{session_id}
        Завершение боевой сессии
        **Events:** `combat.session.ended`

        ## Combat Actions

        ### POST /api/v1/gameplay/combat/sessions/{session_id}/actions
        Выполнение боевого действия
        **Request:**
        - `action_type` (attack, ability, move, reload, extract)
        - `target_id` (для атак)
        - `position` (для движения)
        - `ability_id` (для способностей)
        **Response:** `action_result`, `damage_dealt`, `effects_applied`
        **Events:** `combat.action.executed`
        **Validation:** Античит-проверки (speed, position, cooldowns)

        ### GET /api/v1/gameplay/combat/sessions/{session_id}/state
        Получение текущего состояния боя (realtime)
        **Response:** `participants_state`, `turn_order`, `active_effects`

        ## Combat Analytics

        ### GET /api/v1/gameplay/combat/sessions/{session_id}/logs
        Получение логов боевой сессии
        **Response:** Array of combat events with timestamps

        ### GET /api/v1/gameplay/combat/sessions/{session_id}/stats
        Получение статистики боевой сессии
        **Response:** Damage dealt/taken, kills, assists, accuracy

        ## Integration Endpoints

        ### POST /api/v1/gameplay/combat/rewards
        Выдача наград за бой (вызывается economy-service)
        **Request:** `session_id`, `winners`, `losers`

        ### POST /api/v1/gameplay/combat/quest-progress
        Обновление прогресса квестов (вызывается quest-service)
        **Request:** `session_id`, `player_id`, `quest_id`

    - id: data-flows
      title: "Потоки данных"
      body: |
        ## 1. Создание боевой сессии

        ```mermaid
        sequenceDiagram
            Client->>+Realtime Gateway: Create Combat Session
            Realtime Gateway->>+Gameplay Service: POST /combat/sessions
            Gameplay Service->>+Character Service: GET Combat Stats
            Character Service-->>-Gameplay Service: Stats + Loadout
            Gameplay Service->>PostgreSQL: INSERT combat_sessions
            Gameplay Service->>Redis: SETEX session:{id}
            Gameplay Service->>Kafka: Publish combat.session.created
            Gameplay Service-->>-Realtime Gateway: Session Created
            Realtime Gateway-->>-Client: Session ID + State
            Kafka-->>Analytics Service: Event: combat.session.created
        ```

        ## 2. Обработка боевого действия

        ```mermaid
        sequenceDiagram
            Client->>+Realtime Gateway: Execute Action (WebSocket/UDP)
            Realtime Gateway->>+Gameplay Service: POST /combat/actions
            Gameplay Service->>Security Service: Validate Action (Anti-Cheat)
            Security Service-->>Gameplay Service: Validation Result
            alt Action Valid
                Gameplay Service->>Combat Engine: Calculate Damage
                Combat Engine->>Redis: Update Session State
                Gameplay Service->>PostgreSQL: INSERT combat_logs
                Gameplay Service->>Kafka: Publish combat.action.executed
                Gameplay Service-->>Realtime Gateway: Action Result
                Realtime Gateway-->>Client: State Update
                Kafka-->>Analytics Service: Event: combat.action.executed
            else Action Invalid
                Gameplay Service->>Security Service: Report Suspicious
                Gameplay Service-->>Realtime Gateway: Action Rejected
            end
        ```

        ## 3. Завершение боевой сессии

        ```mermaid
        sequenceDiagram
            Gameplay Service->>+Gameplay Service: Session Timeout/Win Condition
            Gameplay Service->>PostgreSQL: UPDATE combat_sessions (status=ended)
            Gameplay Service->>Redis: DEL session:{id}
            Gameplay Service->>Kafka: Publish combat.session.ended
            Kafka-->>Economy Service: Event: combat.session.ended
            Economy Service->>+Economy Service: Calculate Rewards
            Economy Service->>Gameplay Service: POST /combat/rewards
            Gameplay Service-->>-Client: Session Ended + Rewards
            Kafka-->>Quest Service: Event: combat.session.ended
            Quest Service->>Quest Service: Update Quest Progress
            Kafka-->>Analytics Service: Event: combat.session.ended
        ```

    - id: database-schema
      title: "Структура базы данных"
      body: |
        ## PostgreSQL Tables

        ### combat_sessions
        ```sql
        CREATE TABLE combat_sessions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          session_type VARCHAR(50) NOT NULL,  -- pvp_arena, pve_raid, extract_zone
          zone_id VARCHAR(100),
          status VARCHAR(20) NOT NULL,  -- pending, active, ended, aborted
          difficulty VARCHAR(20),  -- normal, hard, elite
          max_participants INT NOT NULL,
          settings JSONB,
          
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          started_at TIMESTAMP,
          ended_at TIMESTAMP,
          duration_seconds INT,
          
          winner_team VARCHAR(50),  -- team_a, team_b, draw, NULL
          
          CONSTRAINT valid_status CHECK (status IN ('pending', 'active', 'ended', 'aborted')),
          CONSTRAINT valid_type CHECK (session_type IN ('pvp_arena', 'pve_raid', 'extract_zone', 'guild_war'))
        );

        CREATE INDEX idx_combat_sessions_status ON combat_sessions(status);
        CREATE INDEX idx_combat_sessions_created ON combat_sessions(created_at DESC);
        CREATE INDEX idx_combat_sessions_type ON combat_sessions(session_type);
        ```

        ### combat_participants
        ```sql
        CREATE TABLE combat_participants (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          session_id UUID NOT NULL REFERENCES combat_sessions(id) ON DELETE CASCADE,
          player_id UUID NOT NULL,
          character_id UUID NOT NULL,
          
          team VARCHAR(50),  -- team_a, team_b, solo
          role VARCHAR(50),  -- assault, support, tech, stealth
          
          -- Combat Stats
          damage_dealt BIGINT DEFAULT 0,
          damage_taken BIGINT DEFAULT 0,
          healing_done BIGINT DEFAULT 0,
          kills INT DEFAULT 0,
          deaths INT DEFAULT 0,
          assists INT DEFAULT 0,
          shots_fired INT DEFAULT 0,
          shots_hit INT DEFAULT 0,
          
          -- State
          health INT NOT NULL,
          max_health INT NOT NULL,
          status VARCHAR(20) DEFAULT 'alive',  -- alive, dead, extracted
          
          joined_at TIMESTAMP NOT NULL DEFAULT NOW(),
          left_at TIMESTAMP,
          
          CONSTRAINT valid_status CHECK (status IN ('alive', 'dead', 'extracted', 'disconnected'))
        );

        CREATE INDEX idx_participants_session ON combat_participants(session_id);
        CREATE INDEX idx_participants_player ON combat_participants(player_id);
        CREATE UNIQUE INDEX idx_participants_unique ON combat_participants(session_id, player_id);
        ```

        ### combat_logs
        ```sql
        CREATE TABLE combat_logs (
          id BIGSERIAL PRIMARY KEY,
          session_id UUID NOT NULL REFERENCES combat_sessions(id) ON DELETE CASCADE,
          
          event_type VARCHAR(50) NOT NULL,  -- attack, ability, move, reload, death, extract
          actor_id UUID,  -- player who performed action
          target_id UUID,  -- player who received action
          
          action_data JSONB,  -- weapon_id, ability_id, damage, position, etc.
          result_data JSONB,  -- damage_dealt, effects_applied, etc.
          
          timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
          sequence_number BIGINT NOT NULL,
          
          CONSTRAINT valid_event_type CHECK (event_type IN (
            'attack', 'ability', 'move', 'reload', 'death', 'extract',
            'heal', 'revive', 'status_effect', 'objective_complete'
          ))
        );

        CREATE INDEX idx_combat_logs_session ON combat_logs(session_id, sequence_number);
        CREATE INDEX idx_combat_logs_timestamp ON combat_logs(timestamp DESC);
        CREATE INDEX idx_combat_logs_actor ON combat_logs(actor_id);
        ```

        ## Redis Keys

        ### Active Session State
        ```
        Key: session:{session_id}
        Type: Hash
        TTL: 3600 seconds
        Fields:
          - status: active
          - participants: [player_ids]
          - current_turn: player_id
          - turn_number: int
          - last_action: timestamp
        ```

        ### Player Combat State
        ```
        Key: player:{player_id}:combat
        Type: Hash
        TTL: 3600 seconds
        Fields:
          - session_id: UUID
          - health: int
          - position: {x,y,z}
          - status: alive/dead
          - last_action: timestamp
        ```

    - id: event-sourcing
      title: "Event Sourcing & CQRS"
      body: |
        ## Event Bus (Kafka)

        ### Topics

        #### combat.session.created
        ```json
        {
          "event_id": "uuid",
          "event_type": "combat.session.created",
          "timestamp": "2025-12-02T17:00:00Z",
          "session_id": "uuid",
          "session_type": "pvp_arena",
          "participants": ["player_id1", "player_id2"],
          "zone_id": "arena_01",
          "settings": {}
        }
        ```

        #### combat.action.executed
        ```json
        {
          "event_id": "uuid",
          "event_type": "combat.action.executed",
          "timestamp": "2025-12-02T17:00:01Z",
          "session_id": "uuid",
          "actor_id": "player_id1",
          "action_type": "attack",
          "target_id": "player_id2",
          "damage_dealt": 150,
          "effects_applied": ["bleeding"],
          "validation": {
            "anti_cheat_passed": true,
            "position_valid": true,
            "cooldown_valid": true
          }
        }
        ```

        #### combat.session.ended
        ```json
        {
          "event_id": "uuid",
          "event_type": "combat.session.ended",
          "timestamp": "2025-12-02T17:05:00Z",
          "session_id": "uuid",
          "winner_team": "team_a",
          "duration_seconds": 300,
          "participants_stats": [
            {
              "player_id": "uuid",
              "damage_dealt": 5000,
              "kills": 3,
              "deaths": 1
            }
          ]
        }
        ```

        ## Event Consumers

        - **Economy Service:** Слушает `combat.session.ended` → выдает награды
        - **Quest Service:** Слушает `combat.action.executed`, `combat.session.ended` → обновляет квесты
        - **Analytics Service:** Слушает все `combat.*` → сохраняет телеметрию
        - **Security Service:** Слушает `combat.action.executed` → детектит читы

    - id: network-architecture
      title: "Сетевая архитектура и тикрейт"
      body: |
        ## Протоколы синхронизации

        ### PvE зоны (MMORPG)
        - **Протокол:** WebSocket (TCP)
        - **Тикрейт:** 20-30 Hz
        - **Задержка:** <100 мс
        - **Игроков:** 100-500
        - **Использование:** Рейды, инстансы, открытый мир

        ### PvP small (Arenas)
        - **Протокол:** UDP
        - **Тикрейт:** 60-128 Hz
        - **Задержка:** <30 мс
        - **Игроков:** 5-20
        - **Синхронизация:** Полная (все видят всех)

        ### GvG 200 (Guild Wars)
        - **Протокол:** UDP
        - **Тикрейт:** 60-80 Hz
        - **Задержка:** <40 мс
        - **Игроков:** 100v100
        - **Оптимизация:** Spatial partitioning

        ### GvG 400 (Large Guild Wars)
        - **Протокол:** UDP
        - **Тикрейт:** 40-60 Hz
        - **Задержка:** <50 мс
        - **Игроков:** 200v200
        - **Оптимизация:** Spatial sharding (2-4 shards)

        ### Massive war (Territory Wars)
        - **Протокол:** UDP
        - **Тикрейт:** 20-40 Hz
        - **Задержка:** <100 мс
        - **Игроков:** 2000+
        - **Архитектура:** Cluster (5-10 servers)

        ## Server-Authoritative Model

        - Клиент отправляет **намерения** (input), а не состояние
        - Сервер валидирует все действия
        - Сервер рассчитывает урон, хиты, движение
        - Клиент получает **результаты** и обновляет локальное состояние
        - Клиент использует **client-side prediction** для отзывчивости
        - Сервер использует **lag compensation** и **rewind buffer**

        ## Anti-Cheat Integration

        - Валидация скорости движения (max speed checks)
        - Валидация позиции (teleport detection)
        - Валидация частоты действий (cooldown checks)
        - Валидация точности стрельбы (aimbot detection)
        - Reconciliation при desync

    - id: scalability
      title: "Масштабируемость"
      body: |
        ## Horizontal Scaling

        ### Gameplay Service
        - Stateless HTTP handlers для API
        - Stateful session managers (sticky sessions через Redis)
        - Шардирование сессий по `session_id % num_shards`
        - Load balancing через Envoy

        ### Database Sharding
        - Шардирование `combat_sessions` по `created_at` (временные партиции)
        - Репликация read replicas для аналитики
        - Redis cluster для кэша

        ### Kafka Partitioning
        - Партиционирование по `session_id` для гарантии порядка
        - Несколько consumer groups для параллельной обработки

        ## Performance Targets

        - **Latency P99:** <50ms (API endpoints)
        - **Throughput:** 10,000 actions/sec per instance
        - **Session Capacity:** 1,000 active sessions per instance
        - **Database Write Rate:** 50,000 logs/sec
        - **Event Bus Throughput:** 100,000 events/sec

    - id: security
      title: "Безопасность"
      body: |
        ## Authentication & Authorization

        - JWT токены для аутентификации
        - Session tokens с TTL 1 час
        - Rate limiting: 100 actions/min per player
        - IP-based throttling для DDoS защиты

        ## Anti-Cheat Measures

        - **Speed Hack Detection:** Max speed validation
        - **Teleport Detection:** Position delta validation
        - **Aimbot Detection:** Accuracy pattern analysis
        - **Cooldown Exploit:** Server-side cooldown tracking
        - **Macro Detection:** Action timing analysis

        ## Data Protection

        - Шифрование WebSocket/UDP соединений (TLS 1.3)
        - Sensitive data в PostgreSQL (PII, stats)
        - Redis для временных данных (не критичны)

    - id: monitoring
      title: "Мониторинг и observability"
      body: |
        ## Metrics (Prometheus)

        ### Combat Session Metrics
        - `combat_sessions_total` (counter) - всего сессий
        - `combat_sessions_active` (gauge) - активных сессий
        - `combat_sessions_duration_seconds` (histogram) - длительность
        - `combat_actions_total` (counter) - всего действий
        - `combat_actions_invalid` (counter) - невалидных действий

        ### Performance Metrics
        - `combat_api_latency_seconds` (histogram) - задержка API
        - `combat_event_processing_duration` (histogram) - обработка событий
        - `combat_database_query_duration` (histogram) - запросы к БД

        ### Anti-Cheat Metrics
        - `combat_anticheat_violations` (counter) - нарушения
        - `combat_suspicious_actions` (counter) - подозрительные действия

        ## Logs (Loki)

        - Структурированное логирование (JSON)
        - Логи всех действий с `session_id`, `player_id`
        - Корреляция логов с трейсами (trace_id)

        ## Tracing (Tempo)

        - Distributed tracing для всех запросов
        - Корреляция с логами и метриками
        - Trace sampling: 10% (normal), 100% (errors)

        ## Dashboards (Grafana)

        - Combat Session Overview
        - Performance Dashboard
        - Anti-Cheat Dashboard
        - Player Behavior Analytics

    - id: integrations
      title: "Интеграции с другими системами"
      body: |
        ## Character Service Integration

        - **API:** `GET /characters/{id}/combat-stats`
        - **Data:** HP, атрибуты, импланты, способности, loadout
        - **Caching:** Redis, TTL 10 минут
        - **Fallback:** Default stats при недоступности

        ## Economy Service Integration

        - **Event:** `combat.session.ended`
        - **API:** `POST /economy/combat-rewards`
        - **Data:** Награды за победу, лут, опыт
        - **Retry:** Exponential backoff при ошибках

        ## Quest Service Integration

        - **Event:** `combat.action.executed`, `combat.session.ended`
        - **API:** `POST /quests/progress/combat-event`
        - **Data:** Квестовые события (kills, damage, objectives)
        - **Async:** Обработка через Kafka

        ## Analytics Service Integration

        - **Event:** Все `combat.*` события
        - **API:** `POST /analytics/combat-telemetry`
        - **Data:** Полная телеметрия боев
        - **Storage:** ClickHouse для анализа

        ## Security Service Integration

        - **Event:** `combat.action.executed`
        - **API:** `POST /security/validate-action`
        - **Data:** Action data для анализа
        - **Realtime:** Синхронная валидация (timeout 50ms)

    - id: deployment
      title: "Деплой и инфраструктура"
      body: |
        ## Kubernetes Deployment

        ### Gameplay Service
        ```yaml
        replicas: 10
        resources:
          requests:
            cpu: 2000m
            memory: 4Gi
          limits:
            cpu: 4000m
            memory: 8Gi
        ```

        ### Realtime Gateway
        ```yaml
        replicas: 20
        resources:
          requests:
            cpu: 1000m
            memory: 2Gi
          limits:
            cpu: 2000m
            memory: 4Gi
        ```

        ### PostgreSQL
        ```yaml
        type: StatefulSet
        replicas: 3 (1 primary + 2 replicas)
        storage: 1TB (SSD)
        ```

        ### Redis Cluster
        ```yaml
        type: StatefulSet
        replicas: 6 (3 masters + 3 replicas)
        memory: 16GB per instance
        ```

        ### Kafka Cluster
        ```yaml
        replicas: 5
        partitions: 20 per topic
        replication_factor: 3
        ```

        ## CI/CD

        - GitHub Actions для сборки и тестов
        - Docker images для сервисов
        - ArgoCD для деплоя в K8s
        - Canary deployments для критичных сервисов

appendix:
  glossary:
    - term: "Combat Session"
      definition: "Инстанс боевого взаимодействия между игроками и/или NPC"
    - term: "Session Manager"
      definition: "Компонент, управляющий жизненным циклом боевых сессий"
    - term: "Combat Engine"
      definition: "Компонент, отвечающий за расчет урона и боевых эффектов"
    - term: "Action Validator"
      definition: "Компонент античита, валидирующий действия игроков"
  references:
    - title: "Combat Shooter Core"
      url: "knowledge/mechanics/combat/combat-shooter-core.yaml"
    - title: "Combat PvP/PvE"
      url: "knowledge/mechanics/combat/combat-pvp-pve.yaml"
    - title: "Combat Session Backend"
      url: "knowledge/implementation/backend/combat-session-backend.yaml"
  decisions:
    - id: "arch-001"
      decision: "Использовать Event-driven архитектуру через Kafka"
      rationale: "Обеспечивает асинхронную интеграцию и масштабируемость"
      alternatives: "Синхронный REST API между сервисами"
    - id: "arch-002"
      decision: "Server-authoritative модель для боевых действий"
      rationale: "Предотвращает читерство и обеспечивает честность игры"
      alternatives: "Client-authoritative с валидацией"
    - id: "arch-003"
      decision: "Разные протоколы для PvE (WebSocket) и PvP (UDP)"
      rationale: "Оптимизация под разные требования к задержке и надежности"
      alternatives: "Единый протокол для всех режимов"

implementation:
  github_issue: 130
  needs_task: true
  next_steps:
    - "API Designer: Создать OpenAPI спецификацию для Combat Session API"
    - "Database: Создать миграции для combat_sessions, combat_participants, combat_logs"
    - "Backend: Реализовать gameplay-service handlers"
    - "Network: Настроить WebSocket/UDP gateway"
    - "Security: Интегрировать античит валидацию"
  blockers: []

history:
  - version: "1.0.0"
    date: 2025-12-02
    author: architect
    changes: "Создана полная архитектура системы боевых сессий"

validation:
  checksum: ""
  schema_version: "1.0"
