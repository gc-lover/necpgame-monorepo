metadata:
  id: data-synchronization-consistency-guide
  title: "Руководство по синхронизации данных и консистентности для MMORPG"
  document_type: architecture
  category: systems
  status: draft
  version: "1.0.0"
  last_updated: 2025-11-29T12:30:00Z
  owners:
    - role: architect
      contact: architect@necp.game
  tags:
    - architecture
    - data-synchronization
    - consistency
    - database
    - microservices
    - mmorpg
  related_systems:
    - character-service-go
    - inventory-service-go
    - world-service-go
    - realtime-gateway-go
  related_documents:
    - id: hybrid-network-system-architecture
      relation: extends
    - id: realtime-server-system-architecture
      relation: extends
  visibility: internal
  audience:
    - architect
    - backend
    - database

summary:
  problem: |
    Требуется обеспечить качественную синхронизацию данных между различными слоями
    (клиент, сервер, база данных) и механиками игры (инвентарь, персонаж, квесты, боевая система),
    а также достичь консистентности данных в распределенной микросервисной архитектуре.
  goal: |
    Создать руководство по проектированию синхронизации данных и обеспечению консистентности
    для MMORPG с множеством механик и микросервисов.
  essence: |
    Комплексный подход к синхронизации данных между слоями и механиками с использованием
    событийной архитектуры, транзакций, паттернов распределенных систем и стратегий консистентности.

content:
  sections:
    - id: synchronization_between_layers
      title: Синхронизация между слоями и механиками
      body: |
        ## Архитектурные принципы

        ### 1. Клиент-серверная модель с авторитетным сервером

        **Принцип:** Сервер является единственным источником истины (Single Source of Truth)

        **Реализация:**
        - Все критичные игровые данные хранятся и обрабатываются на сервере
        - Клиент получает обновления состояния от сервера
        - Клиентское предсказание используется только для UX, но не влияет на финальное состояние
        - Сервер валидирует все действия клиента перед применением

        **Применение:**
        - Позиции персонажей
        - Инвентарь и предметы
        - Боевая система (урон, здоровье)
        - Экономика (деньги, торговля)
        - Прогресс (опыт, уровни, квесты)

        ### 2. Событийная архитектура (Event-Driven Architecture)

        **Принцип:** Механики взаимодействуют через события, а не прямые вызовы

        **Преимущества:**
        - Слабая связанность между механиками
        - Легкое добавление новых механик
        - Масштабируемость
        - Возможность отката изменений

        **Реализация:**
        - Event Bus (Kafka, RabbitMQ, или внутренний)
        - События: `ItemAdded`, `CharacterLevelUp`, `QuestCompleted`, `CombatDamageDealt`
        - Подписчики на события обрабатывают их асинхронно
        - События сохраняются для аудита и отката

        **Пример:**
        ```
        CharacterService → Event: CharacterLevelUp
        ↓
        InventoryService (подписчик) → Разблокировка слотов инвентаря
        QuestService (подписчик) → Проверка квестов на уровень
        AchievementService (подписчик) → Проверка достижений
        ```

        ### 3. Приоритетная синхронизация

        **Принцип:** Механики могут изменяться параллельно, если не влияют друг на друга

        **Реализация:**
        - Определение зависимостей между механиками
        - Параллельная обработка независимых операций
        - Последовательная обработка зависимых операций
        - Использование транзакций для атомарности

        **Пример:**
        - Параллельно: обновление позиции персонажа + отправка сообщения в чат
        - Последовательно: покупка предмета → обновление инвентаря → списание денег

        ### 4. Метки времени и согласование на сервере

        **Принцип:** Все действия имеют временные метки для корректной обработки

        **Реализация:**
        - Каждое действие клиента содержит timestamp
        - Сервер обрабатывает действия с учетом временных меток
        - Пересчет состояния при получении запоздалых действий
        - Использование Vector Clocks для распределенных систем

        **Применение:**
        - Боевая система (урон, лечение)
        - Торговля (покупка/продажа)
        - Квесты (взаимодействие с NPC)

        ### 5. Интерполяция и экстраполяция

        **Принцип:** Сглаживание движений для компенсации сетевых задержек

        **Реализация:**
        - Интерполяция: сглаживание между известными состояниями
        - Экстраполяция: прогнозирование будущих состояний
        - Коррекция при получении актуального состояния от сервера

        **Применение:**
        - Движение персонажей
        - Анимации
        - Физика объектов

    - id: database_consistency
      title: Консистентность данных в базах данных
      body: |
        ## Модели консистентности

        ### 1. Строгая консистентность (Strong Consistency)

        **Применение:** Критичные данные, где недопустимы временные несоответствия

        **Использование:**
        - Финансовые операции (деньги, торговля)
        - Инвентарь (предметы, слоты)
        - Персонаж (статы, уровни)
        - Квесты (прогресс, награды)

        **Реализация:**
        - ACID транзакции (PostgreSQL)
        - Блокировки (pessimistic/optimistic locking)
        - Ссылочная целостность (foreign keys)
        - Уровни изоляции транзакций

        ### 2. Конечная консистентность (Eventual Consistency)

        **Применение:** Некритичные данные, где допустимы временные несоответствия

        **Использование:**
        - Статистика игроков
        - Логи активности
        - Аналитика
        - Кэшируемые данные

        **Реализация:**
        - Асинхронная репликация
        - Event Sourcing
        - CQRS (Command Query Responsibility Segregation)
        - Message queues для синхронизации

        ### 3. Теорема CAP и выбор стратегии

        **CAP:** Consistency, Availability, Partition tolerance

        **Для MMORPG:**
        - **CP (Consistency + Partition tolerance):** Критичные данные (инвентарь, деньги)
        - **AP (Availability + Partition tolerance):** Некритичные данные (статистика, логи)

        **Реализация:**
        - Разные стратегии для разных типов данных
        - Мониторинг консистентности
        - Механизмы разрешения конфликтов

        ## Паттерны обеспечения консистентности

        ### 1. ACID транзакции

        **Применение:** Операции, требующие атомарности

        **Примеры:**
        - Покупка предмета: списание денег + добавление в инвентарь
        - Улучшение предмета: удаление материалов + обновление предмета
        - Завершение квеста: обновление прогресса + выдача наград

        **Реализация:**
        ```go
        tx, err := db.BeginTx(ctx, &sql.TxOptions{
            Isolation: sql.LevelSerializable,
        })
        // ... операции ...
        if err != nil {
            tx.Rollback()
            return err
        }
        tx.Commit()
        ```

        ### 2. Saga Pattern (для распределенных транзакций)

        **Применение:** Операции, затрагивающие несколько микросервисов

        **Типы:**
        - **Choreography:** Каждый сервис знает, что делать дальше
        - **Orchestration:** Центральный координатор управляет процессом

        **Пример:**
        ```
        Покупка предмета в магазине:
        1. InventoryService: резервирование слота
        2. CharacterService: проверка денег
        3. CharacterService: списание денег
        4. InventoryService: добавление предмета
        5. Если ошибка на любом шаге → компенсирующие транзакции
        ```

        ### 3. Event Sourcing

        **Применение:** Аудит, откат изменений, восстановление состояния

        **Реализация:**
        - Все изменения сохраняются как события
        - Состояние вычисляется из событий
        - Снимки состояния для производительности
        - Возможность отката к любому моменту времени

        **Пример:**
        ```
        Events:
        - CharacterCreated
        - ItemAdded (item_id: 123)
        - ItemRemoved (item_id: 123)
        - MoneyAdded (amount: 1000)
        
        Current State = Apply(Events)
        ```

        ### 4. CQRS (Command Query Responsibility Segregation)

        **Применение:** Разделение операций чтения и записи

        **Преимущества:**
        - Оптимизация для чтения и записи отдельно
        - Масштабирование независимо
        - Разные модели данных для чтения/записи

        **Реализация:**
        - Command Side: обработка команд (изменение данных)
        - Query Side: оптимизированные представления для чтения
        - Синхронизация через события

        ### 5. Блокировки и изоляция

        **Типы блокировок:**
        - **Pessimistic Locking:** Блокировка на время транзакции
        - **Optimistic Locking:** Проверка версии перед обновлением

        **Уровни изоляции:**
        - **Read Uncommitted:** Минимальная изоляция
        - **Read Committed:** Стандартный уровень (PostgreSQL по умолчанию)
        - **Repeatable Read:** Гарантирует повторяемость чтения
        - **Serializable:** Максимальная изоляция (для критичных операций)

        **Применение:**
        - Pessimistic: торговля, аукционы
        - Optimistic: обновление статистики, логи

    - id: synchronization_patterns
      title: Паттерны синхронизации между механиками
      body: |
        ## Паттерны взаимодействия

        ### 1. Event Bus Pattern

        **Описание:** Централизованная шина событий для обмена сообщениями

        **Реализация:**
        - Kafka, RabbitMQ, или внутренний Event Bus
        - Публикация событий от механик
        - Подписка механик на интересующие события
        - Гарантия доставки (at-least-once или exactly-once)

        **Пример:**
        ```
        CombatService → Event: DamageDealt
        ↓
        CharacterService → Обновление здоровья
        AchievementService → Проверка достижений
        QuestService → Проверка квестов на урон
        ```

        ### 2. Outbox Pattern

        **Описание:** Гарантированная доставка событий из транзакций

        **Проблема:** Как гарантировать отправку события при успешной транзакции?

        **Решение:**
        1. Запись события в таблицу Outbox в той же транзакции
        2. Отдельный процесс читает Outbox и отправляет события
        3. После успешной отправки событие удаляется из Outbox

        **Реализация:**
        ```sql
        BEGIN;
        UPDATE inventory SET ...;
        INSERT INTO outbox (event_type, payload) VALUES (...);
        COMMIT;
        ```

        ### 3. Two-Phase Commit (2PC)

        **Описание:** Координация транзакций между несколькими БД

        **Применение:** Критичные операции, затрагивающие несколько сервисов

        **Этапы:**
        1. **Prepare:** Все участники готовы к коммиту
        2. **Commit:** Все участники коммитят транзакцию

        **Недостатки:** Высокая задержка, блокировки

        **Альтернатива:** Saga Pattern (предпочтительнее для микросервисов)

        ### 4. Idempotency Pattern

        **Описание:** Операции должны быть идемпотентными

        **Применение:** Защита от дублирования операций

        **Реализация:**
        - Уникальные ID для операций
        - Проверка выполнения операции перед повторным выполнением
        - Кэширование результатов идемпотентных операций

        **Пример:**
        ```
        Operation ID: uuid-v4
        Если операция уже выполнена → возврат результата
        Если нет → выполнение операции
        ```

        ### 5. Circuit Breaker Pattern

        **Описание:** Защита от каскадных сбоев

        **Применение:** При сбое одного сервиса не должны падать другие

        **Состояния:**
        - **Closed:** Нормальная работа
        - **Open:** Сервис недоступен, возврат ошибки
        - **Half-Open:** Проверка восстановления сервиса

    - id: implementation_recommendations
      title: Рекомендации по реализации
      body: |
        ## Архитектурные решения

        ### 1. Разделение на слои

        **Трехслойная архитектура:**
        - **Data Layer:** База данных, репозитории
        - **Business Logic Layer:** Сервисы, механики
        - **Presentation Layer:** API, WebSocket handlers

        **Преимущества:**
        - Четкое разделение ответственности
        - Легкое тестирование
        - Возможность замены слоев

        ### 2. Микросервисная архитектура

        **Принципы:**
        - Каждый сервис отвечает за свою доменную область
        - Независимое развертывание
        - Слабая связанность через события

        **Сервисы:**
        - `character-service-go`: Персонажи, статы, уровни
        - `inventory-service-go`: Инвентарь, предметы
        - `quest-service-go`: Квесты, прогресс
        - `combat-service-go`: Боевая система
        - `economy-service-go`: Экономика, торговля

        ### 3. Event-Driven Communication

        **Реализация:**
        - Kafka для критичных событий
        - RabbitMQ для некритичных событий
        - gRPC для синхронных вызовов (только при необходимости)

        **События:**
        - `character.level_up`
        - `inventory.item_added`
        - `quest.completed`
        - `combat.damage_dealt`
        - `economy.transaction_completed`

        ### 4. Database per Service

        **Принцип:** Каждый микросервис имеет свою БД

        **Преимущества:**
        - Независимость сервисов
        - Разные типы БД для разных задач
        - Масштабирование независимо

        **Синхронизация:**
        - Через события (Event Sourcing)
        - Через API (для критичных данных)
        - Через репликацию (для некритичных данных)

        ### 5. Caching Strategy

        **Уровни кэширования:**
        - **L1 (In-Memory):** Горячие данные в памяти сервиса
        - **L2 (Redis):** Распределенный кэш для общих данных
        - **L3 (Database):** Персистентное хранилище

        **Инвалидация:**
        - По времени (TTL)
        - По событиям (при изменении данных)
        - По версиям (версионирование данных)

    - id: consistency_strategies
      title: Стратегии консистентности для разных типов данных
      body: |
        ## Классификация данных по критичности

        ### Критичные данные (Strong Consistency)

        **Требования:**
        - Мгновенная консистентность
        - ACID транзакции
        - Блокировки при необходимости

        **Примеры:**
        - Инвентарь (предметы, слоты)
        - Деньги (валюта, баланс)
        - Персонаж (статы, уровни)
        - Квесты (прогресс, награды)

        **Реализация:**
        - PostgreSQL с транзакциями
        - Pessimistic locking для торговли
        - Optimistic locking для обновлений

        ### Некритичные данные (Eventual Consistency)

        **Требования:**
        - Допустимы временные несоответствия
        - Синхронизация через события
        - Компенсация при ошибках

        **Примеры:**
        - Статистика игроков
        - Логи активности
        - Аналитика
        - Кэшируемые данные

        **Реализация:**
        - Асинхронная обработка
        - Event Sourcing
        - CQRS для чтения

        ### Гибридный подход

        **Принцип:** Разные стратегии для разных частей системы

        **Пример:**
        - Инвентарь: Strong Consistency (PostgreSQL)
        - Статистика: Eventual Consistency (Redis + события)
        - Логи: Eventual Consistency (Kafka + ClickHouse)

    - id: conflict_resolution
      title: Разрешение конфликтов
      body: |
        ## Стратегии разрешения конфликтов

        ### 1. Last Write Wins (LWW)

        **Применение:** Некритичные данные

        **Реализация:**
        - Использование timestamp
        - Последнее обновление побеждает

        **Недостатки:** Потеря данных при одновременных обновлениях

        ### 2. Vector Clocks

        **Применение:** Распределенные системы

        **Реализация:**
        - Вектор временных меток для каждого узла
        - Определение причинно-следственных связей
        - Разрешение конфликтов на основе порядка событий

        ### 3. Operational Transformation (OT)

        **Применение:** Совместное редактирование

        **Реализация:**
        - Трансформация операций для согласования
        - Применение операций в правильном порядке

        ### 4. Conflict-Free Replicated Data Types (CRDTs)

        **Применение:** Распределенные структуры данных

        **Преимущества:**
        - Автоматическое разрешение конфликтов
        - Гарантированная консистентность
        - Без координации между узлами

        **Примеры:**
        - Counters (счетчики)
        - Sets (множества)
        - Maps (словари)

    - id: monitoring_and_validation
      title: Мониторинг и валидация консистентности
      body: |
        ## Мониторинг консистентности

        ### 1. Метрики

        **Метрики для отслеживания:**
        - Время синхронизации между сервисами
        - Количество конфликтов
        - Задержка репликации
        - Количество неконсистентных данных

        ### 2. Валидация данных

        **Проверки:**
        - Референсная целостность (foreign keys)
        - Бизнес-правила (валидация данных)
        - Согласованность между сервисами

        ### 3. Алерты

        **Триггеры:**
        - Обнаружение неконсистентных данных
        - Превышение времени синхронизации
        - Критичные ошибки транзакций

        ### 4. Аудит

        **Логирование:**
        - Все изменения данных
        - События синхронизации
        - Ошибки и конфликты

        **Использование:**
        - Отладка проблем
        - Восстановление данных
        - Анализ производительности

appendix:
  glossary:
    - term: Strong Consistency (Строгая консистентность)
      definition: Все реплики данных мгновенно согласованы. Любое чтение возвращает последнее записанное значение.
    - term: Eventual Consistency (Конечная консистентность)
      definition: Данные могут быть временно несогласованы, но со временем синхронизируются.
    - term: ACID
      definition: Atomicity (атомарность), Consistency (консистентность), Isolation (изоляция), Durability (долговечность) - свойства транзакций.
    - term: Event Sourcing
      definition: Хранение всех изменений состояния как последовательности событий. Состояние вычисляется из событий.
    - term: CQRS
      definition: Command Query Responsibility Segregation - разделение операций чтения и записи для оптимизации.
    - term: Saga Pattern
      definition: Паттерн для управления распределенными транзакциями через последовательность локальных транзакций с компенсацией.
    - term: Outbox Pattern
      definition: Паттерн для гарантированной доставки событий из транзакций через таблицу Outbox.
    - term: Idempotency (Идемпотентность)
      definition: Свойство операции, при котором повторное выполнение дает тот же результат, что и первое выполнение.
    - term: Circuit Breaker
      definition: Паттерн для защиты от каскадных сбоев путем временного отключения недоступных сервисов.
    - term: Vector Clocks
      definition: Механизм для определения причинно-следственных связей в распределенных системах.
    - term: CRDT
      definition: Conflict-Free Replicated Data Types - структуры данных, автоматически разрешающие конфликты при репликации.

  references:
    - title: "Синхронизация данных в многопользовательских играх"
      link: https://habr.com/ru/articles/328702/
    - title: "Консистентность данных в распределенных системах"
      link: https://habr.com/ru/companies/flant/articles/500850/
    - title: "Event Sourcing и CQRS"
      link: https://martinfowler.com/eaaDev/EventSourcing.html
    - title: "Saga Pattern для микросервисов"
      link: https://microservices.io/patterns/data/saga.html
    - title: "Теорема CAP"
      link: https://ru.wikipedia.org/wiki/Теорема_CAP

  decisions:
    - date: 2025-11-29
      decision: Использовать Strong Consistency для критичных данных (инвентарь, деньги, персонаж)
      rationale: Критичные данные требуют мгновенной консистентности для предотвращения дублирования предметов, потери денег и других проблем.
    - date: 2025-11-29
      decision: Использовать Eventual Consistency для некритичных данных (статистика, логи, аналитика)
      rationale: Некритичные данные могут быть временно несогласованы, что позволяет улучшить производительность и масштабируемость.
    - date: 2025-11-29
      decision: Применить Event-Driven Architecture для синхронизации между механиками
      rationale: Событийная архитектура обеспечивает слабую связанность между механиками и упрощает добавление новых функций.
    - date: 2025-11-29
      decision: Использовать Saga Pattern для распределенных транзакций между микросервисами
      rationale: Saga Pattern более подходит для микросервисов, чем 2PC, так как не требует блокировок и обеспечивает лучшую производительность.

