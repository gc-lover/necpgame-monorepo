metadata:
  id: data-synchronization-consistency-guide
  title: "Руководство по синхронизации данных и консистентности для MMORPG"
  document_type: architecture
  category: systems
  status: draft
  version: "1.0.0"
  last_updated: 2025-11-29T12:30:00Z
  owners:
    - role: architect
      contact: architect@necp.game
  tags:
    - architecture
    - data-synchronization
    - consistency
    - database
    - microservices
    - mmorpg
  related_systems:
    - character-service-go
    - inventory-service-go
    - world-service-go
    - realtime-gateway-go
  related_documents:
    - id: hybrid-network-system-architecture
      relation: extends
    - id: realtime-server-system-architecture
      relation: extends
  visibility: internal
  audience:
    - architect
    - backend
    - database

summary:
  problem: |
    Требуется обеспечить качественную синхронизацию данных между различными слоями
    (клиент, сервер, база данных) и механиками игры (инвентарь, персонаж, квесты, боевая система),
    а также достичь консистентности данных в распределенной микросервисной архитектуре.
  goal: |
    Создать руководство по проектированию синхронизации данных и обеспечению консистентности
    для MMORPG с множеством механик и микросервисов.
  essence: |
    Комплексный подход к синхронизации данных между слоями и механиками с использованием
    событийной архитектуры, транзакций, паттернов распределенных систем и стратегий консистентности.

content:
  sections:
    - id: synchronization_between_layers
      title: Синхронизация между слоями и механиками
      body: |
        ## Архитектурные принципы

        ### 1. Клиент-серверная модель с авторитетным сервером

        **Принцип:** Сервер является единственным источником истины (Single Source of Truth)

        **Реализация:**
        - Все критичные игровые данные хранятся и обрабатываются на сервере
        - Клиент получает обновления состояния от сервера
        - Клиентское предсказание используется только для UX, но не влияет на финальное состояние
        - Сервер валидирует все действия клиента перед применением

        **Применение:**
        - Позиции персонажей
        - Инвентарь и предметы
        - Боевая система (урон, здоровье)
        - Экономика (деньги, торговля)
        - Прогресс (опыт, уровни, квесты)

        ### 2. Событийная архитектура (Event-Driven Architecture)

        **Принцип:** Механики взаимодействуют через события, а не прямые вызовы

        **Преимущества:**
        - Слабая связанность между механиками
        - Легкое добавление новых механик
        - Масштабируемость
        - Возможность отката изменений

        **Реализация:**
        - Event Bus (Kafka, RabbitMQ, или внутренний)
        - События: `ItemAdded`, `CharacterLevelUp`, `QuestCompleted`, `CombatDamageDealt`
        - Подписчики на события обрабатывают их асинхронно
        - События сохраняются для аудита и отката

        **Пример:**
        ```
        CharacterService → Event: CharacterLevelUp
        ↓
        InventoryService (подписчик) → Разблокировка слотов инвентаря
        QuestService (подписчик) → Проверка квестов на уровень
        AchievementService (подписчик) → Проверка достижений
        ```

        ### 3. Приоритетная синхронизация

        **Принцип:** Механики могут изменяться параллельно, если не влияют друг на друга

        **Реализация:**
        - Определение зависимостей между механиками
        - Параллельная обработка независимых операций
        - Последовательная обработка зависимых операций
        - Использование транзакций для атомарности

        **Пример:**
        - Параллельно: обновление позиции персонажа + отправка сообщения в чат
        - Последовательно: покупка предмета → обновление инвентаря → списание денег

        ### 4. Метки времени и согласование на сервере

        **Принцип:** Все действия имеют временные метки для корректной обработки

        **Реализация:**
        - Каждое действие клиента содержит timestamp
        - Сервер обрабатывает действия с учетом временных меток
        - Пересчет состояния при получении запоздалых действий
        - Использование Vector Clocks для распределенных систем

        **Применение:**
        - Боевая система (урон, лечение)
        - Торговля (покупка/продажа)
        - Квесты (взаимодействие с NPC)

        ### 5. Интерполяция и экстраполяция

        **Принцип:** Сглаживание движений для компенсации сетевых задержек

        **Реализация:**
        - Интерполяция: сглаживание между известными состояниями
        - Экстраполяция: прогнозирование будущих состояний
        - Коррекция при получении актуального состояния от сервера

        **Применение:**
        - Движение персонажей
        - Анимации
        - Физика объектов

    - id: database_consistency
      title: Консистентность данных в базах данных
      body: |
        ## Модели консистентности

        ### 1. Строгая консистентность (Strong Consistency)

        **Применение:** Критичные данные, где недопустимы временные несоответствия

        **Использование:**
        - Финансовые операции (деньги, торговля)
        - Инвентарь (предметы, слоты)
        - Персонаж (статы, уровни)
        - Квесты (прогресс, награды)

        **Реализация:**
        - ACID транзакции (PostgreSQL)
        - Блокировки (pessimistic/optimistic locking)
        - Ссылочная целостность (foreign keys)
        - Уровни изоляции транзакций

        ### 2. Конечная консистентность (Eventual Consistency)

        **Применение:** Некритичные данные, где допустимы временные несоответствия

        **Использование:**
        - Статистика игроков
        - Логи активности
        - Аналитика
        - Кэшируемые данные

        **Реализация:**
        - Асинхронная репликация
        - Event Sourcing
        - CQRS (Command Query Responsibility Segregation)
        - Message queues для синхронизации

        ### 3. Теорема CAP и выбор стратегии

        **CAP:** Consistency, Availability, Partition tolerance

        **Для MMORPG:**
        - **CP (Consistency + Partition tolerance):** Критичные данные (инвентарь, деньги)
        - **AP (Availability + Partition tolerance):** Некритичные данные (статистика, логи)

        **Реализация:**
        - Разные стратегии для разных типов данных
        - Мониторинг консистентности
        - Механизмы разрешения конфликтов

        ## Паттерны обеспечения консистентности

        ### 1. ACID транзакции

        **Применение:** Операции, требующие атомарности

        **Примеры:**
        - Покупка предмета: списание денег + добавление в инвентарь
        - Улучшение предмета: удаление материалов + обновление предмета
        - Завершение квеста: обновление прогресса + выдача наград

        **Реализация:**
        ```go
        tx, err := db.BeginTx(ctx, &sql.TxOptions{
            Isolation: sql.LevelSerializable,
        })
        // ... операции ...
        if err != nil {
            tx.Rollback()
            return err
        }
        tx.Commit()
        ```

        ### 2. Saga Pattern (для распределенных транзакций)

        **Применение:** Операции, затрагивающие несколько микросервисов

        **Типы:**
        - **Choreography:** Каждый сервис знает, что делать дальше
        - **Orchestration:** Центральный координатор управляет процессом

        **Пример:**
        ```
        Покупка предмета в магазине:
        1. InventoryService: резервирование слота
        2. CharacterService: проверка денег
        3. CharacterService: списание денег
        4. InventoryService: добавление предмета
        5. Если ошибка на любом шаге → компенсирующие транзакции
        ```

        ### 3. Event Sourcing

        **Применение:** Аудит, откат изменений, восстановление состояния

        **Реализация:**
        - Все изменения сохраняются как события
        - Состояние вычисляется из событий
        - Снимки состояния для производительности
        - Возможность отката к любому моменту времени

        **Пример:**
        ```
        Events:
        - CharacterCreated
        - ItemAdded (item_id: 123)
        - ItemRemoved (item_id: 123)
        - MoneyAdded (amount: 1000)
        
        Current State = Apply(Events)
        ```

        ### 4. CQRS (Command Query Responsibility Segregation)

        **Применение:** Разделение операций чтения и записи

        **Преимущества:**
        - Оптимизация для чтения и записи отдельно
        - Масштабирование независимо
        - Разные модели данных для чтения/записи

        **Реализация:**
        - Command Side: обработка команд (изменение данных)
        - Query Side: оптимизированные представления для чтения
        - Синхронизация через события

        ### 5. Блокировки и изоляция

        **Типы блокировок:**
        - **Pessimistic Locking:** Блокировка на время транзакции
        - **Optimistic Locking:** Проверка версии перед обновлением

        **Уровни изоляции:**
        - **Read Uncommitted:** Минимальная изоляция
        - **Read Committed:** Стандартный уровень (PostgreSQL по умолчанию)
        - **Repeatable Read:** Гарантирует повторяемость чтения
        - **Serializable:** Максимальная изоляция (для критичных операций)

        **Применение:**
        - Pessimistic: торговля, аукционы
        - Optimistic: обновление статистики, логи

    - id: synchronization_patterns
      title: Паттерны синхронизации между механиками
      body: |
        ## Паттерны взаимодействия

        ### 1. Event Bus Pattern

        **Описание:** Централизованная шина событий для обмена сообщениями

        **Реализация:**
        - Kafka, RabbitMQ, или внутренний Event Bus
        - Публикация событий от механик
        - Подписка механик на интересующие события
        - Гарантия доставки (at-least-once или exactly-once)

        **Пример:**
        ```
        CombatService → Event: DamageDealt
        ↓
        CharacterService → Обновление здоровья
        AchievementService → Проверка достижений
        QuestService → Проверка квестов на урон
        ```

        ### 2. Outbox Pattern

        **Описание:** Гарантированная доставка событий из транзакций

        **Проблема:** Как гарантировать отправку события при успешной транзакции?

        **Решение:**
        1. Запись события в таблицу Outbox в той же транзакции
        2. Отдельный процесс читает Outbox и отправляет события
        3. После успешной отправки событие удаляется из Outbox

        **Реализация:**
        ```sql
        BEGIN;
        UPDATE inventory SET ...;
        INSERT INTO outbox (event_type, payload) VALUES (...);
        COMMIT;
        ```

        ### 3. Two-Phase Commit (2PC)

        **Описание:** Координация транзакций между несколькими БД

        **Применение:** Критичные операции, затрагивающие несколько сервисов

        **Этапы:**
        1. **Prepare:** Все участники готовы к коммиту
        2. **Commit:** Все участники коммитят транзакцию

        **Недостатки:** Высокая задержка, блокировки

        **Альтернатива:** Saga Pattern (предпочтительнее для микросервисов)

        ### 4. Idempotency Pattern

        **Описание:** Операции должны быть идемпотентными

        **Применение:** Защита от дублирования операций

        **Реализация:**
        - Уникальные ID для операций
        - Проверка выполнения операции перед повторным выполнением
        - Кэширование результатов идемпотентных операций

        **Пример:**
        ```
        Operation ID: uuid-v4
        Если операция уже выполнена → возврат результата
        Если нет → выполнение операции
        ```

        ### 5. Circuit Breaker Pattern

        **Описание:** Защита от каскадных сбоев

        **Применение:** При сбое одного сервиса не должны падать другие

        **Состояния:**
        - **Closed:** Нормальная работа
        - **Open:** Сервис недоступен, возврат ошибки
        - **Half-Open:** Проверка восстановления сервиса

    - id: implementation_recommendations
      title: Рекомендации по реализации
      body: |
        ## Архитектурные решения

        ### 1. Разделение на слои

        **Трехслойная архитектура:**
        - **Data Layer:** База данных, репозитории
        - **Business Logic Layer:** Сервисы, механики
        - **Presentation Layer:** API, WebSocket handlers

        **Преимущества:**
        - Четкое разделение ответственности
        - Легкое тестирование
        - Возможность замены слоев

        ### 2. Микросервисная архитектура

        **Принципы:**
        - Каждый сервис отвечает за свою доменную область
        - Независимое развертывание
        - Слабая связанность через события

        **Сервисы:**
        - `character-service-go`: Персонажи, статы, уровни
        - `inventory-service-go`: Инвентарь, предметы
        - `quest-service-go`: Квесты, прогресс
        - `combat-service-go`: Боевая система
        - `economy-service-go`: Экономика, торговля

        ### 3. Event-Driven Communication

