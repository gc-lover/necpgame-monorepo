metadata:
  id: development-stages-timing-guide
  title: "Руководство по этапам работы с БД, синхронизацией и сетевыми оптимизациями"
  document_type: architecture
  category: workflow
  status: draft
  version: "1.0.0"
  last_updated: 2025-11-29T13:00:00Z
  owners:
    - role: architect
      contact: architect@necp.game
  tags:
    - workflow
    - stages
    - database
    - synchronization
    - network
    - timing
  related_documents:
    - id: data-synchronization-consistency-guide
      relation: extends
    - id: hybrid-network-system-architecture
      relation: extends
  visibility: internal
  audience:
    - architect
    - backend
    - database
    - network

summary:
  problem: |
    Требуется определить оптимальные этапы разработки для работы с базами данных,
    синхронизацией данных и сетевыми оптимизациями в контексте workflow агентов.
  goal: |
    Создать руководство по этапам работы с БД, синхронизацией и сетевыми оптимизациями
    для правильной последовательности разработки.
  essence: |
    Определение оптимальных этапов для работы с БД (Database Engineer), синхронизацией
    (Architect) и сетевыми оптимизациями (Network Engineer) в контексте workflow агентов.

content:
  sections:
    - id: database_development_stage
      title: Этап работы с базами данных
      body: |
        ## Когда заниматься базами данных

        ### Оптимальный этап: После Architect, параллельно с API Designer

        **Почему:**
        - Database Engineer нужна архитектура от Architect (определение сущностей)
        - Database Engineer может работать параллельно с API Designer
        - API Designer описывает API схемы, Database Engineer проектирует БД схемы
        - Оба используют архитектуру от Architect как основу

        ### Workflow

        ```
        [Idea Writer] → [Architect]
                           ↓
                    ┌──────┴──────┐
                    ↓              ↓
            [Database Engineer]  [API Designer]
                    ↓              ↓
                    └──────┬──────┘
                           ↓
                    [Backend Developer]
        ```

        ### Входные данные для Database Engineer

        **Обязательные:**
        - OK Архитектура от Architect (определяет сущности и их связи)
        - OK Требования к производительности

        **Желательные (но не обязательные):**
        - OpenAPI спецификация от API Designer (определяет поля API)
        - Существующие схемы БД

        **Важно:**
        - Database Engineer может начать работу сразу после Architect
        - OpenAPI спецификация помогает, но не обязательна
        - Database Engineer может скорректировать схемы после получения OpenAPI

        ### Что делает Database Engineer

        **На этапе database-dev:**
        1. Проектирует детальные схемы БД (таблицы, связи, индексы)
        2. Создает Liquibase миграции в `infrastructure/liquibase/`
        3. Оптимизирует запросы и индексы
        4. Определяет стратегию миграций
        5. Работает с репликацией и партиционированием

        **Когда передается дальше:**
        - Схема БД спроектирована
        - Миграции созданы
        - Индексы определены
        - Constraints настроены
        - Готово к использованию Backend Developer

    - id: synchronization_development_stage
      title: Этап работы с синхронизацией
      body: |
        ## Когда заниматься синхронизацией

        ### Оптимальный этап: На этапе Architect

        **Почему:**
        - Синхронизация - это архитектурная задача
        - Требует проектирования компонентов системы
        - Определения паттернов взаимодействия
        - Проектирования Event Bus архитектуры
        - Определения стратегий консистентности

        ### Workflow

        ```
        [Idea Writer] → [Architect]
                           ↓
                    (проектирует синхронизацию)
                           ↓
                    ┌──────┴──────┐
                    ↓              ↓
            [Database Engineer]  [API Designer]
                    ↓              ↓
                    └──────┬──────┘
                           ↓
                    [Backend Developer]
                           ↓
                    (использует архитектуру синхронизации)
        ```

        ### Что делает Architect на этапе синхронизации

        **На этапе architect:**
        1. Проектирует архитектуру синхронизации между слоями
        2. Определяет компоненты системы синхронизации
        3. Выбирает паттерны синхронизации (Event Sourcing, CQRS, Saga Pattern)
        4. Проектирует Event Bus архитектуру
        5. Определяет стратегии консистентности (Strong vs Eventual)
        6. Проектирует механизмы разрешения конфликтов
        7. Определяет взаимодействие между микросервисами

        **Выходные данные:**
        - Архитектурная схема системы синхронизации
        - Определение компонентов (Event Bus, Outbox Pattern, Saga Pattern)
        - Паттерны синхронизации для разных сценариев
        - Стратегии консистентности для разных типов данных
        - Техническое задание для реализации

        **Когда передается дальше:**
        - Архитектура синхронизации спроектирована
        - Компоненты определены
        - Паттерны выбраны
        - Разбиение на подзадачи готово
        - Готово к работе API Designer и Database Engineer

        ### Важно

        - **Синхронизация проектируется на этапе Architect**, а не на этапе Backend
        - Backend Developer использует готовую архитектуру синхронизации
        - Database Engineer проектирует схемы БД с учетом архитектуры синхронизации
        - API Designer описывает API с учетом паттернов синхронизации

    - id: network_optimization_stage
      title: Этап работы с сетевыми оптимизациями
      body: |
        ## Когда заниматься сетевыми оптимизациями

        ### Оптимальный этап: Два этапа

        **1. Проектирование тикрейта и требований (на этапе Architect):**
        - Проектирование тикрейта для разных механик
        - Определение требований к сетевой нагрузке
        - Проектирование адаптивного тикрейта

        **2. Реализация и оптимизация (после Backend, перед UE5):**
        - Настройка Envoy proxy
        - Оптимизация Protocol Buffers
        - Оптимизация realtime синхронизации
        - Настройка сетевой безопасности

        ### Workflow

        ```
        [Idea Writer] → [Architect]
                           ↓
                    (проектирует тикрейт и требования)
                           ↓
                    [API Designer] → [Backend Developer]
                                           ↓
                                    [Network Engineer]
                                    (реализует и оптимизирует)
                                           ↓
                                    [UE5 Developer]
        ```

        ### Этап 1: Проектирование (Architect)

        **На этапе architect:**
        1. Проектирует тикрейт для разных механик:
           - PvE зоны: 20-30 Hz (WebSocket)
           - PvP small: 60-128 Hz (UDP)
           - GvG 200: 60-80 Hz (UDP)
           - GvG 400: 40-60 Hz (UDP)
           - Massive war: 20-40 Hz (UDP)
        2. Определяет требования к сетевой нагрузке
        3. Проектирует адаптивный тикрейт
        4. Учитывает нагрузку на сеть в зависимости от типа активностей

        **Выходные данные:**
        - Спецификация тикрейта для разных механик
        - Требования к сетевой нагрузке
        - Документация требований к тикрейту

        ### Этап 2: Реализация (Network Engineer)

        **На этапе network-dev:**
        1. Настраивает Envoy proxy
        2. Оптимизирует gRPC/WebSocket соединения
        3. Работает с Protocol Buffers для сети
        4. Оптимизирует realtime синхронизацию
        5. Настраивает сетевую безопасность
        6. Реализует адаптивный тикрейт согласно архитектуре

        **Входные данные:**
        - Требования к тикрейту от Architect
        - Готовый бекенд от Backend Developer
        - Существующие Protocol Buffers
        - Конфигурация Envoy

        **Выходные данные:**
        - Конфигурация Envoy в `infrastructure/envoy/`
        - Обновления Protocol Buffers в `proto/realtime/`
        - Оптимизации сетевого кода
        - Конфигурация адаптивного тикрейта
        - Документация сетевой архитектуры

        **Когда передается дальше:**
        - Envoy настроен
        - Протокол оптимизирован
        - Realtime синхронизация работает
        - Тикрейт реализован для всех типов активностей
        - Нагрузка на сеть рассчитана и учтена
        - Готово к интеграции с UE5 клиентом

    - id: complete_workflow
      title: Полный workflow с учетом всех этапов
      body: |
        ## Рекомендуемая последовательность

        ### Для системных задач (требуют архитектуры):

        ```
        1. [Idea Writer]
           ↓
        2. [Architect]
           ├─ Проектирует архитектуру системы
           ├─ Проектирует синхронизацию данных ⭐
           ├─ Проектирует тикрейт и сетевые требования ⭐
           └─ Определяет компоненты и микросервисы
           ↓
        3. [Database Engineer] (параллельно с API Designer)
           ├─ Проектирует схемы БД
           ├─ Создает Liquibase миграции
           └─ Учитывает архитектуру синхронизации
           ↓
        4. [API Designer] (параллельно с Database Engineer)
           ├─ Создает OpenAPI спецификации
           ├─ Описывает API схемы
           └─ Учитывает паттерны синхронизации
           ↓
        5. [Backend Developer]
           ├─ Реализует Go сервисы
           ├─ Использует готовые миграции от Database Engineer
           ├─ Реализует архитектуру синхронизации от Architect
           └─ Использует OpenAPI спецификации
           ↓
        6. [Network Engineer]
           ├─ Реализует тикрейт согласно архитектуре
           ├─ Настраивает Envoy
           ├─ Оптимизирует Protocol Buffers
           └─ Оптимизирует realtime синхронизацию
           ↓
        7. [Security Agent]
           ├─ Аудит безопасности
           └─ Валидация входных данных
           ↓
        8. [DevOps]
           ├─ Настраивает инфраструктуру
           └─ Настраивает observability
           ↓
        9. [UE5 Developer] → [QA] → [Game Balance] → [Release]
        ```

        ### Ключевые моменты

        **Синхронизация:**
        - ⭐ Проектируется на этапе **Architect**
        - Реализуется на этапе **Backend Developer**
        - Используется на всех последующих этапах

        **Базы данных:**
        - Проектируются на этапе **Database Engineer** (после Architect)
        - Могут работать параллельно с **API Designer**
        - Используются на этапе **Backend Developer**

        **Сетевые оптимизации:**
        - ⭐ Тикрейт проектируется на этапе **Architect**
        - Реализуется на этапе **Network Engineer** (после Backend)
        - Интегрируется с **UE5 Developer**

    - id: timing_recommendations
      title: Рекомендации по срокам
      body: |
        ## Когда начинать работу

        ### Базы данных

        **Начинать:** Сразу после Architect
        **Параллельно с:** API Designer
        **Завершать:** До начала Backend Developer

        **Приоритет:**
        - Высокий - миграции нужны Backend Developer
        - Можно начать до получения OpenAPI спецификации
        - Скорректировать после получения OpenAPI

        ### Синхронизация

        **Начинать:** На этапе Architect
        **Завершать:** На этапе Architect (перед передачей API Designer)
        **Использовать:** На всех последующих этапах

        **Приоритет:**
        - Критичный - основа для всей системы
        - Должна быть спроектирована до Database Engineer и API Designer
        - Влияет на проектирование БД и API

        ### Сетевые оптимизации

        **Проектирование тикрейта:**
        - Начинать: На этапе Architect
        - Завершать: На этапе Architect
        - Приоритет: Высокий (влияет на архитектуру)

        **Реализация и оптимизация:**
        - Начинать: После Backend Developer
        - Завершать: До UE5 Developer
        - Приоритет: Высокий (нужно для клиента)

        ## Параллельная работа

        ### Можно работать параллельно

        - **Database Engineer** и **API Designer** - после Architect
        - **Performance Engineer** - на любом этапе
        - **Security Agent** - после Backend/Network

        ### Нельзя работать параллельно

        - **Backend Developer** требует готовые миграции и OpenAPI
        - **Network Engineer** требует готовый бекенд
        - **UE5 Developer** требует готовый бекенд и сетевую часть

    - id: dependencies
      title: Зависимости между этапами
      body: |
        ## Граф зависимостей

        ```
        Idea Writer
           ↓
        Architect
           ├─→ Database Engineer (нужна архитектура)
           ├─→ API Designer (нужна архитектура)
           └─→ Backend Developer (нужна архитектура)
                ↓
        Database Engineer ──┐
                            ├─→ Backend Developer (нужны миграции)
        API Designer ───────┘
                ↓
        Backend Developer
           ↓
        Network Engineer (нужен бекенд)
           ↓
        Security Agent
           ↓
        DevOps
           ↓
        UE5 Developer
        ```

        ## Критические зависимости

        ### Database Engineer зависит от:
        - OK Architect (архитектура обязательна)
        - WARNING API Designer (желательно, но не обязательно)

        ### API Designer зависит от:
        - OK Architect (архитектура обязательна)

        ### Backend Developer зависит от:
        - OK Architect (архитектура обязательна)
        - OK Database Engineer (миграции обязательны)
        - OK API Designer (OpenAPI спецификация обязательна)

        ### Network Engineer зависит от:
        - OK Architect (тикрейт и требования обязательны)
        - OK Backend Developer (бекенд желателен для оптимизации)

        ### Синхронизация зависит от:
        - OK Architect (проектируется на этом этапе)
        - WARNING Database Engineer (использует схемы БД)
        - WARNING API Designer (использует API схемы)

    - id: best_practices
      title: Лучшие практики
      body: |
        ## Рекомендации

        ### 1. Синхронизация - на этапе Architect

        **Почему:**
        - Синхронизация влияет на всю архитектуру системы
        - Определяет паттерны взаимодействия между сервисами
        - Влияет на проектирование БД и API
        - Должна быть спроектирована до Database Engineer и API Designer

        **Что делать:**
        - Проектировать синхронизацию на этапе Architect
        - Определять паттерны (Event Sourcing, CQRS, Saga Pattern)
        - Проектировать Event Bus архитектуру
        - Определять стратегии консистентности

        ### 2. Базы данных - после Architect, параллельно с API Designer

        **Почему:**
        - Database Engineer нужна архитектура от Architect
        - Может работать параллельно с API Designer
        - OpenAPI спецификация помогает, но не обязательна
        - Миграции нужны Backend Developer

        **Что делать:**
        - Начинать работу сразу после Architect
        - Работать параллельно с API Designer
        - Использовать архитектуру синхронизации от Architect
        - Скорректировать схемы после получения OpenAPI

        ### 3. Сетевые оптимизации - два этапа

        **Почему:**
        - Тикрейт влияет на архитектуру (проектируется на Architect)
        - Реализация требует готовый бекенд (Network Engineer)
        - Интеграция с клиентом требует готовую сетевую часть

        **Что делать:**
        - Проектировать тикрейт на этапе Architect
        - Реализовывать и оптимизировать на этапе Network Engineer
        - Учитывать требования к тикрейту при проектировании архитектуры

        ### 4. Не пропускать этапы

        **Почему:**
        - Каждый этап зависит от предыдущего
        - Пропуск этапов приводит к проблемам
        - Переделки дороже правильной последовательности

        **Что делать:**
        - Следовать workflow агентов
        - Не начинать Backend без миграций и OpenAPI
        - Не начинать Network без архитектуры тикрейта
        - Не начинать UE5 без готового бекенда и сетевой части

appendix:
  glossary:
    - term: Development Stage
      definition: Этап разработки в workflow агентов (idea-writer, architect, database-dev, api-designer, backend-dev, network-dev, и т.д.)
    - term: Parallel Work
      definition: Работа нескольких агентов одновременно над разными аспектами задачи
    - term: Sequential Work
      definition: Работа агентов последовательно, где каждый зависит от предыдущего
    - term: Critical Path
      definition: Последовательность этапов, которые нельзя пропустить или выполнить параллельно

  references:
    - title: "Agent Workflow"
      link: .github/AGENT_WORKFLOW.md
    - title: "Data Synchronization Guide"
      link: knowledge/implementation/architecture/data-synchronization-consistency-guide.yaml
    - title: "Hybrid Network Architecture"
      link: knowledge/implementation/architecture/hybrid-network-system-architecture.yaml

  decisions:
    - date: 2025-11-29
      decision: Синхронизация проектируется на этапе Architect
      rationale: Синхронизация влияет на всю архитектуру системы и должна быть спроектирована до Database Engineer и API Designer.
    - date: 2025-11-29
      decision: Database Engineer работает после Architect, параллельно с API Designer
      rationale: Database Engineer нужна архитектура, но может работать параллельно с API Designer для ускорения разработки.
    - date: 2025-11-29
      decision: Тикрейт проектируется на Architect, реализуется на Network Engineer
      rationale: Тикрейт влияет на архитектуру, но реализация требует готовый бекенд.

