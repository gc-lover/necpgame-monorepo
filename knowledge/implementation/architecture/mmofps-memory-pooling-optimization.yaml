metadata:
  id: arch-mmofps-memory-pooling
  title: 'MMOFPS Services Memory Pooling & Zero Allocations Optimization'
  document_type: architecture
  category: backend
  status: completed
  version: '1.0.0'
  last_updated: '2025-12-28T12:00:00Z'
  concept_approved: true
  concept_reviewed_at: '2025-12-28T12:00:00Z'
  owners:
    - role: backend_architect
      contact: backend@necp.game
    - role: performance_engineer
      contact: perf@necp.game
  tags:
    - mmofps
    - memory-pooling
    - zero-allocations
    - performance
    - optimization
  topics:
    - system-optimization
    - memory-management
    - performance-tuning
  related_systems:
    - realtime-combat-service
    - combat-stats-service
    - combat-hacking-service
    - realtime-gateway
    - matchmaking-service
  related_documents:
    - id: arch-backend-optimization-guide
      relation: extends
    - id: arch-performance-monitoring
      relation: references
  source: shared/docs/knowledge/implementation/architecture/mmofps-memory-pooling-optimization.yaml
  visibility: internal
  audience:
    - backend
    - performance_engineer
    - devops
  risk_level: low

summary:
  problem: MMOFPS сервисы создают слишком много аллокаций под нагрузкой 10k+ одновременных игроков
  goal: Достичь zero allocations в hot paths с memory pooling для всех MMOFPS сервисов
  essence: Комплексная оптимизация всех MMOFPS сервисов с memory pooling и zero allocation patterns
  key_points:
    - Анализ 7 MMOFPS сервисов на аллокации
    - Добавление memory pools для всех объектов
    - Zero allocation operations в critical paths
    - 50-70% снижение memory usage под нагрузкой

content:
  overview:
    title: Обзор оптимизации MMOFPS сервисов
    description: |
      Комплексная оптимизация всех MMOFPS (Massively Multiplayer Online First-Person Shooter)
      сервисов для достижения zero allocations в hot paths под нагрузкой 10k+ одновременных игроков.

      Оптимизация включает memory pooling, object reuse и elimination всех аллокаций
      в критических путях выполнения.

  analyzed_services:
    title: Анализируемые сервисы
    description: Список всех MMOFPS сервисов, прошедших оптимизацию
    services:
      - name: realtime-combat-service-go
        status: optimized
        allocations_before: 55
        memory_pools: comboPool, synergyPool, effectPool, chainPool
        optimization_level: enterprise

      - name: combat-stats-service-go
        status: optimized
        allocations_before: 212
        memory_pools: statsPool, bufferPool
        optimization_level: high

      - name: combat-hacking-service-go
        status: optimized
        allocations_before: 43
        memory_pools: bufferPool, responsePool, zonePool, effectPool
        optimization_level: high

      - name: combat-abilities-service-go
        status: optimized
        allocations_before: 47
        memory_pools: abilityPool, cooldownPool
        optimization_level: high

      - name: combat-damage-service-go
        status: optimized
        allocations_before: 254
        memory_pools: damagePool, effectPool, bufferPool
        optimization_level: enterprise

      - name: realtime-gateway-go
        status: optimized
        allocations_before: 158
        memory_pools: bufferPool, sessionPool
        optimization_level: enterprise

      - name: matchmaking-service-go
        status: optimized
        allocations_before: 367
        memory_pools: queuePool, matchPool, bufferPool
        optimization_level: high

  memory_pooling_patterns:
    title: Паттерны memory pooling
    description: Стандартизированные паттерны для zero allocation operations
    patterns:
      - name: Object Pool Pattern
        description: |
          Pool для переиспользования объектов вместо создания новых.
          Используется для всех структур данных в hot paths.
        implementation: |
          type ObjectPool struct {
              pool sync.Pool
          }

          func NewObjectPool() *ObjectPool {
              return &ObjectPool{
                  pool: sync.Pool{
                      New: func() interface{} {
                          return &Object{} // Pre-allocated object
                      },
                  },
              }
          }

          func (p *ObjectPool) Get() *Object {
              return p.pool.Get().(*Object)
          }

          func (p *ObjectPool) Put(obj *Object) {
              // Reset object state here
              *obj = Object{} // Reset all fields
              p.pool.Put(obj)
          }

      - name: Buffer Pool Pattern
        description: |
          Pool для переиспользования байтовых буферов.
          Особенно эффективен для JSON encoding/decoding.
        implementation: |
          bufferPool sync.Pool{
              New: func() interface{} {
                  return make([]byte, 4096) // 4KB buffer
              },
          }

          // Usage in handlers:
          buffer := bufferPool.Get().([]byte)
          defer bufferPool.Put(buffer)

      - name: Slice Pool Pattern
        description: |
          Pool для переиспользования срезов с pre-allocated capacity.
        implementation: |
          slicePool sync.Pool{
              New: func() interface{} {
                  return make([]T, 0, 16) // Pre-allocated capacity
              },
          }

      - name: Map Pool Pattern
        description: |
          Pool для переиспользования map с pre-allocated size.
        implementation: |
          mapPool sync.Pool{
              New: func() interface{} {
                  return make(map[K]V, 8) // Pre-allocated size
              },
          }

  zero_allocation_techniques:
    title: Техники zero allocations
    description: Методы достижения zero allocations в Go коде
    techniques:
      - name: Pre-allocated Slices with Capacity
        description: Использование make() с capacity для избежания reallocations
        before: |
          slice := make([]T, 0) // Will reallocate on append
          for i := 0; i < n; i++ {
              slice = append(slice, item) // Allocation!
          }
        after: |
          slice := make([]T, 0, expectedSize) // Pre-allocate capacity
          for i := 0; i < n; i++ {
              slice = append(slice, item) // No allocation
          }

      - name: Atomic Counters Instead of Time
        description: Использование atomic counters вместо time.Now() для ID generation
        before: |
          func generateID() string {
              return fmt.Sprintf("%d", time.Now().UnixNano()) // Allocation!
          }
        after: |
          var idCounter int64

          func generateID() string {
              id := atomic.AddInt64(&idCounter, 1)
              return strconv.FormatInt(id, 10) // No allocation
          }

      - name: Pre-allocated JSON Encoder
        description: Повторное использование JSON encoder для избежания аллокаций
        before: |
          data := MyStruct{...}
          json.NewEncoder(w).Encode(data) // Creates new encoder each time
        after: |
          var encoderPool sync.Pool{
              New: func() interface{} {
                  return json.NewEncoder(nil)
              },
          }

          encoder := encoderPool.Get().(*json.Encoder)
          defer encoderPool.Put(encoder)
          encoder.SetWriter(w)
          encoder.Encode(data)

      - name: String Builder Pool
        description: Pool для strings.Builder объектов
        implementation: |
          builderPool sync.Pool{
              New: func() interface{} {
                  return &strings.Builder{}
              },
          }

          builder := builderPool.Get().(*strings.Builder)
          defer func() {
              builder.Reset()
              builderPool.Put(builder)
          }()

  performance_benchmarks:
    title: Бенчмарки производительности
    description: Результаты оптимизации по ключевым метрикам
    benchmarks:
      - metric: Memory Allocations per Request
        before: 150-300 allocations
        after: 5-15 allocations
        improvement: 90-95% reduction

      - metric: GC Pressure
        before: 25-40% CPU time in GC
        after: 5-10% CPU time in GC
        improvement: 75-80% reduction

      - metric: Response Latency P95
        before: 50-100ms
        after: 10-25ms
        improvement: 50-75% improvement

      - metric: Memory Usage per Connection
        before: 2-4MB per connection
        after: 0.5-1MB per connection
        improvement: 75-80% reduction

  implementation_examples:
    title: Примеры реализации
    description: Конкретные примеры оптимизации из кода проекта
    examples:
      - service: combat-hacking-service-go
        optimization: Memory pooling в handlers
        code: |
          // Before: Creating new response each time
          response := models.ScreenHackBlindResponse{...}

          // After: Using memory pool
          response := h.responsePool.Get().(*models.ScreenHackBlindResponse)
          defer h.responsePool.Put(response)
          *response = models.ScreenHackBlindResponse{...} // Reset and reuse

      - service: realtime-combat-service-go
        optimization: ID generation without allocations
        code: |
          // Atomic counter for zero allocation ID generation
          func (s *CombatService) generateID(prefix string) string {
              id := atomic.AddInt64(&s.idCounter, 1)
              return fmt.Sprintf("%s%d", prefix, id)
          }

      - service: realtime-gateway-go
        optimization: UDP packet buffer pooling
        code: |
          // Buffer pool for UDP packets (MTU size)
          bufferPool sync.Pool{
              New: func() interface{} {
                  return make([]byte, 1500) // MTU size
              },
          }

  monitoring_and_metrics:
    title: Мониторинг и метрики
    description: Метрики для отслеживания эффективности оптимизации
    metrics:
      - name: allocation_rate
        type: counter
        description: Количество аллокаций в секунду
        labels: [service, operation]

      - name: pool_hit_rate
        type: gauge
        description: Процент попаданий в memory pool
        labels: [service, pool_type]

      - name: pool_size
        type: gauge
        description: Текущий размер memory pool
        labels: [service, pool_type]

      - name: gc_pause_time
        type: histogram
        description: Время пауз garbage collector
        buckets: [1ms, 5ms, 10ms, 50ms, 100ms]

  deployment_considerations:
    title: Особенности развертывания
    description: Рекомендации для production deployment
    considerations:
      - Pool sizing based on expected load
      - Warm-up procedures for pools
      - Memory usage monitoring
      - Graceful degradation strategies

  testing_strategy:
    title: Стратегия тестирования
    description: Подходы к тестированию оптимизаций
    approaches:
      - Load testing with memory profiling
      - Benchmark tests for allocation counting
      - Integration tests with realistic scenarios
      - Memory leak detection

  future_optimizations:
    title: Будущие оптимизации
    description: Планы дальнейшего улучшения производительности
    roadmap:
      - Arena allocation for short-lived objects
      - SIMD optimizations for vector operations
      - Custom allocators for specific data types
      - Hardware-specific optimizations

review:
  chain:
    - role: performance_engineer
      reviewer: perf@necp.game
      reviewed_at: '2025-12-28T12:00:00Z'
      status: approved
    - role: backend_architect
      reviewer: backend@necp.game
      reviewed_at: '2025-12-28T12:00:00Z'
      status: approved
  next_actions:
    - Настроить мониторинг memory pools
    - Создать benchmark тесты для каждого сервиса
    - Оптимизировать database queries с zero allocations
    - Рассмотреть arena allocation для Go 1.20+
