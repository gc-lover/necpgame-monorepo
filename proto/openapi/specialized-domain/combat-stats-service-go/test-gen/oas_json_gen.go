// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "message",
	1: "domain",
	2: "details",
	3: "code",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerCombatStatsBadRequest as json.
func (s *GetPlayerCombatStatsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerCombatStatsBadRequest from json.
func (s *GetPlayerCombatStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerCombatStatsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerCombatStatsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerCombatStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerCombatStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerCombatStatsNotFound as json.
func (s *GetPlayerCombatStatsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerCombatStatsNotFound from json.
func (s *GetPlayerCombatStatsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerCombatStatsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerCombatStatsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerCombatStatsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerCombatStatsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveSessions.Set {
			e.FieldStart("active_sessions")
			s.ActiveSessions.Encode(e)
		}
	}
	{
		if s.StatsProcessedPerSecond.Set {
			e.FieldStart("stats_processed_per_second")
			s.StatsProcessedPerSecond.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [7]string{
	0: "domain",
	1: "status",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_sessions",
	6: "stats_processed_per_second",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_sessions":
			if err := func() error {
				s.ActiveSessions.Reset()
				if err := s.ActiveSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_sessions\"")
			}
		case "stats_processed_per_second":
			if err := func() error {
				s.StatsProcessedPerSecond.Reset()
				if err := s.StatsProcessedPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats_processed_per_second\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	case HealthResponseStatusDegraded:
		*s = HealthResponseStatusDegraded
	case HealthResponseStatusUnhealthy:
		*s = HealthResponseStatusUnhealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerCombatStatsResponseTrends as json.
func (o OptPlayerCombatStatsResponseTrends) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PlayerCombatStatsResponseTrends from json.
func (o *OptPlayerCombatStatsResponseTrends) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerCombatStatsResponseTrends to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerCombatStatsResponseTrends) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerCombatStatsResponseTrends) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerCombatStatsResponseTrendsAccuracyTrend as json.
func (o OptPlayerCombatStatsResponseTrendsAccuracyTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayerCombatStatsResponseTrendsAccuracyTrend from json.
func (o *OptPlayerCombatStatsResponseTrendsAccuracyTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerCombatStatsResponseTrendsAccuracyTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerCombatStatsResponseTrendsAccuracyTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerCombatStatsResponseTrendsAccuracyTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerCombatStatsResponseTrendsKdRatioTrend as json.
func (o OptPlayerCombatStatsResponseTrendsKdRatioTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayerCombatStatsResponseTrendsKdRatioTrend from json.
func (o *OptPlayerCombatStatsResponseTrendsKdRatioTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerCombatStatsResponseTrendsKdRatioTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerCombatStatsResponseTrendsKdRatioTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerCombatStatsResponseTrendsKdRatioTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerStatsRequestSessionStatsSessionOutcome as json.
func (o OptUpdatePlayerStatsRequestSessionStatsSessionOutcome) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdatePlayerStatsRequestSessionStatsSessionOutcome from json.
func (o *OptUpdatePlayerStatsRequestSessionStatsSessionOutcome) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdatePlayerStatsRequestSessionStatsSessionOutcome to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdatePlayerStatsRequestSessionStatsSessionOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdatePlayerStatsRequestSessionStatsSessionOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerCombatStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerCombatStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("total_kills")
		e.Int64(s.TotalKills)
	}
	{
		e.FieldStart("total_deaths")
		e.Int64(s.TotalDeaths)
	}
	{
		e.FieldStart("total_damage_dealt")
		e.Int64(s.TotalDamageDealt)
	}
	{
		e.FieldStart("total_damage_received")
		e.Int64(s.TotalDamageReceived)
	}
	{
		e.FieldStart("accuracy_percentage")
		e.Float32(s.AccuracyPercentage)
	}
	{
		e.FieldStart("headshot_percentage")
		e.Float32(s.HeadshotPercentage)
	}
	{
		e.FieldStart("average_session_duration")
		e.Int(s.AverageSessionDuration)
	}
	{
		e.FieldStart("win_rate")
		e.Float32(s.WinRate)
	}
	{
		e.FieldStart("favorite_weapon")
		e.Str(s.FavoriteWeapon)
	}
	{
		e.FieldStart("rank")
		e.Int(s.Rank)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.KdRatio.Set {
			e.FieldStart("kd_ratio")
			s.KdRatio.Encode(e)
		}
	}
	{
		if s.TotalSessions.Set {
			e.FieldStart("total_sessions")
			s.TotalSessions.Encode(e)
		}
	}
	{
		if s.TotalPlaytimeHours.Set {
			e.FieldStart("total_playtime_hours")
			s.TotalPlaytimeHours.Encode(e)
		}
	}
	{
		if s.AchievementsUnlocked.Set {
			e.FieldStart("achievements_unlocked")
			s.AchievementsUnlocked.Encode(e)
		}
	}
	{
		if s.CurrentStreak.Set {
			e.FieldStart("current_streak")
			s.CurrentStreak.Encode(e)
		}
	}
	{
		if s.LongestStreak.Set {
			e.FieldStart("longest_streak")
			s.LongestStreak.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayerCombatStats = [18]string{
	0:  "player_id",
	1:  "total_kills",
	2:  "total_deaths",
	3:  "total_damage_dealt",
	4:  "total_damage_received",
	5:  "accuracy_percentage",
	6:  "headshot_percentage",
	7:  "average_session_duration",
	8:  "win_rate",
	9:  "favorite_weapon",
	10: "rank",
	11: "updated_at",
	12: "kd_ratio",
	13: "total_sessions",
	14: "total_playtime_hours",
	15: "achievements_unlocked",
	16: "current_streak",
	17: "longest_streak",
}

// Decode decodes PlayerCombatStats from json.
func (s *PlayerCombatStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerCombatStats to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "total_kills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.TotalKills = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_kills\"")
			}
		case "total_deaths":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.TotalDeaths = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_deaths\"")
			}
		case "total_damage_dealt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.TotalDamageDealt = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_dealt\"")
			}
		case "total_damage_received":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.TotalDamageReceived = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_received\"")
			}
		case "accuracy_percentage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.AccuracyPercentage = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accuracy_percentage\"")
			}
		case "headshot_percentage":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float32()
				s.HeadshotPercentage = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headshot_percentage\"")
			}
		case "average_session_duration":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AverageSessionDuration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_session_duration\"")
			}
		case "win_rate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.WinRate = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win_rate\"")
			}
		case "favorite_weapon":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FavoriteWeapon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_weapon\"")
			}
		case "rank":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Rank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "kd_ratio":
			if err := func() error {
				s.KdRatio.Reset()
				if err := s.KdRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kd_ratio\"")
			}
		case "total_sessions":
			if err := func() error {
				s.TotalSessions.Reset()
				if err := s.TotalSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_sessions\"")
			}
		case "total_playtime_hours":
			if err := func() error {
				s.TotalPlaytimeHours.Reset()
				if err := s.TotalPlaytimeHours.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_playtime_hours\"")
			}
		case "achievements_unlocked":
			if err := func() error {
				s.AchievementsUnlocked.Reset()
				if err := s.AchievementsUnlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_unlocked\"")
			}
		case "current_streak":
			if err := func() error {
				s.CurrentStreak.Reset()
				if err := s.CurrentStreak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_streak\"")
			}
		case "longest_streak":
			if err := func() error {
				s.LongestStreak.Reset()
				if err := s.LongestStreak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longest_streak\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerCombatStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerCombatStats) {
					name = jsonFieldsNameOfPlayerCombatStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerCombatStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerCombatStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerCombatStatsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerCombatStatsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
	{
		if s.Trends.Set {
			e.FieldStart("trends")
			s.Trends.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayerCombatStatsResponse = [2]string{
	0: "stats",
	1: "trends",
}

// Decode decodes PlayerCombatStatsResponse from json.
func (s *PlayerCombatStatsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerCombatStatsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "trends":
			if err := func() error {
				s.Trends.Reset()
				if err := s.Trends.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerCombatStatsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerCombatStatsResponse) {
					name = jsonFieldsNameOfPlayerCombatStatsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerCombatStatsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerCombatStatsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerCombatStatsResponseTrends) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerCombatStatsResponseTrends) encodeFields(e *jx.Encoder) {
	{
		if s.KdRatioTrend.Set {
			e.FieldStart("kd_ratio_trend")
			s.KdRatioTrend.Encode(e)
		}
	}
	{
		if s.AccuracyTrend.Set {
			e.FieldStart("accuracy_trend")
			s.AccuracyTrend.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayerCombatStatsResponseTrends = [2]string{
	0: "kd_ratio_trend",
	1: "accuracy_trend",
}

// Decode decodes PlayerCombatStatsResponseTrends from json.
func (s *PlayerCombatStatsResponseTrends) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerCombatStatsResponseTrends to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kd_ratio_trend":
			if err := func() error {
				s.KdRatioTrend.Reset()
				if err := s.KdRatioTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kd_ratio_trend\"")
			}
		case "accuracy_trend":
			if err := func() error {
				s.AccuracyTrend.Reset()
				if err := s.AccuracyTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accuracy_trend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerCombatStatsResponseTrends")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerCombatStatsResponseTrends) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerCombatStatsResponseTrends) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerCombatStatsResponseTrendsAccuracyTrend as json.
func (s PlayerCombatStatsResponseTrendsAccuracyTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerCombatStatsResponseTrendsAccuracyTrend from json.
func (s *PlayerCombatStatsResponseTrendsAccuracyTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerCombatStatsResponseTrendsAccuracyTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerCombatStatsResponseTrendsAccuracyTrend(v) {
	case PlayerCombatStatsResponseTrendsAccuracyTrendImproving:
		*s = PlayerCombatStatsResponseTrendsAccuracyTrendImproving
	case PlayerCombatStatsResponseTrendsAccuracyTrendDeclining:
		*s = PlayerCombatStatsResponseTrendsAccuracyTrendDeclining
	case PlayerCombatStatsResponseTrendsAccuracyTrendStable:
		*s = PlayerCombatStatsResponseTrendsAccuracyTrendStable
	default:
		*s = PlayerCombatStatsResponseTrendsAccuracyTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerCombatStatsResponseTrendsAccuracyTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerCombatStatsResponseTrendsAccuracyTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerCombatStatsResponseTrendsKdRatioTrend as json.
func (s PlayerCombatStatsResponseTrendsKdRatioTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerCombatStatsResponseTrendsKdRatioTrend from json.
func (s *PlayerCombatStatsResponseTrendsKdRatioTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerCombatStatsResponseTrendsKdRatioTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerCombatStatsResponseTrendsKdRatioTrend(v) {
	case PlayerCombatStatsResponseTrendsKdRatioTrendImproving:
		*s = PlayerCombatStatsResponseTrendsKdRatioTrendImproving
	case PlayerCombatStatsResponseTrendsKdRatioTrendDeclining:
		*s = PlayerCombatStatsResponseTrendsKdRatioTrendDeclining
	case PlayerCombatStatsResponseTrendsKdRatioTrendStable:
		*s = PlayerCombatStatsResponseTrendsKdRatioTrendStable
	default:
		*s = PlayerCombatStatsResponseTrendsKdRatioTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerCombatStatsResponseTrendsKdRatioTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerCombatStatsResponseTrendsKdRatioTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerStatsUpdateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerStatsUpdateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.NewRank.Set {
			e.FieldStart("new_rank")
			s.NewRank.Encode(e)
		}
	}
	{
		if s.AchievementsUnlocked != nil {
			e.FieldStart("achievements_unlocked")
			e.ArrStart()
			for _, elem := range s.AchievementsUnlocked {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPlayerStatsUpdateResponse = [5]string{
	0: "player_id",
	1: "updated_at",
	2: "success",
	3: "new_rank",
	4: "achievements_unlocked",
}

// Decode decodes PlayerStatsUpdateResponse from json.
func (s *PlayerStatsUpdateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerStatsUpdateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "new_rank":
			if err := func() error {
				s.NewRank.Reset()
				if err := s.NewRank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_rank\"")
			}
		case "achievements_unlocked":
			if err := func() error {
				s.AchievementsUnlocked = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AchievementsUnlocked = append(s.AchievementsUnlocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_unlocked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerStatsUpdateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerStatsUpdateResponse) {
					name = jsonFieldsNameOfPlayerStatsUpdateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerStatsUpdateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerStatsUpdateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerCombatStatsBadRequest as json.
func (s *UpdatePlayerCombatStatsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePlayerCombatStatsBadRequest from json.
func (s *UpdatePlayerCombatStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerCombatStatsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePlayerCombatStatsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerCombatStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerCombatStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerCombatStatsUnprocessableEntity as json.
func (s *UpdatePlayerCombatStatsUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePlayerCombatStatsUnprocessableEntity from json.
func (s *UpdatePlayerCombatStatsUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerCombatStatsUnprocessableEntity to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePlayerCombatStatsUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerCombatStatsUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerCombatStatsUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerStatsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerStatsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_stats")
		s.SessionStats.Encode(e)
	}
}

var jsonFieldsNameOfUpdatePlayerStatsRequest = [1]string{
	0: "session_stats",
}

// Decode decodes UpdatePlayerStatsRequest from json.
func (s *UpdatePlayerStatsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerStatsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_stats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SessionStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerStatsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerStatsRequest) {
					name = jsonFieldsNameOfUpdatePlayerStatsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerStatsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerStatsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerStatsRequestSessionStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("kills")
		e.Int(s.Kills)
	}
	{
		e.FieldStart("deaths")
		e.Int(s.Deaths)
	}
	{
		e.FieldStart("damage_dealt")
		e.Int(s.DamageDealt)
	}
	{
		e.FieldStart("damage_received")
		e.Int(s.DamageReceived)
	}
	{
		e.FieldStart("session_duration")
		e.Int(s.SessionDuration)
	}
	{
		e.FieldStart("weapons_used")
		e.ArrStart()
		for _, elem := range s.WeaponsUsed {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.AbilitiesUsed != nil {
			e.FieldStart("abilities_used")
			e.ArrStart()
			for _, elem := range s.AbilitiesUsed {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SessionOutcome.Set {
			e.FieldStart("session_outcome")
			s.SessionOutcome.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePlayerStatsRequestSessionStats = [8]string{
	0: "kills",
	1: "deaths",
	2: "damage_dealt",
	3: "damage_received",
	4: "session_duration",
	5: "weapons_used",
	6: "abilities_used",
	7: "session_outcome",
}

// Decode decodes UpdatePlayerStatsRequestSessionStats from json.
func (s *UpdatePlayerStatsRequestSessionStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerStatsRequestSessionStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kills":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Kills = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "deaths":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Deaths = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deaths\"")
			}
		case "damage_dealt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DamageDealt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_dealt\"")
			}
		case "damage_received":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DamageReceived = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_received\"")
			}
		case "session_duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.SessionDuration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_duration\"")
			}
		case "weapons_used":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.WeaponsUsed = make([]UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WeaponsUsed = append(s.WeaponsUsed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapons_used\"")
			}
		case "abilities_used":
			if err := func() error {
				s.AbilitiesUsed = make([]UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AbilitiesUsed = append(s.AbilitiesUsed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilities_used\"")
			}
		case "session_outcome":
			if err := func() error {
				s.SessionOutcome.Reset()
				if err := s.SessionOutcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_outcome\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerStatsRequestSessionStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerStatsRequestSessionStats) {
					name = jsonFieldsNameOfUpdatePlayerStatsRequestSessionStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerStatsRequestSessionStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ability_id")
		json.EncodeUUID(e, s.AbilityID)
	}
	{
		e.FieldStart("times_used")
		e.Int(s.TimesUsed)
	}
}

var jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem = [2]string{
	0: "ability_id",
	1: "times_used",
}

// Decode decodes UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem from json.
func (s *UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ability_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AbilityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability_id\"")
			}
		case "times_used":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TimesUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"times_used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) {
					name = jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerStatsRequestSessionStatsAbilitiesUsedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerStatsRequestSessionStatsSessionOutcome as json.
func (s UpdatePlayerStatsRequestSessionStatsSessionOutcome) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdatePlayerStatsRequestSessionStatsSessionOutcome from json.
func (s *UpdatePlayerStatsRequestSessionStatsSessionOutcome) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerStatsRequestSessionStatsSessionOutcome to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdatePlayerStatsRequestSessionStatsSessionOutcome(v) {
	case UpdatePlayerStatsRequestSessionStatsSessionOutcomeVictory:
		*s = UpdatePlayerStatsRequestSessionStatsSessionOutcomeVictory
	case UpdatePlayerStatsRequestSessionStatsSessionOutcomeDefeat:
		*s = UpdatePlayerStatsRequestSessionStatsSessionOutcomeDefeat
	case UpdatePlayerStatsRequestSessionStatsSessionOutcomeDraw:
		*s = UpdatePlayerStatsRequestSessionStatsSessionOutcomeDraw
	default:
		*s = UpdatePlayerStatsRequestSessionStatsSessionOutcome(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdatePlayerStatsRequestSessionStatsSessionOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerStatsRequestSessionStatsSessionOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("weapon_id")
		json.EncodeUUID(e, s.WeaponID)
	}
	{
		e.FieldStart("shots_fired")
		e.Int(s.ShotsFired)
	}
	{
		e.FieldStart("hits")
		e.Int(s.Hits)
	}
	{
		if s.Headshots.Set {
			e.FieldStart("headshots")
			s.Headshots.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsWeaponsUsedItem = [4]string{
	0: "weapon_id",
	1: "shots_fired",
	2: "hits",
	3: "headshots",
}

// Decode decodes UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem from json.
func (s *UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weapon_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WeaponID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_id\"")
			}
		case "shots_fired":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ShotsFired = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shots_fired\"")
			}
		case "hits":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Hits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hits\"")
			}
		case "headshots":
			if err := func() error {
				s.Headshots.Reset()
				if err := s.Headshots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headshots\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) {
					name = jsonFieldsNameOfUpdatePlayerStatsRequestSessionStatsWeaponsUsedItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerStatsRequestSessionStatsWeaponsUsedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WeaponAnalyticsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WeaponAnalyticsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("weapon_id")
		json.EncodeUUID(e, s.WeaponID)
	}
	{
		e.FieldStart("weapon_name")
		e.Str(s.WeaponName)
	}
	{
		e.FieldStart("total_usage_count")
		e.Int64(s.TotalUsageCount)
	}
	{
		e.FieldStart("average_accuracy")
		e.Float32(s.AverageAccuracy)
	}
	{
		e.FieldStart("kill_death_ratio")
		e.Float32(s.KillDeathRatio)
	}
	{
		e.FieldStart("average_damage_per_kill")
		e.Int(s.AverageDamagePerKill)
	}
	{
		if s.HeadshotRate.Set {
			e.FieldStart("headshot_rate")
			s.HeadshotRate.Encode(e)
		}
	}
	{
		if s.AverageTtkSeconds.Set {
			e.FieldStart("average_ttk_seconds")
			s.AverageTtkSeconds.Encode(e)
		}
	}
	{
		if s.WinRateWithWeapon.Set {
			e.FieldStart("win_rate_with_weapon")
			s.WinRateWithWeapon.Encode(e)
		}
	}
	{
		if s.PopularityRank.Set {
			e.FieldStart("popularity_rank")
			s.PopularityRank.Encode(e)
		}
	}
}

var jsonFieldsNameOfWeaponAnalyticsResponse = [10]string{
	0: "weapon_id",
	1: "weapon_name",
	2: "total_usage_count",
	3: "average_accuracy",
	4: "kill_death_ratio",
	5: "average_damage_per_kill",
	6: "headshot_rate",
	7: "average_ttk_seconds",
	8: "win_rate_with_weapon",
	9: "popularity_rank",
}

// Decode decodes WeaponAnalyticsResponse from json.
func (s *WeaponAnalyticsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WeaponAnalyticsResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weapon_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WeaponID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_id\"")
			}
		case "weapon_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_name\"")
			}
		case "total_usage_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.TotalUsageCount = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_usage_count\"")
			}
		case "average_accuracy":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.AverageAccuracy = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_accuracy\"")
			}
		case "kill_death_ratio":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float32()
				s.KillDeathRatio = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kill_death_ratio\"")
			}
		case "average_damage_per_kill":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AverageDamagePerKill = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_damage_per_kill\"")
			}
		case "headshot_rate":
			if err := func() error {
				s.HeadshotRate.Reset()
				if err := s.HeadshotRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headshot_rate\"")
			}
		case "average_ttk_seconds":
			if err := func() error {
				s.AverageTtkSeconds.Reset()
				if err := s.AverageTtkSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_ttk_seconds\"")
			}
		case "win_rate_with_weapon":
			if err := func() error {
				s.WinRateWithWeapon.Reset()
				if err := s.WinRateWithWeapon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win_rate_with_weapon\"")
			}
		case "popularity_rank":
			if err := func() error {
				s.PopularityRank.Reset()
				if err := s.PopularityRank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"popularity_rank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WeaponAnalyticsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWeaponAnalyticsResponse) {
					name = jsonFieldsNameOfWeaponAnalyticsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WeaponAnalyticsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WeaponAnalyticsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
