// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AbuseReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbuseReport) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reporter_service")
		e.Str(s.ReporterService)
	}
	{
		e.FieldStart("suspect_identifier")
		e.Str(s.SuspectIdentifier)
	}
	{
		if s.IdentifierType.Set {
			e.FieldStart("identifier_type")
			s.IdentifierType.Encode(e)
		}
	}
	{
		e.FieldStart("abuse_type")
		s.AbuseType.Encode(e)
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		e.FieldStart("evidence")
		s.Evidence.Encode(e)
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbuseReport = [7]string{
	0: "reporter_service",
	1: "suspect_identifier",
	2: "identifier_type",
	3: "abuse_type",
	4: "severity",
	5: "evidence",
	6: "context",
}

// Decode decodes AbuseReport from json.
func (s *AbuseReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReport to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reporter_service":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ReporterService = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reporter_service\"")
			}
		case "suspect_identifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SuspectIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspect_identifier\"")
			}
		case "identifier_type":
			if err := func() error {
				s.IdentifierType.Reset()
				if err := s.IdentifierType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier_type\"")
			}
		case "abuse_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.AbuseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abuse_type\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "evidence":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Evidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbuseReport")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbuseReport) {
					name = jsonFieldsNameOfAbuseReport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbuseReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportAbuseType as json.
func (s AbuseReportAbuseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbuseReportAbuseType from json.
func (s *AbuseReportAbuseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReportAbuseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbuseReportAbuseType(v) {
	case AbuseReportAbuseTypeDdosAttempt:
		*s = AbuseReportAbuseTypeDdosAttempt
	case AbuseReportAbuseTypeCredentialStuffing:
		*s = AbuseReportAbuseTypeCredentialStuffing
	case AbuseReportAbuseTypeScraping:
		*s = AbuseReportAbuseTypeScraping
	case AbuseReportAbuseTypeAPIMisuse:
		*s = AbuseReportAbuseTypeAPIMisuse
	case AbuseReportAbuseTypeRateManipulation:
		*s = AbuseReportAbuseTypeRateManipulation
	default:
		*s = AbuseReportAbuseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbuseReportAbuseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReportAbuseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbuseReportContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbuseReportContext) encodeFields(e *jx.Encoder) {
	{
		if s.GeoLocation.Set {
			e.FieldStart("geo_location")
			s.GeoLocation.Encode(e)
		}
	}
	{
		if s.VpnDetected.Set {
			e.FieldStart("vpn_detected")
			s.VpnDetected.Encode(e)
		}
	}
	{
		if s.ProxyDetected.Set {
			e.FieldStart("proxy_detected")
			s.ProxyDetected.Encode(e)
		}
	}
	{
		if s.TorExitNode.Set {
			e.FieldStart("tor_exit_node")
			s.TorExitNode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbuseReportContext = [4]string{
	0: "geo_location",
	1: "vpn_detected",
	2: "proxy_detected",
	3: "tor_exit_node",
}

// Decode decodes AbuseReportContext from json.
func (s *AbuseReportContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReportContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "geo_location":
			if err := func() error {
				s.GeoLocation.Reset()
				if err := s.GeoLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geo_location\"")
			}
		case "vpn_detected":
			if err := func() error {
				s.VpnDetected.Reset()
				if err := s.VpnDetected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn_detected\"")
			}
		case "proxy_detected":
			if err := func() error {
				s.ProxyDetected.Reset()
				if err := s.ProxyDetected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxy_detected\"")
			}
		case "tor_exit_node":
			if err := func() error {
				s.TorExitNode.Reset()
				if err := s.TorExitNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tor_exit_node\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbuseReportContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbuseReportContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReportContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbuseReportEvidence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbuseReportEvidence) encodeFields(e *jx.Encoder) {
	{
		if s.RequestCount.Set {
			e.FieldStart("request_count")
			s.RequestCount.Encode(e)
		}
	}
	{
		if s.TimeWindowSeconds.Set {
			e.FieldStart("time_window_seconds")
			s.TimeWindowSeconds.Encode(e)
		}
	}
	{
		if s.UnusualPatterns != nil {
			e.FieldStart("unusual_patterns")
			e.ArrStart()
			for _, elem := range s.UnusualPatterns {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AffectedEndpoints != nil {
			e.FieldStart("affected_endpoints")
			e.ArrStart()
			for _, elem := range s.AffectedEndpoints {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UserAgents != nil {
			e.FieldStart("user_agents")
			e.ArrStart()
			for _, elem := range s.UserAgents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAbuseReportEvidence = [5]string{
	0: "request_count",
	1: "time_window_seconds",
	2: "unusual_patterns",
	3: "affected_endpoints",
	4: "user_agents",
}

// Decode decodes AbuseReportEvidence from json.
func (s *AbuseReportEvidence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReportEvidence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_count":
			if err := func() error {
				s.RequestCount.Reset()
				if err := s.RequestCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_count\"")
			}
		case "time_window_seconds":
			if err := func() error {
				s.TimeWindowSeconds.Reset()
				if err := s.TimeWindowSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_window_seconds\"")
			}
		case "unusual_patterns":
			if err := func() error {
				s.UnusualPatterns = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UnusualPatterns = append(s.UnusualPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unusual_patterns\"")
			}
		case "affected_endpoints":
			if err := func() error {
				s.AffectedEndpoints = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AffectedEndpoints = append(s.AffectedEndpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affected_endpoints\"")
			}
		case "user_agents":
			if err := func() error {
				s.UserAgents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UserAgents = append(s.UserAgents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_agents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbuseReportEvidence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbuseReportEvidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReportEvidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportIdentifierType as json.
func (s AbuseReportIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbuseReportIdentifierType from json.
func (s *AbuseReportIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReportIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbuseReportIdentifierType(v) {
	case AbuseReportIdentifierTypeIP:
		*s = AbuseReportIdentifierTypeIP
	case AbuseReportIdentifierTypeUserID:
		*s = AbuseReportIdentifierTypeUserID
	case AbuseReportIdentifierTypeAPIKey:
		*s = AbuseReportIdentifierTypeAPIKey
	case AbuseReportIdentifierTypeSessionID:
		*s = AbuseReportIdentifierTypeSessionID
	default:
		*s = AbuseReportIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbuseReportIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReportIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportSeverity as json.
func (s AbuseReportSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbuseReportSeverity from json.
func (s *AbuseReportSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbuseReportSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbuseReportSeverity(v) {
	case AbuseReportSeverityLow:
		*s = AbuseReportSeverityLow
	case AbuseReportSeverityMedium:
		*s = AbuseReportSeverityMedium
	case AbuseReportSeverityHigh:
		*s = AbuseReportSeverityHigh
	case AbuseReportSeverityCritical:
		*s = AbuseReportSeverityCritical
	default:
		*s = AbuseReportSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbuseReportSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbuseReportSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntityBadRequest as json.
func (s *BlacklistEntityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes BlacklistEntityBadRequest from json.
func (s *BlacklistEntityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BlacklistEntityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlacklistEntityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntityConflict as json.
func (s *BlacklistEntityConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes BlacklistEntityConflict from json.
func (s *BlacklistEntityConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntityConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BlacklistEntityConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlacklistEntityConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntityConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BlacklistEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BlacklistEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entry_id")
		json.EncodeUUID(e, s.EntryID)
	}
	{
		e.FieldStart("entity_identifier")
		e.Str(s.EntityIdentifier)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		if s.ReportedBy.Set {
			e.FieldStart("reported_by")
			s.ReportedBy.Encode(e)
		}
	}
	{
		e.FieldStart("entity_type")
		s.EntityType.Encode(e)
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		if s.LastHitAt.Set {
			e.FieldStart("last_hit_at")
			s.LastHitAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.HitCount.Set {
			e.FieldStart("hit_count")
			s.HitCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfBlacklistEntry = [11]string{
	0:  "entry_id",
	1:  "entity_identifier",
	2:  "reason",
	3:  "reported_by",
	4:  "entity_type",
	5:  "severity",
	6:  "status",
	7:  "created_at",
	8:  "expires_at",
	9:  "last_hit_at",
	10: "hit_count",
}

// Decode decodes BlacklistEntry from json.
func (s *BlacklistEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entry_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EntryID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entry_id\"")
			}
		case "entity_identifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EntityIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_identifier\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "reported_by":
			if err := func() error {
				s.ReportedBy.Reset()
				if err := s.ReportedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_by\"")
			}
		case "entity_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_type\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "last_hit_at":
			if err := func() error {
				s.LastHitAt.Reset()
				if err := s.LastHitAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_hit_at\"")
			}
		case "hit_count":
			if err := func() error {
				s.HitCount.Reset()
				if err := s.HitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hit_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BlacklistEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11010111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBlacklistEntry) {
					name = jsonFieldsNameOfBlacklistEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlacklistEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntryEntityType as json.
func (s BlacklistEntryEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlacklistEntryEntityType from json.
func (s *BlacklistEntryEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntryEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlacklistEntryEntityType(v) {
	case BlacklistEntryEntityTypeIP:
		*s = BlacklistEntryEntityTypeIP
	case BlacklistEntryEntityTypeUserID:
		*s = BlacklistEntryEntityTypeUserID
	case BlacklistEntryEntityTypeAPIKey:
		*s = BlacklistEntryEntityTypeAPIKey
	case BlacklistEntryEntityTypeService:
		*s = BlacklistEntryEntityTypeService
	case BlacklistEntryEntityTypeSubnet:
		*s = BlacklistEntryEntityTypeSubnet
	default:
		*s = BlacklistEntryEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlacklistEntryEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntryEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntrySeverity as json.
func (s BlacklistEntrySeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlacklistEntrySeverity from json.
func (s *BlacklistEntrySeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntrySeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlacklistEntrySeverity(v) {
	case BlacklistEntrySeverityTemporary:
		*s = BlacklistEntrySeverityTemporary
	case BlacklistEntrySeverityPermanent:
		*s = BlacklistEntrySeverityPermanent
	case BlacklistEntrySeverityCritical:
		*s = BlacklistEntrySeverityCritical
	default:
		*s = BlacklistEntrySeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlacklistEntrySeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntrySeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntryStatus as json.
func (s BlacklistEntryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlacklistEntryStatus from json.
func (s *BlacklistEntryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistEntryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlacklistEntryStatus(v) {
	case BlacklistEntryStatusActive:
		*s = BlacklistEntryStatusActive
	case BlacklistEntryStatusExpired:
		*s = BlacklistEntryStatusExpired
	case BlacklistEntryStatusRemoved:
		*s = BlacklistEntryStatusRemoved
	default:
		*s = BlacklistEntryStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlacklistEntryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistEntryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BlacklistRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BlacklistRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entity_identifier")
		e.Str(s.EntityIdentifier)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		if s.ReportedBy.Set {
			e.FieldStart("reported_by")
			s.ReportedBy.Encode(e)
		}
	}
	{
		e.FieldStart("entity_type")
		s.EntityType.Encode(e)
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.DurationSeconds.Set {
			e.FieldStart("duration_seconds")
			s.DurationSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfBlacklistRequest = [6]string{
	0: "entity_identifier",
	1: "reason",
	2: "reported_by",
	3: "entity_type",
	4: "severity",
	5: "duration_seconds",
}

// Decode decodes BlacklistRequest from json.
func (s *BlacklistRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entity_identifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EntityIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_identifier\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "reported_by":
			if err := func() error {
				s.ReportedBy.Reset()
				if err := s.ReportedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_by\"")
			}
		case "entity_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_type\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "duration_seconds":
			if err := func() error {
				s.DurationSeconds.Reset()
				if err := s.DurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BlacklistRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBlacklistRequest) {
					name = jsonFieldsNameOfBlacklistRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlacklistRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistRequestEntityType as json.
func (s BlacklistRequestEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlacklistRequestEntityType from json.
func (s *BlacklistRequestEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistRequestEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlacklistRequestEntityType(v) {
	case BlacklistRequestEntityTypeIP:
		*s = BlacklistRequestEntityTypeIP
	case BlacklistRequestEntityTypeUserID:
		*s = BlacklistRequestEntityTypeUserID
	case BlacklistRequestEntityTypeAPIKey:
		*s = BlacklistRequestEntityTypeAPIKey
	case BlacklistRequestEntityTypeService:
		*s = BlacklistRequestEntityTypeService
	case BlacklistRequestEntityTypeSubnet:
		*s = BlacklistRequestEntityTypeSubnet
	default:
		*s = BlacklistRequestEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlacklistRequestEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistRequestEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistRequestSeverity as json.
func (s BlacklistRequestSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlacklistRequestSeverity from json.
func (s *BlacklistRequestSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistRequestSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlacklistRequestSeverity(v) {
	case BlacklistRequestSeverityTemporary:
		*s = BlacklistRequestSeverityTemporary
	case BlacklistRequestSeverityPermanent:
		*s = BlacklistRequestSeverityPermanent
	case BlacklistRequestSeverityCritical:
		*s = BlacklistRequestSeverityCritical
	default:
		*s = BlacklistRequestSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlacklistRequestSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistRequestSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BlacklistResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BlacklistResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entries")
		e.ArrStart()
		for _, elem := range s.Entries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		if s.ActiveCount.Set {
			e.FieldStart("active_count")
			s.ActiveCount.Encode(e)
		}
	}
	{
		if s.ExpiredCount.Set {
			e.FieldStart("expired_count")
			s.ExpiredCount.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
}

var jsonFieldsNameOfBlacklistResponse = [6]string{
	0: "entries",
	1: "total_count",
	2: "active_count",
	3: "expired_count",
	4: "limit",
	5: "offset",
}

// Decode decodes BlacklistResponse from json.
func (s *BlacklistResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlacklistResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entries":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Entries = make([]BlacklistEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BlacklistEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "active_count":
			if err := func() error {
				s.ActiveCount.Reset()
				if err := s.ActiveCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_count\"")
			}
		case "expired_count":
			if err := func() error {
				s.ExpiredCount.Reset()
				if err := s.ExpiredCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_count\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BlacklistResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBlacklistResponse) {
					name = jsonFieldsNameOfBlacklistResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlacklistResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlacklistResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitBadRequest as json.
func (s *CreateRateLimitBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateRateLimitBadRequest from json.
func (s *CreateRateLimitBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateRateLimitBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitConflict as json.
func (s *CreateRateLimitConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateRateLimitConflict from json.
func (s *CreateRateLimitConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateRateLimitConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRateLimitRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRateLimitRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service_name")
		e.Str(s.ServiceName)
	}
	{
		e.FieldStart("endpoint_pattern")
		e.Str(s.EndpointPattern)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("algorithm")
		s.Algorithm.Encode(e)
	}
	{
		e.FieldStart("limits")
		s.Limits.Encode(e)
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Enforcement.Set {
			e.FieldStart("enforcement")
			s.Enforcement.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRateLimitRequest = [8]string{
	0: "service_name",
	1: "endpoint_pattern",
	2: "description",
	3: "algorithm",
	4: "limits",
	5: "scope",
	6: "enforcement",
	7: "priority",
}

// Decode decodes CreateRateLimitRequest from json.
func (s *CreateRateLimitRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_name\"")
			}
		case "endpoint_pattern":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EndpointPattern = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoint_pattern\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "algorithm":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "limits":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "enforcement":
			if err := func() error {
				s.Enforcement.Reset()
				if err := s.Enforcement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforcement\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRateLimitRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateRateLimitRequest) {
					name = jsonFieldsNameOfCreateRateLimitRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitRequestAlgorithm as json.
func (s CreateRateLimitRequestAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateRateLimitRequestAlgorithm from json.
func (s *CreateRateLimitRequestAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequestAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateRateLimitRequestAlgorithm(v) {
	case CreateRateLimitRequestAlgorithmTokenBucket:
		*s = CreateRateLimitRequestAlgorithmTokenBucket
	case CreateRateLimitRequestAlgorithmSlidingWindow:
		*s = CreateRateLimitRequestAlgorithmSlidingWindow
	case CreateRateLimitRequestAlgorithmLeakyBucket:
		*s = CreateRateLimitRequestAlgorithmLeakyBucket
	case CreateRateLimitRequestAlgorithmFixedWindow:
		*s = CreateRateLimitRequestAlgorithmFixedWindow
	default:
		*s = CreateRateLimitRequestAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRateLimitRequestAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequestAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRateLimitRequestEnforcement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRateLimitRequestEnforcement) encodeFields(e *jx.Encoder) {
	{
		if s.BlockDurationSeconds.Set {
			e.FieldStart("block_duration_seconds")
			s.BlockDurationSeconds.Encode(e)
		}
	}
	{
		if s.GradualBackoff.Set {
			e.FieldStart("gradual_backoff")
			s.GradualBackoff.Encode(e)
		}
	}
	{
		if s.NotifyOnViolation.Set {
			e.FieldStart("notify_on_violation")
			s.NotifyOnViolation.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRateLimitRequestEnforcement = [3]string{
	0: "block_duration_seconds",
	1: "gradual_backoff",
	2: "notify_on_violation",
}

// Decode decodes CreateRateLimitRequestEnforcement from json.
func (s *CreateRateLimitRequestEnforcement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequestEnforcement to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block_duration_seconds":
			if err := func() error {
				s.BlockDurationSeconds.Reset()
				if err := s.BlockDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_duration_seconds\"")
			}
		case "gradual_backoff":
			if err := func() error {
				s.GradualBackoff.Reset()
				if err := s.GradualBackoff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gradual_backoff\"")
			}
		case "notify_on_violation":
			if err := func() error {
				s.NotifyOnViolation.Reset()
				if err := s.NotifyOnViolation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notify_on_violation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRateLimitRequestEnforcement")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitRequestEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequestEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRateLimitRequestLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRateLimitRequestLimits) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsPerSecond.Set {
			e.FieldStart("requests_per_second")
			s.RequestsPerSecond.Encode(e)
		}
	}
	{
		if s.RequestsPerMinute.Set {
			e.FieldStart("requests_per_minute")
			s.RequestsPerMinute.Encode(e)
		}
	}
	{
		if s.RequestsPerHour.Set {
			e.FieldStart("requests_per_hour")
			s.RequestsPerHour.Encode(e)
		}
	}
	{
		if s.BurstLimit.Set {
			e.FieldStart("burst_limit")
			s.BurstLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRateLimitRequestLimits = [4]string{
	0: "requests_per_second",
	1: "requests_per_minute",
	2: "requests_per_hour",
	3: "burst_limit",
}

// Decode decodes CreateRateLimitRequestLimits from json.
func (s *CreateRateLimitRequestLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequestLimits to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_per_second":
			if err := func() error {
				s.RequestsPerSecond.Reset()
				if err := s.RequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_second\"")
			}
		case "requests_per_minute":
			if err := func() error {
				s.RequestsPerMinute.Reset()
				if err := s.RequestsPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_minute\"")
			}
		case "requests_per_hour":
			if err := func() error {
				s.RequestsPerHour.Reset()
				if err := s.RequestsPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_hour\"")
			}
		case "burst_limit":
			if err := func() error {
				s.BurstLimit.Reset()
				if err := s.BurstLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"burst_limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRateLimitRequestLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitRequestLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequestLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRateLimitRequestScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRateLimitRequestScope) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRateLimitRequestScope = [4]string{
	0: "user_id",
	1: "ip_address",
	2: "api_key",
	3: "region",
}

// Decode decodes CreateRateLimitRequestScope from json.
func (s *CreateRateLimitRequestScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequestScope to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRateLimitRequestScope")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRateLimitRequestScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequestScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitRequestScopeRegion as json.
func (s CreateRateLimitRequestScopeRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateRateLimitRequestScopeRegion from json.
func (s *CreateRateLimitRequestScopeRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRateLimitRequestScopeRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateRateLimitRequestScopeRegion(v) {
	case CreateRateLimitRequestScopeRegionGlobal:
		*s = CreateRateLimitRequestScopeRegionGlobal
	case CreateRateLimitRequestScopeRegionRegional:
		*s = CreateRateLimitRequestScopeRegionRegional
	case CreateRateLimitRequestScopeRegionLocal:
		*s = CreateRateLimitRequestScopeRegionLocal
	default:
		*s = CreateRateLimitRequestScopeRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRateLimitRequestScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRateLimitRequestScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			e.FieldStart("retry_after")
			s.RetryAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [5]string{
	0: "code",
	1: "message",
	2: "timestamp",
	3: "details",
	4: "retry_after",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "retry_after":
			if err := func() error {
				s.RetryAfter.Reset()
				if err := s.RetryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_after\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.ActiveRules.Set {
			e.FieldStart("active_rules")
			s.ActiveRules.Encode(e)
		}
	}
	{
		if s.BlockedRequestsLastHour.Set {
			e.FieldStart("blocked_requests_last_hour")
			s.BlockedRequestsLastHour.Encode(e)
		}
	}
	{
		if s.RedisConnections.Set {
			e.FieldStart("redis_connections")
			s.RedisConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [6]string{
	0: "version",
	1: "status",
	2: "timestamp",
	3: "active_rules",
	4: "blocked_requests_last_hour",
	5: "redis_connections",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "active_rules":
			if err := func() error {
				s.ActiveRules.Reset()
				if err := s.ActiveRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_rules\"")
			}
		case "blocked_requests_last_hour":
			if err := func() error {
				s.BlockedRequestsLastHour.Reset()
				if err := s.BlockedRequestsLastHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_requests_last_hour\"")
			}
		case "redis_connections":
			if err := func() error {
				s.RedisConnections.Reset()
				if err := s.RedisConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportContext as json.
func (o OptAbuseReportContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbuseReportContext from json.
func (o *OptAbuseReportContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbuseReportContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbuseReportContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbuseReportContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportIdentifierType as json.
func (o OptAbuseReportIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbuseReportIdentifierType from json.
func (o *OptAbuseReportIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbuseReportIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbuseReportIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbuseReportIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbuseReportSeverity as json.
func (o OptAbuseReportSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbuseReportSeverity from json.
func (o *OptAbuseReportSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbuseReportSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbuseReportSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbuseReportSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistEntrySeverity as json.
func (o OptBlacklistEntrySeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BlacklistEntrySeverity from json.
func (o *OptBlacklistEntrySeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBlacklistEntrySeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBlacklistEntrySeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBlacklistEntrySeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlacklistRequestSeverity as json.
func (o OptBlacklistRequestSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BlacklistRequestSeverity from json.
func (o *OptBlacklistRequestSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBlacklistRequestSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBlacklistRequestSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBlacklistRequestSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitRequestEnforcement as json.
func (o OptCreateRateLimitRequestEnforcement) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateRateLimitRequestEnforcement from json.
func (o *OptCreateRateLimitRequestEnforcement) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateRateLimitRequestEnforcement to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateRateLimitRequestEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateRateLimitRequestEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitRequestScope as json.
func (o OptCreateRateLimitRequestScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateRateLimitRequestScope from json.
func (o *OptCreateRateLimitRequestScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateRateLimitRequestScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateRateLimitRequestScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateRateLimitRequestScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRateLimitRequestScopeRegion as json.
func (o OptCreateRateLimitRequestScopeRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateRateLimitRequestScopeRegion from json.
func (o *OptCreateRateLimitRequestScopeRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateRateLimitRequestScopeRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateRateLimitRequestScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateRateLimitRequestScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleEnforcement as json.
func (o OptRateLimitRuleEnforcement) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimitRuleEnforcement from json.
func (o *OptRateLimitRuleEnforcement) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitRuleEnforcement to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitRuleEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitRuleEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleScope as json.
func (o OptRateLimitRuleScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimitRuleScope from json.
func (o *OptRateLimitRuleScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitRuleScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitRuleScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitRuleScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleScopeRegion as json.
func (o OptRateLimitRuleScopeRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RateLimitRuleScopeRegion from json.
func (o *OptRateLimitRuleScopeRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitRuleScopeRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitRuleScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitRuleScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsAlertsItemSeverity as json.
func (o OptRateLimitStatsAlertsItemSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RateLimitStatsAlertsItemSeverity from json.
func (o *OptRateLimitStatsAlertsItemSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitStatsAlertsItemSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitStatsAlertsItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitStatsAlertsItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsGeographicDistribution as json.
func (o OptRateLimitStatsGeographicDistribution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimitStatsGeographicDistribution from json.
func (o *OptRateLimitStatsGeographicDistribution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitStatsGeographicDistribution to nil")
	}
	o.Set = true
	o.Value = make(RateLimitStatsGeographicDistribution)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitStatsGeographicDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitStatsGeographicDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsSystemPerformance as json.
func (o OptRateLimitStatsSystemPerformance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimitStatsSystemPerformance from json.
func (o *OptRateLimitStatsSystemPerformance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitStatsSystemPerformance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitStatsSystemPerformance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitStatsSystemPerformance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsTopOffendersItemIdentifierType as json.
func (o OptRateLimitStatsTopOffendersItemIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RateLimitStatsTopOffendersItemIdentifierType from json.
func (o *OptRateLimitStatsTopOffendersItemIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimitStatsTopOffendersItemIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimitStatsTopOffendersItemIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimitStatsTopOffendersItemIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateQuotaRequestCustomLimits as json.
func (o OptUpdateQuotaRequestCustomLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateQuotaRequestCustomLimits from json.
func (o *OptUpdateQuotaRequestCustomLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateQuotaRequestCustomLimits to nil")
	}
	o.Set = true
	o.Value = make(UpdateQuotaRequestCustomLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateQuotaRequestCustomLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateQuotaRequestCustomLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateQuotaRequestQuotas as json.
func (o OptUpdateQuotaRequestQuotas) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateQuotaRequestQuotas from json.
func (o *OptUpdateQuotaRequestQuotas) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateQuotaRequestQuotas to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateQuotaRequestQuotas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateQuotaRequestQuotas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateQuotaRequestTier as json.
func (o OptUpdateQuotaRequestTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateQuotaRequestTier from json.
func (o *OptUpdateQuotaRequestTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateQuotaRequestTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateQuotaRequestTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateQuotaRequestTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestAlgorithm as json.
func (o OptUpdateRateLimitRequestAlgorithm) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateRateLimitRequestAlgorithm from json.
func (o *OptUpdateRateLimitRequestAlgorithm) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestAlgorithm to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestEnforcement as json.
func (o OptUpdateRateLimitRequestEnforcement) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRateLimitRequestEnforcement from json.
func (o *OptUpdateRateLimitRequestEnforcement) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestEnforcement to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestLimits as json.
func (o OptUpdateRateLimitRequestLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRateLimitRequestLimits from json.
func (o *OptUpdateRateLimitRequestLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestLimits to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestScope as json.
func (o OptUpdateRateLimitRequestScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRateLimitRequestScope from json.
func (o *OptUpdateRateLimitRequestScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestScopeRegion as json.
func (o OptUpdateRateLimitRequestScopeRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateRateLimitRequestScopeRegion from json.
func (o *OptUpdateRateLimitRequestScopeRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestScopeRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestStatus as json.
func (o OptUpdateRateLimitRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateRateLimitRequestStatus from json.
func (o *OptUpdateRateLimitRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRateLimitRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRateLimitRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRateLimitRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserQuotaCustomLimits as json.
func (o OptUserQuotaCustomLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserQuotaCustomLimits from json.
func (o *OptUserQuotaCustomLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserQuotaCustomLimits to nil")
	}
	o.Set = true
	o.Value = make(UserQuotaCustomLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserQuotaCustomLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserQuotaCustomLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserQuotaTier as json.
func (o OptUserQuotaTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserQuotaTier from json.
func (o *OptUserQuotaTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserQuotaTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserQuotaTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserQuotaTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitListResponse = [4]string{
	0: "rules",
	1: "total_count",
	2: "limit",
	3: "offset",
}

// Decode decodes RateLimitListResponse from json.
func (s *RateLimitListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rules":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Rules = make([]RateLimitRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RateLimitRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitListResponse) {
					name = jsonFieldsNameOfRateLimitListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule_id")
		json.EncodeUUID(e, s.RuleID)
	}
	{
		e.FieldStart("service_name")
		e.Str(s.ServiceName)
	}
	{
		e.FieldStart("endpoint_pattern")
		e.Str(s.EndpointPattern)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("algorithm")
		s.Algorithm.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("limits")
		s.Limits.Encode(e)
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Enforcement.Set {
			e.FieldStart("enforcement")
			s.Enforcement.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitRule = [12]string{
	0:  "rule_id",
	1:  "service_name",
	2:  "endpoint_pattern",
	3:  "description",
	4:  "algorithm",
	5:  "status",
	6:  "created_at",
	7:  "updated_at",
	8:  "limits",
	9:  "scope",
	10: "enforcement",
	11: "priority",
}

// Decode decodes RateLimitRule from json.
func (s *RateLimitRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRule to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.RuleID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_id\"")
			}
		case "service_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ServiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_name\"")
			}
		case "endpoint_pattern":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.EndpointPattern = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoint_pattern\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "algorithm":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "limits":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "enforcement":
			if err := func() error {
				s.Enforcement.Reset()
				if err := s.Enforcement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforcement\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitRule) {
					name = jsonFieldsNameOfRateLimitRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleAlgorithm as json.
func (s RateLimitRuleAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitRuleAlgorithm from json.
func (s *RateLimitRuleAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitRuleAlgorithm(v) {
	case RateLimitRuleAlgorithmTokenBucket:
		*s = RateLimitRuleAlgorithmTokenBucket
	case RateLimitRuleAlgorithmSlidingWindow:
		*s = RateLimitRuleAlgorithmSlidingWindow
	case RateLimitRuleAlgorithmLeakyBucket:
		*s = RateLimitRuleAlgorithmLeakyBucket
	case RateLimitRuleAlgorithmFixedWindow:
		*s = RateLimitRuleAlgorithmFixedWindow
	default:
		*s = RateLimitRuleAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitRuleAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitRuleEnforcement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitRuleEnforcement) encodeFields(e *jx.Encoder) {
	{
		if s.BlockDurationSeconds.Set {
			e.FieldStart("block_duration_seconds")
			s.BlockDurationSeconds.Encode(e)
		}
	}
	{
		if s.GradualBackoff.Set {
			e.FieldStart("gradual_backoff")
			s.GradualBackoff.Encode(e)
		}
	}
	{
		if s.NotifyOnViolation.Set {
			e.FieldStart("notify_on_violation")
			s.NotifyOnViolation.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitRuleEnforcement = [3]string{
	0: "block_duration_seconds",
	1: "gradual_backoff",
	2: "notify_on_violation",
}

// Decode decodes RateLimitRuleEnforcement from json.
func (s *RateLimitRuleEnforcement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleEnforcement to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block_duration_seconds":
			if err := func() error {
				s.BlockDurationSeconds.Reset()
				if err := s.BlockDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_duration_seconds\"")
			}
		case "gradual_backoff":
			if err := func() error {
				s.GradualBackoff.Reset()
				if err := s.GradualBackoff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gradual_backoff\"")
			}
		case "notify_on_violation":
			if err := func() error {
				s.NotifyOnViolation.Reset()
				if err := s.NotifyOnViolation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notify_on_violation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitRuleEnforcement")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitRuleEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitRuleLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitRuleLimits) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsPerSecond.Set {
			e.FieldStart("requests_per_second")
			s.RequestsPerSecond.Encode(e)
		}
	}
	{
		if s.RequestsPerMinute.Set {
			e.FieldStart("requests_per_minute")
			s.RequestsPerMinute.Encode(e)
		}
	}
	{
		if s.RequestsPerHour.Set {
			e.FieldStart("requests_per_hour")
			s.RequestsPerHour.Encode(e)
		}
	}
	{
		if s.BurstLimit.Set {
			e.FieldStart("burst_limit")
			s.BurstLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitRuleLimits = [4]string{
	0: "requests_per_second",
	1: "requests_per_minute",
	2: "requests_per_hour",
	3: "burst_limit",
}

// Decode decodes RateLimitRuleLimits from json.
func (s *RateLimitRuleLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleLimits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_per_second":
			if err := func() error {
				s.RequestsPerSecond.Reset()
				if err := s.RequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_second\"")
			}
		case "requests_per_minute":
			if err := func() error {
				s.RequestsPerMinute.Reset()
				if err := s.RequestsPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_minute\"")
			}
		case "requests_per_hour":
			if err := func() error {
				s.RequestsPerHour.Reset()
				if err := s.RequestsPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_hour\"")
			}
		case "burst_limit":
			if err := func() error {
				s.BurstLimit.Reset()
				if err := s.BurstLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"burst_limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitRuleLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitRuleLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitRuleScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitRuleScope) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitRuleScope = [4]string{
	0: "user_id",
	1: "ip_address",
	2: "api_key",
	3: "region",
}

// Decode decodes RateLimitRuleScope from json.
func (s *RateLimitRuleScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleScope to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitRuleScope")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitRuleScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleScopeRegion as json.
func (s RateLimitRuleScopeRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitRuleScopeRegion from json.
func (s *RateLimitRuleScopeRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleScopeRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitRuleScopeRegion(v) {
	case RateLimitRuleScopeRegionGlobal:
		*s = RateLimitRuleScopeRegionGlobal
	case RateLimitRuleScopeRegionRegional:
		*s = RateLimitRuleScopeRegionRegional
	case RateLimitRuleScopeRegionLocal:
		*s = RateLimitRuleScopeRegionLocal
	default:
		*s = RateLimitRuleScopeRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitRuleScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitRuleStatus as json.
func (s RateLimitRuleStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitRuleStatus from json.
func (s *RateLimitRuleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitRuleStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitRuleStatus(v) {
	case RateLimitRuleStatusActive:
		*s = RateLimitRuleStatusActive
	case RateLimitRuleStatusInactive:
		*s = RateLimitRuleStatusInactive
	case RateLimitRuleStatusPaused:
		*s = RateLimitRuleStatusPaused
	default:
		*s = RateLimitRuleStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitRuleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitRuleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeframe")
		s.Timeframe.Encode(e)
	}
	{
		if s.GeographicDistribution.Set {
			e.FieldStart("geographic_distribution")
			s.GeographicDistribution.Encode(e)
		}
	}
	{
		if s.SystemPerformance.Set {
			e.FieldStart("system_performance")
			s.SystemPerformance.Encode(e)
		}
	}
	{
		e.FieldStart("rules_performance")
		e.ArrStart()
		for _, elem := range s.RulesPerformance {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TopOffenders != nil {
			e.FieldStart("top_offenders")
			e.ArrStart()
			for _, elem := range s.TopOffenders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Alerts != nil {
			e.FieldStart("alerts")
			e.ArrStart()
			for _, elem := range s.Alerts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("total_requests")
		e.Int(s.TotalRequests)
	}
	{
		e.FieldStart("allowed_requests")
		e.Int(s.AllowedRequests)
	}
	{
		e.FieldStart("blocked_requests")
		e.Int(s.BlockedRequests)
	}
	{
		if s.QuotaExceededRequests.Set {
			e.FieldStart("quota_exceeded_requests")
			s.QuotaExceededRequests.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitStats = [10]string{
	0: "timeframe",
	1: "geographic_distribution",
	2: "system_performance",
	3: "rules_performance",
	4: "top_offenders",
	5: "alerts",
	6: "total_requests",
	7: "allowed_requests",
	8: "blocked_requests",
	9: "quota_exceeded_requests",
}

// Decode decodes RateLimitStats from json.
func (s *RateLimitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStats to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeframe":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "geographic_distribution":
			if err := func() error {
				s.GeographicDistribution.Reset()
				if err := s.GeographicDistribution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geographic_distribution\"")
			}
		case "system_performance":
			if err := func() error {
				s.SystemPerformance.Reset()
				if err := s.SystemPerformance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_performance\"")
			}
		case "rules_performance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.RulesPerformance = make([]RateLimitStatsRulesPerformanceItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RateLimitStatsRulesPerformanceItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RulesPerformance = append(s.RulesPerformance, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules_performance\"")
			}
		case "top_offenders":
			if err := func() error {
				s.TopOffenders = make([]RateLimitStatsTopOffendersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RateLimitStatsTopOffendersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopOffenders = append(s.TopOffenders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_offenders\"")
			}
		case "alerts":
			if err := func() error {
				s.Alerts = make([]RateLimitStatsAlertsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RateLimitStatsAlertsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Alerts = append(s.Alerts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alerts\"")
			}
		case "total_requests":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.TotalRequests = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_requests\"")
			}
		case "allowed_requests":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AllowedRequests = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_requests\"")
			}
		case "blocked_requests":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BlockedRequests = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_requests\"")
			}
		case "quota_exceeded_requests":
			if err := func() error {
				s.QuotaExceededRequests.Reset()
				if err := s.QuotaExceededRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quota_exceeded_requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11001001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitStats) {
					name = jsonFieldsNameOfRateLimitStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStatsAlertsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStatsAlertsItem) encodeFields(e *jx.Encoder) {
	{
		if s.AlertID.Set {
			e.FieldStart("alert_id")
			s.AlertID.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.TriggeredAt.Set {
			e.FieldStart("triggered_at")
			s.TriggeredAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Resolved.Set {
			e.FieldStart("resolved")
			s.Resolved.Encode(e)
		}
	}
	{
		if s.AffectedServices != nil {
			e.FieldStart("affected_services")
			e.ArrStart()
			for _, elem := range s.AffectedServices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRateLimitStatsAlertsItem = [6]string{
	0: "alert_id",
	1: "severity",
	2: "message",
	3: "triggered_at",
	4: "resolved",
	5: "affected_services",
}

// Decode decodes RateLimitStatsAlertsItem from json.
func (s *RateLimitStatsAlertsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsAlertsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alert_id":
			if err := func() error {
				s.AlertID.Reset()
				if err := s.AlertID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_id\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "triggered_at":
			if err := func() error {
				s.TriggeredAt.Reset()
				if err := s.TriggeredAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggered_at\"")
			}
		case "resolved":
			if err := func() error {
				s.Resolved.Reset()
				if err := s.Resolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved\"")
			}
		case "affected_services":
			if err := func() error {
				s.AffectedServices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AffectedServices = append(s.AffectedServices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affected_services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsAlertsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStatsAlertsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsAlertsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsAlertsItemSeverity as json.
func (s RateLimitStatsAlertsItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitStatsAlertsItemSeverity from json.
func (s *RateLimitStatsAlertsItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsAlertsItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitStatsAlertsItemSeverity(v) {
	case RateLimitStatsAlertsItemSeverityLow:
		*s = RateLimitStatsAlertsItemSeverityLow
	case RateLimitStatsAlertsItemSeverityMedium:
		*s = RateLimitStatsAlertsItemSeverityMedium
	case RateLimitStatsAlertsItemSeverityHigh:
		*s = RateLimitStatsAlertsItemSeverityHigh
	case RateLimitStatsAlertsItemSeverityCritical:
		*s = RateLimitStatsAlertsItemSeverityCritical
	default:
		*s = RateLimitStatsAlertsItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitStatsAlertsItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsAlertsItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RateLimitStatsGeographicDistribution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RateLimitStatsGeographicDistribution) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes RateLimitStatsGeographicDistribution from json.
func (s *RateLimitStatsGeographicDistribution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsGeographicDistribution to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem RateLimitStatsGeographicDistributionItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsGeographicDistribution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitStatsGeographicDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsGeographicDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStatsGeographicDistributionItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStatsGeographicDistributionItem) encodeFields(e *jx.Encoder) {
	{
		if s.TotalRequests.Set {
			e.FieldStart("total_requests")
			s.TotalRequests.Encode(e)
		}
	}
	{
		if s.BlockedRequests.Set {
			e.FieldStart("blocked_requests")
			s.BlockedRequests.Encode(e)
		}
	}
	{
		if s.TopBlockedEndpoints != nil {
			e.FieldStart("top_blocked_endpoints")
			e.ArrStart()
			for _, elem := range s.TopBlockedEndpoints {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRateLimitStatsGeographicDistributionItem = [3]string{
	0: "total_requests",
	1: "blocked_requests",
	2: "top_blocked_endpoints",
}

// Decode decodes RateLimitStatsGeographicDistributionItem from json.
func (s *RateLimitStatsGeographicDistributionItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsGeographicDistributionItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_requests":
			if err := func() error {
				s.TotalRequests.Reset()
				if err := s.TotalRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_requests\"")
			}
		case "blocked_requests":
			if err := func() error {
				s.BlockedRequests.Reset()
				if err := s.BlockedRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_requests\"")
			}
		case "top_blocked_endpoints":
			if err := func() error {
				s.TopBlockedEndpoints = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TopBlockedEndpoints = append(s.TopBlockedEndpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_blocked_endpoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsGeographicDistributionItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStatsGeographicDistributionItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsGeographicDistributionItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStatsRulesPerformanceItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStatsRulesPerformanceItem) encodeFields(e *jx.Encoder) {
	{
		if s.RuleID.Set {
			e.FieldStart("rule_id")
			s.RuleID.Encode(e)
		}
	}
	{
		if s.ServiceName.Set {
			e.FieldStart("service_name")
			s.ServiceName.Encode(e)
		}
	}
	{
		if s.EndpointPattern.Set {
			e.FieldStart("endpoint_pattern")
			s.EndpointPattern.Encode(e)
		}
	}
	{
		if s.RequestsProcessed.Set {
			e.FieldStart("requests_processed")
			s.RequestsProcessed.Encode(e)
		}
	}
	{
		if s.BlockedCount.Set {
			e.FieldStart("blocked_count")
			s.BlockedCount.Encode(e)
		}
	}
	{
		if s.AverageResponseTimeMs.Set {
			e.FieldStart("average_response_time_ms")
			s.AverageResponseTimeMs.Encode(e)
		}
	}
	{
		if s.HitRatePercent.Set {
			e.FieldStart("hit_rate_percent")
			s.HitRatePercent.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitStatsRulesPerformanceItem = [7]string{
	0: "rule_id",
	1: "service_name",
	2: "endpoint_pattern",
	3: "requests_processed",
	4: "blocked_count",
	5: "average_response_time_ms",
	6: "hit_rate_percent",
}

// Decode decodes RateLimitStatsRulesPerformanceItem from json.
func (s *RateLimitStatsRulesPerformanceItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsRulesPerformanceItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule_id":
			if err := func() error {
				s.RuleID.Reset()
				if err := s.RuleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_id\"")
			}
		case "service_name":
			if err := func() error {
				s.ServiceName.Reset()
				if err := s.ServiceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_name\"")
			}
		case "endpoint_pattern":
			if err := func() error {
				s.EndpointPattern.Reset()
				if err := s.EndpointPattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoint_pattern\"")
			}
		case "requests_processed":
			if err := func() error {
				s.RequestsProcessed.Reset()
				if err := s.RequestsProcessed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_processed\"")
			}
		case "blocked_count":
			if err := func() error {
				s.BlockedCount.Reset()
				if err := s.BlockedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_count\"")
			}
		case "average_response_time_ms":
			if err := func() error {
				s.AverageResponseTimeMs.Reset()
				if err := s.AverageResponseTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_response_time_ms\"")
			}
		case "hit_rate_percent":
			if err := func() error {
				s.HitRatePercent.Reset()
				if err := s.HitRatePercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hit_rate_percent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsRulesPerformanceItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStatsRulesPerformanceItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsRulesPerformanceItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStatsSystemPerformance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStatsSystemPerformance) encodeFields(e *jx.Encoder) {
	{
		if s.RedisOperationsPerSecond.Set {
			e.FieldStart("redis_operations_per_second")
			s.RedisOperationsPerSecond.Encode(e)
		}
	}
	{
		if s.AverageRuleEvaluationTimeMs.Set {
			e.FieldStart("average_rule_evaluation_time_ms")
			s.AverageRuleEvaluationTimeMs.Encode(e)
		}
	}
	{
		if s.MemoryUsageMB.Set {
			e.FieldStart("memory_usage_mb")
			s.MemoryUsageMB.Encode(e)
		}
	}
	{
		if s.CacheHitRatePercent.Set {
			e.FieldStart("cache_hit_rate_percent")
			s.CacheHitRatePercent.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitStatsSystemPerformance = [5]string{
	0: "redis_operations_per_second",
	1: "average_rule_evaluation_time_ms",
	2: "memory_usage_mb",
	3: "cache_hit_rate_percent",
	4: "active_connections",
}

// Decode decodes RateLimitStatsSystemPerformance from json.
func (s *RateLimitStatsSystemPerformance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsSystemPerformance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "redis_operations_per_second":
			if err := func() error {
				s.RedisOperationsPerSecond.Reset()
				if err := s.RedisOperationsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis_operations_per_second\"")
			}
		case "average_rule_evaluation_time_ms":
			if err := func() error {
				s.AverageRuleEvaluationTimeMs.Reset()
				if err := s.AverageRuleEvaluationTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_rule_evaluation_time_ms\"")
			}
		case "memory_usage_mb":
			if err := func() error {
				s.MemoryUsageMB.Reset()
				if err := s.MemoryUsageMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_usage_mb\"")
			}
		case "cache_hit_rate_percent":
			if err := func() error {
				s.CacheHitRatePercent.Reset()
				if err := s.CacheHitRatePercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_hit_rate_percent\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsSystemPerformance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStatsSystemPerformance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsSystemPerformance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsTimeframe as json.
func (s RateLimitStatsTimeframe) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitStatsTimeframe from json.
func (s *RateLimitStatsTimeframe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsTimeframe to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitStatsTimeframe(v) {
	case RateLimitStatsTimeframe1m:
		*s = RateLimitStatsTimeframe1m
	case RateLimitStatsTimeframe5m:
		*s = RateLimitStatsTimeframe5m
	case RateLimitStatsTimeframe15m:
		*s = RateLimitStatsTimeframe15m
	case RateLimitStatsTimeframe1h:
		*s = RateLimitStatsTimeframe1h
	case RateLimitStatsTimeframe6h:
		*s = RateLimitStatsTimeframe6h
	case RateLimitStatsTimeframe24h:
		*s = RateLimitStatsTimeframe24h
	default:
		*s = RateLimitStatsTimeframe(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitStatsTimeframe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsTimeframe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitStatsTopOffendersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitStatsTopOffendersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Identifier.Set {
			e.FieldStart("identifier")
			s.Identifier.Encode(e)
		}
	}
	{
		if s.IdentifierType.Set {
			e.FieldStart("identifier_type")
			s.IdentifierType.Encode(e)
		}
	}
	{
		if s.BlockedRequests.Set {
			e.FieldStart("blocked_requests")
			s.BlockedRequests.Encode(e)
		}
	}
	{
		if s.LastBlockedAt.Set {
			e.FieldStart("last_blocked_at")
			s.LastBlockedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BlockDurationSeconds.Set {
			e.FieldStart("block_duration_seconds")
			s.BlockDurationSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitStatsTopOffendersItem = [5]string{
	0: "identifier",
	1: "identifier_type",
	2: "blocked_requests",
	3: "last_blocked_at",
	4: "block_duration_seconds",
}

// Decode decodes RateLimitStatsTopOffendersItem from json.
func (s *RateLimitStatsTopOffendersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsTopOffendersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identifier":
			if err := func() error {
				s.Identifier.Reset()
				if err := s.Identifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "identifier_type":
			if err := func() error {
				s.IdentifierType.Reset()
				if err := s.IdentifierType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier_type\"")
			}
		case "blocked_requests":
			if err := func() error {
				s.BlockedRequests.Reset()
				if err := s.BlockedRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_requests\"")
			}
		case "last_blocked_at":
			if err := func() error {
				s.LastBlockedAt.Reset()
				if err := s.LastBlockedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_blocked_at\"")
			}
		case "block_duration_seconds":
			if err := func() error {
				s.BlockDurationSeconds.Reset()
				if err := s.BlockDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_duration_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitStatsTopOffendersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitStatsTopOffendersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsTopOffendersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimitStatsTopOffendersItemIdentifierType as json.
func (s RateLimitStatsTopOffendersItemIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RateLimitStatsTopOffendersItemIdentifierType from json.
func (s *RateLimitStatsTopOffendersItemIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitStatsTopOffendersItemIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RateLimitStatsTopOffendersItemIdentifierType(v) {
	case RateLimitStatsTopOffendersItemIdentifierTypeIP:
		*s = RateLimitStatsTopOffendersItemIdentifierTypeIP
	case RateLimitStatsTopOffendersItemIdentifierTypeUserID:
		*s = RateLimitStatsTopOffendersItemIdentifierTypeUserID
	case RateLimitStatsTopOffendersItemIdentifierTypeAPIKey:
		*s = RateLimitStatsTopOffendersItemIdentifierTypeAPIKey
	default:
		*s = RateLimitStatsTopOffendersItemIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RateLimitStatsTopOffendersItemIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitStatsTopOffendersItemIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateQuotaRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateQuotaRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		if s.Quotas.Set {
			e.FieldStart("quotas")
			s.Quotas.Encode(e)
		}
	}
	{
		if s.CustomLimits.Set {
			e.FieldStart("custom_limits")
			s.CustomLimits.Encode(e)
		}
	}
	{
		if s.ResetUsage.Set {
			e.FieldStart("reset_usage")
			s.ResetUsage.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateQuotaRequest = [4]string{
	0: "tier",
	1: "quotas",
	2: "custom_limits",
	3: "reset_usage",
}

// Decode decodes UpdateQuotaRequest from json.
func (s *UpdateQuotaRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuotaRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "quotas":
			if err := func() error {
				s.Quotas.Reset()
				if err := s.Quotas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotas\"")
			}
		case "custom_limits":
			if err := func() error {
				s.CustomLimits.Reset()
				if err := s.CustomLimits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_limits\"")
			}
		case "reset_usage":
			if err := func() error {
				s.ResetUsage.Reset()
				if err := s.ResetUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset_usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuotaRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateQuotaRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuotaRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateQuotaRequestCustomLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateQuotaRequestCustomLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UpdateQuotaRequestCustomLimits from json.
func (s *UpdateQuotaRequestCustomLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuotaRequestCustomLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuotaRequestCustomLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateQuotaRequestCustomLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuotaRequestCustomLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateQuotaRequestQuotas) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateQuotaRequestQuotas) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsPerMinute.Set {
			e.FieldStart("requests_per_minute")
			s.RequestsPerMinute.Encode(e)
		}
	}
	{
		if s.RequestsPerHour.Set {
			e.FieldStart("requests_per_hour")
			s.RequestsPerHour.Encode(e)
		}
	}
	{
		if s.RequestsPerDay.Set {
			e.FieldStart("requests_per_day")
			s.RequestsPerDay.Encode(e)
		}
	}
	{
		if s.ConcurrentConnections.Set {
			e.FieldStart("concurrent_connections")
			s.ConcurrentConnections.Encode(e)
		}
	}
	{
		if s.BandwidthMBPerHour.Set {
			e.FieldStart("bandwidth_mb_per_hour")
			s.BandwidthMBPerHour.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateQuotaRequestQuotas = [5]string{
	0: "requests_per_minute",
	1: "requests_per_hour",
	2: "requests_per_day",
	3: "concurrent_connections",
	4: "bandwidth_mb_per_hour",
}

// Decode decodes UpdateQuotaRequestQuotas from json.
func (s *UpdateQuotaRequestQuotas) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuotaRequestQuotas to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_per_minute":
			if err := func() error {
				s.RequestsPerMinute.Reset()
				if err := s.RequestsPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_minute\"")
			}
		case "requests_per_hour":
			if err := func() error {
				s.RequestsPerHour.Reset()
				if err := s.RequestsPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_hour\"")
			}
		case "requests_per_day":
			if err := func() error {
				s.RequestsPerDay.Reset()
				if err := s.RequestsPerDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_day\"")
			}
		case "concurrent_connections":
			if err := func() error {
				s.ConcurrentConnections.Reset()
				if err := s.ConcurrentConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrent_connections\"")
			}
		case "bandwidth_mb_per_hour":
			if err := func() error {
				s.BandwidthMBPerHour.Reset()
				if err := s.BandwidthMBPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_mb_per_hour\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuotaRequestQuotas")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateQuotaRequestQuotas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuotaRequestQuotas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateQuotaRequestTier as json.
func (s UpdateQuotaRequestTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateQuotaRequestTier from json.
func (s *UpdateQuotaRequestTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuotaRequestTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateQuotaRequestTier(v) {
	case UpdateQuotaRequestTierFree:
		*s = UpdateQuotaRequestTierFree
	case UpdateQuotaRequestTierBronze:
		*s = UpdateQuotaRequestTierBronze
	case UpdateQuotaRequestTierSilver:
		*s = UpdateQuotaRequestTierSilver
	case UpdateQuotaRequestTierGold:
		*s = UpdateQuotaRequestTierGold
	case UpdateQuotaRequestTierPlatinum:
		*s = UpdateQuotaRequestTierPlatinum
	case UpdateQuotaRequestTierVip:
		*s = UpdateQuotaRequestTierVip
	default:
		*s = UpdateQuotaRequestTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateQuotaRequestTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuotaRequestTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitBadRequest as json.
func (s *UpdateRateLimitBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRateLimitBadRequest from json.
func (s *UpdateRateLimitBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRateLimitBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitNotFound as json.
func (s *UpdateRateLimitNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRateLimitNotFound from json.
func (s *UpdateRateLimitNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRateLimitNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRateLimitRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRateLimitRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Algorithm.Set {
			e.FieldStart("algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Enforcement.Set {
			e.FieldStart("enforcement")
			s.Enforcement.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRateLimitRequest = [7]string{
	0: "description",
	1: "algorithm",
	2: "status",
	3: "limits",
	4: "scope",
	5: "enforcement",
	6: "priority",
}

// Decode decodes UpdateRateLimitRequest from json.
func (s *UpdateRateLimitRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "enforcement":
			if err := func() error {
				s.Enforcement.Reset()
				if err := s.Enforcement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforcement\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRateLimitRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestAlgorithm as json.
func (s UpdateRateLimitRequestAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRateLimitRequestAlgorithm from json.
func (s *UpdateRateLimitRequestAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRateLimitRequestAlgorithm(v) {
	case UpdateRateLimitRequestAlgorithmTokenBucket:
		*s = UpdateRateLimitRequestAlgorithmTokenBucket
	case UpdateRateLimitRequestAlgorithmSlidingWindow:
		*s = UpdateRateLimitRequestAlgorithmSlidingWindow
	case UpdateRateLimitRequestAlgorithmLeakyBucket:
		*s = UpdateRateLimitRequestAlgorithmLeakyBucket
	case UpdateRateLimitRequestAlgorithmFixedWindow:
		*s = UpdateRateLimitRequestAlgorithmFixedWindow
	default:
		*s = UpdateRateLimitRequestAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRateLimitRequestAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRateLimitRequestEnforcement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRateLimitRequestEnforcement) encodeFields(e *jx.Encoder) {
	{
		if s.BlockDurationSeconds.Set {
			e.FieldStart("block_duration_seconds")
			s.BlockDurationSeconds.Encode(e)
		}
	}
	{
		if s.GradualBackoff.Set {
			e.FieldStart("gradual_backoff")
			s.GradualBackoff.Encode(e)
		}
	}
	{
		if s.NotifyOnViolation.Set {
			e.FieldStart("notify_on_violation")
			s.NotifyOnViolation.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRateLimitRequestEnforcement = [3]string{
	0: "block_duration_seconds",
	1: "gradual_backoff",
	2: "notify_on_violation",
}

// Decode decodes UpdateRateLimitRequestEnforcement from json.
func (s *UpdateRateLimitRequestEnforcement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestEnforcement to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block_duration_seconds":
			if err := func() error {
				s.BlockDurationSeconds.Reset()
				if err := s.BlockDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_duration_seconds\"")
			}
		case "gradual_backoff":
			if err := func() error {
				s.GradualBackoff.Reset()
				if err := s.GradualBackoff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gradual_backoff\"")
			}
		case "notify_on_violation":
			if err := func() error {
				s.NotifyOnViolation.Reset()
				if err := s.NotifyOnViolation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notify_on_violation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRateLimitRequestEnforcement")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitRequestEnforcement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestEnforcement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRateLimitRequestLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRateLimitRequestLimits) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsPerSecond.Set {
			e.FieldStart("requests_per_second")
			s.RequestsPerSecond.Encode(e)
		}
	}
	{
		if s.RequestsPerMinute.Set {
			e.FieldStart("requests_per_minute")
			s.RequestsPerMinute.Encode(e)
		}
	}
	{
		if s.RequestsPerHour.Set {
			e.FieldStart("requests_per_hour")
			s.RequestsPerHour.Encode(e)
		}
	}
	{
		if s.BurstLimit.Set {
			e.FieldStart("burst_limit")
			s.BurstLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRateLimitRequestLimits = [4]string{
	0: "requests_per_second",
	1: "requests_per_minute",
	2: "requests_per_hour",
	3: "burst_limit",
}

// Decode decodes UpdateRateLimitRequestLimits from json.
func (s *UpdateRateLimitRequestLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestLimits to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_per_second":
			if err := func() error {
				s.RequestsPerSecond.Reset()
				if err := s.RequestsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_second\"")
			}
		case "requests_per_minute":
			if err := func() error {
				s.RequestsPerMinute.Reset()
				if err := s.RequestsPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_minute\"")
			}
		case "requests_per_hour":
			if err := func() error {
				s.RequestsPerHour.Reset()
				if err := s.RequestsPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_hour\"")
			}
		case "burst_limit":
			if err := func() error {
				s.BurstLimit.Reset()
				if err := s.BurstLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"burst_limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRateLimitRequestLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitRequestLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRateLimitRequestScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRateLimitRequestScope) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRateLimitRequestScope = [4]string{
	0: "user_id",
	1: "ip_address",
	2: "api_key",
	3: "region",
}

// Decode decodes UpdateRateLimitRequestScope from json.
func (s *UpdateRateLimitRequestScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestScope to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRateLimitRequestScope")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRateLimitRequestScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestScopeRegion as json.
func (s UpdateRateLimitRequestScopeRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRateLimitRequestScopeRegion from json.
func (s *UpdateRateLimitRequestScopeRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestScopeRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRateLimitRequestScopeRegion(v) {
	case UpdateRateLimitRequestScopeRegionGlobal:
		*s = UpdateRateLimitRequestScopeRegionGlobal
	case UpdateRateLimitRequestScopeRegionRegional:
		*s = UpdateRateLimitRequestScopeRegionRegional
	case UpdateRateLimitRequestScopeRegionLocal:
		*s = UpdateRateLimitRequestScopeRegionLocal
	default:
		*s = UpdateRateLimitRequestScopeRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRateLimitRequestScopeRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestScopeRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRateLimitRequestStatus as json.
func (s UpdateRateLimitRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRateLimitRequestStatus from json.
func (s *UpdateRateLimitRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRateLimitRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRateLimitRequestStatus(v) {
	case UpdateRateLimitRequestStatusActive:
		*s = UpdateRateLimitRequestStatusActive
	case UpdateRateLimitRequestStatusInactive:
		*s = UpdateRateLimitRequestStatusInactive
	case UpdateRateLimitRequestStatusPaused:
		*s = UpdateRateLimitRequestStatusPaused
	default:
		*s = UpdateRateLimitRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRateLimitRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRateLimitRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserQuotaBadRequest as json.
func (s *UpdateUserQuotaBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserQuotaBadRequest from json.
func (s *UpdateUserQuotaBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserQuotaBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserQuotaBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserQuotaBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserQuotaBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserQuotaNotFound as json.
func (s *UpdateUserQuotaNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserQuotaNotFound from json.
func (s *UpdateUserQuotaNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserQuotaNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserQuotaNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserQuotaNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserQuotaNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserQuota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserQuota) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		json.EncodeUUID(e, s.UserID)
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("quotas")
		s.Quotas.Encode(e)
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
	{
		e.FieldStart("reset_schedule")
		s.ResetSchedule.Encode(e)
	}
	{
		if s.CustomLimits.Set {
			e.FieldStart("custom_limits")
			s.CustomLimits.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserQuota = [7]string{
	0: "user_id",
	1: "tier",
	2: "created_at",
	3: "quotas",
	4: "usage",
	5: "reset_schedule",
	6: "custom_limits",
}

// Decode decodes UserQuota from json.
func (s *UserQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuota to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "quotas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Quotas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotas\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "reset_schedule":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResetSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset_schedule\"")
			}
		case "custom_limits":
			if err := func() error {
				s.CustomLimits.Reset()
				if err := s.CustomLimits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_limits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserQuota")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserQuota) {
					name = jsonFieldsNameOfUserQuota[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserQuotaCustomLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserQuotaCustomLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UserQuotaCustomLimits from json.
func (s *UserQuotaCustomLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuotaCustomLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserQuotaCustomLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserQuotaCustomLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuotaCustomLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserQuotaQuotas) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserQuotaQuotas) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsPerMinute.Set {
			e.FieldStart("requests_per_minute")
			s.RequestsPerMinute.Encode(e)
		}
	}
	{
		if s.RequestsPerHour.Set {
			e.FieldStart("requests_per_hour")
			s.RequestsPerHour.Encode(e)
		}
	}
	{
		if s.RequestsPerDay.Set {
			e.FieldStart("requests_per_day")
			s.RequestsPerDay.Encode(e)
		}
	}
	{
		if s.ConcurrentConnections.Set {
			e.FieldStart("concurrent_connections")
			s.ConcurrentConnections.Encode(e)
		}
	}
	{
		if s.BandwidthMBPerHour.Set {
			e.FieldStart("bandwidth_mb_per_hour")
			s.BandwidthMBPerHour.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserQuotaQuotas = [5]string{
	0: "requests_per_minute",
	1: "requests_per_hour",
	2: "requests_per_day",
	3: "concurrent_connections",
	4: "bandwidth_mb_per_hour",
}

// Decode decodes UserQuotaQuotas from json.
func (s *UserQuotaQuotas) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuotaQuotas to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_per_minute":
			if err := func() error {
				s.RequestsPerMinute.Reset()
				if err := s.RequestsPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_minute\"")
			}
		case "requests_per_hour":
			if err := func() error {
				s.RequestsPerHour.Reset()
				if err := s.RequestsPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_hour\"")
			}
		case "requests_per_day":
			if err := func() error {
				s.RequestsPerDay.Reset()
				if err := s.RequestsPerDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_per_day\"")
			}
		case "concurrent_connections":
			if err := func() error {
				s.ConcurrentConnections.Reset()
				if err := s.ConcurrentConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrent_connections\"")
			}
		case "bandwidth_mb_per_hour":
			if err := func() error {
				s.BandwidthMBPerHour.Reset()
				if err := s.BandwidthMBPerHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_mb_per_hour\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserQuotaQuotas")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserQuotaQuotas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuotaQuotas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserQuotaResetSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserQuotaResetSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.MinuteReset.Set {
			e.FieldStart("minute_reset")
			s.MinuteReset.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.HourReset.Set {
			e.FieldStart("hour_reset")
			s.HourReset.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DayReset.Set {
			e.FieldStart("day_reset")
			s.DayReset.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserQuotaResetSchedule = [3]string{
	0: "minute_reset",
	1: "hour_reset",
	2: "day_reset",
}

// Decode decodes UserQuotaResetSchedule from json.
func (s *UserQuotaResetSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuotaResetSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minute_reset":
			if err := func() error {
				s.MinuteReset.Reset()
				if err := s.MinuteReset.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minute_reset\"")
			}
		case "hour_reset":
			if err := func() error {
				s.HourReset.Reset()
				if err := s.HourReset.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hour_reset\"")
			}
		case "day_reset":
			if err := func() error {
				s.DayReset.Reset()
				if err := s.DayReset.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"day_reset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserQuotaResetSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserQuotaResetSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuotaResetSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserQuotaTier as json.
func (s UserQuotaTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserQuotaTier from json.
func (s *UserQuotaTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuotaTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserQuotaTier(v) {
	case UserQuotaTierFree:
		*s = UserQuotaTierFree
	case UserQuotaTierBronze:
		*s = UserQuotaTierBronze
	case UserQuotaTierSilver:
		*s = UserQuotaTierSilver
	case UserQuotaTierGold:
		*s = UserQuotaTierGold
	case UserQuotaTierPlatinum:
		*s = UserQuotaTierPlatinum
	case UserQuotaTierVip:
		*s = UserQuotaTierVip
	default:
		*s = UserQuotaTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserQuotaTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuotaTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserQuotaUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserQuotaUsage) encodeFields(e *jx.Encoder) {
	{
		if s.RequestsThisMinute.Set {
			e.FieldStart("requests_this_minute")
			s.RequestsThisMinute.Encode(e)
		}
	}
	{
		if s.RequestsThisHour.Set {
			e.FieldStart("requests_this_hour")
			s.RequestsThisHour.Encode(e)
		}
	}
	{
		if s.RequestsThisDay.Set {
			e.FieldStart("requests_this_day")
			s.RequestsThisDay.Encode(e)
		}
	}
	{
		if s.ConcurrentConnections.Set {
			e.FieldStart("concurrent_connections")
			s.ConcurrentConnections.Encode(e)
		}
	}
	{
		if s.BandwidthUsedMB.Set {
			e.FieldStart("bandwidth_used_mb")
			s.BandwidthUsedMB.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserQuotaUsage = [5]string{
	0: "requests_this_minute",
	1: "requests_this_hour",
	2: "requests_this_day",
	3: "concurrent_connections",
	4: "bandwidth_used_mb",
}

// Decode decodes UserQuotaUsage from json.
func (s *UserQuotaUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserQuotaUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests_this_minute":
			if err := func() error {
				s.RequestsThisMinute.Reset()
				if err := s.RequestsThisMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_this_minute\"")
			}
		case "requests_this_hour":
			if err := func() error {
				s.RequestsThisHour.Reset()
				if err := s.RequestsThisHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_this_hour\"")
			}
		case "requests_this_day":
			if err := func() error {
				s.RequestsThisDay.Reset()
				if err := s.RequestsThisDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests_this_day\"")
			}
		case "concurrent_connections":
			if err := func() error {
				s.ConcurrentConnections.Reset()
				if err := s.ConcurrentConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrent_connections\"")
			}
		case "bandwidth_used_mb":
			if err := func() error {
				s.BandwidthUsedMB.Reset()
				if err := s.BandwidthUsedMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_used_mb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserQuotaUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserQuotaUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserQuotaUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
