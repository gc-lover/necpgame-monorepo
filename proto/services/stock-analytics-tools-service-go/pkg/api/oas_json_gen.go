// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AnalystRatings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalystRatings) encodeFields(e *jx.Encoder) {
	{
		if s.ConsensusRating.Set {
			e.FieldStart("consensus_rating")
			s.ConsensusRating.Encode(e)
		}
	}
	{
		if s.AveragePriceTarget.Set {
			e.FieldStart("average_price_target")
			s.AveragePriceTarget.Encode(e)
		}
	}
	{
		if s.NumberOfAnalysts.Set {
			e.FieldStart("number_of_analysts")
			s.NumberOfAnalysts.Encode(e)
		}
	}
	{
		if s.RatingDistribution.Set {
			e.FieldStart("rating_distribution")
			s.RatingDistribution.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalystRatings = [4]string{
	0: "consensus_rating",
	1: "average_price_target",
	2: "number_of_analysts",
	3: "rating_distribution",
}

// Decode decodes AnalystRatings from json.
func (s *AnalystRatings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalystRatings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "consensus_rating":
			if err := func() error {
				s.ConsensusRating.Reset()
				if err := s.ConsensusRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consensus_rating\"")
			}
		case "average_price_target":
			if err := func() error {
				s.AveragePriceTarget.Reset()
				if err := s.AveragePriceTarget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_price_target\"")
			}
		case "number_of_analysts":
			if err := func() error {
				s.NumberOfAnalysts.Reset()
				if err := s.NumberOfAnalysts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number_of_analysts\"")
			}
		case "rating_distribution":
			if err := func() error {
				s.RatingDistribution.Reset()
				if err := s.RatingDistribution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating_distribution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalystRatings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalystRatings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalystRatings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalystRatingsConsensusRating as json.
func (s AnalystRatingsConsensusRating) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnalystRatingsConsensusRating from json.
func (s *AnalystRatingsConsensusRating) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalystRatingsConsensusRating to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnalystRatingsConsensusRating(v) {
	case AnalystRatingsConsensusRatingStrongBuy:
		*s = AnalystRatingsConsensusRatingStrongBuy
	case AnalystRatingsConsensusRatingBuy:
		*s = AnalystRatingsConsensusRatingBuy
	case AnalystRatingsConsensusRatingHold:
		*s = AnalystRatingsConsensusRatingHold
	case AnalystRatingsConsensusRatingSell:
		*s = AnalystRatingsConsensusRatingSell
	case AnalystRatingsConsensusRatingStrongSell:
		*s = AnalystRatingsConsensusRatingStrongSell
	default:
		*s = AnalystRatingsConsensusRating(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnalystRatingsConsensusRating) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalystRatingsConsensusRating) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalystRatingsRatingDistribution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalystRatingsRatingDistribution) encodeFields(e *jx.Encoder) {
	{
		if s.StrongBuy.Set {
			e.FieldStart("strong_buy")
			s.StrongBuy.Encode(e)
		}
	}
	{
		if s.Buy.Set {
			e.FieldStart("buy")
			s.Buy.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.Sell.Set {
			e.FieldStart("sell")
			s.Sell.Encode(e)
		}
	}
	{
		if s.StrongSell.Set {
			e.FieldStart("strong_sell")
			s.StrongSell.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalystRatingsRatingDistribution = [5]string{
	0: "strong_buy",
	1: "buy",
	2: "hold",
	3: "sell",
	4: "strong_sell",
}

// Decode decodes AnalystRatingsRatingDistribution from json.
func (s *AnalystRatingsRatingDistribution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalystRatingsRatingDistribution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strong_buy":
			if err := func() error {
				s.StrongBuy.Reset()
				if err := s.StrongBuy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strong_buy\"")
			}
		case "buy":
			if err := func() error {
				s.Buy.Reset()
				if err := s.Buy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buy\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "sell":
			if err := func() error {
				s.Sell.Reset()
				if err := s.Sell.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sell\"")
			}
		case "strong_sell":
			if err := func() error {
				s.StrongSell.Reset()
				if err := s.StrongSell.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strong_sell\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalystRatingsRatingDistribution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalystRatingsRatingDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalystRatingsRatingDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetAllocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetAllocation) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.ExpectedReturn.Set {
			e.FieldStart("expected_return")
			s.ExpectedReturn.Encode(e)
		}
	}
	{
		if s.Volatility.Set {
			e.FieldStart("volatility")
			s.Volatility.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetAllocation = [4]string{
	0: "symbol",
	1: "weight",
	2: "expected_return",
	3: "volatility",
}

// Decode decodes AssetAllocation from json.
func (s *AssetAllocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetAllocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "expected_return":
			if err := func() error {
				s.ExpectedReturn.Reset()
				if err := s.ExpectedReturn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_return\"")
			}
		case "volatility":
			if err := func() error {
				s.Volatility.Reset()
				if err := s.Volatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetAllocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BacktestingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BacktestingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("strategy")
		s.Strategy.Encode(e)
	}
	{
		e.FieldStart("symbols")
		e.ArrStart()
		for _, elem := range s.Symbols {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("start_date")
		json.EncodeDate(e, s.StartDate)
	}
	{
		e.FieldStart("end_date")
		json.EncodeDate(e, s.EndDate)
	}
	{
		if s.InitialCapital.Set {
			e.FieldStart("initial_capital")
			s.InitialCapital.Encode(e)
		}
	}
	{
		if s.CommissionPerTrade.Set {
			e.FieldStart("commission_per_trade")
			s.CommissionPerTrade.Encode(e)
		}
	}
}

var jsonFieldsNameOfBacktestingRequest = [6]string{
	0: "strategy",
	1: "symbols",
	2: "start_date",
	3: "end_date",
	4: "initial_capital",
	5: "commission_per_trade",
}

// Decode decodes BacktestingRequest from json.
func (s *BacktestingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BacktestingRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strategy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Strategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "symbols":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Symbols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Symbols = append(s.Symbols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols\"")
			}
		case "start_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.EndDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "initial_capital":
			if err := func() error {
				s.InitialCapital.Reset()
				if err := s.InitialCapital.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_capital\"")
			}
		case "commission_per_trade":
			if err := func() error {
				s.CommissionPerTrade.Reset()
				if err := s.CommissionPerTrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission_per_trade\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BacktestingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBacktestingRequest) {
					name = jsonFieldsNameOfBacktestingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BacktestingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BacktestingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BacktestingResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BacktestingResponse) encodeFields(e *jx.Encoder) {
	{
		if s.StrategyName.Set {
			e.FieldStart("strategy_name")
			s.StrategyName.Encode(e)
		}
	}
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		if s.PerformanceMetrics.Set {
			e.FieldStart("performance_metrics")
			s.PerformanceMetrics.Encode(e)
		}
	}
	{
		if s.Trades != nil {
			e.FieldStart("trades")
			e.ArrStart()
			for _, elem := range s.Trades {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EquityCurve != nil {
			e.FieldStart("equity_curve")
			e.ArrStart()
			for _, elem := range s.EquityCurve {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBacktestingResponse = [5]string{
	0: "strategy_name",
	1: "period",
	2: "performance_metrics",
	3: "trades",
	4: "equity_curve",
}

// Decode decodes BacktestingResponse from json.
func (s *BacktestingResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BacktestingResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strategy_name":
			if err := func() error {
				s.StrategyName.Reset()
				if err := s.StrategyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy_name\"")
			}
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "performance_metrics":
			if err := func() error {
				s.PerformanceMetrics.Reset()
				if err := s.PerformanceMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_metrics\"")
			}
		case "trades":
			if err := func() error {
				s.Trades = make([]TradeRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TradeRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trades = append(s.Trades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trades\"")
			}
		case "equity_curve":
			if err := func() error {
				s.EquityCurve = make([]EquityPoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EquityPoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EquityCurve = append(s.EquityCurve, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"equity_curve\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BacktestingResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BacktestingResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BacktestingResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BacktestingResponsePeriod) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BacktestingResponsePeriod) encodeFields(e *jx.Encoder) {
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfBacktestingResponsePeriod = [2]string{
	0: "start_date",
	1: "end_date",
}

// Decode decodes BacktestingResponsePeriod from json.
func (s *BacktestingResponsePeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BacktestingResponsePeriod to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BacktestingResponsePeriod")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BacktestingResponsePeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BacktestingResponsePeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [3]string{
	0: "error",
	1: "code",
	2: "details",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBadRequestDetails = [0]string{}

// Decode decodes BadRequestDetails from json.
func (s *BadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompanyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompanyInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.Industry.Set {
			e.FieldStart("industry")
			s.Industry.Encode(e)
		}
	}
	{
		if s.MarketCap.Set {
			e.FieldStart("market_cap")
			s.MarketCap.Encode(e)
		}
	}
	{
		if s.Employees.Set {
			e.FieldStart("employees")
			s.Employees.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompanyInfo = [5]string{
	0: "name",
	1: "sector",
	2: "industry",
	3: "market_cap",
	4: "employees",
}

// Decode decodes CompanyInfo from json.
func (s *CompanyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompanyInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "industry":
			if err := func() error {
				s.Industry.Reset()
				if err := s.Industry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"industry\"")
			}
		case "market_cap":
			if err := func() error {
				s.MarketCap.Reset()
				if err := s.MarketCap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"market_cap\"")
			}
		case "employees":
			if err := func() error {
				s.Employees.Reset()
				if err := s.Employees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"employees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompanyInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompanyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompanyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CorrelationAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CorrelationAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.Symbols != nil {
			e.FieldStart("symbols")
			e.ArrStart()
			for _, elem := range s.Symbols {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		if s.CorrelationMatrix != nil {
			e.FieldStart("correlation_matrix")
			e.ArrStart()
			for _, elem := range s.CorrelationMatrix {
				e.ArrStart()
				for _, elem := range elem {
					e.Float32(elem)
				}
				e.ArrEnd()
			}
			e.ArrEnd()
		}
	}
	{
		if s.AverageCorrelations.Set {
			e.FieldStart("average_correlations")
			s.AverageCorrelations.Encode(e)
		}
	}
}

var jsonFieldsNameOfCorrelationAnalysis = [4]string{
	0: "symbols",
	1: "period",
	2: "correlation_matrix",
	3: "average_correlations",
}

// Decode decodes CorrelationAnalysis from json.
func (s *CorrelationAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CorrelationAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbols":
			if err := func() error {
				s.Symbols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Symbols = append(s.Symbols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols\"")
			}
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "correlation_matrix":
			if err := func() error {
				s.CorrelationMatrix = make([][]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []float32
					elem = make([]float32, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem float32
						v, err := d.Float32()
						elemElem = float32(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.CorrelationMatrix = append(s.CorrelationMatrix, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_matrix\"")
			}
		case "average_correlations":
			if err := func() error {
				s.AverageCorrelations.Reset()
				if err := s.AverageCorrelations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_correlations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CorrelationAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CorrelationAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CorrelationAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CorrelationAnalysisAverageCorrelations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CorrelationAnalysisAverageCorrelations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes CorrelationAnalysisAverageCorrelations from json.
func (s *CorrelationAnalysisAverageCorrelations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CorrelationAnalysisAverageCorrelations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CorrelationAnalysisAverageCorrelations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CorrelationAnalysisAverageCorrelations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CorrelationAnalysisAverageCorrelations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquityPoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquityPoint) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Equity.Set {
			e.FieldStart("equity")
			s.Equity.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquityPoint = [2]string{
	0: "date",
	1: "equity",
}

// Decode decodes EquityPoint from json.
func (s *EquityPoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquityPoint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "equity":
			if err := func() error {
				s.Equity.Reset()
				if err := s.Equity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"equity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquityPoint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquityPoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquityPoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FinancialRatios) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FinancialRatios) encodeFields(e *jx.Encoder) {
	{
		if s.PeRatio.Set {
			e.FieldStart("pe_ratio")
			s.PeRatio.Encode(e)
		}
	}
	{
		if s.PbRatio.Set {
			e.FieldStart("pb_ratio")
			s.PbRatio.Encode(e)
		}
	}
	{
		if s.Roe.Set {
			e.FieldStart("roe")
			s.Roe.Encode(e)
		}
	}
	{
		if s.Roa.Set {
			e.FieldStart("roa")
			s.Roa.Encode(e)
		}
	}
	{
		if s.DebtToEquity.Set {
			e.FieldStart("debt_to_equity")
			s.DebtToEquity.Encode(e)
		}
	}
	{
		if s.CurrentRatio.Set {
			e.FieldStart("current_ratio")
			s.CurrentRatio.Encode(e)
		}
	}
}

var jsonFieldsNameOfFinancialRatios = [6]string{
	0: "pe_ratio",
	1: "pb_ratio",
	2: "roe",
	3: "roa",
	4: "debt_to_equity",
	5: "current_ratio",
}

// Decode decodes FinancialRatios from json.
func (s *FinancialRatios) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FinancialRatios to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pe_ratio":
			if err := func() error {
				s.PeRatio.Reset()
				if err := s.PeRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pe_ratio\"")
			}
		case "pb_ratio":
			if err := func() error {
				s.PbRatio.Reset()
				if err := s.PbRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pb_ratio\"")
			}
		case "roe":
			if err := func() error {
				s.Roe.Reset()
				if err := s.Roe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roe\"")
			}
		case "roa":
			if err := func() error {
				s.Roa.Reset()
				if err := s.Roa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roa\"")
			}
		case "debt_to_equity":
			if err := func() error {
				s.DebtToEquity.Reset()
				if err := s.DebtToEquity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debt_to_equity\"")
			}
		case "current_ratio":
			if err := func() error {
				s.CurrentRatio.Reset()
				if err := s.CurrentRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_ratio\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FinancialRatios")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FinancialRatios) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FinancialRatios) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FundamentalAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FundamentalAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.CompanyInfo.Set {
			e.FieldStart("company_info")
			s.CompanyInfo.Encode(e)
		}
	}
	{
		if s.FinancialRatios.Set {
			e.FieldStart("financial_ratios")
			s.FinancialRatios.Encode(e)
		}
	}
	{
		if s.ValuationMetrics.Set {
			e.FieldStart("valuation_metrics")
			s.ValuationMetrics.Encode(e)
		}
	}
	{
		if s.AnalystRatings.Set {
			e.FieldStart("analyst_ratings")
			s.AnalystRatings.Encode(e)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfFundamentalAnalysis = [6]string{
	0: "symbol",
	1: "company_info",
	2: "financial_ratios",
	3: "valuation_metrics",
	4: "analyst_ratings",
	5: "last_updated",
}

// Decode decodes FundamentalAnalysis from json.
func (s *FundamentalAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FundamentalAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "company_info":
			if err := func() error {
				s.CompanyInfo.Reset()
				if err := s.CompanyInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company_info\"")
			}
		case "financial_ratios":
			if err := func() error {
				s.FinancialRatios.Reset()
				if err := s.FinancialRatios.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"financial_ratios\"")
			}
		case "valuation_metrics":
			if err := func() error {
				s.ValuationMetrics.Reset()
				if err := s.ValuationMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valuation_metrics\"")
			}
		case "analyst_ratings":
			if err := func() error {
				s.AnalystRatings.Reset()
				if err := s.AnalystRatings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyst_ratings\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FundamentalAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FundamentalAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FundamentalAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GarchParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GarchParameters) encodeFields(e *jx.Encoder) {
	{
		if s.Omega.Set {
			e.FieldStart("omega")
			s.Omega.Encode(e)
		}
	}
	{
		if s.Alpha.Set {
			e.FieldStart("alpha")
			s.Alpha.Encode(e)
		}
	}
	{
		if s.Beta.Set {
			e.FieldStart("beta")
			s.Beta.Encode(e)
		}
	}
	{
		if s.ModelFit.Set {
			e.FieldStart("model_fit")
			s.ModelFit.Encode(e)
		}
	}
}

var jsonFieldsNameOfGarchParameters = [4]string{
	0: "omega",
	1: "alpha",
	2: "beta",
	3: "model_fit",
}

// Decode decodes GarchParameters from json.
func (s *GarchParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GarchParameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "omega":
			if err := func() error {
				s.Omega.Reset()
				if err := s.Omega.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"omega\"")
			}
		case "alpha":
			if err := func() error {
				s.Alpha.Reset()
				if err := s.Alpha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpha\"")
			}
		case "beta":
			if err := func() error {
				s.Beta.Reset()
				if err := s.Beta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beta\"")
			}
		case "model_fit":
			if err := func() error {
				s.ModelFit.Reset()
				if err := s.ModelFit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_fit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GarchParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GarchParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GarchParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfHealthCheckOK = [3]string{
	0: "status",
	1: "service",
	2: "timestamp",
}

// Decode decodes HealthCheckOK from json.
func (s *HealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MomentumIndicators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MomentumIndicators) encodeFields(e *jx.Encoder) {
	{
		if s.Rsi.Set {
			e.FieldStart("rsi")
			s.Rsi.Encode(e)
		}
	}
	{
		if s.StochasticK.Set {
			e.FieldStart("stochastic_k")
			s.StochasticK.Encode(e)
		}
	}
	{
		if s.StochasticD.Set {
			e.FieldStart("stochastic_d")
			s.StochasticD.Encode(e)
		}
	}
	{
		if s.WilliamsR.Set {
			e.FieldStart("williams_r")
			s.WilliamsR.Encode(e)
		}
	}
	{
		if s.MacdHistogram.Set {
			e.FieldStart("macd_histogram")
			s.MacdHistogram.Encode(e)
		}
	}
}

var jsonFieldsNameOfMomentumIndicators = [5]string{
	0: "rsi",
	1: "stochastic_k",
	2: "stochastic_d",
	3: "williams_r",
	4: "macd_histogram",
}

// Decode decodes MomentumIndicators from json.
func (s *MomentumIndicators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MomentumIndicators to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rsi":
			if err := func() error {
				s.Rsi.Reset()
				if err := s.Rsi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rsi\"")
			}
		case "stochastic_k":
			if err := func() error {
				s.StochasticK.Reset()
				if err := s.StochasticK.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stochastic_k\"")
			}
		case "stochastic_d":
			if err := func() error {
				s.StochasticD.Reset()
				if err := s.StochasticD.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stochastic_d\"")
			}
		case "williams_r":
			if err := func() error {
				s.WilliamsR.Reset()
				if err := s.WilliamsR.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"williams_r\"")
			}
		case "macd_histogram":
			if err := func() error {
				s.MacdHistogram.Reset()
				if err := s.MacdHistogram.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"macd_histogram\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MomentumIndicators")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MomentumIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MomentumIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [2]string{
	0: "error",
	1: "code",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalystRatings as json.
func (o OptAnalystRatings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnalystRatings from json.
func (o *OptAnalystRatings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnalystRatings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnalystRatings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnalystRatings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalystRatingsConsensusRating as json.
func (o OptAnalystRatingsConsensusRating) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnalystRatingsConsensusRating from json.
func (o *OptAnalystRatingsConsensusRating) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnalystRatingsConsensusRating to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnalystRatingsConsensusRating) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnalystRatingsConsensusRating) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalystRatingsRatingDistribution as json.
func (o OptAnalystRatingsRatingDistribution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnalystRatingsRatingDistribution from json.
func (o *OptAnalystRatingsRatingDistribution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnalystRatingsRatingDistribution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnalystRatingsRatingDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnalystRatingsRatingDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BacktestingResponsePeriod as json.
func (o OptBacktestingResponsePeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BacktestingResponsePeriod from json.
func (o *OptBacktestingResponsePeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBacktestingResponsePeriod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBacktestingResponsePeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBacktestingResponsePeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompanyInfo as json.
func (o OptCompanyInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CompanyInfo from json.
func (o *OptCompanyInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompanyInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompanyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompanyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CorrelationAnalysisAverageCorrelations as json.
func (o OptCorrelationAnalysisAverageCorrelations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CorrelationAnalysisAverageCorrelations from json.
func (o *OptCorrelationAnalysisAverageCorrelations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCorrelationAnalysisAverageCorrelations to nil")
	}
	o.Set = true
	o.Value = make(CorrelationAnalysisAverageCorrelations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCorrelationAnalysisAverageCorrelations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCorrelationAnalysisAverageCorrelations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FinancialRatios as json.
func (o OptFinancialRatios) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FinancialRatios from json.
func (o *OptFinancialRatios) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFinancialRatios to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFinancialRatios) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFinancialRatios) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GarchParameters as json.
func (o OptGarchParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GarchParameters from json.
func (o *OptGarchParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGarchParameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGarchParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGarchParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MomentumIndicators as json.
func (o OptMomentumIndicators) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MomentumIndicators from json.
func (o *OptMomentumIndicators) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMomentumIndicators to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMomentumIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMomentumIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformanceMetrics as json.
func (o OptPerformanceMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PerformanceMetrics from json.
func (o *OptPerformanceMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPerformanceMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortfolioConstraints as json.
func (o OptPortfolioConstraints) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PortfolioConstraints from json.
func (o *OptPortfolioConstraints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPortfolioConstraints to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPortfolioConstraints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPortfolioConstraints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortfolioOptimizationRequestRiskTolerance as json.
func (o OptPortfolioOptimizationRequestRiskTolerance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PortfolioOptimizationRequestRiskTolerance from json.
func (o *OptPortfolioOptimizationRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPortfolioOptimizationRequestRiskTolerance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPortfolioOptimizationRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPortfolioOptimizationRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PricePredictionConfidenceInterval as json.
func (o OptPricePredictionConfidenceInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PricePredictionConfidenceInterval from json.
func (o *OptPricePredictionConfidenceInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPricePredictionConfidenceInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPricePredictionConfidenceInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPricePredictionConfidenceInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskAssessmentRequestMarketConditions as json.
func (o OptRiskAssessmentRequestMarketConditions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RiskAssessmentRequestMarketConditions from json.
func (o *OptRiskAssessmentRequestMarketConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRiskAssessmentRequestMarketConditions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRiskAssessmentRequestMarketConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRiskAssessmentRequestMarketConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskAssessmentRequestTimeHorizon as json.
func (o OptRiskAssessmentRequestTimeHorizon) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RiskAssessmentRequestTimeHorizon from json.
func (o *OptRiskAssessmentRequestTimeHorizon) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRiskAssessmentRequestTimeHorizon to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRiskAssessmentRequestTimeHorizon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRiskAssessmentRequestTimeHorizon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskMetrics as json.
func (o OptRiskMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RiskMetrics from json.
func (o *OptRiskMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRiskMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRiskMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRiskMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupportResistance as json.
func (o OptSupportResistance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupportResistance from json.
func (o *OptSupportResistance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupportResistance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupportResistance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupportResistance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradeRecordSide as json.
func (o OptTradeRecordSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TradeRecordSide from json.
func (o *OptTradeRecordSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTradeRecordSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTradeRecordSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTradeRecordSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradingStrategyParameters as json.
func (o OptTradingStrategyParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TradingStrategyParameters from json.
func (o *OptTradingStrategyParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTradingStrategyParameters to nil")
	}
	o.Set = true
	o.Value = make(TradingStrategyParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTradingStrategyParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTradingStrategyParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradingStrategyType as json.
func (o OptTradingStrategyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TradingStrategyType from json.
func (o *OptTradingStrategyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTradingStrategyType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTradingStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTradingStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrendAnalysis as json.
func (o OptTrendAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TrendAnalysis from json.
func (o *OptTrendAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrendAnalysis to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrendAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrendAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrendAnalysisPrimaryTrend as json.
func (o OptTrendAnalysisPrimaryTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrendAnalysisPrimaryTrend from json.
func (o *OptTrendAnalysisPrimaryTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrendAnalysisPrimaryTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrendAnalysisPrimaryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrendAnalysisPrimaryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrendAnalysisSecondaryTrend as json.
func (o OptTrendAnalysisSecondaryTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrendAnalysisSecondaryTrend from json.
func (o *OptTrendAnalysisSecondaryTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrendAnalysisSecondaryTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrendAnalysisSecondaryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrendAnalysisSecondaryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValuationMetrics as json.
func (o OptValuationMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValuationMetrics from json.
func (o *OptValuationMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValuationMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValuationMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValuationMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValuationMetricsFairValueRange as json.
func (o OptValuationMetricsFairValueRange) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValuationMetricsFairValueRange from json.
func (o *OptValuationMetricsFairValueRange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValuationMetricsFairValueRange to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValuationMetricsFairValueRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValuationMetricsFairValueRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolatilityIndicators as json.
func (o OptVolatilityIndicators) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VolatilityIndicators from json.
func (o *OptVolatilityIndicators) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolatilityIndicators to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolatilityIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolatilityIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAnalysis as json.
func (o OptVolumeAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VolumeAnalysis from json.
func (o *OptVolumeAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolumeAnalysis to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolumeAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolumeAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAnalysisVolumePriceTrend as json.
func (o OptVolumeAnalysisVolumePriceTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VolumeAnalysisVolumePriceTrend from json.
func (o *OptVolumeAnalysisVolumePriceTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolumeAnalysisVolumePriceTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolumeAnalysisVolumePriceTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolumeAnalysisVolumePriceTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAnalysisVolumeTrend as json.
func (o OptVolumeAnalysisVolumeTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VolumeAnalysisVolumeTrend from json.
func (o *OptVolumeAnalysisVolumeTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolumeAnalysisVolumeTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolumeAnalysisVolumeTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolumeAnalysisVolumeTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformanceMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformanceMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.TotalReturn.Set {
			e.FieldStart("total_return")
			s.TotalReturn.Encode(e)
		}
	}
	{
		if s.AnnualizedReturn.Set {
			e.FieldStart("annualized_return")
			s.AnnualizedReturn.Encode(e)
		}
	}
	{
		if s.Volatility.Set {
			e.FieldStart("volatility")
			s.Volatility.Encode(e)
		}
	}
	{
		if s.SharpeRatio.Set {
			e.FieldStart("sharpe_ratio")
			s.SharpeRatio.Encode(e)
		}
	}
	{
		if s.MaxDrawdown.Set {
			e.FieldStart("max_drawdown")
			s.MaxDrawdown.Encode(e)
		}
	}
	{
		if s.WinRate.Set {
			e.FieldStart("win_rate")
			s.WinRate.Encode(e)
		}
	}
	{
		if s.ProfitFactor.Set {
			e.FieldStart("profit_factor")
			s.ProfitFactor.Encode(e)
		}
	}
}

var jsonFieldsNameOfPerformanceMetrics = [7]string{
	0: "total_return",
	1: "annualized_return",
	2: "volatility",
	3: "sharpe_ratio",
	4: "max_drawdown",
	5: "win_rate",
	6: "profit_factor",
}

// Decode decodes PerformanceMetrics from json.
func (s *PerformanceMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformanceMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_return":
			if err := func() error {
				s.TotalReturn.Reset()
				if err := s.TotalReturn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_return\"")
			}
		case "annualized_return":
			if err := func() error {
				s.AnnualizedReturn.Reset()
				if err := s.AnnualizedReturn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annualized_return\"")
			}
		case "volatility":
			if err := func() error {
				s.Volatility.Reset()
				if err := s.Volatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility\"")
			}
		case "sharpe_ratio":
			if err := func() error {
				s.SharpeRatio.Reset()
				if err := s.SharpeRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharpe_ratio\"")
			}
		case "max_drawdown":
			if err := func() error {
				s.MaxDrawdown.Reset()
				if err := s.MaxDrawdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_drawdown\"")
			}
		case "win_rate":
			if err := func() error {
				s.WinRate.Reset()
				if err := s.WinRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win_rate\"")
			}
		case "profit_factor":
			if err := func() error {
				s.ProfitFactor.Reset()
				if err := s.ProfitFactor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profit_factor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PerformanceMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortfolioConstraints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortfolioConstraints) encodeFields(e *jx.Encoder) {
	{
		if s.MaxWeight.Set {
			e.FieldStart("max_weight")
			s.MaxWeight.Encode(e)
		}
	}
	{
		if s.MinWeight.Set {
			e.FieldStart("min_weight")
			s.MinWeight.Encode(e)
		}
	}
	{
		if s.MaxSectorWeight.Set {
			e.FieldStart("max_sector_weight")
			s.MaxSectorWeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortfolioConstraints = [3]string{
	0: "max_weight",
	1: "min_weight",
	2: "max_sector_weight",
}

// Decode decodes PortfolioConstraints from json.
func (s *PortfolioConstraints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioConstraints to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_weight":
			if err := func() error {
				s.MaxWeight.Reset()
				if err := s.MaxWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_weight\"")
			}
		case "min_weight":
			if err := func() error {
				s.MinWeight.Reset()
				if err := s.MinWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_weight\"")
			}
		case "max_sector_weight":
			if err := func() error {
				s.MaxSectorWeight.Reset()
				if err := s.MaxSectorWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_sector_weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioConstraints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortfolioConstraints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioConstraints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortfolioHolding) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortfolioHolding) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.PurchasePrice.Set {
			e.FieldStart("purchase_price")
			s.PurchasePrice.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortfolioHolding = [4]string{
	0: "symbol",
	1: "weight",
	2: "quantity",
	3: "purchase_price",
}

// Decode decodes PortfolioHolding from json.
func (s *PortfolioHolding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioHolding to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "purchase_price":
			if err := func() error {
				s.PurchasePrice.Reset()
				if err := s.PurchasePrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purchase_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioHolding")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortfolioHolding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioHolding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortfolioOptimizationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortfolioOptimizationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("symbols")
		e.ArrStart()
		for _, elem := range s.Symbols {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Constraints.Set {
			e.FieldStart("constraints")
			s.Constraints.Encode(e)
		}
	}
	{
		if s.RiskTolerance.Set {
			e.FieldStart("risk_tolerance")
			s.RiskTolerance.Encode(e)
		}
	}
	{
		if s.InvestmentAmount.Set {
			e.FieldStart("investment_amount")
			s.InvestmentAmount.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortfolioOptimizationRequest = [4]string{
	0: "symbols",
	1: "constraints",
	2: "risk_tolerance",
	3: "investment_amount",
}

// Decode decodes PortfolioOptimizationRequest from json.
func (s *PortfolioOptimizationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioOptimizationRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbols":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Symbols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Symbols = append(s.Symbols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbols\"")
			}
		case "constraints":
			if err := func() error {
				s.Constraints.Reset()
				if err := s.Constraints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"constraints\"")
			}
		case "risk_tolerance":
			if err := func() error {
				s.RiskTolerance.Reset()
				if err := s.RiskTolerance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_tolerance\"")
			}
		case "investment_amount":
			if err := func() error {
				s.InvestmentAmount.Reset()
				if err := s.InvestmentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"investment_amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioOptimizationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortfolioOptimizationRequest) {
					name = jsonFieldsNameOfPortfolioOptimizationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortfolioOptimizationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioOptimizationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortfolioOptimizationRequestRiskTolerance as json.
func (s PortfolioOptimizationRequestRiskTolerance) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PortfolioOptimizationRequestRiskTolerance from json.
func (s *PortfolioOptimizationRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioOptimizationRequestRiskTolerance to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PortfolioOptimizationRequestRiskTolerance(v) {
	case PortfolioOptimizationRequestRiskToleranceConservative:
		*s = PortfolioOptimizationRequestRiskToleranceConservative
	case PortfolioOptimizationRequestRiskToleranceModerate:
		*s = PortfolioOptimizationRequestRiskToleranceModerate
	case PortfolioOptimizationRequestRiskToleranceAggressive:
		*s = PortfolioOptimizationRequestRiskToleranceAggressive
	default:
		*s = PortfolioOptimizationRequestRiskTolerance(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PortfolioOptimizationRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioOptimizationRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortfolioOptimizationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortfolioOptimizationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Allocations != nil {
			e.FieldStart("allocations")
			e.ArrStart()
			for _, elem := range s.Allocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExpectedReturn.Set {
			e.FieldStart("expected_return")
			s.ExpectedReturn.Encode(e)
		}
	}
	{
		if s.ExpectedVolatility.Set {
			e.FieldStart("expected_volatility")
			s.ExpectedVolatility.Encode(e)
		}
	}
	{
		if s.SharpeRatio.Set {
			e.FieldStart("sharpe_ratio")
			s.SharpeRatio.Encode(e)
		}
	}
	{
		if s.OptimizationDate.Set {
			e.FieldStart("optimization_date")
			s.OptimizationDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPortfolioOptimizationResponse = [5]string{
	0: "allocations",
	1: "expected_return",
	2: "expected_volatility",
	3: "sharpe_ratio",
	4: "optimization_date",
}

// Decode decodes PortfolioOptimizationResponse from json.
func (s *PortfolioOptimizationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioOptimizationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocations":
			if err := func() error {
				s.Allocations = make([]AssetAllocation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetAllocation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Allocations = append(s.Allocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocations\"")
			}
		case "expected_return":
			if err := func() error {
				s.ExpectedReturn.Reset()
				if err := s.ExpectedReturn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_return\"")
			}
		case "expected_volatility":
			if err := func() error {
				s.ExpectedVolatility.Reset()
				if err := s.ExpectedVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_volatility\"")
			}
		case "sharpe_ratio":
			if err := func() error {
				s.SharpeRatio.Reset()
				if err := s.SharpeRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharpe_ratio\"")
			}
		case "optimization_date":
			if err := func() error {
				s.OptimizationDate.Reset()
				if err := s.OptimizationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioOptimizationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortfolioOptimizationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioOptimizationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PricePrediction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PricePrediction) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.ModelUsed.Set {
			e.FieldStart("model_used")
			s.ModelUsed.Encode(e)
		}
	}
	{
		if s.CurrentPrice.Set {
			e.FieldStart("current_price")
			s.CurrentPrice.Encode(e)
		}
	}
	{
		if s.Predictions != nil {
			e.FieldStart("predictions")
			e.ArrStart()
			for _, elem := range s.Predictions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ConfidenceInterval.Set {
			e.FieldStart("confidence_interval")
			s.ConfidenceInterval.Encode(e)
		}
	}
	{
		if s.ModelAccuracy.Set {
			e.FieldStart("model_accuracy")
			s.ModelAccuracy.Encode(e)
		}
	}
}

var jsonFieldsNameOfPricePrediction = [6]string{
	0: "symbol",
	1: "model_used",
	2: "current_price",
	3: "predictions",
	4: "confidence_interval",
	5: "model_accuracy",
}

// Decode decodes PricePrediction from json.
func (s *PricePrediction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PricePrediction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "model_used":
			if err := func() error {
				s.ModelUsed.Reset()
				if err := s.ModelUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_used\"")
			}
		case "current_price":
			if err := func() error {
				s.CurrentPrice.Reset()
				if err := s.CurrentPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_price\"")
			}
		case "predictions":
			if err := func() error {
				s.Predictions = make([]PricePredictionPoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PricePredictionPoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Predictions = append(s.Predictions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predictions\"")
			}
		case "confidence_interval":
			if err := func() error {
				s.ConfidenceInterval.Reset()
				if err := s.ConfidenceInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence_interval\"")
			}
		case "model_accuracy":
			if err := func() error {
				s.ModelAccuracy.Reset()
				if err := s.ModelAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_accuracy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PricePrediction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PricePrediction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PricePrediction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PricePredictionConfidenceInterval) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PricePredictionConfidenceInterval) encodeFields(e *jx.Encoder) {
	{
		if s.LowerBound.Set {
			e.FieldStart("lower_bound")
			s.LowerBound.Encode(e)
		}
	}
	{
		if s.UpperBound.Set {
			e.FieldStart("upper_bound")
			s.UpperBound.Encode(e)
		}
	}
}

var jsonFieldsNameOfPricePredictionConfidenceInterval = [2]string{
	0: "lower_bound",
	1: "upper_bound",
}

// Decode decodes PricePredictionConfidenceInterval from json.
func (s *PricePredictionConfidenceInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PricePredictionConfidenceInterval to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lower_bound":
			if err := func() error {
				s.LowerBound.Reset()
				if err := s.LowerBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lower_bound\"")
			}
		case "upper_bound":
			if err := func() error {
				s.UpperBound.Reset()
				if err := s.UpperBound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upper_bound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PricePredictionConfidenceInterval")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PricePredictionConfidenceInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PricePredictionConfidenceInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PricePredictionPoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PricePredictionPoint) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.PredictedPrice.Set {
			e.FieldStart("predicted_price")
			s.PredictedPrice.Encode(e)
		}
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
}

var jsonFieldsNameOfPricePredictionPoint = [3]string{
	0: "date",
	1: "predicted_price",
	2: "confidence",
}

// Decode decodes PricePredictionPoint from json.
func (s *PricePredictionPoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PricePredictionPoint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "predicted_price":
			if err := func() error {
				s.PredictedPrice.Reset()
				if err := s.PredictedPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predicted_price\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PricePredictionPoint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PricePredictionPoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PricePredictionPoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadinessCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadinessCheckOK) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadinessCheckOK = [1]string{
	0: "status",
}

// Decode decodes ReadinessCheckOK from json.
func (s *ReadinessCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadinessCheckOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadinessCheckOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadinessCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadinessCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RiskAssessmentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RiskAssessmentRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("portfolio")
		e.ArrStart()
		for _, elem := range s.Portfolio {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.MarketConditions.Set {
			e.FieldStart("market_conditions")
			s.MarketConditions.Encode(e)
		}
	}
	{
		if s.TimeHorizon.Set {
			e.FieldStart("time_horizon")
			s.TimeHorizon.Encode(e)
		}
	}
}

var jsonFieldsNameOfRiskAssessmentRequest = [3]string{
	0: "portfolio",
	1: "market_conditions",
	2: "time_horizon",
}

// Decode decodes RiskAssessmentRequest from json.
func (s *RiskAssessmentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskAssessmentRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "portfolio":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Portfolio = make([]PortfolioHolding, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortfolioHolding
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Portfolio = append(s.Portfolio, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolio\"")
			}
		case "market_conditions":
			if err := func() error {
				s.MarketConditions.Reset()
				if err := s.MarketConditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"market_conditions\"")
			}
		case "time_horizon":
			if err := func() error {
				s.TimeHorizon.Reset()
				if err := s.TimeHorizon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_horizon\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RiskAssessmentRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRiskAssessmentRequest) {
					name = jsonFieldsNameOfRiskAssessmentRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RiskAssessmentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskAssessmentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskAssessmentRequestMarketConditions as json.
func (s RiskAssessmentRequestMarketConditions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RiskAssessmentRequestMarketConditions from json.
func (s *RiskAssessmentRequestMarketConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskAssessmentRequestMarketConditions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RiskAssessmentRequestMarketConditions(v) {
	case RiskAssessmentRequestMarketConditionsBullMarket:
		*s = RiskAssessmentRequestMarketConditionsBullMarket
	case RiskAssessmentRequestMarketConditionsBearMarket:
		*s = RiskAssessmentRequestMarketConditionsBearMarket
	case RiskAssessmentRequestMarketConditionsSidewaysMarket:
		*s = RiskAssessmentRequestMarketConditionsSidewaysMarket
	default:
		*s = RiskAssessmentRequestMarketConditions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RiskAssessmentRequestMarketConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskAssessmentRequestMarketConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskAssessmentRequestTimeHorizon as json.
func (s RiskAssessmentRequestTimeHorizon) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RiskAssessmentRequestTimeHorizon from json.
func (s *RiskAssessmentRequestTimeHorizon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskAssessmentRequestTimeHorizon to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RiskAssessmentRequestTimeHorizon(v) {
	case RiskAssessmentRequestTimeHorizonShortTerm:
		*s = RiskAssessmentRequestTimeHorizonShortTerm
	case RiskAssessmentRequestTimeHorizonMediumTerm:
		*s = RiskAssessmentRequestTimeHorizonMediumTerm
	case RiskAssessmentRequestTimeHorizonLongTerm:
		*s = RiskAssessmentRequestTimeHorizonLongTerm
	default:
		*s = RiskAssessmentRequestTimeHorizon(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RiskAssessmentRequestTimeHorizon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskAssessmentRequestTimeHorizon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RiskAssessmentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RiskAssessmentResponse) encodeFields(e *jx.Encoder) {
	{
		if s.OverallRiskScore.Set {
			e.FieldStart("overall_risk_score")
			s.OverallRiskScore.Encode(e)
		}
	}
	{
		if s.RiskMetrics.Set {
			e.FieldStart("risk_metrics")
			s.RiskMetrics.Encode(e)
		}
	}
	{
		if s.StressTestResults != nil {
			e.FieldStart("stress_test_results")
			e.ArrStart()
			for _, elem := range s.StressTestResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Recommendations != nil {
			e.FieldStart("recommendations")
			e.ArrStart()
			for _, elem := range s.Recommendations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRiskAssessmentResponse = [4]string{
	0: "overall_risk_score",
	1: "risk_metrics",
	2: "stress_test_results",
	3: "recommendations",
}

// Decode decodes RiskAssessmentResponse from json.
func (s *RiskAssessmentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskAssessmentResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overall_risk_score":
			if err := func() error {
				s.OverallRiskScore.Reset()
				if err := s.OverallRiskScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overall_risk_score\"")
			}
		case "risk_metrics":
			if err := func() error {
				s.RiskMetrics.Reset()
				if err := s.RiskMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_metrics\"")
			}
		case "stress_test_results":
			if err := func() error {
				s.StressTestResults = make([]StressTestResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StressTestResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StressTestResults = append(s.StressTestResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stress_test_results\"")
			}
		case "recommendations":
			if err := func() error {
				s.Recommendations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Recommendations = append(s.Recommendations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommendations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RiskAssessmentResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RiskAssessmentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskAssessmentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RiskMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RiskMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.ValueAtRisk95.Set {
			e.FieldStart("value_at_risk_95")
			s.ValueAtRisk95.Encode(e)
		}
	}
	{
		if s.ExpectedShortfall.Set {
			e.FieldStart("expected_shortfall")
			s.ExpectedShortfall.Encode(e)
		}
	}
	{
		if s.Beta.Set {
			e.FieldStart("beta")
			s.Beta.Encode(e)
		}
	}
	{
		if s.MaxDrawdown.Set {
			e.FieldStart("max_drawdown")
			s.MaxDrawdown.Encode(e)
		}
	}
	{
		if s.Volatility.Set {
			e.FieldStart("volatility")
			s.Volatility.Encode(e)
		}
	}
}

var jsonFieldsNameOfRiskMetrics = [5]string{
	0: "value_at_risk_95",
	1: "expected_shortfall",
	2: "beta",
	3: "max_drawdown",
	4: "volatility",
}

// Decode decodes RiskMetrics from json.
func (s *RiskMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value_at_risk_95":
			if err := func() error {
				s.ValueAtRisk95.Reset()
				if err := s.ValueAtRisk95.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_at_risk_95\"")
			}
		case "expected_shortfall":
			if err := func() error {
				s.ExpectedShortfall.Reset()
				if err := s.ExpectedShortfall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_shortfall\"")
			}
		case "beta":
			if err := func() error {
				s.Beta.Reset()
				if err := s.Beta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beta\"")
			}
		case "max_drawdown":
			if err := func() error {
				s.MaxDrawdown.Reset()
				if err := s.MaxDrawdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_drawdown\"")
			}
		case "volatility":
			if err := func() error {
				s.Volatility.Reset()
				if err := s.Volatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RiskMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RiskMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StressTestResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StressTestResult) encodeFields(e *jx.Encoder) {
	{
		if s.Scenario.Set {
			e.FieldStart("scenario")
			s.Scenario.Encode(e)
		}
	}
	{
		if s.Probability.Set {
			e.FieldStart("probability")
			s.Probability.Encode(e)
		}
	}
	{
		if s.PortfolioLoss.Set {
			e.FieldStart("portfolio_loss")
			s.PortfolioLoss.Encode(e)
		}
	}
	{
		if s.RecoveryTimeMonths.Set {
			e.FieldStart("recovery_time_months")
			s.RecoveryTimeMonths.Encode(e)
		}
	}
}

var jsonFieldsNameOfStressTestResult = [4]string{
	0: "scenario",
	1: "probability",
	2: "portfolio_loss",
	3: "recovery_time_months",
}

// Decode decodes StressTestResult from json.
func (s *StressTestResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StressTestResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scenario":
			if err := func() error {
				s.Scenario.Reset()
				if err := s.Scenario.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scenario\"")
			}
		case "probability":
			if err := func() error {
				s.Probability.Reset()
				if err := s.Probability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"probability\"")
			}
		case "portfolio_loss":
			if err := func() error {
				s.PortfolioLoss.Reset()
				if err := s.PortfolioLoss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolio_loss\"")
			}
		case "recovery_time_months":
			if err := func() error {
				s.RecoveryTimeMonths.Reset()
				if err := s.RecoveryTimeMonths.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_time_months\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StressTestResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StressTestResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StressTestResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportResistance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportResistance) encodeFields(e *jx.Encoder) {
	{
		if s.SupportLevels != nil {
			e.FieldStart("support_levels")
			e.ArrStart()
			for _, elem := range s.SupportLevels {
				e.Float32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResistanceLevels != nil {
			e.FieldStart("resistance_levels")
			e.ArrStart()
			for _, elem := range s.ResistanceLevels {
				e.Float32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PivotPoint.Set {
			e.FieldStart("pivot_point")
			s.PivotPoint.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportResistance = [3]string{
	0: "support_levels",
	1: "resistance_levels",
	2: "pivot_point",
}

// Decode decodes SupportResistance from json.
func (s *SupportResistance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportResistance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "support_levels":
			if err := func() error {
				s.SupportLevels = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float32
					v, err := d.Float32()
					elem = float32(v)
					if err != nil {
						return err
					}
					s.SupportLevels = append(s.SupportLevels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"support_levels\"")
			}
		case "resistance_levels":
			if err := func() error {
				s.ResistanceLevels = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float32
					v, err := d.Float32()
					elem = float32(v)
					if err != nil {
						return err
					}
					s.ResistanceLevels = append(s.ResistanceLevels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resistance_levels\"")
			}
		case "pivot_point":
			if err := func() error {
				s.PivotPoint.Reset()
				if err := s.PivotPoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pivot_point\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportResistance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportResistance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportResistance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TechnicalAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TechnicalAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.TrendAnalysis.Set {
			e.FieldStart("trend_analysis")
			s.TrendAnalysis.Encode(e)
		}
	}
	{
		if s.MomentumIndicators.Set {
			e.FieldStart("momentum_indicators")
			s.MomentumIndicators.Encode(e)
		}
	}
	{
		if s.VolatilityIndicators.Set {
			e.FieldStart("volatility_indicators")
			s.VolatilityIndicators.Encode(e)
		}
	}
	{
		if s.VolumeAnalysis.Set {
			e.FieldStart("volume_analysis")
			s.VolumeAnalysis.Encode(e)
		}
	}
	{
		if s.SupportResistance.Set {
			e.FieldStart("support_resistance")
			s.SupportResistance.Encode(e)
		}
	}
	{
		if s.PatternRecognition != nil {
			e.FieldStart("pattern_recognition")
			e.ArrStart()
			for _, elem := range s.PatternRecognition {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTechnicalAnalysis = [7]string{
	0: "symbol",
	1: "trend_analysis",
	2: "momentum_indicators",
	3: "volatility_indicators",
	4: "volume_analysis",
	5: "support_resistance",
	6: "pattern_recognition",
}

// Decode decodes TechnicalAnalysis from json.
func (s *TechnicalAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TechnicalAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "trend_analysis":
			if err := func() error {
				s.TrendAnalysis.Reset()
				if err := s.TrendAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trend_analysis\"")
			}
		case "momentum_indicators":
			if err := func() error {
				s.MomentumIndicators.Reset()
				if err := s.MomentumIndicators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"momentum_indicators\"")
			}
		case "volatility_indicators":
			if err := func() error {
				s.VolatilityIndicators.Reset()
				if err := s.VolatilityIndicators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility_indicators\"")
			}
		case "volume_analysis":
			if err := func() error {
				s.VolumeAnalysis.Reset()
				if err := s.VolumeAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_analysis\"")
			}
		case "support_resistance":
			if err := func() error {
				s.SupportResistance.Reset()
				if err := s.SupportResistance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"support_resistance\"")
			}
		case "pattern_recognition":
			if err := func() error {
				s.PatternRecognition = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PatternRecognition = append(s.PatternRecognition, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern_recognition\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TechnicalAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TechnicalAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TechnicalAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradeRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradeRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.FieldStart("side")
			s.Side.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Commission.Set {
			e.FieldStart("commission")
			s.Commission.Encode(e)
		}
	}
}

var jsonFieldsNameOfTradeRecord = [6]string{
	0: "symbol",
	1: "side",
	2: "quantity",
	3: "price",
	4: "timestamp",
	5: "commission",
}

// Decode decodes TradeRecord from json.
func (s *TradeRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradeRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradeRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradeRecordSide as json.
func (s TradeRecordSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TradeRecordSide from json.
func (s *TradeRecordSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeRecordSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TradeRecordSide(v) {
	case TradeRecordSideBuy:
		*s = TradeRecordSideBuy
	case TradeRecordSideSell:
		*s = TradeRecordSideSell
	default:
		*s = TradeRecordSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TradeRecordSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeRecordSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradingStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradingStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfTradingStrategy = [3]string{
	0: "name",
	1: "type",
	2: "parameters",
}

// Decode decodes TradingStrategy from json.
func (s *TradingStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradingStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradingStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradingStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradingStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TradingStrategyParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TradingStrategyParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes TradingStrategyParameters from json.
func (s *TradingStrategyParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradingStrategyParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradingStrategyParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TradingStrategyParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradingStrategyParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradingStrategyType as json.
func (s TradingStrategyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TradingStrategyType from json.
func (s *TradingStrategyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradingStrategyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TradingStrategyType(v) {
	case TradingStrategyTypeTechnical:
		*s = TradingStrategyTypeTechnical
	case TradingStrategyTypeFundamental:
		*s = TradingStrategyTypeFundamental
	case TradingStrategyTypeQuantitative:
		*s = TradingStrategyTypeQuantitative
	default:
		*s = TradingStrategyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TradingStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradingStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrendAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrendAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryTrend.Set {
			e.FieldStart("primary_trend")
			s.PrimaryTrend.Encode(e)
		}
	}
	{
		if s.SecondaryTrend.Set {
			e.FieldStart("secondary_trend")
			s.SecondaryTrend.Encode(e)
		}
	}
	{
		if s.TrendStrength.Set {
			e.FieldStart("trend_strength")
			s.TrendStrength.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrendAnalysis = [3]string{
	0: "primary_trend",
	1: "secondary_trend",
	2: "trend_strength",
}

// Decode decodes TrendAnalysis from json.
func (s *TrendAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrendAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "primary_trend":
			if err := func() error {
				s.PrimaryTrend.Reset()
				if err := s.PrimaryTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_trend\"")
			}
		case "secondary_trend":
			if err := func() error {
				s.SecondaryTrend.Reset()
				if err := s.SecondaryTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondary_trend\"")
			}
		case "trend_strength":
			if err := func() error {
				s.TrendStrength.Reset()
				if err := s.TrendStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trend_strength\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrendAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrendAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrendAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrendAnalysisPrimaryTrend as json.
func (s TrendAnalysisPrimaryTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrendAnalysisPrimaryTrend from json.
func (s *TrendAnalysisPrimaryTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrendAnalysisPrimaryTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrendAnalysisPrimaryTrend(v) {
	case TrendAnalysisPrimaryTrendBullish:
		*s = TrendAnalysisPrimaryTrendBullish
	case TrendAnalysisPrimaryTrendBearish:
		*s = TrendAnalysisPrimaryTrendBearish
	case TrendAnalysisPrimaryTrendSideways:
		*s = TrendAnalysisPrimaryTrendSideways
	default:
		*s = TrendAnalysisPrimaryTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrendAnalysisPrimaryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrendAnalysisPrimaryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrendAnalysisSecondaryTrend as json.
func (s TrendAnalysisSecondaryTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrendAnalysisSecondaryTrend from json.
func (s *TrendAnalysisSecondaryTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrendAnalysisSecondaryTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrendAnalysisSecondaryTrend(v) {
	case TrendAnalysisSecondaryTrendBullish:
		*s = TrendAnalysisSecondaryTrendBullish
	case TrendAnalysisSecondaryTrendBearish:
		*s = TrendAnalysisSecondaryTrendBearish
	case TrendAnalysisSecondaryTrendSideways:
		*s = TrendAnalysisSecondaryTrendSideways
	default:
		*s = TrendAnalysisSecondaryTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrendAnalysisSecondaryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrendAnalysisSecondaryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValuationMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValuationMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.IntrinsicValue.Set {
			e.FieldStart("intrinsic_value")
			s.IntrinsicValue.Encode(e)
		}
	}
	{
		if s.FairValueRange.Set {
			e.FieldStart("fair_value_range")
			s.FairValueRange.Encode(e)
		}
	}
	{
		if s.GrowthRate.Set {
			e.FieldStart("growth_rate")
			s.GrowthRate.Encode(e)
		}
	}
	{
		if s.DiscountRate.Set {
			e.FieldStart("discount_rate")
			s.DiscountRate.Encode(e)
		}
	}
}

var jsonFieldsNameOfValuationMetrics = [4]string{
	0: "intrinsic_value",
	1: "fair_value_range",
	2: "growth_rate",
	3: "discount_rate",
}

// Decode decodes ValuationMetrics from json.
func (s *ValuationMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValuationMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "intrinsic_value":
			if err := func() error {
				s.IntrinsicValue.Reset()
				if err := s.IntrinsicValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrinsic_value\"")
			}
		case "fair_value_range":
			if err := func() error {
				s.FairValueRange.Reset()
				if err := s.FairValueRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fair_value_range\"")
			}
		case "growth_rate":
			if err := func() error {
				s.GrowthRate.Reset()
				if err := s.GrowthRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"growth_rate\"")
			}
		case "discount_rate":
			if err := func() error {
				s.DiscountRate.Reset()
				if err := s.DiscountRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discount_rate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValuationMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValuationMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValuationMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValuationMetricsFairValueRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValuationMetricsFairValueRange) encodeFields(e *jx.Encoder) {
	{
		if s.Low.Set {
			e.FieldStart("low")
			s.Low.Encode(e)
		}
	}
	{
		if s.High.Set {
			e.FieldStart("high")
			s.High.Encode(e)
		}
	}
}

var jsonFieldsNameOfValuationMetricsFairValueRange = [2]string{
	0: "low",
	1: "high",
}

// Decode decodes ValuationMetricsFairValueRange from json.
func (s *ValuationMetricsFairValueRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValuationMetricsFairValueRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "low":
			if err := func() error {
				s.Low.Reset()
				if err := s.Low.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"low\"")
			}
		case "high":
			if err := func() error {
				s.High.Reset()
				if err := s.High.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"high\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValuationMetricsFairValueRange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValuationMetricsFairValueRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValuationMetricsFairValueRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VolatilityAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VolatilityAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		if s.HistoricalVolatility.Set {
			e.FieldStart("historical_volatility")
			s.HistoricalVolatility.Encode(e)
		}
	}
	{
		if s.ImpliedVolatility.Set {
			e.FieldStart("implied_volatility")
			s.ImpliedVolatility.Encode(e)
		}
	}
	{
		if s.RealizedVolatility.Set {
			e.FieldStart("realized_volatility")
			s.RealizedVolatility.Encode(e)
		}
	}
	{
		if s.VolatilityCone != nil {
			e.FieldStart("volatility_cone")
			e.ArrStart()
			for _, elem := range s.VolatilityCone {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GarchModel.Set {
			e.FieldStart("garch_model")
			s.GarchModel.Encode(e)
		}
	}
}

var jsonFieldsNameOfVolatilityAnalysis = [7]string{
	0: "symbol",
	1: "period",
	2: "historical_volatility",
	3: "implied_volatility",
	4: "realized_volatility",
	5: "volatility_cone",
	6: "garch_model",
}

// Decode decodes VolatilityAnalysis from json.
func (s *VolatilityAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolatilityAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "historical_volatility":
			if err := func() error {
				s.HistoricalVolatility.Reset()
				if err := s.HistoricalVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"historical_volatility\"")
			}
		case "implied_volatility":
			if err := func() error {
				s.ImpliedVolatility.Reset()
				if err := s.ImpliedVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implied_volatility\"")
			}
		case "realized_volatility":
			if err := func() error {
				s.RealizedVolatility.Reset()
				if err := s.RealizedVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realized_volatility\"")
			}
		case "volatility_cone":
			if err := func() error {
				s.VolatilityCone = make([]VolatilityPoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VolatilityPoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolatilityCone = append(s.VolatilityCone, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility_cone\"")
			}
		case "garch_model":
			if err := func() error {
				s.GarchModel.Reset()
				if err := s.GarchModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"garch_model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VolatilityAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VolatilityAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolatilityAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VolatilityIndicators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VolatilityIndicators) encodeFields(e *jx.Encoder) {
	{
		if s.BollingerBandwidth.Set {
			e.FieldStart("bollinger_bandwidth")
			s.BollingerBandwidth.Encode(e)
		}
	}
	{
		if s.AverageTrueRange.Set {
			e.FieldStart("average_true_range")
			s.AverageTrueRange.Encode(e)
		}
	}
	{
		if s.HistoricalVolatility.Set {
			e.FieldStart("historical_volatility")
			s.HistoricalVolatility.Encode(e)
		}
	}
}

var jsonFieldsNameOfVolatilityIndicators = [3]string{
	0: "bollinger_bandwidth",
	1: "average_true_range",
	2: "historical_volatility",
}

// Decode decodes VolatilityIndicators from json.
func (s *VolatilityIndicators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolatilityIndicators to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bollinger_bandwidth":
			if err := func() error {
				s.BollingerBandwidth.Reset()
				if err := s.BollingerBandwidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bollinger_bandwidth\"")
			}
		case "average_true_range":
			if err := func() error {
				s.AverageTrueRange.Reset()
				if err := s.AverageTrueRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_true_range\"")
			}
		case "historical_volatility":
			if err := func() error {
				s.HistoricalVolatility.Reset()
				if err := s.HistoricalVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"historical_volatility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VolatilityIndicators")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VolatilityIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolatilityIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VolatilityPoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VolatilityPoint) encodeFields(e *jx.Encoder) {
	{
		if s.Percentile.Set {
			e.FieldStart("percentile")
			s.Percentile.Encode(e)
		}
	}
	{
		if s.Volatility.Set {
			e.FieldStart("volatility")
			s.Volatility.Encode(e)
		}
	}
}

var jsonFieldsNameOfVolatilityPoint = [2]string{
	0: "percentile",
	1: "volatility",
}

// Decode decodes VolatilityPoint from json.
func (s *VolatilityPoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolatilityPoint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "percentile":
			if err := func() error {
				s.Percentile.Reset()
				if err := s.Percentile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentile\"")
			}
		case "volatility":
			if err := func() error {
				s.Volatility.Reset()
				if err := s.Volatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volatility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VolatilityPoint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VolatilityPoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolatilityPoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VolumeAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VolumeAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.VolumeTrend.Set {
			e.FieldStart("volume_trend")
			s.VolumeTrend.Encode(e)
		}
	}
	{
		if s.VolumePriceTrend.Set {
			e.FieldStart("volume_price_trend")
			s.VolumePriceTrend.Encode(e)
		}
	}
	{
		if s.Obv.Set {
			e.FieldStart("obv")
			s.Obv.Encode(e)
		}
	}
	{
		if s.VolumeRatio.Set {
			e.FieldStart("volume_ratio")
			s.VolumeRatio.Encode(e)
		}
	}
}

var jsonFieldsNameOfVolumeAnalysis = [4]string{
	0: "volume_trend",
	1: "volume_price_trend",
	2: "obv",
	3: "volume_ratio",
}

// Decode decodes VolumeAnalysis from json.
func (s *VolumeAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolumeAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "volume_trend":
			if err := func() error {
				s.VolumeTrend.Reset()
				if err := s.VolumeTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_trend\"")
			}
		case "volume_price_trend":
			if err := func() error {
				s.VolumePriceTrend.Reset()
				if err := s.VolumePriceTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_price_trend\"")
			}
		case "obv":
			if err := func() error {
				s.Obv.Reset()
				if err := s.Obv.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"obv\"")
			}
		case "volume_ratio":
			if err := func() error {
				s.VolumeRatio.Reset()
				if err := s.VolumeRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_ratio\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VolumeAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VolumeAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolumeAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAnalysisVolumePriceTrend as json.
func (s VolumeAnalysisVolumePriceTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VolumeAnalysisVolumePriceTrend from json.
func (s *VolumeAnalysisVolumePriceTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolumeAnalysisVolumePriceTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VolumeAnalysisVolumePriceTrend(v) {
	case VolumeAnalysisVolumePriceTrendConfirmation:
		*s = VolumeAnalysisVolumePriceTrendConfirmation
	case VolumeAnalysisVolumePriceTrendDivergence:
		*s = VolumeAnalysisVolumePriceTrendDivergence
	case VolumeAnalysisVolumePriceTrendNeutral:
		*s = VolumeAnalysisVolumePriceTrendNeutral
	default:
		*s = VolumeAnalysisVolumePriceTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VolumeAnalysisVolumePriceTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolumeAnalysisVolumePriceTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAnalysisVolumeTrend as json.
func (s VolumeAnalysisVolumeTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VolumeAnalysisVolumeTrend from json.
func (s *VolumeAnalysisVolumeTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolumeAnalysisVolumeTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VolumeAnalysisVolumeTrend(v) {
	case VolumeAnalysisVolumeTrendIncreasing:
		*s = VolumeAnalysisVolumeTrendIncreasing
	case VolumeAnalysisVolumeTrendDecreasing:
		*s = VolumeAnalysisVolumeTrendDecreasing
	case VolumeAnalysisVolumeTrendStable:
		*s = VolumeAnalysisVolumeTrendStable
	default:
		*s = VolumeAnalysisVolumeTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VolumeAnalysisVolumeTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolumeAnalysisVolumeTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
