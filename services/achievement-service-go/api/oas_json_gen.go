// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Achievement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Achievement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		e.FieldStart("requirements")
		e.ArrStart()
		for _, elem := range s.Requirements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("is_hidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.IsRepeatable.Set {
			e.FieldStart("is_repeatable")
			s.IsRepeatable.Encode(e)
		}
	}
	{
		if s.MaxCompletions.Set {
			e.FieldStart("max_completions")
			s.MaxCompletions.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		if s.PointsValue.Set {
			e.FieldStart("points_value")
			s.PointsValue.Encode(e)
		}
	}
	{
		if s.UnlockRequirements != nil {
			e.FieldStart("unlock_requirements")
			e.ArrStart()
			for _, elem := range s.UnlockRequirements {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AntiCheatToken.Set {
			e.FieldStart("anti_cheat_token")
			s.AntiCheatToken.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievement = [17]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "name",
	4:  "description",
	5:  "category",
	6:  "icon_url",
	7:  "requirements",
	8:  "rewards",
	9:  "is_hidden",
	10: "is_repeatable",
	11: "max_completions",
	12: "difficulty",
	13: "points_value",
	14: "unlock_requirements",
	15: "anti_cheat_token",
	16: "is_active",
}

// Decode decodes Achievement from json.
func (s *Achievement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Achievement to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "requirements":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Requirements = make([]AchievementRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requirements = append(s.Requirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]AchievementReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "is_hidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_hidden\"")
			}
		case "is_repeatable":
			if err := func() error {
				s.IsRepeatable.Reset()
				if err := s.IsRepeatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_repeatable\"")
			}
		case "max_completions":
			if err := func() error {
				s.MaxCompletions.Reset()
				if err := s.MaxCompletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completions\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "points_value":
			if err := func() error {
				s.PointsValue.Reset()
				if err := s.PointsValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_value\"")
			}
		case "unlock_requirements":
			if err := func() error {
				s.UnlockRequirements = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.UnlockRequirements = append(s.UnlockRequirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlock_requirements\"")
			}
		case "anti_cheat_token":
			if err := func() error {
				s.AntiCheatToken.Reset()
				if err := s.AntiCheatToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anti_cheat_token\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Achievement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10101111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievement) {
					name = jsonFieldsNameOfAchievement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Achievement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Achievement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementCategory as json.
func (s AchievementCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementCategory from json.
func (s *AchievementCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementCategory(v) {
	case AchievementCategoryCombat:
		*s = AchievementCategoryCombat
	case AchievementCategoryExploration:
		*s = AchievementCategoryExploration
	case AchievementCategorySocial:
		*s = AchievementCategorySocial
	case AchievementCategoryProgression:
		*s = AchievementCategoryProgression
	case AchievementCategoryCollection:
		*s = AchievementCategoryCollection
	case AchievementCategoryChallenge:
		*s = AchievementCategoryChallenge
	default:
		*s = AchievementCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementClaimRewardsBadRequest as json.
func (s *AchievementClaimRewardsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AchievementClaimRewardsBadRequest from json.
func (s *AchievementClaimRewardsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementClaimRewardsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AchievementClaimRewardsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementClaimRewardsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementClaimRewardsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementClaimRewardsConflict as json.
func (s *AchievementClaimRewardsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AchievementClaimRewardsConflict from json.
func (s *AchievementClaimRewardsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementClaimRewardsConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AchievementClaimRewardsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementClaimRewardsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementClaimRewardsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementClaimRewardsNotFound as json.
func (s *AchievementClaimRewardsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AchievementClaimRewardsNotFound from json.
func (s *AchievementClaimRewardsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementClaimRewardsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AchievementClaimRewardsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementClaimRewardsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementClaimRewardsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementDifficulty as json.
func (s AchievementDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementDifficulty from json.
func (s *AchievementDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementDifficulty(v) {
	case AchievementDifficultyEasy:
		*s = AchievementDifficultyEasy
	case AchievementDifficultyMedium:
		*s = AchievementDifficultyMedium
	case AchievementDifficultyHard:
		*s = AchievementDifficultyHard
	case AchievementDifficultyLegendary:
		*s = AchievementDifficultyLegendary
	default:
		*s = AchievementDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementProgress) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("achievement_id")
		json.EncodeUUID(e, s.AchievementID)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("current_value")
		e.Int(s.CurrentValue)
	}
	{
		e.FieldStart("target_value")
		e.Int(s.TargetValue)
	}
	{
		e.FieldStart("is_completed")
		e.Bool(s.IsCompleted)
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletionCount.Set {
			e.FieldStart("completion_count")
			s.CompletionCount.Encode(e)
		}
	}
	{
		if s.RewardsClaimed.Set {
			e.FieldStart("rewards_claimed")
			s.RewardsClaimed.Encode(e)
		}
	}
	{
		if s.ProgressHistory != nil {
			e.FieldStart("progress_history")
			e.ArrStart()
			for _, elem := range s.ProgressHistory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAchievementProgress = [10]string{
	0: "achievement_id",
	1: "character_id",
	2: "current_value",
	3: "target_value",
	4: "is_completed",
	5: "completed_at",
	6: "last_updated",
	7: "completion_count",
	8: "rewards_claimed",
	9: "progress_history",
}

// Decode decodes AchievementProgress from json.
func (s *AchievementProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementProgress to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AchievementID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "current_value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CurrentValue = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_value\"")
			}
		case "target_value":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TargetValue = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_value\"")
			}
		case "is_completed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsCompleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_completed\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		case "completion_count":
			if err := func() error {
				s.CompletionCount.Reset()
				if err := s.CompletionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_count\"")
			}
		case "rewards_claimed":
			if err := func() error {
				s.RewardsClaimed.Reset()
				if err := s.RewardsClaimed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards_claimed\"")
			}
		case "progress_history":
			if err := func() error {
				s.ProgressHistory = make([]AchievementProgressProgressHistoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementProgressProgressHistoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProgressHistory = append(s.ProgressHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementProgress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementProgress) {
					name = jsonFieldsNameOfAchievementProgress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementProgressProgressHistoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementProgressProgressHistoryItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievementProgressProgressHistoryItem = [3]string{
	0: "value",
	1: "timestamp",
	2: "event_type",
}

// Decode decodes AchievementProgressProgressHistoryItem from json.
func (s *AchievementProgressProgressHistoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementProgressProgressHistoryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementProgressProgressHistoryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementProgressProgressHistoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementProgressProgressHistoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementProgressResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("progress")
		s.Progress.Encode(e)
	}
	{
		if s.NextMilestone.Set {
			e.FieldStart("next_milestone")
			s.NextMilestone.Encode(e)
		}
	}
	{
		if s.EstimatedCompletion.Set {
			e.FieldStart("estimated_completion")
			s.EstimatedCompletion.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAchievementProgressResponse = [3]string{
	0: "progress",
	1: "next_milestone",
	2: "estimated_completion",
}

// Decode decodes AchievementProgressResponse from json.
func (s *AchievementProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementProgressResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "progress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "next_milestone":
			if err := func() error {
				s.NextMilestone.Reset()
				if err := s.NextMilestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_milestone\"")
			}
		case "estimated_completion":
			if err := func() error {
				s.EstimatedCompletion.Reset()
				if err := s.EstimatedCompletion.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_completion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementProgressResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementProgressResponse) {
					name = jsonFieldsNameOfAchievementProgressResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("target_value")
		e.Int(s.TargetValue)
	}
	{
		if s.TargetEntity.Set {
			e.FieldStart("target_entity")
			s.TargetEntity.Encode(e)
		}
	}
	{
		if s.Condition.Set {
			e.FieldStart("condition")
			s.Condition.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievementRequirement = [5]string{
	0: "type",
	1: "target_value",
	2: "target_entity",
	3: "condition",
	4: "description",
}

// Decode decodes AchievementRequirement from json.
func (s *AchievementRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target_value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TargetValue = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_value\"")
			}
		case "target_entity":
			if err := func() error {
				s.TargetEntity.Reset()
				if err := s.TargetEntity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_entity\"")
			}
		case "condition":
			if err := func() error {
				s.Condition.Reset()
				if err := s.Condition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"condition\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementRequirement) {
					name = jsonFieldsNameOfAchievementRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRequirementType as json.
func (s AchievementRequirementType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementRequirementType from json.
func (s *AchievementRequirementType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementRequirementType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementRequirementType(v) {
	case AchievementRequirementTypeKillCount:
		*s = AchievementRequirementTypeKillCount
	case AchievementRequirementTypeItemCollect:
		*s = AchievementRequirementTypeItemCollect
	case AchievementRequirementTypeDistanceTraveled:
		*s = AchievementRequirementTypeDistanceTraveled
	case AchievementRequirementTypeTimePlayed:
		*s = AchievementRequirementTypeTimePlayed
	case AchievementRequirementTypeLevelReached:
		*s = AchievementRequirementTypeLevelReached
	case AchievementRequirementTypeQuestCompleted:
		*s = AchievementRequirementTypeQuestCompleted
	case AchievementRequirementTypeSocialInteraction:
		*s = AchievementRequirementTypeSocialInteraction
	case AchievementRequirementTypeCombatStreak:
		*s = AchievementRequirementTypeCombatStreak
	case AchievementRequirementTypeExplorationDiscovery:
		*s = AchievementRequirementTypeExplorationDiscovery
	case AchievementRequirementTypeCurrencyEarned:
		*s = AchievementRequirementTypeCurrencyEarned
	default:
		*s = AchievementRequirementType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementRequirementType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementRequirementType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("achievement")
		s.Achievement.Encode(e)
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievementResponse = [2]string{
	0: "achievement",
	1: "progress",
}

// Decode decodes AchievementResponse from json.
func (s *AchievementResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Achievement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementResponse) {
					name = jsonFieldsNameOfAchievementResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		if s.CurrencyType.Set {
			e.FieldStart("currency_type")
			s.CurrencyType.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.TitleName.Set {
			e.FieldStart("title_name")
			s.TitleName.Encode(e)
		}
	}
	{
		if s.CosmeticID.Set {
			e.FieldStart("cosmetic_id")
			s.CosmeticID.Encode(e)
		}
	}
	{
		if s.AbilityID.Set {
			e.FieldStart("ability_id")
			s.AbilityID.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievementReward = [7]string{
	0: "type",
	1: "item_id",
	2: "currency_type",
	3: "amount",
	4: "title_name",
	5: "cosmetic_id",
	6: "ability_id",
}

// Decode decodes AchievementReward from json.
func (s *AchievementReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "currency_type":
			if err := func() error {
				s.CurrencyType.Reset()
				if err := s.CurrencyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_type\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "title_name":
			if err := func() error {
				s.TitleName.Reset()
				if err := s.TitleName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title_name\"")
			}
		case "cosmetic_id":
			if err := func() error {
				s.CosmeticID.Reset()
				if err := s.CosmeticID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cosmetic_id\"")
			}
		case "ability_id":
			if err := func() error {
				s.AbilityID.Reset()
				if err := s.AbilityID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementReward) {
					name = jsonFieldsNameOfAchievementReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRewardCurrencyType as json.
func (s AchievementRewardCurrencyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementRewardCurrencyType from json.
func (s *AchievementRewardCurrencyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementRewardCurrencyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementRewardCurrencyType(v) {
	case AchievementRewardCurrencyTypeEurodollars:
		*s = AchievementRewardCurrencyTypeEurodollars
	case AchievementRewardCurrencyTypeStreetCred:
		*s = AchievementRewardCurrencyTypeStreetCred
	case AchievementRewardCurrencyTypePremiumCurrency:
		*s = AchievementRewardCurrencyTypePremiumCurrency
	default:
		*s = AchievementRewardCurrencyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementRewardCurrencyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementRewardCurrencyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRewardType as json.
func (s AchievementRewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementRewardType from json.
func (s *AchievementRewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementRewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementRewardType(v) {
	case AchievementRewardTypeItem:
		*s = AchievementRewardTypeItem
	case AchievementRewardTypeCurrency:
		*s = AchievementRewardTypeCurrency
	case AchievementRewardTypeExperience:
		*s = AchievementRewardTypeExperience
	case AchievementRewardTypeTitle:
		*s = AchievementRewardTypeTitle
	case AchievementRewardTypeCosmetic:
		*s = AchievementRewardTypeCosmetic
	case AchievementRewardTypeAbility:
		*s = AchievementRewardTypeAbility
	case AchievementRewardTypeReputation:
		*s = AchievementRewardTypeReputation
	default:
		*s = AchievementRewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsSummaryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsSummaryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		s.Summary.Encode(e)
	}
	{
		if s.Timeframe.Set {
			e.FieldStart("timeframe")
			s.Timeframe.Encode(e)
		}
	}
	{
		if s.CharacterID.Set {
			e.FieldStart("character_id")
			s.CharacterID.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsSummaryResponse = [3]string{
	0: "summary",
	1: "timeframe",
	2: "character_id",
}

// Decode decodes AnalyticsSummaryResponse from json.
func (s *AnalyticsSummaryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsSummaryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "timeframe":
			if err := func() error {
				s.Timeframe.Reset()
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "character_id":
			if err := func() error {
				s.CharacterID.Reset()
				if err := s.CharacterID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsSummaryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsSummaryResponse) {
					name = jsonFieldsNameOfAnalyticsSummaryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsSummaryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsSummaryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsSummaryResponseSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsSummaryResponseSummary) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAchievements.Set {
			e.FieldStart("total_achievements")
			s.TotalAchievements.Encode(e)
		}
	}
	{
		if s.UnlockedAchievements.Set {
			e.FieldStart("unlocked_achievements")
			s.UnlockedAchievements.Encode(e)
		}
	}
	{
		if s.CompletedAchievements.Set {
			e.FieldStart("completed_achievements")
			s.CompletedAchievements.Encode(e)
		}
	}
	{
		if s.TotalPoints.Set {
			e.FieldStart("total_points")
			s.TotalPoints.Encode(e)
		}
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("average_completion_time")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.CategoryBreakdown.Set {
			e.FieldStart("category_breakdown")
			s.CategoryBreakdown.Encode(e)
		}
	}
	{
		if s.RecentCompletions != nil {
			e.FieldStart("recent_completions")
			e.ArrStart()
			for _, elem := range s.RecentCompletions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnalyticsSummaryResponseSummary = [7]string{
	0: "total_achievements",
	1: "unlocked_achievements",
	2: "completed_achievements",
	3: "total_points",
	4: "average_completion_time",
	5: "category_breakdown",
	6: "recent_completions",
}

// Decode decodes AnalyticsSummaryResponseSummary from json.
func (s *AnalyticsSummaryResponseSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsSummaryResponseSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_achievements":
			if err := func() error {
				s.TotalAchievements.Reset()
				if err := s.TotalAchievements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_achievements\"")
			}
		case "unlocked_achievements":
			if err := func() error {
				s.UnlockedAchievements.Reset()
				if err := s.UnlockedAchievements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlocked_achievements\"")
			}
		case "completed_achievements":
			if err := func() error {
				s.CompletedAchievements.Reset()
				if err := s.CompletedAchievements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_achievements\"")
			}
		case "total_points":
			if err := func() error {
				s.TotalPoints.Reset()
				if err := s.TotalPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_points\"")
			}
		case "average_completion_time":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_completion_time\"")
			}
		case "category_breakdown":
			if err := func() error {
				s.CategoryBreakdown.Reset()
				if err := s.CategoryBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_breakdown\"")
			}
		case "recent_completions":
			if err := func() error {
				s.RecentCompletions = make([]AnalyticsSummaryResponseSummaryRecentCompletionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnalyticsSummaryResponseSummaryRecentCompletionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecentCompletions = append(s.RecentCompletions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recent_completions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsSummaryResponseSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsSummaryResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsSummaryResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsSummaryResponseSummaryCategoryBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsSummaryResponseSummaryCategoryBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.Combat.Set {
			e.FieldStart("combat")
			s.Combat.Encode(e)
		}
	}
	{
		if s.Exploration.Set {
			e.FieldStart("exploration")
			s.Exploration.Encode(e)
		}
	}
	{
		if s.Social.Set {
			e.FieldStart("social")
			s.Social.Encode(e)
		}
	}
	{
		if s.Progression.Set {
			e.FieldStart("progression")
			s.Progression.Encode(e)
		}
	}
	{
		if s.Collection.Set {
			e.FieldStart("collection")
			s.Collection.Encode(e)
		}
	}
	{
		if s.Challenge.Set {
			e.FieldStart("challenge")
			s.Challenge.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsSummaryResponseSummaryCategoryBreakdown = [6]string{
	0: "combat",
	1: "exploration",
	2: "social",
	3: "progression",
	4: "collection",
	5: "challenge",
}

// Decode decodes AnalyticsSummaryResponseSummaryCategoryBreakdown from json.
func (s *AnalyticsSummaryResponseSummaryCategoryBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsSummaryResponseSummaryCategoryBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "combat":
			if err := func() error {
				s.Combat.Reset()
				if err := s.Combat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat\"")
			}
		case "exploration":
			if err := func() error {
				s.Exploration.Reset()
				if err := s.Exploration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exploration\"")
			}
		case "social":
			if err := func() error {
				s.Social.Reset()
				if err := s.Social.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"social\"")
			}
		case "progression":
			if err := func() error {
				s.Progression.Reset()
				if err := s.Progression.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progression\"")
			}
		case "collection":
			if err := func() error {
				s.Collection.Reset()
				if err := s.Collection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collection\"")
			}
		case "challenge":
			if err := func() error {
				s.Challenge.Reset()
				if err := s.Challenge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challenge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsSummaryResponseSummaryCategoryBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsSummaryResponseSummaryCategoryBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsSummaryResponseSummaryCategoryBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsSummaryResponseSummaryRecentCompletionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsSummaryResponseSummaryRecentCompletionsItem) encodeFields(e *jx.Encoder) {
	{
		if s.AchievementID.Set {
			e.FieldStart("achievement_id")
			s.AchievementID.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PointsEarned.Set {
			e.FieldStart("points_earned")
			s.PointsEarned.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsSummaryResponseSummaryRecentCompletionsItem = [3]string{
	0: "achievement_id",
	1: "completed_at",
	2: "points_earned",
}

// Decode decodes AnalyticsSummaryResponseSummaryRecentCompletionsItem from json.
func (s *AnalyticsSummaryResponseSummaryRecentCompletionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsSummaryResponseSummaryRecentCompletionsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			if err := func() error {
				s.AchievementID.Reset()
				if err := s.AchievementID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "points_earned":
			if err := func() error {
				s.PointsEarned.Reset()
				if err := s.PointsEarned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_earned\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsSummaryResponseSummaryRecentCompletionsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsSummaryResponseSummaryRecentCompletionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsSummaryResponseSummaryRecentCompletionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBadRequest) {
					name = jsonFieldsNameOfBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBadRequestDetails = [0]string{}

// Decode decodes BadRequestDetails from json.
func (s *BadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateProgressRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateProgressRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BatchID.Set {
			e.FieldStart("batch_id")
			s.BatchID.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateProgressRequest = [2]string{
	0: "updates",
	1: "batch_id",
}

// Decode decodes BatchUpdateProgressRequest from json.
func (s *BatchUpdateProgressRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateProgressRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updates":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Updates = make([]UpdateProgressRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateProgressRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "batch_id":
			if err := func() error {
				s.BatchID.Reset()
				if err := s.BatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateProgressRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchUpdateProgressRequest) {
					name = jsonFieldsNameOfBatchUpdateProgressRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateProgressRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateProgressRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateProgressResponse) encodeFields(e *jx.Encoder) {
	{
		if s.BatchID.Set {
			e.FieldStart("batch_id")
			s.BatchID.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateProgressResponse = [3]string{
	0: "batch_id",
	1: "results",
	2: "summary",
}

// Decode decodes BatchUpdateProgressResponse from json.
func (s *BatchUpdateProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateProgressResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "batch_id":
			if err := func() error {
				s.BatchID.Reset()
				if err := s.BatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_id\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Results = make([]BatchUpdateProgressResponseResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchUpdateProgressResponseResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateProgressResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchUpdateProgressResponse) {
					name = jsonFieldsNameOfBatchUpdateProgressResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateProgressResponseResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateProgressResponseResultsItem) encodeFields(e *jx.Encoder) {
	{
		if s.AchievementID.Set {
			e.FieldStart("achievement_id")
			s.AchievementID.Encode(e)
		}
	}
	{
		if s.CharacterID.Set {
			e.FieldStart("character_id")
			s.CharacterID.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.NewProgress.Set {
			e.FieldStart("new_progress")
			s.NewProgress.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateProgressResponseResultsItem = [5]string{
	0: "achievement_id",
	1: "character_id",
	2: "success",
	3: "error_message",
	4: "new_progress",
}

// Decode decodes BatchUpdateProgressResponseResultsItem from json.
func (s *BatchUpdateProgressResponseResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateProgressResponseResultsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			if err := func() error {
				s.AchievementID.Reset()
				if err := s.AchievementID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "character_id":
			if err := func() error {
				s.CharacterID.Reset()
				if err := s.CharacterID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "new_progress":
			if err := func() error {
				s.NewProgress.Reset()
				if err := s.NewProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_progress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateProgressResponseResultsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateProgressResponseResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateProgressResponseResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateProgressResponseSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateProgressResponseSummary) encodeFields(e *jx.Encoder) {
	{
		if s.TotalUpdates.Set {
			e.FieldStart("total_updates")
			s.TotalUpdates.Encode(e)
		}
	}
	{
		if s.SuccessfulUpdates.Set {
			e.FieldStart("successful_updates")
			s.SuccessfulUpdates.Encode(e)
		}
	}
	{
		if s.FailedUpdates.Set {
			e.FieldStart("failed_updates")
			s.FailedUpdates.Encode(e)
		}
	}
	{
		if s.NewUnlocks.Set {
			e.FieldStart("new_unlocks")
			s.NewUnlocks.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateProgressResponseSummary = [4]string{
	0: "total_updates",
	1: "successful_updates",
	2: "failed_updates",
	3: "new_unlocks",
}

// Decode decodes BatchUpdateProgressResponseSummary from json.
func (s *BatchUpdateProgressResponseSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateProgressResponseSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_updates":
			if err := func() error {
				s.TotalUpdates.Reset()
				if err := s.TotalUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_updates\"")
			}
		case "successful_updates":
			if err := func() error {
				s.SuccessfulUpdates.Reset()
				if err := s.SuccessfulUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_updates\"")
			}
		case "failed_updates":
			if err := func() error {
				s.FailedUpdates.Reset()
				if err := s.FailedUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_updates\"")
			}
		case "new_unlocks":
			if err := func() error {
				s.NewUnlocks.Reset()
				if err := s.NewUnlocks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_unlocks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateProgressResponseSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateProgressResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateProgressResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		if s.ClaimAll.Set {
			e.FieldStart("claim_all")
			s.ClaimAll.Encode(e)
		}
	}
	{
		if s.SpecificRewards != nil {
			e.FieldStart("specific_rewards")
			e.ArrStart()
			for _, elem := range s.SpecificRewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InventoryLocation.Set {
			e.FieldStart("inventory_location")
			s.InventoryLocation.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRewardsRequest = [4]string{
	0: "character_id",
	1: "claim_all",
	2: "specific_rewards",
	3: "inventory_location",
}

// Decode decodes ClaimRewardsRequest from json.
func (s *ClaimRewardsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "claim_all":
			if err := func() error {
				s.ClaimAll.Reset()
				if err := s.ClaimAll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claim_all\"")
			}
		case "specific_rewards":
			if err := func() error {
				s.SpecificRewards = make([]ClaimRewardsRequestSpecificRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClaimRewardsRequestSpecificRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpecificRewards = append(s.SpecificRewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specific_rewards\"")
			}
		case "inventory_location":
			if err := func() error {
				s.InventoryLocation.Reset()
				if err := s.InventoryLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimRewardsRequest) {
					name = jsonFieldsNameOfClaimRewardsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardsRequestSpecificRewardsItem as json.
func (s ClaimRewardsRequestSpecificRewardsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClaimRewardsRequestSpecificRewardsItem from json.
func (s *ClaimRewardsRequestSpecificRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsRequestSpecificRewardsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClaimRewardsRequestSpecificRewardsItem(v) {
	case ClaimRewardsRequestSpecificRewardsItemItem:
		*s = ClaimRewardsRequestSpecificRewardsItemItem
	case ClaimRewardsRequestSpecificRewardsItemCurrency:
		*s = ClaimRewardsRequestSpecificRewardsItemCurrency
	case ClaimRewardsRequestSpecificRewardsItemExperience:
		*s = ClaimRewardsRequestSpecificRewardsItemExperience
	case ClaimRewardsRequestSpecificRewardsItemTitle:
		*s = ClaimRewardsRequestSpecificRewardsItemTitle
	case ClaimRewardsRequestSpecificRewardsItemCosmetic:
		*s = ClaimRewardsRequestSpecificRewardsItemCosmetic
	case ClaimRewardsRequestSpecificRewardsItemAbility:
		*s = ClaimRewardsRequestSpecificRewardsItemAbility
	case ClaimRewardsRequestSpecificRewardsItemReputation:
		*s = ClaimRewardsRequestSpecificRewardsItemReputation
	default:
		*s = ClaimRewardsRequestSpecificRewardsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClaimRewardsRequestSpecificRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsRequestSpecificRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.ClaimedRewards != nil {
			e.FieldStart("claimed_rewards")
			e.ArrStart()
			for _, elem := range s.ClaimedRewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FailedRewards != nil {
			e.FieldStart("failed_rewards")
			e.ArrStart()
			for _, elem := range s.FailedRewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InventoryUpdates != nil {
			e.FieldStart("inventory_updates")
			e.ArrStart()
			for _, elem := range s.InventoryUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfClaimRewardsResponse = [4]string{
	0: "success",
	1: "claimed_rewards",
	2: "failed_rewards",
	3: "inventory_updates",
}

// Decode decodes ClaimRewardsResponse from json.
func (s *ClaimRewardsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "claimed_rewards":
			if err := func() error {
				s.ClaimedRewards = make([]ClaimRewardsResponseClaimedRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClaimRewardsResponseClaimedRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClaimedRewards = append(s.ClaimedRewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_rewards\"")
			}
		case "failed_rewards":
			if err := func() error {
				s.FailedRewards = make([]ClaimRewardsResponseFailedRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClaimRewardsResponseFailedRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailedRewards = append(s.FailedRewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_rewards\"")
			}
		case "inventory_updates":
			if err := func() error {
				s.InventoryUpdates = make([]ClaimRewardsResponseInventoryUpdatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClaimRewardsResponseInventoryUpdatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InventoryUpdates = append(s.InventoryUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimRewardsResponse) {
					name = jsonFieldsNameOfClaimRewardsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardsResponseClaimedRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardsResponseClaimedRewardsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		if s.InventorySlot.Set {
			e.FieldStart("inventory_slot")
			s.InventorySlot.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRewardsResponseClaimedRewardsItem = [4]string{
	0: "type",
	1: "amount",
	2: "item_id",
	3: "inventory_slot",
}

// Decode decodes ClaimRewardsResponseClaimedRewardsItem from json.
func (s *ClaimRewardsResponseClaimedRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsResponseClaimedRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "inventory_slot":
			if err := func() error {
				s.InventorySlot.Reset()
				if err := s.InventorySlot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardsResponseClaimedRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardsResponseClaimedRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsResponseClaimedRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardsResponseClaimedRewardsItemType as json.
func (s ClaimRewardsResponseClaimedRewardsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClaimRewardsResponseClaimedRewardsItemType from json.
func (s *ClaimRewardsResponseClaimedRewardsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsResponseClaimedRewardsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClaimRewardsResponseClaimedRewardsItemType(v) {
	case ClaimRewardsResponseClaimedRewardsItemTypeItem:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeItem
	case ClaimRewardsResponseClaimedRewardsItemTypeCurrency:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeCurrency
	case ClaimRewardsResponseClaimedRewardsItemTypeExperience:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeExperience
	case ClaimRewardsResponseClaimedRewardsItemTypeTitle:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeTitle
	case ClaimRewardsResponseClaimedRewardsItemTypeCosmetic:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeCosmetic
	case ClaimRewardsResponseClaimedRewardsItemTypeAbility:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeAbility
	case ClaimRewardsResponseClaimedRewardsItemTypeReputation:
		*s = ClaimRewardsResponseClaimedRewardsItemTypeReputation
	default:
		*s = ClaimRewardsResponseClaimedRewardsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClaimRewardsResponseClaimedRewardsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsResponseClaimedRewardsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardsResponseFailedRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardsResponseFailedRewardsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRewardsResponseFailedRewardsItem = [2]string{
	0: "type",
	1: "reason",
}

// Decode decodes ClaimRewardsResponseFailedRewardsItem from json.
func (s *ClaimRewardsResponseFailedRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsResponseFailedRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardsResponseFailedRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardsResponseFailedRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsResponseFailedRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardsResponseInventoryUpdatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardsResponseInventoryUpdatesItem) encodeFields(e *jx.Encoder) {
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		if s.QuantityChange.Set {
			e.FieldStart("quantity_change")
			s.QuantityChange.Encode(e)
		}
	}
	{
		if s.NewTotal.Set {
			e.FieldStart("new_total")
			s.NewTotal.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRewardsResponseInventoryUpdatesItem = [3]string{
	0: "item_id",
	1: "quantity_change",
	2: "new_total",
}

// Decode decodes ClaimRewardsResponseInventoryUpdatesItem from json.
func (s *ClaimRewardsResponseInventoryUpdatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardsResponseInventoryUpdatesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "quantity_change":
			if err := func() error {
				s.QuantityChange.Reset()
				if err := s.QuantityChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity_change\"")
			}
		case "new_total":
			if err := func() error {
				s.NewTotal.Reset()
				if err := s.NewTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardsResponseInventoryUpdatesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardsResponseInventoryUpdatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardsResponseInventoryUpdatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAchievementRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAchievementRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		e.FieldStart("requirements")
		e.ArrStart()
		for _, elem := range s.Requirements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("is_hidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.IsRepeatable.Set {
			e.FieldStart("is_repeatable")
			s.IsRepeatable.Encode(e)
		}
	}
	{
		if s.MaxCompletions.Set {
			e.FieldStart("max_completions")
			s.MaxCompletions.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		if s.PointsValue.Set {
			e.FieldStart("points_value")
			s.PointsValue.Encode(e)
		}
	}
	{
		if s.UnlockRequirements != nil {
			e.FieldStart("unlock_requirements")
			e.ArrStart()
			for _, elem := range s.UnlockRequirements {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateAchievementRequest = [12]string{
	0:  "name",
	1:  "description",
	2:  "category",
	3:  "icon_url",
	4:  "requirements",
	5:  "rewards",
	6:  "is_hidden",
	7:  "is_repeatable",
	8:  "max_completions",
	9:  "difficulty",
	10: "points_value",
	11: "unlock_requirements",
}

// Decode decodes CreateAchievementRequest from json.
func (s *CreateAchievementRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAchievementRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "requirements":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Requirements = make([]AchievementRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requirements = append(s.Requirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]AchievementReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "is_hidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_hidden\"")
			}
		case "is_repeatable":
			if err := func() error {
				s.IsRepeatable.Reset()
				if err := s.IsRepeatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_repeatable\"")
			}
		case "max_completions":
			if err := func() error {
				s.MaxCompletions.Reset()
				if err := s.MaxCompletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completions\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "points_value":
			if err := func() error {
				s.PointsValue.Reset()
				if err := s.PointsValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_value\"")
			}
		case "unlock_requirements":
			if err := func() error {
				s.UnlockRequirements = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.UnlockRequirements = append(s.UnlockRequirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlock_requirements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAchievementRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAchievementRequest) {
					name = jsonFieldsNameOfCreateAchievementRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAchievementRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAchievementRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAchievementRequestCategory as json.
func (s CreateAchievementRequestCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateAchievementRequestCategory from json.
func (s *CreateAchievementRequestCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAchievementRequestCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateAchievementRequestCategory(v) {
	case CreateAchievementRequestCategoryCombat:
		*s = CreateAchievementRequestCategoryCombat
	case CreateAchievementRequestCategoryExploration:
		*s = CreateAchievementRequestCategoryExploration
	case CreateAchievementRequestCategorySocial:
		*s = CreateAchievementRequestCategorySocial
	case CreateAchievementRequestCategoryProgression:
		*s = CreateAchievementRequestCategoryProgression
	case CreateAchievementRequestCategoryCollection:
		*s = CreateAchievementRequestCategoryCollection
	case CreateAchievementRequestCategoryChallenge:
		*s = CreateAchievementRequestCategoryChallenge
	default:
		*s = CreateAchievementRequestCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAchievementRequestCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAchievementRequestCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAchievementRequestDifficulty as json.
func (s CreateAchievementRequestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateAchievementRequestDifficulty from json.
func (s *CreateAchievementRequestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAchievementRequestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateAchievementRequestDifficulty(v) {
	case CreateAchievementRequestDifficultyEasy:
		*s = CreateAchievementRequestDifficultyEasy
	case CreateAchievementRequestDifficultyMedium:
		*s = CreateAchievementRequestDifficultyMedium
	case CreateAchievementRequestDifficultyHard:
		*s = CreateAchievementRequestDifficultyHard
	case CreateAchievementRequestDifficultyLegendary:
		*s = CreateAchievementRequestDifficultyLegendary
	default:
		*s = CreateAchievementRequestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAchievementRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAchievementRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAchievementRecommendationsNotFoundApplicationJSON as json.
func (s GetAchievementRecommendationsNotFoundApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetAchievementRecommendationsNotFoundApplicationJSON from json.
func (s *GetAchievementRecommendationsNotFoundApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAchievementRecommendationsNotFoundApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAchievementRecommendationsNotFoundApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAchievementRecommendationsNotFoundApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAchievementRecommendationsNotFoundApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAchievementRecommendationsOKApplicationJSON as json.
func (s GetAchievementRecommendationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetAchievementRecommendationsOKApplicationJSON from json.
func (s *GetAchievementRecommendationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAchievementRecommendationsOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAchievementRecommendationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAchievementRecommendationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAchievementRecommendationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("leaderboard")
		e.ArrStart()
		for _, elem := range s.Leaderboard {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TotalEntries.Set {
			e.FieldStart("total_entries")
			s.TotalEntries.Encode(e)
		}
	}
	{
		if s.Timeframe.Set {
			e.FieldStart("timeframe")
			s.Timeframe.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardResponse = [4]string{
	0: "leaderboard",
	1: "total_entries",
	2: "timeframe",
	3: "category",
}

// Decode decodes LeaderboardResponse from json.
func (s *LeaderboardResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leaderboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Leaderboard = make([]LeaderboardResponseLeaderboardItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeaderboardResponseLeaderboardItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Leaderboard = append(s.Leaderboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard\"")
			}
		case "total_entries":
			if err := func() error {
				s.TotalEntries.Reset()
				if err := s.TotalEntries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_entries\"")
			}
		case "timeframe":
			if err := func() error {
				s.Timeframe.Reset()
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardResponse) {
					name = jsonFieldsNameOfLeaderboardResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardResponseLeaderboardItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardResponseLeaderboardItem) encodeFields(e *jx.Encoder) {
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
	{
		if s.CharacterID.Set {
			e.FieldStart("character_id")
			s.CharacterID.Encode(e)
		}
	}
	{
		if s.CharacterName.Set {
			e.FieldStart("character_name")
			s.CharacterName.Encode(e)
		}
	}
	{
		if s.AchievementPoints.Set {
			e.FieldStart("achievement_points")
			s.AchievementPoints.Encode(e)
		}
	}
	{
		if s.AchievementsCompleted.Set {
			e.FieldStart("achievements_completed")
			s.AchievementsCompleted.Encode(e)
		}
	}
	{
		if s.LastCompletion.Set {
			e.FieldStart("last_completion")
			s.LastCompletion.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CategoryFocus.Set {
			e.FieldStart("category_focus")
			s.CategoryFocus.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardResponseLeaderboardItem = [7]string{
	0: "rank",
	1: "character_id",
	2: "character_name",
	3: "achievement_points",
	4: "achievements_completed",
	5: "last_completion",
	6: "category_focus",
}

// Decode decodes LeaderboardResponseLeaderboardItem from json.
func (s *LeaderboardResponseLeaderboardItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardResponseLeaderboardItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "character_id":
			if err := func() error {
				s.CharacterID.Reset()
				if err := s.CharacterID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "character_name":
			if err := func() error {
				s.CharacterName.Reset()
				if err := s.CharacterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_name\"")
			}
		case "achievement_points":
			if err := func() error {
				s.AchievementPoints.Reset()
				if err := s.AchievementPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_points\"")
			}
		case "achievements_completed":
			if err := func() error {
				s.AchievementsCompleted.Reset()
				if err := s.AchievementsCompleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_completed\"")
			}
		case "last_completion":
			if err := func() error {
				s.LastCompletion.Reset()
				if err := s.LastCompletion.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_completion\"")
			}
		case "category_focus":
			if err := func() error {
				s.CategoryFocus.Reset()
				if err := s.CategoryFocus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_focus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardResponseLeaderboardItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardResponseLeaderboardItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardResponseLeaderboardItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardResponseLeaderboardItemCategoryFocus as json.
func (s LeaderboardResponseLeaderboardItemCategoryFocus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LeaderboardResponseLeaderboardItemCategoryFocus from json.
func (s *LeaderboardResponseLeaderboardItemCategoryFocus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardResponseLeaderboardItemCategoryFocus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LeaderboardResponseLeaderboardItemCategoryFocus(v) {
	case LeaderboardResponseLeaderboardItemCategoryFocusCombat:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusCombat
	case LeaderboardResponseLeaderboardItemCategoryFocusExploration:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusExploration
	case LeaderboardResponseLeaderboardItemCategoryFocusSocial:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusSocial
	case LeaderboardResponseLeaderboardItemCategoryFocusProgression:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusProgression
	case LeaderboardResponseLeaderboardItemCategoryFocusCollection:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusCollection
	case LeaderboardResponseLeaderboardItemCategoryFocusChallenge:
		*s = LeaderboardResponseLeaderboardItemCategoryFocusChallenge
	default:
		*s = LeaderboardResponseLeaderboardItemCategoryFocus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeaderboardResponseLeaderboardItemCategoryFocus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardResponseLeaderboardItemCategoryFocus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAchievementsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAchievementsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Pagination.Set {
			e.FieldStart("pagination")
			s.Pagination.Encode(e)
		}
	}
	{
		e.FieldStart("achievements")
		e.ArrStart()
		for _, elem := range s.Achievements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_count")
		e.Int32(s.TotalCount)
	}
	{
		if s.FiltersApplied.Set {
			e.FieldStart("filters_applied")
			s.FiltersApplied.Encode(e)
		}
	}
}

var jsonFieldsNameOfListAchievementsResponse = [4]string{
	0: "pagination",
	1: "achievements",
	2: "total_count",
	3: "filters_applied",
}

// Decode decodes ListAchievementsResponse from json.
func (s *ListAchievementsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAchievementsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pagination":
			if err := func() error {
				s.Pagination.Reset()
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		case "achievements":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Achievements = make([]AchievementResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TotalCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "filters_applied":
			if err := func() error {
				s.FiltersApplied.Reset()
				if err := s.FiltersApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters_applied\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAchievementsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListAchievementsResponse) {
					name = jsonFieldsNameOfListAchievementsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAchievementsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAchievementsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAchievementsResponseFiltersApplied) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAchievementsResponseFiltersApplied) encodeFields(e *jx.Encoder) {
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfListAchievementsResponseFiltersApplied = [2]string{
	0: "category",
	1: "status",
}

// Decode decodes ListAchievementsResponseFiltersApplied from json.
func (s *ListAchievementsResponseFiltersApplied) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAchievementsResponseFiltersApplied to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAchievementsResponseFiltersApplied")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAchievementsResponseFiltersApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAchievementsResponseFiltersApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAchievementsResponsePagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAchievementsResponsePagination) encodeFields(e *jx.Encoder) {
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.HasMore.Set {
			e.FieldStart("has_more")
			s.HasMore.Encode(e)
		}
	}
}

var jsonFieldsNameOfListAchievementsResponsePagination = [3]string{
	0: "offset",
	1: "limit",
	2: "has_more",
}

// Decode decodes ListAchievementsResponsePagination from json.
func (s *ListAchievementsResponsePagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAchievementsResponsePagination to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "has_more":
			if err := func() error {
				s.HasMore.Reset()
				if err := s.HasMore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAchievementsResponsePagination")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAchievementsResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAchievementsResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OK) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfOK = [2]string{
	0: "success",
	1: "message",
}

// Decode decodes OK from json.
func (s *OK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementDifficulty as json.
func (o OptAchievementDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AchievementDifficulty from json.
func (o *OptAchievementDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAchievementDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAchievementDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAchievementDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementProgress as json.
func (o OptAchievementProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AchievementProgress from json.
func (o *OptAchievementProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAchievementProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAchievementProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAchievementProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRewardCurrencyType as json.
func (o OptAchievementRewardCurrencyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AchievementRewardCurrencyType from json.
func (o *OptAchievementRewardCurrencyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAchievementRewardCurrencyType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAchievementRewardCurrencyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAchievementRewardCurrencyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalyticsSummaryResponseSummaryCategoryBreakdown as json.
func (o OptAnalyticsSummaryResponseSummaryCategoryBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnalyticsSummaryResponseSummaryCategoryBreakdown from json.
func (o *OptAnalyticsSummaryResponseSummaryCategoryBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnalyticsSummaryResponseSummaryCategoryBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnalyticsSummaryResponseSummaryCategoryBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnalyticsSummaryResponseSummaryCategoryBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchUpdateProgressResponseSummary as json.
func (o OptBatchUpdateProgressResponseSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BatchUpdateProgressResponseSummary from json.
func (o *OptBatchUpdateProgressResponseSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchUpdateProgressResponseSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchUpdateProgressResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchUpdateProgressResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardsResponseClaimedRewardsItemType as json.
func (o OptClaimRewardsResponseClaimedRewardsItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ClaimRewardsResponseClaimedRewardsItemType from json.
func (o *OptClaimRewardsResponseClaimedRewardsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClaimRewardsResponseClaimedRewardsItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClaimRewardsResponseClaimedRewardsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClaimRewardsResponseClaimedRewardsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAchievementRequestDifficulty as json.
func (o OptCreateAchievementRequestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateAchievementRequestDifficulty from json.
func (o *OptCreateAchievementRequestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateAchievementRequestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateAchievementRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateAchievementRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardResponseLeaderboardItemCategoryFocus as json.
func (o OptLeaderboardResponseLeaderboardItemCategoryFocus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LeaderboardResponseLeaderboardItemCategoryFocus from json.
func (o *OptLeaderboardResponseLeaderboardItemCategoryFocus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeaderboardResponseLeaderboardItemCategoryFocus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeaderboardResponseLeaderboardItemCategoryFocus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeaderboardResponseLeaderboardItemCategoryFocus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAchievementsResponseFiltersApplied as json.
func (o OptListAchievementsResponseFiltersApplied) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ListAchievementsResponseFiltersApplied from json.
func (o *OptListAchievementsResponseFiltersApplied) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListAchievementsResponseFiltersApplied to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListAchievementsResponseFiltersApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListAchievementsResponseFiltersApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAchievementsResponsePagination as json.
func (o OptListAchievementsResponsePagination) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ListAchievementsResponsePagination from json.
func (o *OptListAchievementsResponsePagination) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListAchievementsResponsePagination to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListAchievementsResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListAchievementsResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsRequestBatchMetadata as json.
func (o OptProcessEventsRequestBatchMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProcessEventsRequestBatchMetadata from json.
func (o *OptProcessEventsRequestBatchMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessEventsRequestBatchMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessEventsRequestBatchMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessEventsRequestBatchMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsRequestBatchMetadataProcessingPriority as json.
func (o OptProcessEventsRequestBatchMetadataProcessingPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProcessEventsRequestBatchMetadataProcessingPriority from json.
func (o *OptProcessEventsRequestBatchMetadataProcessingPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessEventsRequestBatchMetadataProcessingPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessEventsRequestBatchMetadataProcessingPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessEventsRequestBatchMetadataProcessingPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsRequestEventsItemLocation as json.
func (o OptProcessEventsRequestEventsItemLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProcessEventsRequestEventsItemLocation from json.
func (o *OptProcessEventsRequestEventsItemLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessEventsRequestEventsItemLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessEventsRequestEventsItemLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessEventsRequestEventsItemLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsResponseNotificationsItemType as json.
func (o OptProcessEventsResponseNotificationsItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProcessEventsResponseNotificationsItemType from json.
func (o *OptProcessEventsResponseNotificationsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessEventsResponseNotificationsItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessEventsResponseNotificationsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessEventsResponseNotificationsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsResponseProcessingStats as json.
func (o OptProcessEventsResponseProcessingStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProcessEventsResponseProcessingStats from json.
func (o *OptProcessEventsResponseProcessingStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessEventsResponseProcessingStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessEventsResponseProcessingStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessEventsResponseProcessingStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrainingResponseStatus as json.
func (o OptTrainingResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrainingResponseStatus from json.
func (o *OptTrainingResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrainingResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrainingResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrainingResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAchievementRequestCategory as json.
func (o OptUpdateAchievementRequestCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateAchievementRequestCategory from json.
func (o *OptUpdateAchievementRequestCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateAchievementRequestCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateAchievementRequestCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateAchievementRequestCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAchievementRequestDifficulty as json.
func (o OptUpdateAchievementRequestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateAchievementRequestDifficulty from json.
func (o *OptUpdateAchievementRequestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateAchievementRequestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateAchievementRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateAchievementRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateProgressRequestEventContext as json.
func (o OptUpdateProgressRequestEventContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateProgressRequestEventContext from json.
func (o *OptUpdateProgressRequestEventContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateProgressRequestEventContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateProgressRequestEventContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateProgressRequestEventContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateProgressRequestEventContextLocation as json.
func (o OptUpdateProgressRequestEventContextLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateProgressRequestEventContextLocation from json.
func (o *OptUpdateProgressRequestEventContextLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateProgressRequestEventContextLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateProgressRequestEventContextLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateProgressRequestEventContextLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateProgressRequestValidationContext as json.
func (o OptValidateProgressRequestValidationContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidateProgressRequestValidationContext from json.
func (o *OptValidateProgressRequestValidationContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidateProgressRequestValidationContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidateProgressRequestValidationContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidateProgressRequestValidationContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BatchMetadata.Set {
			e.FieldStart("batch_metadata")
			s.BatchMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsRequest = [3]string{
	0: "character_id",
	1: "events",
	2: "batch_metadata",
}

// Decode decodes ProcessEventsRequest from json.
func (s *ProcessEventsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Events = make([]ProcessEventsRequestEventsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProcessEventsRequestEventsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "batch_metadata":
			if err := func() error {
				s.BatchMetadata.Reset()
				if err := s.BatchMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProcessEventsRequest) {
					name = jsonFieldsNameOfProcessEventsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsRequestBatchMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsRequestBatchMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.ClientVersion.Set {
			e.FieldStart("client_version")
			s.ClientVersion.Encode(e)
		}
	}
	{
		if s.ProcessingPriority.Set {
			e.FieldStart("processing_priority")
			s.ProcessingPriority.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsRequestBatchMetadata = [3]string{
	0: "session_id",
	1: "client_version",
	2: "processing_priority",
}

// Decode decodes ProcessEventsRequestBatchMetadata from json.
func (s *ProcessEventsRequestBatchMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestBatchMetadata to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "client_version":
			if err := func() error {
				s.ClientVersion.Reset()
				if err := s.ClientVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_version\"")
			}
		case "processing_priority":
			if err := func() error {
				s.ProcessingPriority.Reset()
				if err := s.ProcessingPriority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsRequestBatchMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsRequestBatchMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestBatchMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsRequestBatchMetadataProcessingPriority as json.
func (s ProcessEventsRequestBatchMetadataProcessingPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProcessEventsRequestBatchMetadataProcessingPriority from json.
func (s *ProcessEventsRequestBatchMetadataProcessingPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestBatchMetadataProcessingPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProcessEventsRequestBatchMetadataProcessingPriority(v) {
	case ProcessEventsRequestBatchMetadataProcessingPriorityLow:
		*s = ProcessEventsRequestBatchMetadataProcessingPriorityLow
	case ProcessEventsRequestBatchMetadataProcessingPriorityNormal:
		*s = ProcessEventsRequestBatchMetadataProcessingPriorityNormal
	case ProcessEventsRequestBatchMetadataProcessingPriorityHigh:
		*s = ProcessEventsRequestBatchMetadataProcessingPriorityHigh
	default:
		*s = ProcessEventsRequestBatchMetadataProcessingPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProcessEventsRequestBatchMetadataProcessingPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestBatchMetadataProcessingPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsRequestEventsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsRequestEventsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		if s.EntityID.Set {
			e.FieldStart("entity_id")
			s.EntityID.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		e.Int64(s.Timestamp)
	}
}

var jsonFieldsNameOfProcessEventsRequestEventsItem = [6]string{
	0: "event_type",
	1: "entity_id",
	2: "value",
	3: "location",
	4: "metadata",
	5: "timestamp",
}

// Decode decodes ProcessEventsRequestEventsItem from json.
func (s *ProcessEventsRequestEventsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestEventsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "entity_id":
			if err := func() error {
				s.EntityID.Reset()
				if err := s.EntityID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem ProcessEventsRequestEventsItemMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Timestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsRequestEventsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProcessEventsRequestEventsItem) {
					name = jsonFieldsNameOfProcessEventsRequestEventsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsRequestEventsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestEventsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsRequestEventsItemEventType as json.
func (s ProcessEventsRequestEventsItemEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProcessEventsRequestEventsItemEventType from json.
func (s *ProcessEventsRequestEventsItemEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestEventsItemEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProcessEventsRequestEventsItemEventType(v) {
	case ProcessEventsRequestEventsItemEventTypeEnemyKilled:
		*s = ProcessEventsRequestEventsItemEventTypeEnemyKilled
	case ProcessEventsRequestEventsItemEventTypeItemCollected:
		*s = ProcessEventsRequestEventsItemEventTypeItemCollected
	case ProcessEventsRequestEventsItemEventTypeQuestCompleted:
		*s = ProcessEventsRequestEventsItemEventTypeQuestCompleted
	case ProcessEventsRequestEventsItemEventTypeLocationDiscovered:
		*s = ProcessEventsRequestEventsItemEventTypeLocationDiscovered
	case ProcessEventsRequestEventsItemEventTypeSocialInteraction:
		*s = ProcessEventsRequestEventsItemEventTypeSocialInteraction
	case ProcessEventsRequestEventsItemEventTypeCombatStreak:
		*s = ProcessEventsRequestEventsItemEventTypeCombatStreak
	case ProcessEventsRequestEventsItemEventTypeDistanceTraveled:
		*s = ProcessEventsRequestEventsItemEventTypeDistanceTraveled
	case ProcessEventsRequestEventsItemEventTypeTimePlayed:
		*s = ProcessEventsRequestEventsItemEventTypeTimePlayed
	case ProcessEventsRequestEventsItemEventTypeLevelGained:
		*s = ProcessEventsRequestEventsItemEventTypeLevelGained
	case ProcessEventsRequestEventsItemEventTypeCurrencyEarned:
		*s = ProcessEventsRequestEventsItemEventTypeCurrencyEarned
	default:
		*s = ProcessEventsRequestEventsItemEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProcessEventsRequestEventsItemEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestEventsItemEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsRequestEventsItemLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsRequestEventsItemLocation) encodeFields(e *jx.Encoder) {
	{
		if s.X.Set {
			e.FieldStart("x")
			s.X.Encode(e)
		}
	}
	{
		if s.Y.Set {
			e.FieldStart("y")
			s.Y.Encode(e)
		}
	}
	{
		if s.Z.Set {
			e.FieldStart("z")
			s.Z.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsRequestEventsItemLocation = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes ProcessEventsRequestEventsItemLocation from json.
func (s *ProcessEventsRequestEventsItemLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestEventsItemLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			if err := func() error {
				s.X.Reset()
				if err := s.X.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			if err := func() error {
				s.Y.Reset()
				if err := s.Y.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			if err := func() error {
				s.Z.Reset()
				if err := s.Z.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsRequestEventsItemLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsRequestEventsItemLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestEventsItemLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsRequestEventsItemMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsRequestEventsItemMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProcessEventsRequestEventsItemMetadata = [0]string{}

// Decode decodes ProcessEventsRequestEventsItemMetadata from json.
func (s *ProcessEventsRequestEventsItemMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsRequestEventsItemMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsRequestEventsItemMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsRequestEventsItemMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsRequestEventsItemMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("processed_events")
		e.Int32(s.ProcessedEvents)
	}
	{
		e.FieldStart("progress_updates")
		e.ArrStart()
		for _, elem := range s.ProgressUpdates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NewUnlocks != nil {
			e.FieldStart("new_unlocks")
			e.ArrStart()
			for _, elem := range s.NewUnlocks {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProcessingStats.Set {
			e.FieldStart("processing_stats")
			s.ProcessingStats.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsResponse = [5]string{
	0: "processed_events",
	1: "progress_updates",
	2: "new_unlocks",
	3: "notifications",
	4: "processing_stats",
}

// Decode decodes ProcessEventsResponse from json.
func (s *ProcessEventsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processed_events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ProcessedEvents = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processed_events\"")
			}
		case "progress_updates":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ProgressUpdates = make([]ProcessEventsResponseProgressUpdatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProcessEventsResponseProgressUpdatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProgressUpdates = append(s.ProgressUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_updates\"")
			}
		case "new_unlocks":
			if err := func() error {
				s.NewUnlocks = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.NewUnlocks = append(s.NewUnlocks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_unlocks\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]ProcessEventsResponseNotificationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProcessEventsResponseNotificationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "processing_stats":
			if err := func() error {
				s.ProcessingStats.Reset()
				if err := s.ProcessingStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProcessEventsResponse) {
					name = jsonFieldsNameOfProcessEventsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsResponseNotificationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsResponseNotificationsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.AchievementID.Set {
			e.FieldStart("achievement_id")
			s.AchievementID.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsResponseNotificationsItem = [3]string{
	0: "type",
	1: "achievement_id",
	2: "message",
}

// Decode decodes ProcessEventsResponseNotificationsItem from json.
func (s *ProcessEventsResponseNotificationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsResponseNotificationsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "achievement_id":
			if err := func() error {
				s.AchievementID.Reset()
				if err := s.AchievementID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsResponseNotificationsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsResponseNotificationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsResponseNotificationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessEventsResponseNotificationsItemType as json.
func (s ProcessEventsResponseNotificationsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProcessEventsResponseNotificationsItemType from json.
func (s *ProcessEventsResponseNotificationsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsResponseNotificationsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProcessEventsResponseNotificationsItemType(v) {
	case ProcessEventsResponseNotificationsItemTypeProgressUpdate:
		*s = ProcessEventsResponseNotificationsItemTypeProgressUpdate
	case ProcessEventsResponseNotificationsItemTypeAchievementUnlocked:
		*s = ProcessEventsResponseNotificationsItemTypeAchievementUnlocked
	case ProcessEventsResponseNotificationsItemTypeRewardAvailable:
		*s = ProcessEventsResponseNotificationsItemTypeRewardAvailable
	default:
		*s = ProcessEventsResponseNotificationsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProcessEventsResponseNotificationsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsResponseNotificationsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsResponseProcessingStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsResponseProcessingStats) encodeFields(e *jx.Encoder) {
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
	{
		if s.EventsPerSecond.Set {
			e.FieldStart("events_per_second")
			s.EventsPerSecond.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsResponseProcessingStats = [2]string{
	0: "processing_time_ms",
	1: "events_per_second",
}

// Decode decodes ProcessEventsResponseProcessingStats from json.
func (s *ProcessEventsResponseProcessingStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsResponseProcessingStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		case "events_per_second":
			if err := func() error {
				s.EventsPerSecond.Reset()
				if err := s.EventsPerSecond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_per_second\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsResponseProcessingStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsResponseProcessingStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsResponseProcessingStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessEventsResponseProgressUpdatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessEventsResponseProgressUpdatesItem) encodeFields(e *jx.Encoder) {
	{
		if s.AchievementID.Set {
			e.FieldStart("achievement_id")
			s.AchievementID.Encode(e)
		}
	}
	{
		if s.OldProgress.Set {
			e.FieldStart("old_progress")
			s.OldProgress.Encode(e)
		}
	}
	{
		if s.NewProgress.Set {
			e.FieldStart("new_progress")
			s.NewProgress.Encode(e)
		}
	}
	{
		if s.TargetProgress.Set {
			e.FieldStart("target_progress")
			s.TargetProgress.Encode(e)
		}
	}
	{
		if s.Unlocked.Set {
			e.FieldStart("unlocked")
			s.Unlocked.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessEventsResponseProgressUpdatesItem = [5]string{
	0: "achievement_id",
	1: "old_progress",
	2: "new_progress",
	3: "target_progress",
	4: "unlocked",
}

// Decode decodes ProcessEventsResponseProgressUpdatesItem from json.
func (s *ProcessEventsResponseProgressUpdatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessEventsResponseProgressUpdatesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			if err := func() error {
				s.AchievementID.Reset()
				if err := s.AchievementID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "old_progress":
			if err := func() error {
				s.OldProgress.Reset()
				if err := s.OldProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_progress\"")
			}
		case "new_progress":
			if err := func() error {
				s.NewProgress.Reset()
				if err := s.NewProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_progress\"")
			}
		case "target_progress":
			if err := func() error {
				s.TargetProgress.Reset()
				if err := s.TargetProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_progress\"")
			}
		case "unlocked":
			if err := func() error {
				s.Unlocked.Reset()
				if err := s.Unlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlocked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessEventsResponseProgressUpdatesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessEventsResponseProgressUpdatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessEventsResponseProgressUpdatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			e.FieldStart("retry_after")
			s.RetryAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfTooManyRequests = [4]string{
	0: "code",
	1: "message",
	2: "details",
	3: "retry_after",
}

// Decode decodes TooManyRequests from json.
func (s *TooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem TooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "retry_after":
			if err := func() error {
				s.RetryAfter.Reset()
				if err := s.RetryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_after\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTooManyRequests) {
					name = jsonFieldsNameOfTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTooManyRequestsDetails = [0]string{}

// Decode decodes TooManyRequestsDetails from json.
func (s *TooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrainingResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrainingResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TrainingDataID.Set {
			e.FieldStart("training_data_id")
			s.TrainingDataID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrainingResponse = [3]string{
	0: "training_data_id",
	1: "status",
	2: "message",
}

// Decode decodes TrainingResponse from json.
func (s *TrainingResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrainingResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "training_data_id":
			if err := func() error {
				s.TrainingDataID.Reset()
				if err := s.TrainingDataID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"training_data_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrainingResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrainingResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrainingResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrainingResponseStatus as json.
func (s TrainingResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrainingResponseStatus from json.
func (s *TrainingResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrainingResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrainingResponseStatus(v) {
	case TrainingResponseStatusAccepted:
		*s = TrainingResponseStatusAccepted
	case TrainingResponseStatusProcessed:
		*s = TrainingResponseStatusProcessed
	case TrainingResponseStatusRejected:
		*s = TrainingResponseStatusRejected
	default:
		*s = TrainingResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrainingResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrainingResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Unauthorized from json.
func (s *Unauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorized) {
					name = jsonFieldsNameOfUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUnauthorizedDetails = [0]string{}

// Decode decodes UnauthorizedDetails from json.
func (s *UnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnlockAchievementRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnlockAchievementRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		if s.ForceUnlock.Set {
			e.FieldStart("force_unlock")
			s.ForceUnlock.Encode(e)
		}
	}
	{
		if s.SkipRewards.Set {
			e.FieldStart("skip_rewards")
			s.SkipRewards.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnlockAchievementRequest = [3]string{
	0: "character_id",
	1: "force_unlock",
	2: "skip_rewards",
}

// Decode decodes UnlockAchievementRequest from json.
func (s *UnlockAchievementRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnlockAchievementRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "force_unlock":
			if err := func() error {
				s.ForceUnlock.Reset()
				if err := s.ForceUnlock.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_unlock\"")
			}
		case "skip_rewards":
			if err := func() error {
				s.SkipRewards.Reset()
				if err := s.SkipRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip_rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnlockAchievementRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnlockAchievementRequest) {
					name = jsonFieldsNameOfUnlockAchievementRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnlockAchievementRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnlockAchievementRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAchievementRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAchievementRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		if s.Requirements != nil {
			e.FieldStart("requirements")
			e.ArrStart()
			for _, elem := range s.Requirements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("is_hidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.IsRepeatable.Set {
			e.FieldStart("is_repeatable")
			s.IsRepeatable.Encode(e)
		}
	}
	{
		if s.MaxCompletions.Set {
			e.FieldStart("max_completions")
			s.MaxCompletions.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		if s.PointsValue.Set {
			e.FieldStart("points_value")
			s.PointsValue.Encode(e)
		}
	}
	{
		if s.UnlockRequirements != nil {
			e.FieldStart("unlock_requirements")
			e.ArrStart()
			for _, elem := range s.UnlockRequirements {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateAchievementRequest = [13]string{
	0:  "name",
	1:  "description",
	2:  "category",
	3:  "icon_url",
	4:  "requirements",
	5:  "rewards",
	6:  "is_hidden",
	7:  "is_repeatable",
	8:  "max_completions",
	9:  "difficulty",
	10: "points_value",
	11: "unlock_requirements",
	12: "is_active",
}

// Decode decodes UpdateAchievementRequest from json.
func (s *UpdateAchievementRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAchievementRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "requirements":
			if err := func() error {
				s.Requirements = make([]AchievementRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requirements = append(s.Requirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]AchievementReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "is_hidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_hidden\"")
			}
		case "is_repeatable":
			if err := func() error {
				s.IsRepeatable.Reset()
				if err := s.IsRepeatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_repeatable\"")
			}
		case "max_completions":
			if err := func() error {
				s.MaxCompletions.Reset()
				if err := s.MaxCompletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completions\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "points_value":
			if err := func() error {
				s.PointsValue.Reset()
				if err := s.PointsValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_value\"")
			}
		case "unlock_requirements":
			if err := func() error {
				s.UnlockRequirements = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.UnlockRequirements = append(s.UnlockRequirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlock_requirements\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAchievementRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAchievementRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAchievementRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAchievementRequestCategory as json.
func (s UpdateAchievementRequestCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateAchievementRequestCategory from json.
func (s *UpdateAchievementRequestCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAchievementRequestCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateAchievementRequestCategory(v) {
	case UpdateAchievementRequestCategoryCombat:
		*s = UpdateAchievementRequestCategoryCombat
	case UpdateAchievementRequestCategoryExploration:
		*s = UpdateAchievementRequestCategoryExploration
	case UpdateAchievementRequestCategorySocial:
		*s = UpdateAchievementRequestCategorySocial
	case UpdateAchievementRequestCategoryProgression:
		*s = UpdateAchievementRequestCategoryProgression
	case UpdateAchievementRequestCategoryCollection:
		*s = UpdateAchievementRequestCategoryCollection
	case UpdateAchievementRequestCategoryChallenge:
		*s = UpdateAchievementRequestCategoryChallenge
	default:
		*s = UpdateAchievementRequestCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAchievementRequestCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAchievementRequestCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAchievementRequestDifficulty as json.
func (s UpdateAchievementRequestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateAchievementRequestDifficulty from json.
func (s *UpdateAchievementRequestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAchievementRequestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateAchievementRequestDifficulty(v) {
	case UpdateAchievementRequestDifficultyEasy:
		*s = UpdateAchievementRequestDifficultyEasy
	case UpdateAchievementRequestDifficultyMedium:
		*s = UpdateAchievementRequestDifficultyMedium
	case UpdateAchievementRequestDifficultyHard:
		*s = UpdateAchievementRequestDifficultyHard
	case UpdateAchievementRequestDifficultyLegendary:
		*s = UpdateAchievementRequestDifficultyLegendary
	default:
		*s = UpdateAchievementRequestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAchievementRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAchievementRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProgressRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProgressRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("achievement_id")
		json.EncodeUUID(e, s.AchievementID)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("progress_increment")
		e.Int(s.ProgressIncrement)
	}
	{
		if s.EventContext.Set {
			e.FieldStart("event_context")
			s.EventContext.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProgressRequest = [6]string{
	0: "achievement_id",
	1: "character_id",
	2: "progress_increment",
	3: "event_context",
	4: "timestamp",
	5: "version",
}

// Decode decodes UpdateProgressRequest from json.
func (s *UpdateProgressRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProgressRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AchievementID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "progress_increment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ProgressIncrement = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_increment\"")
			}
		case "event_context":
			if err := func() error {
				s.EventContext.Reset()
				if err := s.EventContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_context\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProgressRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateProgressRequest) {
					name = jsonFieldsNameOfUpdateProgressRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProgressRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProgressRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProgressRequestEventContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProgressRequestEventContext) encodeFields(e *jx.Encoder) {
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
	{
		if s.EntityID.Set {
			e.FieldStart("entity_id")
			s.EntityID.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProgressRequestEventContext = [4]string{
	0: "event_type",
	1: "entity_id",
	2: "location",
	3: "metadata",
}

// Decode decodes UpdateProgressRequestEventContext from json.
func (s *UpdateProgressRequestEventContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProgressRequestEventContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "entity_id":
			if err := func() error {
				s.EntityID.Reset()
				if err := s.EntityID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem UpdateProgressRequestEventContextMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProgressRequestEventContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProgressRequestEventContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProgressRequestEventContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProgressRequestEventContextLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProgressRequestEventContextLocation) encodeFields(e *jx.Encoder) {
	{
		if s.X.Set {
			e.FieldStart("x")
			s.X.Encode(e)
		}
	}
	{
		if s.Y.Set {
			e.FieldStart("y")
			s.Y.Encode(e)
		}
	}
	{
		if s.Z.Set {
			e.FieldStart("z")
			s.Z.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProgressRequestEventContextLocation = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes UpdateProgressRequestEventContextLocation from json.
func (s *UpdateProgressRequestEventContextLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProgressRequestEventContextLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			if err := func() error {
				s.X.Reset()
				if err := s.X.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			if err := func() error {
				s.Y.Reset()
				if err := s.Y.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			if err := func() error {
				s.Z.Reset()
				if err := s.Z.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProgressRequestEventContextLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProgressRequestEventContextLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProgressRequestEventContextLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProgressRequestEventContextMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProgressRequestEventContextMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateProgressRequestEventContextMetadata = [0]string{}

// Decode decodes UpdateProgressRequestEventContextMetadata from json.
func (s *UpdateProgressRequestEventContextMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProgressRequestEventContextMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProgressRequestEventContextMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProgressRequestEventContextMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProgressRequestEventContextMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProgressResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("new_progress")
		s.NewProgress.Encode(e)
	}
	{
		if s.AchievementUnlocked.Set {
			e.FieldStart("achievement_unlocked")
			s.AchievementUnlocked.Encode(e)
		}
	}
	{
		if s.RewardsAvailable.Set {
			e.FieldStart("rewards_available")
			s.RewardsAvailable.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateProgressResponse = [5]string{
	0: "success",
	1: "new_progress",
	2: "achievement_unlocked",
	3: "rewards_available",
	4: "notifications",
}

// Decode decodes UpdateProgressResponse from json.
func (s *UpdateProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProgressResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "new_progress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NewProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_progress\"")
			}
		case "achievement_unlocked":
			if err := func() error {
				s.AchievementUnlocked.Reset()
				if err := s.AchievementUnlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_unlocked\"")
			}
		case "rewards_available":
			if err := func() error {
				s.RewardsAvailable.Reset()
				if err := s.RewardsAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards_available\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProgressResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateProgressResponse) {
					name = jsonFieldsNameOfUpdateProgressResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateProgressRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateProgressRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("achievement_id")
		json.EncodeUUID(e, s.AchievementID)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("claimed_progress")
		e.Int(s.ClaimedProgress)
	}
	{
		if s.ClientHash.Set {
			e.FieldStart("client_hash")
			s.ClientHash.Encode(e)
		}
	}
	{
		if s.ValidationContext.Set {
			e.FieldStart("validation_context")
			s.ValidationContext.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidateProgressRequest = [5]string{
	0: "achievement_id",
	1: "character_id",
	2: "claimed_progress",
	3: "client_hash",
	4: "validation_context",
}

// Decode decodes ValidateProgressRequest from json.
func (s *ValidateProgressRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateProgressRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AchievementID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "claimed_progress":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ClaimedProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_progress\"")
			}
		case "client_hash":
			if err := func() error {
				s.ClientHash.Reset()
				if err := s.ClientHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_hash\"")
			}
		case "validation_context":
			if err := func() error {
				s.ValidationContext.Reset()
				if err := s.ValidationContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateProgressRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateProgressRequest) {
					name = jsonFieldsNameOfValidateProgressRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateProgressRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateProgressRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateProgressRequestValidationContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateProgressRequestValidationContext) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.RecentEvents != nil {
			e.FieldStart("recent_events")
			e.ArrStart()
			for _, elem := range s.RecentEvents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidateProgressRequestValidationContext = [3]string{
	0: "timestamp",
	1: "session_id",
	2: "recent_events",
}

// Decode decodes ValidateProgressRequestValidationContext from json.
func (s *ValidateProgressRequestValidationContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateProgressRequestValidationContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "recent_events":
			if err := func() error {
				s.RecentEvents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RecentEvents = append(s.RecentEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recent_events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateProgressRequestValidationContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateProgressRequestValidationContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateProgressRequestValidationContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateProgressResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ValidationToken.Set {
			e.FieldStart("validation_token")
			s.ValidationToken.Encode(e)
		}
	}
	{
		if s.Violations != nil {
			e.FieldStart("violations")
			e.ArrStart()
			for _, elem := range s.Violations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ServerProgress.Set {
			e.FieldStart("server_progress")
			s.ServerProgress.Encode(e)
		}
	}
	{
		if s.ClaimedProgress.Set {
			e.FieldStart("claimed_progress")
			s.ClaimedProgress.Encode(e)
		}
	}
	{
		if s.ConfidenceScore.Set {
			e.FieldStart("confidence_score")
			s.ConfidenceScore.Encode(e)
		}
	}
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
}

var jsonFieldsNameOfValidateProgressResponse = [6]string{
	0: "validation_token",
	1: "violations",
	2: "server_progress",
	3: "claimed_progress",
	4: "confidence_score",
	5: "is_valid",
}

// Decode decodes ValidateProgressResponse from json.
func (s *ValidateProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateProgressResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "validation_token":
			if err := func() error {
				s.ValidationToken.Reset()
				if err := s.ValidationToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_token\"")
			}
		case "violations":
			if err := func() error {
				s.Violations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Violations = append(s.Violations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violations\"")
			}
		case "server_progress":
			if err := func() error {
				s.ServerProgress.Reset()
				if err := s.ServerProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_progress\"")
			}
		case "claimed_progress":
			if err := func() error {
				s.ClaimedProgress.Reset()
				if err := s.ClaimedProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_progress\"")
			}
		case "confidence_score":
			if err := func() error {
				s.ConfidenceScore.Reset()
				if err := s.ConfidenceScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence_score\"")
			}
		case "is_valid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateProgressResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateProgressResponse) {
					name = jsonFieldsNameOfValidateProgressResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
