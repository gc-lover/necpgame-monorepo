// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AiBehaviorServiceHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AiBehaviorServiceHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfAiBehaviorServiceHealthCheckOK = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes AiBehaviorServiceHealthCheckOK from json.
func (s *AiBehaviorServiceHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AiBehaviorServiceHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAiBehaviorServiceHealthCheckOK) {
					name = jsonFieldsNameOfAiBehaviorServiceHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AiBehaviorServiceHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AiBehaviorServiceHealthCheckOKStatus as json.
func (s AiBehaviorServiceHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AiBehaviorServiceHealthCheckOKStatus from json.
func (s *AiBehaviorServiceHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AiBehaviorServiceHealthCheckOKStatus(v) {
	case AiBehaviorServiceHealthCheckOKStatusHealthy:
		*s = AiBehaviorServiceHealthCheckOKStatusHealthy
	case AiBehaviorServiceHealthCheckOKStatusDegraded:
		*s = AiBehaviorServiceHealthCheckOKStatusDegraded
	case AiBehaviorServiceHealthCheckOKStatusUnhealthy:
		*s = AiBehaviorServiceHealthCheckOKStatusUnhealthy
	default:
		*s = AiBehaviorServiceHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AiBehaviorServiceHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AiBehaviorServiceHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AiBehaviorServiceHealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfAiBehaviorServiceHealthCheckServiceUnavailable = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes AiBehaviorServiceHealthCheckServiceUnavailable from json.
func (s *AiBehaviorServiceHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckServiceUnavailable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AiBehaviorServiceHealthCheckServiceUnavailable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAiBehaviorServiceHealthCheckServiceUnavailable) {
					name = jsonFieldsNameOfAiBehaviorServiceHealthCheckServiceUnavailable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AiBehaviorServiceHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AiBehaviorServiceHealthCheckServiceUnavailableStatus as json.
func (s AiBehaviorServiceHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AiBehaviorServiceHealthCheckServiceUnavailableStatus from json.
func (s *AiBehaviorServiceHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AiBehaviorServiceHealthCheckServiceUnavailableStatus(v) {
	case AiBehaviorServiceHealthCheckServiceUnavailableStatusHealthy:
		*s = AiBehaviorServiceHealthCheckServiceUnavailableStatusHealthy
	case AiBehaviorServiceHealthCheckServiceUnavailableStatusDegraded:
		*s = AiBehaviorServiceHealthCheckServiceUnavailableStatusDegraded
	case AiBehaviorServiceHealthCheckServiceUnavailableStatusUnhealthy:
		*s = AiBehaviorServiceHealthCheckServiceUnavailableStatusUnhealthy
	default:
		*s = AiBehaviorServiceHealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AiBehaviorServiceHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AiBehaviorServiceHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfAiBehaviorServiceHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes AiBehaviorServiceHealthCheckTooManyRequests from json.
func (s *AiBehaviorServiceHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem AiBehaviorServiceHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AiBehaviorServiceHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAiBehaviorServiceHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfAiBehaviorServiceHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AiBehaviorServiceHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAiBehaviorServiceHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes AiBehaviorServiceHealthCheckTooManyRequestsDetails from json.
func (s *AiBehaviorServiceHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AiBehaviorServiceHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AiBehaviorServiceHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AiBehaviorServiceHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyzeSuspiciousBehaviorBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyzeSuspiciousBehaviorBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes AnalyzeSuspiciousBehaviorBadRequest from json.
func (s *AnalyzeSuspiciousBehaviorBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyzeSuspiciousBehaviorBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem AnalyzeSuspiciousBehaviorBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyzeSuspiciousBehaviorBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyzeSuspiciousBehaviorBadRequest) {
					name = jsonFieldsNameOfAnalyzeSuspiciousBehaviorBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyzeSuspiciousBehaviorBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAnalyzeSuspiciousBehaviorBadRequestDetails = [0]string{}

// Decode decodes AnalyzeSuspiciousBehaviorBadRequestDetails from json.
func (s *AnalyzeSuspiciousBehaviorBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyzeSuspiciousBehaviorBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AnalyzeSuspiciousBehaviorBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyzeSuspiciousBehaviorBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyzeSuspiciousBehaviorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyzeSuspiciousBehaviorNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyzeSuspiciousBehaviorNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes AnalyzeSuspiciousBehaviorNotFound from json.
func (s *AnalyzeSuspiciousBehaviorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyzeSuspiciousBehaviorNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem AnalyzeSuspiciousBehaviorNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyzeSuspiciousBehaviorNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyzeSuspiciousBehaviorNotFound) {
					name = jsonFieldsNameOfAnalyzeSuspiciousBehaviorNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyzeSuspiciousBehaviorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyzeSuspiciousBehaviorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyzeSuspiciousBehaviorNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyzeSuspiciousBehaviorNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAnalyzeSuspiciousBehaviorNotFoundDetails = [0]string{}

// Decode decodes AnalyzeSuspiciousBehaviorNotFoundDetails from json.
func (s *AnalyzeSuspiciousBehaviorNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyzeSuspiciousBehaviorNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AnalyzeSuspiciousBehaviorNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyzeSuspiciousBehaviorNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyzeSuspiciousBehaviorNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BehaviorAnalysisResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BehaviorAnalysisResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_id")
		json.EncodeUUID(e, s.AccountID)
	}
	{
		e.FieldStart("analysis_id")
		json.EncodeUUID(e, s.AnalysisID)
	}
	{
		e.FieldStart("risk_level")
		s.RiskLevel.Encode(e)
	}
	{
		e.FieldStart("analyzed_at")
		json.EncodeDateTime(e, s.AnalyzedAt)
	}
	{
		if s.Recommendations != nil {
			e.FieldStart("recommendations")
			e.ArrStart()
			for _, elem := range s.Recommendations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RiskScore.Set {
			e.FieldStart("risk_score")
			s.RiskScore.Encode(e)
		}
	}
	{
		if s.RequiresInvestigation.Set {
			e.FieldStart("requires_investigation")
			s.RequiresInvestigation.Encode(e)
		}
	}
}

var jsonFieldsNameOfBehaviorAnalysisResult = [7]string{
	0: "account_id",
	1: "analysis_id",
	2: "risk_level",
	3: "analyzed_at",
	4: "recommendations",
	5: "risk_score",
	6: "requires_investigation",
}

// Decode decodes BehaviorAnalysisResult from json.
func (s *BehaviorAnalysisResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BehaviorAnalysisResult to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "analysis_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AnalysisID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_id\"")
			}
		case "risk_level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RiskLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_level\"")
			}
		case "analyzed_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.AnalyzedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyzed_at\"")
			}
		case "recommendations":
			if err := func() error {
				s.Recommendations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Recommendations = append(s.Recommendations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommendations\"")
			}
		case "risk_score":
			if err := func() error {
				s.RiskScore.Reset()
				if err := s.RiskScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_score\"")
			}
		case "requires_investigation":
			if err := func() error {
				s.RequiresInvestigation.Reset()
				if err := s.RequiresInvestigation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_investigation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BehaviorAnalysisResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBehaviorAnalysisResult) {
					name = jsonFieldsNameOfBehaviorAnalysisResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BehaviorAnalysisResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BehaviorAnalysisResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BehaviorAnalysisResultRiskLevel as json.
func (s BehaviorAnalysisResultRiskLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BehaviorAnalysisResultRiskLevel from json.
func (s *BehaviorAnalysisResultRiskLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BehaviorAnalysisResultRiskLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BehaviorAnalysisResultRiskLevel(v) {
	case BehaviorAnalysisResultRiskLevelLow:
		*s = BehaviorAnalysisResultRiskLevelLow
	case BehaviorAnalysisResultRiskLevelMedium:
		*s = BehaviorAnalysisResultRiskLevelMedium
	case BehaviorAnalysisResultRiskLevelHigh:
		*s = BehaviorAnalysisResultRiskLevelHigh
	case BehaviorAnalysisResultRiskLevelCritical:
		*s = BehaviorAnalysisResultRiskLevelCritical
	default:
		*s = BehaviorAnalysisResultRiskLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BehaviorAnalysisResultRiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BehaviorAnalysisResultRiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BehaviorPattern) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BehaviorPattern) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pattern_type")
		s.PatternType.Encode(e)
	}
	{
		if s.DetectedAt.Set {
			e.FieldStart("detected_at")
			s.DetectedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("frequency")
		e.Float32(s.Frequency)
	}
	{
		e.FieldStart("confidence")
		e.Float32(s.Confidence)
	}
}

var jsonFieldsNameOfBehaviorPattern = [4]string{
	0: "pattern_type",
	1: "detected_at",
	2: "frequency",
	3: "confidence",
}

// Decode decodes BehaviorPattern from json.
func (s *BehaviorPattern) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BehaviorPattern to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pattern_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PatternType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern_type\"")
			}
		case "detected_at":
			if err := func() error {
				s.DetectedAt.Reset()
				if err := s.DetectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detected_at\"")
			}
		case "frequency":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Frequency = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Confidence = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BehaviorPattern")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBehaviorPattern) {
					name = jsonFieldsNameOfBehaviorPattern[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BehaviorPattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BehaviorPattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BehaviorPatternPatternType as json.
func (s BehaviorPatternPatternType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BehaviorPatternPatternType from json.
func (s *BehaviorPatternPatternType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BehaviorPatternPatternType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BehaviorPatternPatternType(v) {
	case BehaviorPatternPatternTypeAggressivePlay:
		*s = BehaviorPatternPatternTypeAggressivePlay
	case BehaviorPatternPatternTypeDefensivePlay:
		*s = BehaviorPatternPatternTypeDefensivePlay
	case BehaviorPatternPatternTypeTeamPlayer:
		*s = BehaviorPatternPatternTypeTeamPlayer
	case BehaviorPatternPatternTypeLoneWolf:
		*s = BehaviorPatternPatternTypeLoneWolf
	case BehaviorPatternPatternTypeAchievementHunter:
		*s = BehaviorPatternPatternTypeAchievementHunter
	case BehaviorPatternPatternTypeCasualPlayer:
		*s = BehaviorPatternPatternTypeCasualPlayer
	default:
		*s = BehaviorPatternPatternType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BehaviorPatternPatternType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BehaviorPatternPatternType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatStrategyPrediction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatStrategyPrediction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_id")
		json.EncodeUUID(e, s.AccountID)
	}
	{
		e.FieldStart("predicted_strategy")
		s.PredictedStrategy.Encode(e)
	}
	{
		e.FieldStart("predicted_at")
		json.EncodeDateTime(e, s.PredictedAt)
	}
	{
		if s.StrategyExplanation.Set {
			e.FieldStart("strategy_explanation")
			s.StrategyExplanation.Encode(e)
		}
	}
	{
		if s.CounterStrategies != nil {
			e.FieldStart("counter_strategies")
			e.ArrStart()
			for _, elem := range s.CounterStrategies {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("confidence_score")
		e.Float32(s.ConfidenceScore)
	}
}

var jsonFieldsNameOfCombatStrategyPrediction = [6]string{
	0: "account_id",
	1: "predicted_strategy",
	2: "predicted_at",
	3: "strategy_explanation",
	4: "counter_strategies",
	5: "confidence_score",
}

// Decode decodes CombatStrategyPrediction from json.
func (s *CombatStrategyPrediction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatStrategyPrediction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "predicted_strategy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PredictedStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predicted_strategy\"")
			}
		case "predicted_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PredictedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predicted_at\"")
			}
		case "strategy_explanation":
			if err := func() error {
				s.StrategyExplanation.Reset()
				if err := s.StrategyExplanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy_explanation\"")
			}
		case "counter_strategies":
			if err := func() error {
				s.CounterStrategies = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CounterStrategies = append(s.CounterStrategies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"counter_strategies\"")
			}
		case "confidence_score":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.ConfidenceScore = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatStrategyPrediction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatStrategyPrediction) {
					name = jsonFieldsNameOfCombatStrategyPrediction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatStrategyPrediction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatStrategyPrediction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatStrategyPredictionPredictedStrategy as json.
func (s CombatStrategyPredictionPredictedStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatStrategyPredictionPredictedStrategy from json.
func (s *CombatStrategyPredictionPredictedStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatStrategyPredictionPredictedStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatStrategyPredictionPredictedStrategy(v) {
	case CombatStrategyPredictionPredictedStrategyAggressive:
		*s = CombatStrategyPredictionPredictedStrategyAggressive
	case CombatStrategyPredictionPredictedStrategyDefensive:
		*s = CombatStrategyPredictionPredictedStrategyDefensive
	case CombatStrategyPredictionPredictedStrategyFlanking:
		*s = CombatStrategyPredictionPredictedStrategyFlanking
	case CombatStrategyPredictionPredictedStrategyCamping:
		*s = CombatStrategyPredictionPredictedStrategyCamping
	case CombatStrategyPredictionPredictedStrategyRushdown:
		*s = CombatStrategyPredictionPredictedStrategyRushdown
	case CombatStrategyPredictionPredictedStrategyKite:
		*s = CombatStrategyPredictionPredictedStrategyKite
	default:
		*s = CombatStrategyPredictionPredictedStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatStrategyPredictionPredictedStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatStrategyPredictionPredictedStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EngagementMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EngagementMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.SessionsPerDay.Set {
			e.FieldStart("sessions_per_day")
			s.SessionsPerDay.Encode(e)
		}
	}
	{
		if s.RetentionRate.Set {
			e.FieldStart("retention_rate")
			s.RetentionRate.Encode(e)
		}
	}
	{
		if s.ProgressionRate.Set {
			e.FieldStart("progression_rate")
			s.ProgressionRate.Encode(e)
		}
	}
	{
		if s.AverageSessionDuration.Set {
			e.FieldStart("average_session_duration")
			s.AverageSessionDuration.Encode(e)
		}
	}
}

var jsonFieldsNameOfEngagementMetrics = [4]string{
	0: "sessions_per_day",
	1: "retention_rate",
	2: "progression_rate",
	3: "average_session_duration",
}

// Decode decodes EngagementMetrics from json.
func (s *EngagementMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EngagementMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sessions_per_day":
			if err := func() error {
				s.SessionsPerDay.Reset()
				if err := s.SessionsPerDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_per_day\"")
			}
		case "retention_rate":
			if err := func() error {
				s.RetentionRate.Reset()
				if err := s.RetentionRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retention_rate\"")
			}
		case "progression_rate":
			if err := func() error {
				s.ProgressionRate.Reset()
				if err := s.ProgressionRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progression_rate\"")
			}
		case "average_session_duration":
			if err := func() error {
				s.AverageSessionDuration.Reset()
				if err := s.AverageSessionDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_session_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EngagementMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EngagementMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EngagementMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExampleDomainBatchHealthCheckBadRequest from json.
func (s *ExampleDomainBatchHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExampleDomainBatchHealthCheckBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainBatchHealthCheckBadRequest) {
					name = jsonFieldsNameOfExampleDomainBatchHealthCheckBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckBadRequestDetails = [0]string{}

// Decode decodes ExampleDomainBatchHealthCheckBadRequestDetails from json.
func (s *ExampleDomainBatchHealthCheckBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_time_ms")
		e.Int(s.TotalTimeMs)
	}
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckOK = [2]string{
	0: "results",
	1: "total_time_ms",
}

// Decode decodes ExampleDomainBatchHealthCheckOK from json.
func (s *ExampleDomainBatchHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "total_time_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalTimeMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainBatchHealthCheckOK) {
					name = jsonFieldsNameOfExampleDomainBatchHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("services")
		e.ArrStart()
		for _, elem := range s.Services {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckReq = [1]string{
	0: "services",
}

// Decode decodes ExampleDomainBatchHealthCheckReq from json.
func (s *ExampleDomainBatchHealthCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "services":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Services = make([]ExampleDomainBatchHealthCheckReqServicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExampleDomainBatchHealthCheckReqServicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainBatchHealthCheckReq) {
					name = jsonFieldsNameOfExampleDomainBatchHealthCheckReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExampleDomainBatchHealthCheckReqServicesItem as json.
func (s ExampleDomainBatchHealthCheckReqServicesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExampleDomainBatchHealthCheckReqServicesItem from json.
func (s *ExampleDomainBatchHealthCheckReqServicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckReqServicesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExampleDomainBatchHealthCheckReqServicesItem(v) {
	case ExampleDomainBatchHealthCheckReqServicesItemExampleDomain:
		*s = ExampleDomainBatchHealthCheckReqServicesItemExampleDomain
	case ExampleDomainBatchHealthCheckReqServicesItemSystemDomain:
		*s = ExampleDomainBatchHealthCheckReqServicesItemSystemDomain
	case ExampleDomainBatchHealthCheckReqServicesItemSpecializedDomain:
		*s = ExampleDomainBatchHealthCheckReqServicesItemSpecializedDomain
	default:
		*s = ExampleDomainBatchHealthCheckReqServicesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExampleDomainBatchHealthCheckReqServicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckReqServicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExampleDomainBatchHealthCheckTooManyRequests from json.
func (s *ExampleDomainBatchHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExampleDomainBatchHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainBatchHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfExampleDomainBatchHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainBatchHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExampleDomainBatchHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes ExampleDomainBatchHealthCheckTooManyRequestsDetails from json.
func (s *ExampleDomainBatchHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainBatchHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainBatchHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainBatchHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExampleDomainHealthWebSocketBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExampleDomainHealthWebSocketBadRequest from json.
func (s *ExampleDomainHealthWebSocketBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExampleDomainHealthWebSocketBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainHealthWebSocketBadRequest) {
					name = jsonFieldsNameOfExampleDomainHealthWebSocketBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExampleDomainHealthWebSocketBadRequestDetails = [0]string{}

// Decode decodes ExampleDomainHealthWebSocketBadRequestDetails from json.
func (s *ExampleDomainHealthWebSocketBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketOK) encodeFields(e *jx.Encoder) {
	{
		if s.WebsocketURL.Set {
			e.FieldStart("websocket_url")
			s.WebsocketURL.Encode(e)
		}
	}
	{
		if s.SupportedProtocols != nil {
			e.FieldStart("supported_protocols")
			e.ArrStart()
			for _, elem := range s.SupportedProtocols {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExampleDomainHealthWebSocketOK = [2]string{
	0: "websocket_url",
	1: "supported_protocols",
}

// Decode decodes ExampleDomainHealthWebSocketOK from json.
func (s *ExampleDomainHealthWebSocketOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "websocket_url":
			if err := func() error {
				s.WebsocketURL.Reset()
				if err := s.WebsocketURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"websocket_url\"")
			}
		case "supported_protocols":
			if err := func() error {
				s.SupportedProtocols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SupportedProtocols = append(s.SupportedProtocols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_protocols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExampleDomainHealthWebSocketTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExampleDomainHealthWebSocketTooManyRequests from json.
func (s *ExampleDomainHealthWebSocketTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExampleDomainHealthWebSocketTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainHealthWebSocketTooManyRequests) {
					name = jsonFieldsNameOfExampleDomainHealthWebSocketTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExampleDomainHealthWebSocketTooManyRequestsDetails = [0]string{}

// Decode decodes ExampleDomainHealthWebSocketTooManyRequestsDetails from json.
func (s *ExampleDomainHealthWebSocketTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExampleDomainHealthWebSocketUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExampleDomainHealthWebSocketUnauthorized from json.
func (s *ExampleDomainHealthWebSocketUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExampleDomainHealthWebSocketUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExampleDomainHealthWebSocketUnauthorized) {
					name = jsonFieldsNameOfExampleDomainHealthWebSocketUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExampleDomainHealthWebSocketUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExampleDomainHealthWebSocketUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExampleDomainHealthWebSocketUnauthorizedDetails = [0]string{}

// Decode decodes ExampleDomainHealthWebSocketUnauthorizedDetails from json.
func (s *ExampleDomainHealthWebSocketUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExampleDomainHealthWebSocketUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExampleDomainHealthWebSocketUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExampleDomainHealthWebSocketUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExampleDomainHealthWebSocketUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateNpcRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateNpcRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("npc_type")
		s.NpcType.Encode(e)
	}
	{
		if s.Faction.Set {
			e.FieldStart("faction")
			s.Faction.Encode(e)
		}
	}
	{
		if s.CustomProperties.Set {
			e.FieldStart("custom_properties")
			s.CustomProperties.Encode(e)
		}
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		if s.DifficultyLevel.Set {
			e.FieldStart("difficulty_level")
			s.DifficultyLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateNpcRequest = [5]string{
	0: "npc_type",
	1: "faction",
	2: "custom_properties",
	3: "location",
	4: "difficulty_level",
}

// Decode decodes GenerateNpcRequest from json.
func (s *GenerateNpcRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateNpcRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "npc_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NpcType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_type\"")
			}
		case "faction":
			if err := func() error {
				s.Faction.Reset()
				if err := s.Faction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction\"")
			}
		case "custom_properties":
			if err := func() error {
				s.CustomProperties.Reset()
				if err := s.CustomProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_properties\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "difficulty_level":
			if err := func() error {
				s.DifficultyLevel.Reset()
				if err := s.DifficultyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateNpcRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateNpcRequest) {
					name = jsonFieldsNameOfGenerateNpcRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateNpcRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateNpcRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GenerateNpcRequestCustomProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GenerateNpcRequestCustomProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes GenerateNpcRequestCustomProperties from json.
func (s *GenerateNpcRequestCustomProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateNpcRequestCustomProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateNpcRequestCustomProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateNpcRequestCustomProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateNpcRequestCustomProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateNpcRequestNpcType as json.
func (s GenerateNpcRequestNpcType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateNpcRequestNpcType from json.
func (s *GenerateNpcRequestNpcType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateNpcRequestNpcType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateNpcRequestNpcType(v) {
	case GenerateNpcRequestNpcTypeEnemy:
		*s = GenerateNpcRequestNpcTypeEnemy
	case GenerateNpcRequestNpcTypeAlly:
		*s = GenerateNpcRequestNpcTypeAlly
	case GenerateNpcRequestNpcTypeNeutral:
		*s = GenerateNpcRequestNpcTypeNeutral
	case GenerateNpcRequestNpcTypeMerchant:
		*s = GenerateNpcRequestNpcTypeMerchant
	case GenerateNpcRequestNpcTypeQuestGiver:
		*s = GenerateNpcRequestNpcTypeQuestGiver
	default:
		*s = GenerateNpcRequestNpcType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateNpcRequestNpcType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateNpcRequestNpcType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralNpcBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralNpcBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateProceduralNpcBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GenerateProceduralNpcBadRequest from json.
func (s *GenerateProceduralNpcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralNpcBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GenerateProceduralNpcBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralNpcBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateProceduralNpcBadRequest) {
					name = jsonFieldsNameOfGenerateProceduralNpcBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralNpcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralNpcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralNpcBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralNpcBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGenerateProceduralNpcBadRequestDetails = [0]string{}

// Decode decodes GenerateProceduralNpcBadRequestDetails from json.
func (s *GenerateProceduralNpcBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralNpcBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralNpcBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralNpcBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralNpcBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralNpcInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralNpcInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateProceduralNpcInternalServerError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GenerateProceduralNpcInternalServerError from json.
func (s *GenerateProceduralNpcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralNpcInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GenerateProceduralNpcInternalServerErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralNpcInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateProceduralNpcInternalServerError) {
					name = jsonFieldsNameOfGenerateProceduralNpcInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralNpcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralNpcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralNpcInternalServerErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralNpcInternalServerErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGenerateProceduralNpcInternalServerErrorDetails = [0]string{}

// Decode decodes GenerateProceduralNpcInternalServerErrorDetails from json.
func (s *GenerateProceduralNpcInternalServerErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralNpcInternalServerErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralNpcInternalServerErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralNpcInternalServerErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralNpcInternalServerErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralQuestBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralQuestBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateProceduralQuestBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GenerateProceduralQuestBadRequest from json.
func (s *GenerateProceduralQuestBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralQuestBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GenerateProceduralQuestBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralQuestBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateProceduralQuestBadRequest) {
					name = jsonFieldsNameOfGenerateProceduralQuestBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralQuestBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralQuestBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralQuestBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralQuestBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGenerateProceduralQuestBadRequestDetails = [0]string{}

// Decode decodes GenerateProceduralQuestBadRequestDetails from json.
func (s *GenerateProceduralQuestBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralQuestBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralQuestBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralQuestBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralQuestBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralQuestInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralQuestInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateProceduralQuestInternalServerError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GenerateProceduralQuestInternalServerError from json.
func (s *GenerateProceduralQuestInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralQuestInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GenerateProceduralQuestInternalServerErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralQuestInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateProceduralQuestInternalServerError) {
					name = jsonFieldsNameOfGenerateProceduralQuestInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralQuestInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralQuestInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateProceduralQuestInternalServerErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateProceduralQuestInternalServerErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGenerateProceduralQuestInternalServerErrorDetails = [0]string{}

// Decode decodes GenerateProceduralQuestInternalServerErrorDetails from json.
func (s *GenerateProceduralQuestInternalServerErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateProceduralQuestInternalServerErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GenerateProceduralQuestInternalServerErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateProceduralQuestInternalServerErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateProceduralQuestInternalServerErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateQuestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateQuestRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quest_type")
		s.QuestType.Encode(e)
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		if s.Theme.Set {
			e.FieldStart("theme")
			s.Theme.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.CustomParameters.Set {
			e.FieldStart("custom_parameters")
			s.CustomParameters.Encode(e)
		}
	}
	{
		e.FieldStart("player_level")
		e.Int(s.PlayerLevel)
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateQuestRequest = [7]string{
	0: "quest_type",
	1: "difficulty",
	2: "theme",
	3: "location",
	4: "custom_parameters",
	5: "player_level",
	6: "time_limit",
}

// Decode decodes GenerateQuestRequest from json.
func (s *GenerateQuestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateQuestRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.QuestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_type\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "theme":
			if err := func() error {
				s.Theme.Reset()
				if err := s.Theme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"theme\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "custom_parameters":
			if err := func() error {
				s.CustomParameters.Reset()
				if err := s.CustomParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_parameters\"")
			}
		case "player_level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.PlayerLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_level\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateQuestRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateQuestRequest) {
					name = jsonFieldsNameOfGenerateQuestRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateQuestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateQuestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GenerateQuestRequestCustomParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GenerateQuestRequestCustomParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes GenerateQuestRequestCustomParameters from json.
func (s *GenerateQuestRequestCustomParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateQuestRequestCustomParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateQuestRequestCustomParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateQuestRequestCustomParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateQuestRequestCustomParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestDifficulty as json.
func (s GenerateQuestRequestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateQuestRequestDifficulty from json.
func (s *GenerateQuestRequestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateQuestRequestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateQuestRequestDifficulty(v) {
	case GenerateQuestRequestDifficultyEasy:
		*s = GenerateQuestRequestDifficultyEasy
	case GenerateQuestRequestDifficultyMedium:
		*s = GenerateQuestRequestDifficultyMedium
	case GenerateQuestRequestDifficultyHard:
		*s = GenerateQuestRequestDifficultyHard
	case GenerateQuestRequestDifficultyEpic:
		*s = GenerateQuestRequestDifficultyEpic
	default:
		*s = GenerateQuestRequestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateQuestRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateQuestRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestQuestType as json.
func (s GenerateQuestRequestQuestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateQuestRequestQuestType from json.
func (s *GenerateQuestRequestQuestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateQuestRequestQuestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateQuestRequestQuestType(v) {
	case GenerateQuestRequestQuestTypeCombat:
		*s = GenerateQuestRequestQuestTypeCombat
	case GenerateQuestRequestQuestTypeExploration:
		*s = GenerateQuestRequestQuestTypeExploration
	case GenerateQuestRequestQuestTypeCollection:
		*s = GenerateQuestRequestQuestTypeCollection
	case GenerateQuestRequestQuestTypeEscort:
		*s = GenerateQuestRequestQuestTypeEscort
	case GenerateQuestRequestQuestTypePuzzle:
		*s = GenerateQuestRequestQuestTypePuzzle
	case GenerateQuestRequestQuestTypeAssassination:
		*s = GenerateQuestRequestQuestTypeAssassination
	default:
		*s = GenerateQuestRequestQuestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateQuestRequestQuestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateQuestRequestQuestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestTheme as json.
func (s GenerateQuestRequestTheme) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateQuestRequestTheme from json.
func (s *GenerateQuestRequestTheme) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateQuestRequestTheme to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateQuestRequestTheme(v) {
	case GenerateQuestRequestThemeCyberpunk:
		*s = GenerateQuestRequestThemeCyberpunk
	case GenerateQuestRequestThemeMilitary:
		*s = GenerateQuestRequestThemeMilitary
	case GenerateQuestRequestThemeSupernatural:
		*s = GenerateQuestRequestThemeSupernatural
	case GenerateQuestRequestThemeMystery:
		*s = GenerateQuestRequestThemeMystery
	case GenerateQuestRequestThemeAdventure:
		*s = GenerateQuestRequestThemeAdventure
	default:
		*s = GenerateQuestRequestTheme(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateQuestRequestTheme) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateQuestRequestTheme) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneratedNpc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneratedNpc) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("npc_type")
		s.NpcType.Encode(e)
	}
	{
		e.FieldStart("generated_at")
		json.EncodeDateTime(e, s.GeneratedAt)
	}
	{
		if s.GenerationSeed.Set {
			e.FieldStart("generation_seed")
			s.GenerationSeed.Encode(e)
		}
	}
	{
		e.FieldStart("behavior")
		s.Behavior.Encode(e)
	}
	{
		if s.Stats.Set {
			e.FieldStart("stats")
			s.Stats.Encode(e)
		}
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
}

var jsonFieldsNameOfGeneratedNpc = [7]string{
	0: "id",
	1: "npc_type",
	2: "generated_at",
	3: "generation_seed",
	4: "behavior",
	5: "stats",
	6: "location",
}

// Decode decodes GeneratedNpc from json.
func (s *GeneratedNpc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedNpc to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "npc_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NpcType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_type\"")
			}
		case "generated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.GeneratedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_at\"")
			}
		case "generation_seed":
			if err := func() error {
				s.GenerationSeed.Reset()
				if err := s.GenerationSeed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generation_seed\"")
			}
		case "behavior":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Behavior.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeneratedNpc")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeneratedNpc) {
					name = jsonFieldsNameOfGeneratedNpc[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratedNpc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedNpc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratedNpcNpcType as json.
func (s GeneratedNpcNpcType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GeneratedNpcNpcType from json.
func (s *GeneratedNpcNpcType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedNpcNpcType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GeneratedNpcNpcType(v) {
	case GeneratedNpcNpcTypeEnemy:
		*s = GeneratedNpcNpcTypeEnemy
	case GeneratedNpcNpcTypeAlly:
		*s = GeneratedNpcNpcTypeAlly
	case GeneratedNpcNpcTypeNeutral:
		*s = GeneratedNpcNpcTypeNeutral
	case GeneratedNpcNpcTypeMerchant:
		*s = GeneratedNpcNpcTypeMerchant
	case GeneratedNpcNpcTypeQuestGiver:
		*s = GeneratedNpcNpcTypeQuestGiver
	default:
		*s = GeneratedNpcNpcType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GeneratedNpcNpcType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedNpcNpcType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneratedQuest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneratedQuest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		e.FieldStart("generated_at")
		json.EncodeDateTime(e, s.GeneratedAt)
	}
	{
		if s.GenerationSeed.Set {
			e.FieldStart("generation_seed")
			s.GenerationSeed.Encode(e)
		}
	}
	{
		e.FieldStart("objectives")
		e.ArrStart()
		for _, elem := range s.Objectives {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EstimatedDuration.Set {
			e.FieldStart("estimated_duration")
			s.EstimatedDuration.Encode(e)
		}
	}
}

var jsonFieldsNameOfGeneratedQuest = [9]string{
	0: "id",
	1: "title",
	2: "description",
	3: "difficulty",
	4: "generated_at",
	5: "generation_seed",
	6: "objectives",
	7: "rewards",
	8: "estimated_duration",
}

// Decode decodes GeneratedQuest from json.
func (s *GeneratedQuest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedQuest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "generated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.GeneratedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_at\"")
			}
		case "generation_seed":
			if err := func() error {
				s.GenerationSeed.Reset()
				if err := s.GenerationSeed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generation_seed\"")
			}
		case "objectives":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Objectives = make([]QuestObjective, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestObjective
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]QuestReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "estimated_duration":
			if err := func() error {
				s.EstimatedDuration.Reset()
				if err := s.EstimatedDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeneratedQuest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeneratedQuest) {
					name = jsonFieldsNameOfGeneratedQuest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratedQuest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedQuest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratedQuestDifficulty as json.
func (s GeneratedQuestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GeneratedQuestDifficulty from json.
func (s *GeneratedQuestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedQuestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GeneratedQuestDifficulty(v) {
	case GeneratedQuestDifficultyEasy:
		*s = GeneratedQuestDifficultyEasy
	case GeneratedQuestDifficultyMedium:
		*s = GeneratedQuestDifficultyMedium
	case GeneratedQuestDifficultyHard:
		*s = GeneratedQuestDifficultyHard
	case GeneratedQuestDifficultyEpic:
		*s = GeneratedQuestDifficultyEpic
	default:
		*s = GeneratedQuestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GeneratedQuestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedQuestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCombatStrategyPredictionNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCombatStrategyPredictionNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCombatStrategyPredictionNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetCombatStrategyPredictionNotFound from json.
func (s *GetCombatStrategyPredictionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCombatStrategyPredictionNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetCombatStrategyPredictionNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCombatStrategyPredictionNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCombatStrategyPredictionNotFound) {
					name = jsonFieldsNameOfGetCombatStrategyPredictionNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCombatStrategyPredictionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCombatStrategyPredictionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCombatStrategyPredictionNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCombatStrategyPredictionNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetCombatStrategyPredictionNotFoundDetails = [0]string{}

// Decode decodes GetCombatStrategyPredictionNotFoundDetails from json.
func (s *GetCombatStrategyPredictionNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCombatStrategyPredictionNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetCombatStrategyPredictionNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCombatStrategyPredictionNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCombatStrategyPredictionNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCombatStrategyPredictionUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCombatStrategyPredictionUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCombatStrategyPredictionUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetCombatStrategyPredictionUnauthorized from json.
func (s *GetCombatStrategyPredictionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCombatStrategyPredictionUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetCombatStrategyPredictionUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCombatStrategyPredictionUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCombatStrategyPredictionUnauthorized) {
					name = jsonFieldsNameOfGetCombatStrategyPredictionUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCombatStrategyPredictionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCombatStrategyPredictionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCombatStrategyPredictionUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCombatStrategyPredictionUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetCombatStrategyPredictionUnauthorizedDetails = [0]string{}

// Decode decodes GetCombatStrategyPredictionUnauthorizedDetails from json.
func (s *GetCombatStrategyPredictionUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCombatStrategyPredictionUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetCombatStrategyPredictionUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCombatStrategyPredictionUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCombatStrategyPredictionUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNpcBehaviorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNpcBehaviorNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNpcBehaviorNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNpcBehaviorNotFound from json.
func (s *GetNpcBehaviorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNpcBehaviorNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNpcBehaviorNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNpcBehaviorNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNpcBehaviorNotFound) {
					name = jsonFieldsNameOfGetNpcBehaviorNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNpcBehaviorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNpcBehaviorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNpcBehaviorNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNpcBehaviorNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNpcBehaviorNotFoundDetails = [0]string{}

// Decode decodes GetNpcBehaviorNotFoundDetails from json.
func (s *GetNpcBehaviorNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNpcBehaviorNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNpcBehaviorNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNpcBehaviorNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNpcBehaviorNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNpcBehaviorUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNpcBehaviorUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNpcBehaviorUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNpcBehaviorUnauthorized from json.
func (s *GetNpcBehaviorUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNpcBehaviorUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNpcBehaviorUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNpcBehaviorUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNpcBehaviorUnauthorized) {
					name = jsonFieldsNameOfGetNpcBehaviorUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNpcBehaviorUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNpcBehaviorUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNpcBehaviorUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNpcBehaviorUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNpcBehaviorUnauthorizedDetails = [0]string{}

// Decode decodes GetNpcBehaviorUnauthorizedDetails from json.
func (s *GetNpcBehaviorUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNpcBehaviorUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNpcBehaviorUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNpcBehaviorUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNpcBehaviorUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerBehaviorAnalyticsNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerBehaviorAnalyticsNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerBehaviorAnalyticsNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetPlayerBehaviorAnalyticsNotFound from json.
func (s *GetPlayerBehaviorAnalyticsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerBehaviorAnalyticsNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetPlayerBehaviorAnalyticsNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerBehaviorAnalyticsNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerBehaviorAnalyticsNotFound) {
					name = jsonFieldsNameOfGetPlayerBehaviorAnalyticsNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerBehaviorAnalyticsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerBehaviorAnalyticsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerBehaviorAnalyticsNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerBehaviorAnalyticsNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetPlayerBehaviorAnalyticsNotFoundDetails = [0]string{}

// Decode decodes GetPlayerBehaviorAnalyticsNotFoundDetails from json.
func (s *GetPlayerBehaviorAnalyticsNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerBehaviorAnalyticsNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerBehaviorAnalyticsNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerBehaviorAnalyticsNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerBehaviorAnalyticsNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerBehaviorAnalyticsUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerBehaviorAnalyticsUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetPlayerBehaviorAnalyticsUnauthorized from json.
func (s *GetPlayerBehaviorAnalyticsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerBehaviorAnalyticsUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetPlayerBehaviorAnalyticsUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerBehaviorAnalyticsUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerBehaviorAnalyticsUnauthorized) {
					name = jsonFieldsNameOfGetPlayerBehaviorAnalyticsUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerBehaviorAnalyticsUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetPlayerBehaviorAnalyticsUnauthorizedDetails = [0]string{}

// Decode decodes GetPlayerBehaviorAnalyticsUnauthorizedDetails from json.
func (s *GetPlayerBehaviorAnalyticsUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerBehaviorAnalyticsUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerBehaviorAnalyticsUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerBehaviorAnalyticsUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerSkillAssessmentNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerSkillAssessmentNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerSkillAssessmentNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetPlayerSkillAssessmentNotFound from json.
func (s *GetPlayerSkillAssessmentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerSkillAssessmentNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetPlayerSkillAssessmentNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerSkillAssessmentNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerSkillAssessmentNotFound) {
					name = jsonFieldsNameOfGetPlayerSkillAssessmentNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerSkillAssessmentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerSkillAssessmentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerSkillAssessmentNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerSkillAssessmentNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetPlayerSkillAssessmentNotFoundDetails = [0]string{}

// Decode decodes GetPlayerSkillAssessmentNotFoundDetails from json.
func (s *GetPlayerSkillAssessmentNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerSkillAssessmentNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerSkillAssessmentNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerSkillAssessmentNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerSkillAssessmentNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerSkillAssessmentUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerSkillAssessmentUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerSkillAssessmentUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetPlayerSkillAssessmentUnauthorized from json.
func (s *GetPlayerSkillAssessmentUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerSkillAssessmentUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetPlayerSkillAssessmentUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerSkillAssessmentUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerSkillAssessmentUnauthorized) {
					name = jsonFieldsNameOfGetPlayerSkillAssessmentUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerSkillAssessmentUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerSkillAssessmentUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerSkillAssessmentUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerSkillAssessmentUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetPlayerSkillAssessmentUnauthorizedDetails = [0]string{}

// Decode decodes GetPlayerSkillAssessmentUnauthorizedDetails from json.
func (s *GetPlayerSkillAssessmentUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerSkillAssessmentUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerSkillAssessmentUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerSkillAssessmentUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerSkillAssessmentUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelTrainingJob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelTrainingJob) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("job_id")
		json.EncodeUUID(e, s.JobID)
	}
	{
		e.FieldStart("model_type")
		e.Str(s.ModelType)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.EstimatedCompletion.Set {
			e.FieldStart("estimated_completion")
			s.EstimatedCompletion.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progress_percentage")
			s.ProgressPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfModelTrainingJob = [6]string{
	0: "job_id",
	1: "model_type",
	2: "status",
	3: "created_at",
	4: "estimated_completion",
	5: "progress_percentage",
}

// Decode decodes ModelTrainingJob from json.
func (s *ModelTrainingJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingJob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "job_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.JobID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job_id\"")
			}
		case "model_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ModelType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_type\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "estimated_completion":
			if err := func() error {
				s.EstimatedCompletion.Reset()
				if err := s.EstimatedCompletion.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_completion\"")
			}
		case "progress_percentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelTrainingJob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfModelTrainingJob) {
					name = jsonFieldsNameOfModelTrainingJob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelTrainingJob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingJob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingJobStatus as json.
func (s ModelTrainingJobStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModelTrainingJobStatus from json.
func (s *ModelTrainingJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingJobStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModelTrainingJobStatus(v) {
	case ModelTrainingJobStatusQueued:
		*s = ModelTrainingJobStatusQueued
	case ModelTrainingJobStatusTraining:
		*s = ModelTrainingJobStatusTraining
	case ModelTrainingJobStatusValidating:
		*s = ModelTrainingJobStatusValidating
	case ModelTrainingJobStatusCompleted:
		*s = ModelTrainingJobStatusCompleted
	case ModelTrainingJobStatusFailed:
		*s = ModelTrainingJobStatusFailed
	default:
		*s = ModelTrainingJobStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelTrainingJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelTrainingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelTrainingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model_type")
		s.ModelType.Encode(e)
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		e.FieldStart("training_data")
		s.TrainingData.Encode(e)
	}
	{
		if s.Hyperparameters.Set {
			e.FieldStart("hyperparameters")
			s.Hyperparameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfModelTrainingRequest = [4]string{
	0: "model_type",
	1: "priority",
	2: "training_data",
	3: "hyperparameters",
}

// Decode decodes ModelTrainingRequest from json.
func (s *ModelTrainingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ModelType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_type\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "training_data":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TrainingData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"training_data\"")
			}
		case "hyperparameters":
			if err := func() error {
				s.Hyperparameters.Reset()
				if err := s.Hyperparameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hyperparameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelTrainingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfModelTrainingRequest) {
					name = jsonFieldsNameOfModelTrainingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelTrainingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ModelTrainingRequestHyperparameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ModelTrainingRequestHyperparameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ModelTrainingRequestHyperparameters from json.
func (s *ModelTrainingRequestHyperparameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequestHyperparameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelTrainingRequestHyperparameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelTrainingRequestHyperparameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequestHyperparameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingRequestModelType as json.
func (s ModelTrainingRequestModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModelTrainingRequestModelType from json.
func (s *ModelTrainingRequestModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequestModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModelTrainingRequestModelType(v) {
	case ModelTrainingRequestModelTypeDifficultyScaling:
		*s = ModelTrainingRequestModelTypeDifficultyScaling
	case ModelTrainingRequestModelTypeBehaviorPrediction:
		*s = ModelTrainingRequestModelTypeBehaviorPrediction
	case ModelTrainingRequestModelTypeContentRecommendation:
		*s = ModelTrainingRequestModelTypeContentRecommendation
	case ModelTrainingRequestModelTypeAntiCheat:
		*s = ModelTrainingRequestModelTypeAntiCheat
	default:
		*s = ModelTrainingRequestModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelTrainingRequestModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequestModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingRequestPriority as json.
func (s ModelTrainingRequestPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModelTrainingRequestPriority from json.
func (s *ModelTrainingRequestPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequestPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModelTrainingRequestPriority(v) {
	case ModelTrainingRequestPriorityLow:
		*s = ModelTrainingRequestPriorityLow
	case ModelTrainingRequestPriorityNormal:
		*s = ModelTrainingRequestPriorityNormal
	case ModelTrainingRequestPriorityHigh:
		*s = ModelTrainingRequestPriorityHigh
	case ModelTrainingRequestPriorityCritical:
		*s = ModelTrainingRequestPriorityCritical
	default:
		*s = ModelTrainingRequestPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelTrainingRequestPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequestPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelTrainingRequestTrainingData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelTrainingRequestTrainingData) encodeFields(e *jx.Encoder) {
	{
		if s.DatasetSize.Set {
			e.FieldStart("dataset_size")
			s.DatasetSize.Encode(e)
		}
	}
	{
		if s.DataSources != nil {
			e.FieldStart("data_sources")
			e.ArrStart()
			for _, elem := range s.DataSources {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TimeRange.Set {
			e.FieldStart("time_range")
			s.TimeRange.Encode(e)
		}
	}
}

var jsonFieldsNameOfModelTrainingRequestTrainingData = [3]string{
	0: "dataset_size",
	1: "data_sources",
	2: "time_range",
}

// Decode decodes ModelTrainingRequestTrainingData from json.
func (s *ModelTrainingRequestTrainingData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequestTrainingData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_size":
			if err := func() error {
				s.DatasetSize.Reset()
				if err := s.DatasetSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_size\"")
			}
		case "data_sources":
			if err := func() error {
				s.DataSources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DataSources = append(s.DataSources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_sources\"")
			}
		case "time_range":
			if err := func() error {
				s.TimeRange.Reset()
				if err := s.TimeRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_range\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelTrainingRequestTrainingData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelTrainingRequestTrainingData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequestTrainingData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelTrainingRequestTrainingDataTimeRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelTrainingRequestTrainingDataTimeRange) encodeFields(e *jx.Encoder) {
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfModelTrainingRequestTrainingDataTimeRange = [2]string{
	0: "start_date",
	1: "end_date",
}

// Decode decodes ModelTrainingRequestTrainingDataTimeRange from json.
func (s *ModelTrainingRequestTrainingDataTimeRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelTrainingRequestTrainingDataTimeRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelTrainingRequestTrainingDataTimeRange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelTrainingRequestTrainingDataTimeRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelTrainingRequestTrainingDataTimeRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NpcBehavior) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NpcBehavior) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("npc_id")
		json.EncodeUUID(e, s.NpcID)
	}
	{
		e.FieldStart("behavior_type")
		s.BehaviorType.Encode(e)
	}
	{
		if s.CombatStyle.Set {
			e.FieldStart("combat_style")
			s.CombatStyle.Encode(e)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionResponses.Set {
			e.FieldStart("interaction_responses")
			s.InteractionResponses.Encode(e)
		}
	}
	{
		if s.PatrolRoute != nil {
			e.FieldStart("patrol_route")
			e.ArrStart()
			for _, elem := range s.PatrolRoute {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("aggressiveness")
		e.Float32(s.Aggressiveness)
	}
	{
		e.FieldStart("intelligence")
		e.Float32(s.Intelligence)
	}
}

var jsonFieldsNameOfNpcBehavior = [8]string{
	0: "npc_id",
	1: "behavior_type",
	2: "combat_style",
	3: "last_updated",
	4: "interaction_responses",
	5: "patrol_route",
	6: "aggressiveness",
	7: "intelligence",
}

// Decode decodes NpcBehavior from json.
func (s *NpcBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NpcBehavior to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "npc_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NpcID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_id\"")
			}
		case "behavior_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BehaviorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior_type\"")
			}
		case "combat_style":
			if err := func() error {
				s.CombatStyle.Reset()
				if err := s.CombatStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_style\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		case "interaction_responses":
			if err := func() error {
				s.InteractionResponses.Reset()
				if err := s.InteractionResponses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_responses\"")
			}
		case "patrol_route":
			if err := func() error {
				s.PatrolRoute = make([]Vector3, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vector3
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PatrolRoute = append(s.PatrolRoute, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patrol_route\"")
			}
		case "aggressiveness":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float32()
				s.Aggressiveness = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggressiveness\"")
			}
		case "intelligence":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float32()
				s.Intelligence = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intelligence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NpcBehavior")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNpcBehavior) {
					name = jsonFieldsNameOfNpcBehavior[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NpcBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NpcBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NpcBehaviorBehaviorType as json.
func (s NpcBehaviorBehaviorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NpcBehaviorBehaviorType from json.
func (s *NpcBehaviorBehaviorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NpcBehaviorBehaviorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NpcBehaviorBehaviorType(v) {
	case NpcBehaviorBehaviorTypePassive:
		*s = NpcBehaviorBehaviorTypePassive
	case NpcBehaviorBehaviorTypeAggressive:
		*s = NpcBehaviorBehaviorTypeAggressive
	case NpcBehaviorBehaviorTypeDefensive:
		*s = NpcBehaviorBehaviorTypeDefensive
	case NpcBehaviorBehaviorTypePatrol:
		*s = NpcBehaviorBehaviorTypePatrol
	case NpcBehaviorBehaviorTypeGuard:
		*s = NpcBehaviorBehaviorTypeGuard
	case NpcBehaviorBehaviorTypeMerchant:
		*s = NpcBehaviorBehaviorTypeMerchant
	case NpcBehaviorBehaviorTypeQuestGiver:
		*s = NpcBehaviorBehaviorTypeQuestGiver
	default:
		*s = NpcBehaviorBehaviorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NpcBehaviorBehaviorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NpcBehaviorBehaviorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NpcBehaviorCombatStyle as json.
func (s NpcBehaviorCombatStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NpcBehaviorCombatStyle from json.
func (s *NpcBehaviorCombatStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NpcBehaviorCombatStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NpcBehaviorCombatStyle(v) {
	case NpcBehaviorCombatStyleMelee:
		*s = NpcBehaviorCombatStyleMelee
	case NpcBehaviorCombatStyleRanged:
		*s = NpcBehaviorCombatStyleRanged
	case NpcBehaviorCombatStyleMagic:
		*s = NpcBehaviorCombatStyleMagic
	case NpcBehaviorCombatStyleMixed:
		*s = NpcBehaviorCombatStyleMixed
	default:
		*s = NpcBehaviorCombatStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NpcBehaviorCombatStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NpcBehaviorCombatStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NpcBehaviorInteractionResponses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NpcBehaviorInteractionResponses) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NpcBehaviorInteractionResponses from json.
func (s *NpcBehaviorInteractionResponses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NpcBehaviorInteractionResponses to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NpcBehaviorInteractionResponses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NpcBehaviorInteractionResponses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NpcBehaviorInteractionResponses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NpcStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NpcStats) encodeFields(e *jx.Encoder) {
	{
		if s.Speed.Set {
			e.FieldStart("speed")
			s.Speed.Encode(e)
		}
	}
	{
		if s.Health.Set {
			e.FieldStart("health")
			s.Health.Encode(e)
		}
	}
	{
		if s.Damage.Set {
			e.FieldStart("damage")
			s.Damage.Encode(e)
		}
	}
	{
		if s.Defense.Set {
			e.FieldStart("defense")
			s.Defense.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
}

var jsonFieldsNameOfNpcStats = [5]string{
	0: "speed",
	1: "health",
	2: "damage",
	3: "defense",
	4: "level",
}

// Decode decodes NpcStats from json.
func (s *NpcStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NpcStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speed":
			if err := func() error {
				s.Speed.Reset()
				if err := s.Speed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "health":
			if err := func() error {
				s.Health.Reset()
				if err := s.Health.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		case "damage":
			if err := func() error {
				s.Damage.Reset()
				if err := s.Damage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "defense":
			if err := func() error {
				s.Defense.Reset()
				if err := s.Defense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defense\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NpcStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NpcStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NpcStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EngagementMetrics as json.
func (o OptEngagementMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EngagementMetrics from json.
func (o *OptEngagementMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEngagementMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEngagementMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEngagementMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateNpcRequestCustomProperties as json.
func (o OptGenerateNpcRequestCustomProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GenerateNpcRequestCustomProperties from json.
func (o *OptGenerateNpcRequestCustomProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateNpcRequestCustomProperties to nil")
	}
	o.Set = true
	o.Value = make(GenerateNpcRequestCustomProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateNpcRequestCustomProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateNpcRequestCustomProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestCustomParameters as json.
func (o OptGenerateQuestRequestCustomParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GenerateQuestRequestCustomParameters from json.
func (o *OptGenerateQuestRequestCustomParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateQuestRequestCustomParameters to nil")
	}
	o.Set = true
	o.Value = make(GenerateQuestRequestCustomParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateQuestRequestCustomParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateQuestRequestCustomParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestDifficulty as json.
func (o OptGenerateQuestRequestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GenerateQuestRequestDifficulty from json.
func (o *OptGenerateQuestRequestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateQuestRequestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateQuestRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateQuestRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateQuestRequestTheme as json.
func (o OptGenerateQuestRequestTheme) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GenerateQuestRequestTheme from json.
func (o *OptGenerateQuestRequestTheme) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateQuestRequestTheme to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateQuestRequestTheme) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateQuestRequestTheme) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratedQuestDifficulty as json.
func (o OptGeneratedQuestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GeneratedQuestDifficulty from json.
func (o *OptGeneratedQuestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGeneratedQuestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGeneratedQuestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGeneratedQuestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingRequestHyperparameters as json.
func (o OptModelTrainingRequestHyperparameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModelTrainingRequestHyperparameters from json.
func (o *OptModelTrainingRequestHyperparameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModelTrainingRequestHyperparameters to nil")
	}
	o.Set = true
	o.Value = make(ModelTrainingRequestHyperparameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModelTrainingRequestHyperparameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModelTrainingRequestHyperparameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingRequestPriority as json.
func (o OptModelTrainingRequestPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ModelTrainingRequestPriority from json.
func (o *OptModelTrainingRequestPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModelTrainingRequestPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModelTrainingRequestPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModelTrainingRequestPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelTrainingRequestTrainingDataTimeRange as json.
func (o OptModelTrainingRequestTrainingDataTimeRange) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModelTrainingRequestTrainingDataTimeRange from json.
func (o *OptModelTrainingRequestTrainingDataTimeRange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModelTrainingRequestTrainingDataTimeRange to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModelTrainingRequestTrainingDataTimeRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModelTrainingRequestTrainingDataTimeRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NpcBehaviorCombatStyle as json.
func (o OptNpcBehaviorCombatStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NpcBehaviorCombatStyle from json.
func (o *OptNpcBehaviorCombatStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNpcBehaviorCombatStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNpcBehaviorCombatStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNpcBehaviorCombatStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NpcBehaviorInteractionResponses as json.
func (o OptNpcBehaviorInteractionResponses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NpcBehaviorInteractionResponses from json.
func (o *OptNpcBehaviorInteractionResponses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNpcBehaviorInteractionResponses to nil")
	}
	o.Set = true
	o.Value = make(NpcBehaviorInteractionResponses)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNpcBehaviorInteractionResponses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNpcBehaviorInteractionResponses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NpcStats as json.
func (o OptNpcStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NpcStats from json.
func (o *OptNpcStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNpcStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNpcStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNpcStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformanceMetrics as json.
func (o OptPerformanceMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PerformanceMetrics from json.
func (o *OptPerformanceMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPerformanceMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerSkillAssessmentPlayStyle as json.
func (o OptPlayerSkillAssessmentPlayStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayerSkillAssessmentPlayStyle from json.
func (o *OptPlayerSkillAssessmentPlayStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerSkillAssessmentPlayStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerSkillAssessmentPlayStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerSkillAssessmentPlayStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNpcBehaviorRequestBehaviorType as json.
func (o OptUpdateNpcBehaviorRequestBehaviorType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateNpcBehaviorRequestBehaviorType from json.
func (o *OptUpdateNpcBehaviorRequestBehaviorType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNpcBehaviorRequestBehaviorType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNpcBehaviorRequestBehaviorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNpcBehaviorRequestBehaviorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNpcBehaviorRequestCombatStyle as json.
func (o OptUpdateNpcBehaviorRequestCombatStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateNpcBehaviorRequestCombatStyle from json.
func (o *OptUpdateNpcBehaviorRequestCombatStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNpcBehaviorRequestCombatStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNpcBehaviorRequestCombatStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNpcBehaviorRequestCombatStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNpcBehaviorRequestInteractionResponses as json.
func (o OptUpdateNpcBehaviorRequestInteractionResponses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNpcBehaviorRequestInteractionResponses from json.
func (o *OptUpdateNpcBehaviorRequestInteractionResponses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNpcBehaviorRequestInteractionResponses to nil")
	}
	o.Set = true
	o.Value = make(UpdateNpcBehaviorRequestInteractionResponses)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNpcBehaviorRequestInteractionResponses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNpcBehaviorRequestInteractionResponses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSkillAssessmentRequestPlayStyle as json.
func (o OptUpdateSkillAssessmentRequestPlayStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateSkillAssessmentRequestPlayStyle from json.
func (o *OptUpdateSkillAssessmentRequestPlayStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSkillAssessmentRequestPlayStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSkillAssessmentRequestPlayStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSkillAssessmentRequestPlayStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformanceMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformanceMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.WinRate.Set {
			e.FieldStart("win_rate")
			s.WinRate.Encode(e)
		}
	}
	{
		if s.AverageScore.Set {
			e.FieldStart("average_score")
			s.AverageScore.Encode(e)
		}
	}
	{
		if s.AverageKillsPerMatch.Set {
			e.FieldStart("average_kills_per_match")
			s.AverageKillsPerMatch.Encode(e)
		}
	}
	{
		if s.AverageDeathsPerMatch.Set {
			e.FieldStart("average_deaths_per_match")
			s.AverageDeathsPerMatch.Encode(e)
		}
	}
	{
		if s.AccuracyPercentage.Set {
			e.FieldStart("accuracy_percentage")
			s.AccuracyPercentage.Encode(e)
		}
	}
	{
		if s.AverageMatchDuration.Set {
			e.FieldStart("average_match_duration")
			s.AverageMatchDuration.Encode(e)
		}
	}
}

var jsonFieldsNameOfPerformanceMetrics = [6]string{
	0: "win_rate",
	1: "average_score",
	2: "average_kills_per_match",
	3: "average_deaths_per_match",
	4: "accuracy_percentage",
	5: "average_match_duration",
}

// Decode decodes PerformanceMetrics from json.
func (s *PerformanceMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformanceMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "win_rate":
			if err := func() error {
				s.WinRate.Reset()
				if err := s.WinRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win_rate\"")
			}
		case "average_score":
			if err := func() error {
				s.AverageScore.Reset()
				if err := s.AverageScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_score\"")
			}
		case "average_kills_per_match":
			if err := func() error {
				s.AverageKillsPerMatch.Reset()
				if err := s.AverageKillsPerMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_kills_per_match\"")
			}
		case "average_deaths_per_match":
			if err := func() error {
				s.AverageDeathsPerMatch.Reset()
				if err := s.AverageDeathsPerMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_deaths_per_match\"")
			}
		case "accuracy_percentage":
			if err := func() error {
				s.AccuracyPercentage.Reset()
				if err := s.AccuracyPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accuracy_percentage\"")
			}
		case "average_match_duration":
			if err := func() error {
				s.AverageMatchDuration.Reset()
				if err := s.AverageMatchDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_match_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PerformanceMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerBehaviorAnalytics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerBehaviorAnalytics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_id")
		json.EncodeUUID(e, s.AccountID)
	}
	{
		e.FieldStart("time_range")
		s.TimeRange.Encode(e)
	}
	{
		e.FieldStart("analyzed_at")
		json.EncodeDateTime(e, s.AnalyzedAt)
	}
	{
		if s.EngagementMetrics.Set {
			e.FieldStart("engagement_metrics")
			s.EngagementMetrics.Encode(e)
		}
	}
	{
		if s.BehaviorPatterns != nil {
			e.FieldStart("behavior_patterns")
			e.ArrStart()
			for _, elem := range s.BehaviorPatterns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RiskIndicators != nil {
			e.FieldStart("risk_indicators")
			e.ArrStart()
			for _, elem := range s.RiskIndicators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPlayerBehaviorAnalytics = [6]string{
	0: "account_id",
	1: "time_range",
	2: "analyzed_at",
	3: "engagement_metrics",
	4: "behavior_patterns",
	5: "risk_indicators",
}

// Decode decodes PlayerBehaviorAnalytics from json.
func (s *PlayerBehaviorAnalytics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerBehaviorAnalytics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "time_range":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TimeRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_range\"")
			}
		case "analyzed_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.AnalyzedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyzed_at\"")
			}
		case "engagement_metrics":
			if err := func() error {
				s.EngagementMetrics.Reset()
				if err := s.EngagementMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"engagement_metrics\"")
			}
		case "behavior_patterns":
			if err := func() error {
				s.BehaviorPatterns = make([]BehaviorPattern, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BehaviorPattern
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BehaviorPatterns = append(s.BehaviorPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior_patterns\"")
			}
		case "risk_indicators":
			if err := func() error {
				s.RiskIndicators = make([]RiskIndicator, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RiskIndicator
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RiskIndicators = append(s.RiskIndicators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_indicators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerBehaviorAnalytics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerBehaviorAnalytics) {
					name = jsonFieldsNameOfPlayerBehaviorAnalytics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerBehaviorAnalytics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerBehaviorAnalytics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerBehaviorAnalyticsTimeRange as json.
func (s PlayerBehaviorAnalyticsTimeRange) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerBehaviorAnalyticsTimeRange from json.
func (s *PlayerBehaviorAnalyticsTimeRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerBehaviorAnalyticsTimeRange to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerBehaviorAnalyticsTimeRange(v) {
	case PlayerBehaviorAnalyticsTimeRange1h:
		*s = PlayerBehaviorAnalyticsTimeRange1h
	case PlayerBehaviorAnalyticsTimeRange24h:
		*s = PlayerBehaviorAnalyticsTimeRange24h
	case PlayerBehaviorAnalyticsTimeRange7d:
		*s = PlayerBehaviorAnalyticsTimeRange7d
	case PlayerBehaviorAnalyticsTimeRange30d:
		*s = PlayerBehaviorAnalyticsTimeRange30d
	case PlayerBehaviorAnalyticsTimeRange90d:
		*s = PlayerBehaviorAnalyticsTimeRange90d
	default:
		*s = PlayerBehaviorAnalyticsTimeRange(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerBehaviorAnalyticsTimeRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerBehaviorAnalyticsTimeRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerSkillAssessment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerSkillAssessment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_id")
		json.EncodeUUID(e, s.AccountID)
	}
	{
		e.FieldStart("assessed_at")
		json.EncodeDateTime(e, s.AssessedAt)
	}
	{
		if s.PlayStyle.Set {
			e.FieldStart("play_style")
			s.PlayStyle.Encode(e)
		}
	}
	{
		if s.PerformanceMetrics.Set {
			e.FieldStart("performance_metrics")
			s.PerformanceMetrics.Encode(e)
		}
	}
	{
		if s.PreferredGameModes != nil {
			e.FieldStart("preferred_game_modes")
			e.ArrStart()
			for _, elem := range s.PreferredGameModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("skill_level")
		e.Float32(s.SkillLevel)
	}
	{
		e.FieldStart("confidence_score")
		e.Float32(s.ConfidenceScore)
	}
}

var jsonFieldsNameOfPlayerSkillAssessment = [7]string{
	0: "account_id",
	1: "assessed_at",
	2: "play_style",
	3: "performance_metrics",
	4: "preferred_game_modes",
	5: "skill_level",
	6: "confidence_score",
}

// Decode decodes PlayerSkillAssessment from json.
func (s *PlayerSkillAssessment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerSkillAssessment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "assessed_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.AssessedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessed_at\"")
			}
		case "play_style":
			if err := func() error {
				s.PlayStyle.Reset()
				if err := s.PlayStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_style\"")
			}
		case "performance_metrics":
			if err := func() error {
				s.PerformanceMetrics.Reset()
				if err := s.PerformanceMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_metrics\"")
			}
		case "preferred_game_modes":
			if err := func() error {
				s.PreferredGameModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PreferredGameModes = append(s.PreferredGameModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_game_modes\"")
			}
		case "skill_level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.SkillLevel = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_level\"")
			}
		case "confidence_score":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float32()
				s.ConfidenceScore = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerSkillAssessment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerSkillAssessment) {
					name = jsonFieldsNameOfPlayerSkillAssessment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerSkillAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerSkillAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerSkillAssessmentPlayStyle as json.
func (s PlayerSkillAssessmentPlayStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerSkillAssessmentPlayStyle from json.
func (s *PlayerSkillAssessmentPlayStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerSkillAssessmentPlayStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerSkillAssessmentPlayStyle(v) {
	case PlayerSkillAssessmentPlayStyleAggressive:
		*s = PlayerSkillAssessmentPlayStyleAggressive
	case PlayerSkillAssessmentPlayStyleDefensive:
		*s = PlayerSkillAssessmentPlayStyleDefensive
	case PlayerSkillAssessmentPlayStyleStrategic:
		*s = PlayerSkillAssessmentPlayStyleStrategic
	case PlayerSkillAssessmentPlayStyleCasual:
		*s = PlayerSkillAssessmentPlayStyleCasual
	default:
		*s = PlayerSkillAssessmentPlayStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerSkillAssessmentPlayStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerSkillAssessmentPlayStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestObjective) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestObjective) encodeFields(e *jx.Encoder) {
	{
		if s.TargetID.Set {
			e.FieldStart("target_id")
			s.TargetID.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("objective_type")
		s.ObjectiveType.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.TargetCount.Set {
			e.FieldStart("target_count")
			s.TargetCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestObjective = [5]string{
	0: "target_id",
	1: "description",
	2: "objective_type",
	3: "location",
	4: "target_count",
}

// Decode decodes QuestObjective from json.
func (s *QuestObjective) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjective to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			if err := func() error {
				s.TargetID.Reset()
				if err := s.TargetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objective_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ObjectiveType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "target_count":
			if err := func() error {
				s.TargetCount.Reset()
				if err := s.TargetCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestObjective")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQuestObjective) {
					name = jsonFieldsNameOfQuestObjective[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestObjective) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjective) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestObjectiveObjectiveType as json.
func (s QuestObjectiveObjectiveType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestObjectiveObjectiveType from json.
func (s *QuestObjectiveObjectiveType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjectiveObjectiveType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestObjectiveObjectiveType(v) {
	case QuestObjectiveObjectiveTypeKill:
		*s = QuestObjectiveObjectiveTypeKill
	case QuestObjectiveObjectiveTypeCollect:
		*s = QuestObjectiveObjectiveTypeCollect
	case QuestObjectiveObjectiveTypeExplore:
		*s = QuestObjectiveObjectiveTypeExplore
	case QuestObjectiveObjectiveTypeInteract:
		*s = QuestObjectiveObjectiveTypeInteract
	case QuestObjectiveObjectiveTypeSurvive:
		*s = QuestObjectiveObjectiveTypeSurvive
	case QuestObjectiveObjectiveTypeEscort:
		*s = QuestObjectiveObjectiveTypeEscort
	default:
		*s = QuestObjectiveObjectiveType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestObjectiveObjectiveType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjectiveObjectiveType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestReward) encodeFields(e *jx.Encoder) {
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		e.FieldStart("reward_type")
		s.RewardType.Encode(e)
	}
	{
		e.FieldStart("amount")
		e.Int(s.Amount)
	}
}

var jsonFieldsNameOfQuestReward = [3]string{
	0: "item_id",
	1: "reward_type",
	2: "amount",
}

// Decode decodes QuestReward from json.
func (s *QuestReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "reward_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RewardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward_type\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Amount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQuestReward) {
					name = jsonFieldsNameOfQuestReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestRewardRewardType as json.
func (s QuestRewardRewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestRewardRewardType from json.
func (s *QuestRewardRewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestRewardRewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestRewardRewardType(v) {
	case QuestRewardRewardTypeExperience:
		*s = QuestRewardRewardTypeExperience
	case QuestRewardRewardTypeCurrency:
		*s = QuestRewardRewardTypeCurrency
	case QuestRewardRewardTypeItem:
		*s = QuestRewardRewardTypeItem
	case QuestRewardRewardTypeReputation:
		*s = QuestRewardRewardTypeReputation
	case QuestRewardRewardTypeTitle:
		*s = QuestRewardRewardTypeTitle
	default:
		*s = QuestRewardRewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestRewardRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestRewardRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RiskIndicator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RiskIndicator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("indicator_type")
		s.IndicatorType.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Evidence != nil {
			e.FieldStart("evidence")
			e.ArrStart()
			for _, elem := range s.Evidence {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("severity")
		e.Float32(s.Severity)
	}
}

var jsonFieldsNameOfRiskIndicator = [4]string{
	0: "indicator_type",
	1: "description",
	2: "evidence",
	3: "severity",
}

// Decode decodes RiskIndicator from json.
func (s *RiskIndicator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskIndicator to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "indicator_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IndicatorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indicator_type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "evidence":
			if err := func() error {
				s.Evidence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Evidence = append(s.Evidence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Severity = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RiskIndicator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRiskIndicator) {
					name = jsonFieldsNameOfRiskIndicator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RiskIndicator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskIndicator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RiskIndicatorIndicatorType as json.
func (s RiskIndicatorIndicatorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RiskIndicatorIndicatorType from json.
func (s *RiskIndicatorIndicatorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RiskIndicatorIndicatorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RiskIndicatorIndicatorType(v) {
	case RiskIndicatorIndicatorTypeAimbotSuspicion:
		*s = RiskIndicatorIndicatorTypeAimbotSuspicion
	case RiskIndicatorIndicatorTypeSpeedHackSuspicion:
		*s = RiskIndicatorIndicatorTypeSpeedHackSuspicion
	case RiskIndicatorIndicatorTypeWallHackSuspicion:
		*s = RiskIndicatorIndicatorTypeWallHackSuspicion
	case RiskIndicatorIndicatorTypeUnusualWinRate:
		*s = RiskIndicatorIndicatorTypeUnusualWinRate
	case RiskIndicatorIndicatorTypePatternExploitation:
		*s = RiskIndicatorIndicatorTypePatternExploitation
	default:
		*s = RiskIndicatorIndicatorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RiskIndicatorIndicatorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RiskIndicatorIndicatorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuspiciousBehaviorReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuspiciousBehaviorReport) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("account_id")
		json.EncodeUUID(e, s.AccountID)
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		e.FieldStart("behavior_type")
		s.BehaviorType.Encode(e)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("evidence")
		e.ArrStart()
		for _, elem := range s.Evidence {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("severity")
		e.Float32(s.Severity)
	}
}

var jsonFieldsNameOfSuspiciousBehaviorReport = [6]string{
	0: "account_id",
	1: "session_id",
	2: "behavior_type",
	3: "timestamp",
	4: "evidence",
	5: "severity",
}

// Decode decodes SuspiciousBehaviorReport from json.
func (s *SuspiciousBehaviorReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuspiciousBehaviorReport to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AccountID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "behavior_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.BehaviorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior_type\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "evidence":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Evidence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Evidence = append(s.Evidence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.Severity = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuspiciousBehaviorReport")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuspiciousBehaviorReport) {
					name = jsonFieldsNameOfSuspiciousBehaviorReport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuspiciousBehaviorReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuspiciousBehaviorReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuspiciousBehaviorReportBehaviorType as json.
func (s SuspiciousBehaviorReportBehaviorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SuspiciousBehaviorReportBehaviorType from json.
func (s *SuspiciousBehaviorReportBehaviorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuspiciousBehaviorReportBehaviorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SuspiciousBehaviorReportBehaviorType(v) {
	case SuspiciousBehaviorReportBehaviorTypeAimbot:
		*s = SuspiciousBehaviorReportBehaviorTypeAimbot
	case SuspiciousBehaviorReportBehaviorTypeSpeedHack:
		*s = SuspiciousBehaviorReportBehaviorTypeSpeedHack
	case SuspiciousBehaviorReportBehaviorTypeWallHack:
		*s = SuspiciousBehaviorReportBehaviorTypeWallHack
	case SuspiciousBehaviorReportBehaviorTypeUnusualAccuracy:
		*s = SuspiciousBehaviorReportBehaviorTypeUnusualAccuracy
	case SuspiciousBehaviorReportBehaviorTypePatternExploitation:
		*s = SuspiciousBehaviorReportBehaviorTypePatternExploitation
	case SuspiciousBehaviorReportBehaviorTypeStatManipulation:
		*s = SuspiciousBehaviorReportBehaviorTypeStatManipulation
	default:
		*s = SuspiciousBehaviorReportBehaviorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuspiciousBehaviorReportBehaviorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuspiciousBehaviorReportBehaviorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TriggerModelTrainingBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TriggerModelTrainingBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfTriggerModelTrainingBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes TriggerModelTrainingBadRequest from json.
func (s *TriggerModelTrainingBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerModelTrainingBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem TriggerModelTrainingBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TriggerModelTrainingBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTriggerModelTrainingBadRequest) {
					name = jsonFieldsNameOfTriggerModelTrainingBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerModelTrainingBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerModelTrainingBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TriggerModelTrainingBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TriggerModelTrainingBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTriggerModelTrainingBadRequestDetails = [0]string{}

// Decode decodes TriggerModelTrainingBadRequestDetails from json.
func (s *TriggerModelTrainingBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerModelTrainingBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TriggerModelTrainingBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerModelTrainingBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerModelTrainingBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TriggerModelTrainingTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TriggerModelTrainingTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			e.FieldStart("retry_after")
			s.RetryAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfTriggerModelTrainingTooManyRequests = [4]string{
	0: "code",
	1: "message",
	2: "details",
	3: "retry_after",
}

// Decode decodes TriggerModelTrainingTooManyRequests from json.
func (s *TriggerModelTrainingTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerModelTrainingTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem TriggerModelTrainingTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "retry_after":
			if err := func() error {
				s.RetryAfter.Reset()
				if err := s.RetryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_after\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TriggerModelTrainingTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTriggerModelTrainingTooManyRequests) {
					name = jsonFieldsNameOfTriggerModelTrainingTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerModelTrainingTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerModelTrainingTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TriggerModelTrainingTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TriggerModelTrainingTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTriggerModelTrainingTooManyRequestsDetails = [0]string{}

// Decode decodes TriggerModelTrainingTooManyRequestsDetails from json.
func (s *TriggerModelTrainingTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerModelTrainingTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TriggerModelTrainingTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerModelTrainingTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerModelTrainingTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNpcBehaviorBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNpcBehaviorBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNpcBehaviorBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNpcBehaviorBadRequest from json.
func (s *UpdateNpcBehaviorBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNpcBehaviorBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNpcBehaviorBadRequest) {
					name = jsonFieldsNameOfUpdateNpcBehaviorBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNpcBehaviorBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNpcBehaviorBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNpcBehaviorBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNpcBehaviorBadRequestDetails = [0]string{}

// Decode decodes UpdateNpcBehaviorBadRequestDetails from json.
func (s *UpdateNpcBehaviorBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNpcBehaviorBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNpcBehaviorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNpcBehaviorNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNpcBehaviorNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNpcBehaviorNotFound from json.
func (s *UpdateNpcBehaviorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNpcBehaviorNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNpcBehaviorNotFound) {
					name = jsonFieldsNameOfUpdateNpcBehaviorNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNpcBehaviorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNpcBehaviorNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNpcBehaviorNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNpcBehaviorNotFoundDetails = [0]string{}

// Decode decodes UpdateNpcBehaviorNotFoundDetails from json.
func (s *UpdateNpcBehaviorNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNpcBehaviorNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNpcBehaviorRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNpcBehaviorRequest) encodeFields(e *jx.Encoder) {
	{
		if s.BehaviorType.Set {
			e.FieldStart("behavior_type")
			s.BehaviorType.Encode(e)
		}
	}
	{
		if s.CombatStyle.Set {
			e.FieldStart("combat_style")
			s.CombatStyle.Encode(e)
		}
	}
	{
		if s.InteractionResponses.Set {
			e.FieldStart("interaction_responses")
			s.InteractionResponses.Encode(e)
		}
	}
	{
		if s.PatrolRoute != nil {
			e.FieldStart("patrol_route")
			e.ArrStart()
			for _, elem := range s.PatrolRoute {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Aggressiveness.Set {
			e.FieldStart("aggressiveness")
			s.Aggressiveness.Encode(e)
		}
	}
	{
		if s.Intelligence.Set {
			e.FieldStart("intelligence")
			s.Intelligence.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNpcBehaviorRequest = [6]string{
	0: "behavior_type",
	1: "combat_style",
	2: "interaction_responses",
	3: "patrol_route",
	4: "aggressiveness",
	5: "intelligence",
}

// Decode decodes UpdateNpcBehaviorRequest from json.
func (s *UpdateNpcBehaviorRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "behavior_type":
			if err := func() error {
				s.BehaviorType.Reset()
				if err := s.BehaviorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior_type\"")
			}
		case "combat_style":
			if err := func() error {
				s.CombatStyle.Reset()
				if err := s.CombatStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_style\"")
			}
		case "interaction_responses":
			if err := func() error {
				s.InteractionResponses.Reset()
				if err := s.InteractionResponses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_responses\"")
			}
		case "patrol_route":
			if err := func() error {
				s.PatrolRoute = make([]Vector3, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vector3
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PatrolRoute = append(s.PatrolRoute, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patrol_route\"")
			}
		case "aggressiveness":
			if err := func() error {
				s.Aggressiveness.Reset()
				if err := s.Aggressiveness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggressiveness\"")
			}
		case "intelligence":
			if err := func() error {
				s.Intelligence.Reset()
				if err := s.Intelligence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intelligence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNpcBehaviorRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNpcBehaviorRequestBehaviorType as json.
func (s UpdateNpcBehaviorRequestBehaviorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateNpcBehaviorRequestBehaviorType from json.
func (s *UpdateNpcBehaviorRequestBehaviorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorRequestBehaviorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateNpcBehaviorRequestBehaviorType(v) {
	case UpdateNpcBehaviorRequestBehaviorTypePassive:
		*s = UpdateNpcBehaviorRequestBehaviorTypePassive
	case UpdateNpcBehaviorRequestBehaviorTypeAggressive:
		*s = UpdateNpcBehaviorRequestBehaviorTypeAggressive
	case UpdateNpcBehaviorRequestBehaviorTypeDefensive:
		*s = UpdateNpcBehaviorRequestBehaviorTypeDefensive
	case UpdateNpcBehaviorRequestBehaviorTypePatrol:
		*s = UpdateNpcBehaviorRequestBehaviorTypePatrol
	case UpdateNpcBehaviorRequestBehaviorTypeGuard:
		*s = UpdateNpcBehaviorRequestBehaviorTypeGuard
	case UpdateNpcBehaviorRequestBehaviorTypeMerchant:
		*s = UpdateNpcBehaviorRequestBehaviorTypeMerchant
	case UpdateNpcBehaviorRequestBehaviorTypeQuestGiver:
		*s = UpdateNpcBehaviorRequestBehaviorTypeQuestGiver
	default:
		*s = UpdateNpcBehaviorRequestBehaviorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNpcBehaviorRequestBehaviorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorRequestBehaviorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNpcBehaviorRequestCombatStyle as json.
func (s UpdateNpcBehaviorRequestCombatStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateNpcBehaviorRequestCombatStyle from json.
func (s *UpdateNpcBehaviorRequestCombatStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorRequestCombatStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateNpcBehaviorRequestCombatStyle(v) {
	case UpdateNpcBehaviorRequestCombatStyleMelee:
		*s = UpdateNpcBehaviorRequestCombatStyleMelee
	case UpdateNpcBehaviorRequestCombatStyleRanged:
		*s = UpdateNpcBehaviorRequestCombatStyleRanged
	case UpdateNpcBehaviorRequestCombatStyleMagic:
		*s = UpdateNpcBehaviorRequestCombatStyleMagic
	case UpdateNpcBehaviorRequestCombatStyleMixed:
		*s = UpdateNpcBehaviorRequestCombatStyleMixed
	default:
		*s = UpdateNpcBehaviorRequestCombatStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNpcBehaviorRequestCombatStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorRequestCombatStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateNpcBehaviorRequestInteractionResponses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateNpcBehaviorRequestInteractionResponses) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateNpcBehaviorRequestInteractionResponses from json.
func (s *UpdateNpcBehaviorRequestInteractionResponses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNpcBehaviorRequestInteractionResponses to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNpcBehaviorRequestInteractionResponses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNpcBehaviorRequestInteractionResponses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNpcBehaviorRequestInteractionResponses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerSkillAssessmentBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerSkillAssessmentBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePlayerSkillAssessmentBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdatePlayerSkillAssessmentBadRequest from json.
func (s *UpdatePlayerSkillAssessmentBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerSkillAssessmentBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdatePlayerSkillAssessmentBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerSkillAssessmentBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerSkillAssessmentBadRequest) {
					name = jsonFieldsNameOfUpdatePlayerSkillAssessmentBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerSkillAssessmentBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerSkillAssessmentBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerSkillAssessmentBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerSkillAssessmentBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdatePlayerSkillAssessmentBadRequestDetails = [0]string{}

// Decode decodes UpdatePlayerSkillAssessmentBadRequestDetails from json.
func (s *UpdatePlayerSkillAssessmentBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerSkillAssessmentBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerSkillAssessmentBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerSkillAssessmentBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerSkillAssessmentBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerSkillAssessmentNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerSkillAssessmentNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePlayerSkillAssessmentNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdatePlayerSkillAssessmentNotFound from json.
func (s *UpdatePlayerSkillAssessmentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerSkillAssessmentNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdatePlayerSkillAssessmentNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerSkillAssessmentNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePlayerSkillAssessmentNotFound) {
					name = jsonFieldsNameOfUpdatePlayerSkillAssessmentNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerSkillAssessmentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerSkillAssessmentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePlayerSkillAssessmentNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePlayerSkillAssessmentNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdatePlayerSkillAssessmentNotFoundDetails = [0]string{}

// Decode decodes UpdatePlayerSkillAssessmentNotFoundDetails from json.
func (s *UpdatePlayerSkillAssessmentNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerSkillAssessmentNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePlayerSkillAssessmentNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerSkillAssessmentNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerSkillAssessmentNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSkillAssessmentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSkillAssessmentRequest) encodeFields(e *jx.Encoder) {
	{
		if s.PlayStyle.Set {
			e.FieldStart("play_style")
			s.PlayStyle.Encode(e)
		}
	}
	{
		if s.PerformanceData.Set {
			e.FieldStart("performance_data")
			s.PerformanceData.Encode(e)
		}
	}
	{
		if s.SkillLevel.Set {
			e.FieldStart("skill_level")
			s.SkillLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSkillAssessmentRequest = [3]string{
	0: "play_style",
	1: "performance_data",
	2: "skill_level",
}

// Decode decodes UpdateSkillAssessmentRequest from json.
func (s *UpdateSkillAssessmentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSkillAssessmentRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "play_style":
			if err := func() error {
				s.PlayStyle.Reset()
				if err := s.PlayStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_style\"")
			}
		case "performance_data":
			if err := func() error {
				s.PerformanceData.Reset()
				if err := s.PerformanceData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_data\"")
			}
		case "skill_level":
			if err := func() error {
				s.SkillLevel.Reset()
				if err := s.SkillLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSkillAssessmentRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSkillAssessmentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSkillAssessmentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSkillAssessmentRequestPlayStyle as json.
func (s UpdateSkillAssessmentRequestPlayStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSkillAssessmentRequestPlayStyle from json.
func (s *UpdateSkillAssessmentRequestPlayStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSkillAssessmentRequestPlayStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSkillAssessmentRequestPlayStyle(v) {
	case UpdateSkillAssessmentRequestPlayStyleAggressive:
		*s = UpdateSkillAssessmentRequestPlayStyleAggressive
	case UpdateSkillAssessmentRequestPlayStyleDefensive:
		*s = UpdateSkillAssessmentRequestPlayStyleDefensive
	case UpdateSkillAssessmentRequestPlayStyleStrategic:
		*s = UpdateSkillAssessmentRequestPlayStyleStrategic
	case UpdateSkillAssessmentRequestPlayStyleCasual:
		*s = UpdateSkillAssessmentRequestPlayStyleCasual
	default:
		*s = UpdateSkillAssessmentRequestPlayStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSkillAssessmentRequestPlayStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSkillAssessmentRequestPlayStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vector3) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vector3) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfVector3 = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes Vector3 from json.
func (s *Vector3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vector3 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vector3")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVector3) {
					name = jsonFieldsNameOfVector3[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vector3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vector3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.MessageTimestamp.Set {
			e.FieldStart("message_timestamp")
			s.MessageTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("health")
		s.Health.Encode(e)
	}
}

var jsonFieldsNameOfWebSocketHealthMessage = [4]string{
	0: "type",
	1: "timestamp",
	2: "message_timestamp",
	3: "health",
}

// Decode decodes WebSocketHealthMessage from json.
func (s *WebSocketHealthMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "message_timestamp":
			if err := func() error {
				s.MessageTimestamp.Reset()
				if err := s.MessageTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_timestamp\"")
			}
		case "health":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Health.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessage) {
					name = jsonFieldsNameOfWebSocketHealthMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessageHealth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessageHealth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebSocketHealthMessageHealth = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes WebSocketHealthMessageHealth from json.
func (s *WebSocketHealthMessageHealth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessageHealth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessageHealth) {
					name = jsonFieldsNameOfWebSocketHealthMessageHealth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessageHealth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageHealthStatus as json.
func (s WebSocketHealthMessageHealthStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageHealthStatus from json.
func (s *WebSocketHealthMessageHealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealthStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageHealthStatus(v) {
	case WebSocketHealthMessageHealthStatusHealthy:
		*s = WebSocketHealthMessageHealthStatusHealthy
	case WebSocketHealthMessageHealthStatusDegraded:
		*s = WebSocketHealthMessageHealthStatusDegraded
	case WebSocketHealthMessageHealthStatusUnhealthy:
		*s = WebSocketHealthMessageHealthStatusUnhealthy
	default:
		*s = WebSocketHealthMessageHealthStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageHealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageType as json.
func (s WebSocketHealthMessageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageType from json.
func (s *WebSocketHealthMessageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageType(v) {
	case WebSocketHealthMessageTypeHealthUpdate:
		*s = WebSocketHealthMessageTypeHealthUpdate
	case WebSocketHealthMessageTypeHealthAlert:
		*s = WebSocketHealthMessageTypeHealthAlert
	case WebSocketHealthMessageTypeServiceDown:
		*s = WebSocketHealthMessageTypeServiceDown
	default:
		*s = WebSocketHealthMessageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
