// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AvailableReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("tier")
		s.Tier.Encode(e)
	}
	{
		e.FieldStart("reward")
		s.Reward.Encode(e)
	}
	{
		if s.CanClaim.Set {
			e.FieldStart("canClaim")
			s.CanClaim.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfAvailableReward = [5]string{
	0: "level",
	1: "tier",
	2: "reward",
	3: "canClaim",
	4: "reason",
}

// Decode decodes AvailableReward from json.
func (s *AvailableReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "reward":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Reward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward\"")
			}
		case "canClaim":
			if err := func() error {
				s.CanClaim.Reset()
				if err := s.CanClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canClaim\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableReward) {
					name = jsonFieldsNameOfAvailableReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AvailableRewardTier as json.
func (s AvailableRewardTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AvailableRewardTier from json.
func (s *AvailableRewardTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableRewardTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AvailableRewardTier(v) {
	case AvailableRewardTierFree:
		*s = AvailableRewardTierFree
	case AvailableRewardTierPremium:
		*s = AvailableRewardTierPremium
	default:
		*s = AvailableRewardTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AvailableRewardTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableRewardTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("reward")
		s.Reward.Encode(e)
	}
	{
		if s.ClaimedAt.Set {
			e.FieldStart("claimedAt")
			s.ClaimedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InventoryId.Set {
			e.FieldStart("inventoryId")
			s.InventoryId.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimResult = [4]string{
	0: "success",
	1: "reward",
	2: "claimedAt",
	3: "inventoryId",
}

// Decode decodes ClaimResult from json.
func (s *ClaimResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "reward":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward\"")
			}
		case "claimedAt":
			if err := func() error {
				s.ClaimedAt.Reset()
				if err := s.ClaimedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedAt\"")
			}
		case "inventoryId":
			if err := func() error {
				s.InventoryId.Reset()
				if err := s.InventoryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventoryId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimResult) {
					name = jsonFieldsNameOfClaimResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfHealthGetOK = [2]string{
	0: "status",
	1: "timestamp",
}

// Decode decodes HealthGetOK from json.
func (s *HealthGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerProgressClaimedRewardsItemTier as json.
func (o OptPlayerProgressClaimedRewardsItemTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayerProgressClaimedRewardsItemTier from json.
func (o *OptPlayerProgressClaimedRewardsItemTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerProgressClaimedRewardsItemTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerProgressClaimedRewardsItemTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerProgressClaimedRewardsItemTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerStatisticsFavoriteRewardType as json.
func (o OptPlayerStatisticsFavoriteRewardType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayerStatisticsFavoriteRewardType from json.
func (o *OptPlayerStatisticsFavoriteRewardType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerStatisticsFavoriteRewardType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerStatisticsFavoriteRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerStatisticsFavoriteRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Reward as json.
func (o OptReward) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Reward from json.
func (o *OptReward) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReward to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardRarity as json.
func (o OptRewardRarity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RewardRarity from json.
func (o *OptRewardRarity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRewardRarity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRewardRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRewardRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerProgress) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("seasonId")
		e.Str(s.SeasonId)
	}
	{
		e.FieldStart("currentLevel")
		e.Int(s.CurrentLevel)
	}
	{
		e.FieldStart("currentXp")
		e.Int(s.CurrentXp)
	}
	{
		e.FieldStart("totalXp")
		e.Int(s.TotalXp)
	}
	{
		if s.XpToNextLevel.Set {
			e.FieldStart("xpToNextLevel")
			s.XpToNextLevel.Encode(e)
		}
	}
	{
		e.FieldStart("hasPremium")
		e.Bool(s.HasPremium)
	}
	{
		if s.ClaimedRewards != nil {
			e.FieldStart("claimedRewards")
			e.ArrStart()
			for _, elem := range s.ClaimedRewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPlayerProgress = [8]string{
	0: "playerId",
	1: "seasonId",
	2: "currentLevel",
	3: "currentXp",
	4: "totalXp",
	5: "xpToNextLevel",
	6: "hasPremium",
	7: "claimedRewards",
}

// Decode decodes PlayerProgress from json.
func (s *PlayerProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerProgress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "seasonId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SeasonId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonId\"")
			}
		case "currentLevel":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CurrentLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentLevel\"")
			}
		case "currentXp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CurrentXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentXp\"")
			}
		case "totalXp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalXp\"")
			}
		case "xpToNextLevel":
			if err := func() error {
				s.XpToNextLevel.Reset()
				if err := s.XpToNextLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xpToNextLevel\"")
			}
		case "hasPremium":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasPremium = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasPremium\"")
			}
		case "claimedRewards":
			if err := func() error {
				s.ClaimedRewards = make([]PlayerProgressClaimedRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PlayerProgressClaimedRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClaimedRewards = append(s.ClaimedRewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedRewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerProgress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerProgress) {
					name = jsonFieldsNameOfPlayerProgress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerProgressClaimedRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerProgressClaimedRewardsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		if s.ClaimedAt.Set {
			e.FieldStart("claimedAt")
			s.ClaimedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPlayerProgressClaimedRewardsItem = [3]string{
	0: "level",
	1: "tier",
	2: "claimedAt",
}

// Decode decodes PlayerProgressClaimedRewardsItem from json.
func (s *PlayerProgressClaimedRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerProgressClaimedRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "claimedAt":
			if err := func() error {
				s.ClaimedAt.Reset()
				if err := s.ClaimedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerProgressClaimedRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerProgressClaimedRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerProgressClaimedRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerProgressClaimedRewardsItemTier as json.
func (s PlayerProgressClaimedRewardsItemTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerProgressClaimedRewardsItemTier from json.
func (s *PlayerProgressClaimedRewardsItemTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerProgressClaimedRewardsItemTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerProgressClaimedRewardsItemTier(v) {
	case PlayerProgressClaimedRewardsItemTierFree:
		*s = PlayerProgressClaimedRewardsItemTierFree
	case PlayerProgressClaimedRewardsItemTierPremium:
		*s = PlayerProgressClaimedRewardsItemTierPremium
	default:
		*s = PlayerProgressClaimedRewardsItemTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerProgressClaimedRewardsItemTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerProgressClaimedRewardsItemTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerStatistics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("seasonsPlayed")
		e.Int(s.SeasonsPlayed)
	}
	{
		e.FieldStart("totalXpEarned")
		e.Int(s.TotalXpEarned)
	}
	{
		e.FieldStart("highestLevelReached")
		e.Int(s.HighestLevelReached)
	}
	{
		e.FieldStart("rewardsClaimed")
		e.Int(s.RewardsClaimed)
	}
	{
		if s.PremiumPassesPurchased.Set {
			e.FieldStart("premiumPassesPurchased")
			s.PremiumPassesPurchased.Encode(e)
		}
	}
	{
		if s.FavoriteRewardType.Set {
			e.FieldStart("favoriteRewardType")
			s.FavoriteRewardType.Encode(e)
		}
	}
	{
		if s.SeasonsData != nil {
			e.FieldStart("seasonsData")
			e.ArrStart()
			for _, elem := range s.SeasonsData {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPlayerStatistics = [8]string{
	0: "playerId",
	1: "seasonsPlayed",
	2: "totalXpEarned",
	3: "highestLevelReached",
	4: "rewardsClaimed",
	5: "premiumPassesPurchased",
	6: "favoriteRewardType",
	7: "seasonsData",
}

// Decode decodes PlayerStatistics from json.
func (s *PlayerStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerStatistics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "seasonsPlayed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.SeasonsPlayed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonsPlayed\"")
			}
		case "totalXpEarned":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalXpEarned = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalXpEarned\"")
			}
		case "highestLevelReached":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.HighestLevelReached = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highestLevelReached\"")
			}
		case "rewardsClaimed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.RewardsClaimed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsClaimed\"")
			}
		case "premiumPassesPurchased":
			if err := func() error {
				s.PremiumPassesPurchased.Reset()
				if err := s.PremiumPassesPurchased.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premiumPassesPurchased\"")
			}
		case "favoriteRewardType":
			if err := func() error {
				s.FavoriteRewardType.Reset()
				if err := s.FavoriteRewardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favoriteRewardType\"")
			}
		case "seasonsData":
			if err := func() error {
				s.SeasonsData = make([]PlayerStatisticsSeasonsDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PlayerStatisticsSeasonsDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SeasonsData = append(s.SeasonsData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonsData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerStatistics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerStatistics) {
					name = jsonFieldsNameOfPlayerStatistics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerStatisticsFavoriteRewardType as json.
func (s PlayerStatisticsFavoriteRewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerStatisticsFavoriteRewardType from json.
func (s *PlayerStatisticsFavoriteRewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerStatisticsFavoriteRewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerStatisticsFavoriteRewardType(v) {
	case PlayerStatisticsFavoriteRewardTypeCosmetic:
		*s = PlayerStatisticsFavoriteRewardTypeCosmetic
	case PlayerStatisticsFavoriteRewardTypeWeapon:
		*s = PlayerStatisticsFavoriteRewardTypeWeapon
	case PlayerStatisticsFavoriteRewardTypeCurrency:
		*s = PlayerStatisticsFavoriteRewardTypeCurrency
	case PlayerStatisticsFavoriteRewardTypeBoost:
		*s = PlayerStatisticsFavoriteRewardTypeBoost
	case PlayerStatisticsFavoriteRewardTypeTitle:
		*s = PlayerStatisticsFavoriteRewardTypeTitle
	case PlayerStatisticsFavoriteRewardTypeEmote:
		*s = PlayerStatisticsFavoriteRewardTypeEmote
	default:
		*s = PlayerStatisticsFavoriteRewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerStatisticsFavoriteRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerStatisticsFavoriteRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerStatisticsSeasonsDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerStatisticsSeasonsDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.SeasonId.Set {
			e.FieldStart("seasonId")
			s.SeasonId.Encode(e)
		}
	}
	{
		if s.SeasonName.Set {
			e.FieldStart("seasonName")
			s.SeasonName.Encode(e)
		}
	}
	{
		if s.FinalLevel.Set {
			e.FieldStart("finalLevel")
			s.FinalLevel.Encode(e)
		}
	}
	{
		if s.XpEarned.Set {
			e.FieldStart("xpEarned")
			s.XpEarned.Encode(e)
		}
	}
	{
		if s.RewardsClaimed.Set {
			e.FieldStart("rewardsClaimed")
			s.RewardsClaimed.Encode(e)
		}
	}
	{
		if s.HadPremium.Set {
			e.FieldStart("hadPremium")
			s.HadPremium.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayerStatisticsSeasonsDataItem = [6]string{
	0: "seasonId",
	1: "seasonName",
	2: "finalLevel",
	3: "xpEarned",
	4: "rewardsClaimed",
	5: "hadPremium",
}

// Decode decodes PlayerStatisticsSeasonsDataItem from json.
func (s *PlayerStatisticsSeasonsDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerStatisticsSeasonsDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "seasonId":
			if err := func() error {
				s.SeasonId.Reset()
				if err := s.SeasonId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonId\"")
			}
		case "seasonName":
			if err := func() error {
				s.SeasonName.Reset()
				if err := s.SeasonName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonName\"")
			}
		case "finalLevel":
			if err := func() error {
				s.FinalLevel.Reset()
				if err := s.FinalLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalLevel\"")
			}
		case "xpEarned":
			if err := func() error {
				s.XpEarned.Reset()
				if err := s.XpEarned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xpEarned\"")
			}
		case "rewardsClaimed":
			if err := func() error {
				s.RewardsClaimed.Reset()
				if err := s.RewardsClaimed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsClaimed\"")
			}
		case "hadPremium":
			if err := func() error {
				s.HadPremium.Reset()
				if err := s.HadPremium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hadPremium\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerStatisticsSeasonsDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerStatisticsSeasonsDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerStatisticsSeasonsDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProgressPlayerIdXpPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProgressPlayerIdXpPostOK) encodeFields(e *jx.Encoder) {
	{
		if s.NewLevel.Set {
			e.FieldStart("newLevel")
			s.NewLevel.Encode(e)
		}
	}
	{
		if s.XpGained.Set {
			e.FieldStart("xpGained")
			s.XpGained.Encode(e)
		}
	}
	{
		if s.RewardsUnlocked != nil {
			e.FieldStart("rewardsUnlocked")
			e.ArrStart()
			for _, elem := range s.RewardsUnlocked {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProgressPlayerIdXpPostOK = [3]string{
	0: "newLevel",
	1: "xpGained",
	2: "rewardsUnlocked",
}

// Decode decodes ProgressPlayerIdXpPostOK from json.
func (s *ProgressPlayerIdXpPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProgressPlayerIdXpPostOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "newLevel":
			if err := func() error {
				s.NewLevel.Reset()
				if err := s.NewLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newLevel\"")
			}
		case "xpGained":
			if err := func() error {
				s.XpGained.Reset()
				if err := s.XpGained.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xpGained\"")
			}
		case "rewardsUnlocked":
			if err := func() error {
				s.RewardsUnlocked = make([]Reward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Reward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RewardsUnlocked = append(s.RewardsUnlocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsUnlocked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProgressPlayerIdXpPostOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProgressPlayerIdXpPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProgressPlayerIdXpPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProgressPlayerIdXpPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProgressPlayerIdXpPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("amount")
		e.Int(s.Amount)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfProgressPlayerIdXpPostReq = [3]string{
	0: "amount",
	1: "reason",
	2: "metadata",
}

// Decode decodes ProgressPlayerIdXpPostReq from json.
func (s *ProgressPlayerIdXpPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProgressPlayerIdXpPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Amount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem ProgressPlayerIdXpPostReqMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProgressPlayerIdXpPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProgressPlayerIdXpPostReq) {
					name = jsonFieldsNameOfProgressPlayerIdXpPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProgressPlayerIdXpPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProgressPlayerIdXpPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProgressPlayerIdXpPostReqMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProgressPlayerIdXpPostReqMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProgressPlayerIdXpPostReqMetadata = [0]string{}

// Decode decodes ProgressPlayerIdXpPostReqMetadata from json.
func (s *ProgressPlayerIdXpPostReqMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProgressPlayerIdXpPostReqMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProgressPlayerIdXpPostReqMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProgressPlayerIdXpPostReqMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProgressPlayerIdXpPostReqMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProgressPlayerIdXpPostReqReason as json.
func (s ProgressPlayerIdXpPostReqReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProgressPlayerIdXpPostReqReason from json.
func (s *ProgressPlayerIdXpPostReqReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProgressPlayerIdXpPostReqReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProgressPlayerIdXpPostReqReason(v) {
	case ProgressPlayerIdXpPostReqReasonMissionComplete:
		*s = ProgressPlayerIdXpPostReqReasonMissionComplete
	case ProgressPlayerIdXpPostReqReasonMatchWin:
		*s = ProgressPlayerIdXpPostReqReasonMatchWin
	case ProgressPlayerIdXpPostReqReasonDailyLogin:
		*s = ProgressPlayerIdXpPostReqReasonDailyLogin
	case ProgressPlayerIdXpPostReqReasonAchievement:
		*s = ProgressPlayerIdXpPostReqReasonAchievement
	case ProgressPlayerIdXpPostReqReasonPurchase:
		*s = ProgressPlayerIdXpPostReqReasonPurchase
	default:
		*s = ProgressPlayerIdXpPostReqReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProgressPlayerIdXpPostReqReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProgressPlayerIdXpPostReqReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Reward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Reward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Rarity.Set {
			e.FieldStart("rarity")
			s.Rarity.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfReward = [6]string{
	0: "id",
	1: "type",
	2: "name",
	3: "description",
	4: "rarity",
	5: "metadata",
}

// Decode decodes Reward from json.
func (s *Reward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "rarity":
			if err := func() error {
				s.Rarity.Reset()
				if err := s.Rarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem RewardMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Reward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReward) {
					name = jsonFieldsNameOfReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Reward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Reward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRewardMetadata = [0]string{}

// Decode decodes RewardMetadata from json.
func (s *RewardMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RewardMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardRarity as json.
func (s RewardRarity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RewardRarity from json.
func (s *RewardRarity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardRarity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RewardRarity(v) {
	case RewardRarityCommon:
		*s = RewardRarityCommon
	case RewardRarityRare:
		*s = RewardRarityRare
	case RewardRarityEpic:
		*s = RewardRarityEpic
	case RewardRarityLegendary:
		*s = RewardRarityLegendary
	default:
		*s = RewardRarity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RewardRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardType as json.
func (s RewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RewardType from json.
func (s *RewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RewardType(v) {
	case RewardTypeCosmetic:
		*s = RewardTypeCosmetic
	case RewardTypeWeapon:
		*s = RewardTypeWeapon
	case RewardTypeCurrency:
		*s = RewardTypeCurrency
	case RewardTypeBoost:
		*s = RewardTypeBoost
	case RewardTypeTitle:
		*s = RewardTypeTitle
	case RewardTypeEmote:
		*s = RewardTypeEmote
	default:
		*s = RewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardsPlayerIdAvailableGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardsPlayerIdAvailableGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCount.Set {
			e.FieldStart("totalCount")
			s.TotalCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfRewardsPlayerIdAvailableGetOK = [2]string{
	0: "rewards",
	1: "totalCount",
}

// Decode decodes RewardsPlayerIdAvailableGetOK from json.
func (s *RewardsPlayerIdAvailableGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardsPlayerIdAvailableGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rewards":
			if err := func() error {
				s.Rewards = make([]AvailableReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AvailableReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "totalCount":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardsPlayerIdAvailableGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardsPlayerIdAvailableGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardsPlayerIdAvailableGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardsPlayerIdClaimPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardsPlayerIdClaimPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("tier")
		s.Tier.Encode(e)
	}
}

var jsonFieldsNameOfRewardsPlayerIdClaimPostReq = [2]string{
	0: "level",
	1: "tier",
}

// Decode decodes RewardsPlayerIdClaimPostReq from json.
func (s *RewardsPlayerIdClaimPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardsPlayerIdClaimPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardsPlayerIdClaimPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRewardsPlayerIdClaimPostReq) {
					name = jsonFieldsNameOfRewardsPlayerIdClaimPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardsPlayerIdClaimPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardsPlayerIdClaimPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardsPlayerIdClaimPostReqTier as json.
func (s RewardsPlayerIdClaimPostReqTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RewardsPlayerIdClaimPostReqTier from json.
func (s *RewardsPlayerIdClaimPostReqTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardsPlayerIdClaimPostReqTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RewardsPlayerIdClaimPostReqTier(v) {
	case RewardsPlayerIdClaimPostReqTierFree:
		*s = RewardsPlayerIdClaimPostReqTierFree
	case RewardsPlayerIdClaimPostReqTierPremium:
		*s = RewardsPlayerIdClaimPostReqTierPremium
	default:
		*s = RewardsPlayerIdClaimPostReqTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RewardsPlayerIdClaimPostReqTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardsPlayerIdClaimPostReqTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Season) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Season) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("endDate")
		json.EncodeDateTime(e, s.EndDate)
	}
	{
		e.FieldStart("maxLevel")
		e.Int(s.MaxLevel)
	}
	{
		if s.XpPerLevel.Set {
			e.FieldStart("xpPerLevel")
			s.XpPerLevel.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSeason = [9]string{
	0: "id",
	1: "name",
	2: "description",
	3: "startDate",
	4: "endDate",
	5: "maxLevel",
	6: "xpPerLevel",
	7: "status",
	8: "rewards",
}

// Decode decodes Season from json.
func (s *Season) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Season to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "endDate":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endDate\"")
			}
		case "maxLevel":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLevel\"")
			}
		case "xpPerLevel":
			if err := func() error {
				s.XpPerLevel.Reset()
				if err := s.XpPerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xpPerLevel\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]SeasonReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SeasonReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Season")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSeason) {
					name = jsonFieldsNameOfSeason[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Season) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Season) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SeasonReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SeasonReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("freeReward")
		s.FreeReward.Encode(e)
	}
	{
		if s.PremiumReward.Set {
			e.FieldStart("premiumReward")
			s.PremiumReward.Encode(e)
		}
	}
}

var jsonFieldsNameOfSeasonReward = [3]string{
	0: "level",
	1: "freeReward",
	2: "premiumReward",
}

// Decode decodes SeasonReward from json.
func (s *SeasonReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SeasonReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "freeReward":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FreeReward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freeReward\"")
			}
		case "premiumReward":
			if err := func() error {
				s.PremiumReward.Reset()
				if err := s.PremiumReward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premiumReward\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SeasonReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSeasonReward) {
					name = jsonFieldsNameOfSeasonReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SeasonReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SeasonReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SeasonStatus as json.
func (s SeasonStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SeasonStatus from json.
func (s *SeasonStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SeasonStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SeasonStatus(v) {
	case SeasonStatusUpcoming:
		*s = SeasonStatusUpcoming
	case SeasonStatusActive:
		*s = SeasonStatusActive
	case SeasonStatusEnded:
		*s = SeasonStatusEnded
	default:
		*s = SeasonStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SeasonStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SeasonStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
