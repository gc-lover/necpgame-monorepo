// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for CompatibilityMatrixOverallCompatibility.
const (
	CompatibilityMatrixOverallCompatibilityConflict             CompatibilityMatrixOverallCompatibility = "conflict"
	CompatibilityMatrixOverallCompatibilityFullCompatibility    CompatibilityMatrixOverallCompatibility = "full_compatibility"
	CompatibilityMatrixOverallCompatibilityHostility            CompatibilityMatrixOverallCompatibility = "hostility"
	CompatibilityMatrixOverallCompatibilityNeutral              CompatibilityMatrixOverallCompatibility = "neutral"
	CompatibilityMatrixOverallCompatibilityPartialCompatibility CompatibilityMatrixOverallCompatibility = "partial_compatibility"
)

// Defines values for CompatibilityPairCompatibilityLevel.
const (
	CompatibilityPairCompatibilityLevelConflict             CompatibilityPairCompatibilityLevel = "conflict"
	CompatibilityPairCompatibilityLevelFullCompatibility    CompatibilityPairCompatibilityLevel = "full_compatibility"
	CompatibilityPairCompatibilityLevelHostility            CompatibilityPairCompatibilityLevel = "hostility"
	CompatibilityPairCompatibilityLevelNeutral              CompatibilityPairCompatibilityLevel = "neutral"
	CompatibilityPairCompatibilityLevelPartialCompatibility CompatibilityPairCompatibilityLevel = "partial_compatibility"
)

// Defines values for CompatibilityPairReputationMatch.
const (
	CompatibilityPairReputationMatchNeutral  CompatibilityPairReputationMatch = "neutral"
	CompatibilityPairReputationMatchOpposite CompatibilityPairReputationMatch = "opposite"
	CompatibilityPairReputationMatchSame     CompatibilityPairReputationMatch = "same"
)

// Defines values for CompatibilityResultCompatibilityLevel.
const (
	CompatibilityResultCompatibilityLevelConflict             CompatibilityResultCompatibilityLevel = "conflict"
	CompatibilityResultCompatibilityLevelFullCompatibility    CompatibilityResultCompatibilityLevel = "full_compatibility"
	CompatibilityResultCompatibilityLevelHostility            CompatibilityResultCompatibilityLevel = "hostility"
	CompatibilityResultCompatibilityLevelNeutral              CompatibilityResultCompatibilityLevel = "neutral"
	CompatibilityResultCompatibilityLevelPartialCompatibility CompatibilityResultCompatibilityLevel = "partial_compatibility"
)

// Defines values for ConflictEventConflictType.
const (
	ConflictEventConflictTypeDominanceStruggle ConflictEventConflictType = "dominance_struggle"
	ConflictEventConflictTypeMentalBreakdown   ConflictEventConflictType = "mental_breakdown"
	ConflictEventConflictTypeTemporaryTakeover ConflictEventConflictType = "temporary_takeover"
)

// Defines values for CreateConflictEventRequestConflictType.
const (
	CreateConflictEventRequestConflictTypeDominanceStruggle CreateConflictEventRequestConflictType = "dominance_struggle"
	CreateConflictEventRequestConflictTypeMentalBreakdown   CreateConflictEventRequestConflictType = "mental_breakdown"
	CreateConflictEventRequestConflictTypeTemporaryTakeover CreateConflictEventRequestConflictType = "temporary_takeover"
)

// Defines values for EngramConflictConflictType.
const (
	DominanceStruggle  EngramConflictConflictType = "dominance_struggle"
	ReputationConflict EngramConflictConflictType = "reputation_conflict"
	UsageImbalance     EngramConflictConflictType = "usage_imbalance"
	ValueConflict      EngramConflictConflictType = "value_conflict"
)

// Defines values for ResolveConflictRequestResolutionType.
const (
	Balance      ResolveConflictRequestResolutionType = "balance"
	FavorEngram1 ResolveConflictRequestResolutionType = "favor_engram_1"
	FavorEngram2 ResolveConflictRequestResolutionType = "favor_engram_2"
	Merge        ResolveConflictRequestResolutionType = "merge"
	RemoveOne    ResolveConflictRequestResolutionType = "remove_one"
)

// CheckCompatibilityRequest defines model for CheckCompatibilityRequest.
type CheckCompatibilityRequest struct {
	// EngramIds ID энграмм для проверки совместимости
	EngramIds []openapi_types.UUID `json:"engram_ids"`
}

// CompatibilityMatrix defines model for CompatibilityMatrix.
type CompatibilityMatrix struct {
	// CompatibilityPairs Пары совместимости между энграммами
	CompatibilityPairs []CompatibilityPair `json:"compatibility_pairs"`

	// Engrams Список ID активных энграмм
	Engrams []openapi_types.UUID `json:"engrams"`

	// OverallCompatibility Общая совместимость всех энграмм
	OverallCompatibility *CompatibilityMatrixOverallCompatibility `json:"overall_compatibility,omitempty"`

	// SynergyBonus Общий бонус синергии (+50%, +25%, 0%, -25%, -50%)
	SynergyBonus *float32 `json:"synergy_bonus,omitempty"`
}

// CompatibilityMatrixOverallCompatibility Общая совместимость всех энграмм
type CompatibilityMatrixOverallCompatibility string

// CompatibilityPair defines model for CompatibilityPair.
type CompatibilityPair struct {
	// CompatibilityLevel Уровень совместимости
	CompatibilityLevel CompatibilityPairCompatibilityLevel `json:"compatibility_level"`

	// CompatibilityPercentage Процент совместимости (-50% до +50%)
	CompatibilityPercentage float32 `json:"compatibility_percentage"`

	// Engram1Id ID первой энграммы
	Engram1Id openapi_types.UUID `json:"engram_1_id"`

	// Engram2Id ID второй энграммы
	Engram2Id openapi_types.UUID `json:"engram_2_id"`

	// ReputationMatch Совпадение репутации по фракциям
	ReputationMatch *map[string]CompatibilityPairReputationMatch `json:"reputation_match,omitempty"`

	// ValuesMatch Совпадение ценностей
	ValuesMatch *map[string]bool `json:"values_match,omitempty"`
}

// CompatibilityPairCompatibilityLevel Уровень совместимости
type CompatibilityPairCompatibilityLevel string

// CompatibilityPairReputationMatch defines model for CompatibilityPair.ReputationMatch.
type CompatibilityPairReputationMatch string

// CompatibilityResult defines model for CompatibilityResult.
type CompatibilityResult struct {
	// CanInstall Можно ли установить эти энграммы вместе
	CanInstall *bool `json:"can_install,omitempty"`

	// CompatibilityLevel Уровень совместимости
	CompatibilityLevel CompatibilityResultCompatibilityLevel `json:"compatibility_level"`

	// CompatibilityPercentage Процент совместимости
	CompatibilityPercentage float32 `json:"compatibility_percentage"`

	// EngramIds ID проверенных энграмм
	EngramIds []openapi_types.UUID `json:"engram_ids"`

	// Pairs Совместимость всех пар
	Pairs *[]CompatibilityPair `json:"pairs,omitempty"`

	// Warnings Предупреждения о совместимости
	Warnings *[]string `json:"warnings,omitempty"`
}

// CompatibilityResultCompatibilityLevel Уровень совместимости
type CompatibilityResultCompatibilityLevel string

// ConflictEvent defines model for ConflictEvent.
type ConflictEvent struct {
	// CharacterId ID персонажа
	CharacterId openapi_types.UUID `json:"character_id"`

	// ConflictType Тип события конфликта
	ConflictType ConflictEventConflictType `json:"conflict_type"`

	// CreatedAt Время создания события
	CreatedAt time.Time `json:"created_at"`

	// EngramIds ID энграмм, участвующих в конфликте
	EngramIds *[]openapi_types.UUID `json:"engram_ids,omitempty"`

	// EventData Данные события
	EventData *map[string]interface{} `json:"event_data"`

	// EventId ID события
	EventId openapi_types.UUID `json:"event_id"`
}

// ConflictEventConflictType Тип события конфликта
type ConflictEventConflictType string

// CreateConflictEventRequest defines model for CreateConflictEventRequest.
type CreateConflictEventRequest struct {
	// ConflictType Тип события конфликта
	ConflictType CreateConflictEventRequestConflictType `json:"conflict_type"`

	// Engram1Id ID первой энграммы
	Engram1Id openapi_types.UUID `json:"engram_1_id"`

	// Engram2Id ID второй энграммы
	Engram2Id openapi_types.UUID `json:"engram_2_id"`

	// EventData Дополнительные данные события
	EventData *map[string]interface{} `json:"event_data"`
}

// CreateConflictEventRequestConflictType Тип события конфликта
type CreateConflictEventRequestConflictType string

// EngramConflict defines model for EngramConflict.
type EngramConflict struct {
	// CharacterId ID персонажа
	CharacterId openapi_types.UUID `json:"character_id"`

	// ConflictId ID конфликта
	ConflictId openapi_types.UUID `json:"conflict_id"`

	// ConflictLevel Уровень конфликта (1-10)
	ConflictLevel int `json:"conflict_level"`

	// ConflictType Тип конфликта
	ConflictType EngramConflictConflictType `json:"conflict_type"`

	// Engram1Id ID первой энграммы
	Engram1Id openapi_types.UUID `json:"engram_1_id"`

	// Engram2Id ID второй энграммы
	Engram2Id openapi_types.UUID `json:"engram_2_id"`

	// IsActive Активен ли конфликт
	IsActive *bool `json:"is_active,omitempty"`

	// ResolvedAt Время разрешения конфликта
	ResolvedAt *time.Time `json:"resolved_at"`

	// StartedAt Время начала конфликта
	StartedAt time.Time `json:"started_at"`

	// UsagePointsDiff Разница в баллах использования между энграммами
	UsagePointsDiff *int `json:"usage_points_diff,omitempty"`
}

// EngramConflictConflictType Тип конфликта
type EngramConflictConflictType string

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// ResolveConflictRequest defines model for ResolveConflictRequest.
type ResolveConflictRequest struct {
	// ChosenEngramId ID выбранной энграммы (если нужно выбрать одну)
	ChosenEngramId *openapi_types.UUID `json:"chosen_engram_id"`

	// ConflictId ID конфликта для разрешения
	ConflictId openapi_types.UUID `json:"conflict_id"`

	// PlayerDecision Решение игрока для разрешения конфликта
	PlayerDecision *string `json:"player_decision"`

	// ResolutionType Тип разрешения конфликта
	ResolutionType ResolveConflictRequestResolutionType `json:"resolution_type"`
}

// ResolveConflictRequestResolutionType Тип разрешения конфликта
type ResolveConflictRequestResolutionType string

// ResolveConflictResponse defines model for ResolveConflictResponse.
type ResolveConflictResponse struct {
	// ConflictId ID разрешённого конфликта
	ConflictId openapi_types.UUID `json:"conflict_id"`

	// InfluenceChanges Изменения влияния энграмм после разрешения
	InfluenceChanges *map[string]float32 `json:"influence_changes,omitempty"`

	// NewBalance Новый баланс между энграммами
	NewBalance *map[string]float32 `json:"new_balance,omitempty"`

	// ResolvedAt Время разрешения
	ResolvedAt *time.Time `json:"resolved_at,omitempty"`

	// Success Успешно ли разрешён конфликт
	Success bool `json:"success"`
}

// CharacterId defines model for CharacterId.
type CharacterId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// CheckEngramCompatibilityJSONRequestBody defines body for CheckEngramCompatibility for application/json ContentType.
type CheckEngramCompatibilityJSONRequestBody = CheckCompatibilityRequest

// CreateConflictEventJSONRequestBody defines body for CreateConflictEvent for application/json ContentType.
type CreateConflictEventJSONRequestBody = CreateConflictEventRequest

// ResolveEngramConflictJSONRequestBody defines body for ResolveEngramConflict for application/json ContentType.
type ResolveEngramConflictJSONRequestBody = ResolveConflictRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получить совместимость активных энграмм
	// (GET /character/characters/{character_id}/engrams/compatibility)
	GetEngramCompatibility(w http.ResponseWriter, r *http.Request, characterId CharacterId)
	// Проверить совместимость энграмм
	// (POST /character/characters/{character_id}/engrams/compatibility/check)
	CheckEngramCompatibility(w http.ResponseWriter, r *http.Request, characterId CharacterId)
	// Получить текущие конфликты между энграммами
	// (GET /character/characters/{character_id}/engrams/conflicts)
	GetEngramConflicts(w http.ResponseWriter, r *http.Request, characterId CharacterId)
	// Создать событие конфликта между энграммами
	// (POST /character/characters/{character_id}/engrams/conflicts/events)
	CreateConflictEvent(w http.ResponseWriter, r *http.Request, characterId CharacterId)
	// Разрешить конфликт между энграммами
	// (POST /character/characters/{character_id}/engrams/conflicts/resolve)
	ResolveEngramConflict(w http.ResponseWriter, r *http.Request, characterId CharacterId)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Получить совместимость активных энграмм
// (GET /character/characters/{character_id}/engrams/compatibility)
func (_ Unimplemented) GetEngramCompatibility(w http.ResponseWriter, r *http.Request, characterId CharacterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Проверить совместимость энграмм
// (POST /character/characters/{character_id}/engrams/compatibility/check)
func (_ Unimplemented) CheckEngramCompatibility(w http.ResponseWriter, r *http.Request, characterId CharacterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить текущие конфликты между энграммами
// (GET /character/characters/{character_id}/engrams/conflicts)
func (_ Unimplemented) GetEngramConflicts(w http.ResponseWriter, r *http.Request, characterId CharacterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создать событие конфликта между энграммами
// (POST /character/characters/{character_id}/engrams/conflicts/events)
func (_ Unimplemented) CreateConflictEvent(w http.ResponseWriter, r *http.Request, characterId CharacterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Разрешить конфликт между энграммами
// (POST /character/characters/{character_id}/engrams/conflicts/resolve)
func (_ Unimplemented) ResolveEngramConflict(w http.ResponseWriter, r *http.Request, characterId CharacterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetEngramCompatibility operation middleware
func (siw *ServerInterfaceWrapper) GetEngramCompatibility(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "character_id" -------------
	var characterId CharacterId

	err = runtime.BindStyledParameterWithOptions("simple", "character_id", chi.URLParam(r, "character_id"), &characterId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "character_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEngramCompatibility(w, r, characterId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CheckEngramCompatibility operation middleware
func (siw *ServerInterfaceWrapper) CheckEngramCompatibility(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "character_id" -------------
	var characterId CharacterId

	err = runtime.BindStyledParameterWithOptions("simple", "character_id", chi.URLParam(r, "character_id"), &characterId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "character_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CheckEngramCompatibility(w, r, characterId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEngramConflicts operation middleware
func (siw *ServerInterfaceWrapper) GetEngramConflicts(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "character_id" -------------
	var characterId CharacterId

	err = runtime.BindStyledParameterWithOptions("simple", "character_id", chi.URLParam(r, "character_id"), &characterId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "character_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEngramConflicts(w, r, characterId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateConflictEvent operation middleware
func (siw *ServerInterfaceWrapper) CreateConflictEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "character_id" -------------
	var characterId CharacterId

	err = runtime.BindStyledParameterWithOptions("simple", "character_id", chi.URLParam(r, "character_id"), &characterId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "character_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateConflictEvent(w, r, characterId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ResolveEngramConflict operation middleware
func (siw *ServerInterfaceWrapper) ResolveEngramConflict(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "character_id" -------------
	var characterId CharacterId

	err = runtime.BindStyledParameterWithOptions("simple", "character_id", chi.URLParam(r, "character_id"), &characterId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "character_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResolveEngramConflict(w, r, characterId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/character/characters/{character_id}/engrams/compatibility", wrapper.GetEngramCompatibility)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/character/characters/{character_id}/engrams/compatibility/check", wrapper.CheckEngramCompatibility)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/character/characters/{character_id}/engrams/conflicts", wrapper.GetEngramConflicts)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/character/characters/{character_id}/engrams/conflicts/events", wrapper.CreateConflictEvent)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/character/characters/{character_id}/engrams/conflicts/resolve", wrapper.ResolveEngramConflict)
	})

	return r
}
