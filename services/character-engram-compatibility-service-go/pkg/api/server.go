// Code generated by ogen. DO NOT EDIT.
// This file contains the generated server implementation.

package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
)

// ErrNotImplemented is returned when method is not implemented.
var ErrNotImplemented = fmt.Errorf("not implemented")

// NewServer creates new Server instance.
func NewServer(handler ServerInterface) *Server {
	return &Server{
		handler: handler,
	}
}

// Server represents server.
type Server struct {
	handler ServerInterface
}

// ServeHTTP implements http.Handler.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Path
	switch {
	case strings.HasPrefix(path, "/character/characters/"):
		s.handleCharacterRoutes(w, r)
	default:
		http.NotFound(w, r)
	}
}

// handleCharacterRoutes handles character-specific routes.
func (s *Server) handleCharacterRoutes(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	characterIDStr, exists := vars["character_id"]
	if !exists {
		http.NotFound(w, r)
		return
	}

	characterID, err := uuid.Parse(characterIDStr)
	if err != nil {
		s.writeError(w, http.StatusBadRequest, "Invalid character ID")
		return
	}

	path := strings.TrimPrefix(r.URL.Path, fmt.Sprintf("/character/characters/%s", characterIDStr))

	switch {
	case path == "/engrams/compatibility" && r.Method == http.MethodGet:
		s.handleGetEngramCompatibility(w, r, characterID)
	case path == "/engrams/compatibility/check" && r.Method == http.MethodPost:
		s.handleCheckEngramCompatibility(w, r, characterID)
	case path == "/engrams/conflicts" && r.Method == http.MethodGet:
		s.handleGetEngramConflicts(w, r, characterID)
	case path == "/engrams/conflicts/resolve" && r.Method == http.MethodPost:
		s.handleResolveEngramConflict(w, r, characterID)
	case path == "/engrams/conflicts/events" && r.Method == http.MethodPost:
		s.handleCreateConflictEvent(w, r, characterID)
	default:
		http.NotFound(w, r)
	}
}

// handleGetEngramCompatibility handles GET /character/characters/{character_id}/engrams/compatibility
func (s *Server) handleGetEngramCompatibility(w http.ResponseWriter, r *http.Request, characterID uuid.UUID) {
	params := GetEngramCompatibilityParams{CharacterID: characterID}
	res, err := s.handler.GetEngramCompatibility(r.Context(), params)
	if err != nil {
		s.writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	switch v := res.(type) {
	case GetEngramCompatibilityOK:
		s.writeJSON(w, http.StatusOK, map[string]interface{}{"data": v.Data})
	case GetEngramCompatibilityNotFound:
		s.writeJSON(w, http.StatusNotFound, map[string]interface{}{"error": v.Error})
	case GetEngramCompatibilityUnauthorized:
		s.writeJSON(w, http.StatusUnauthorized, map[string]interface{}{"error": v.Error})
	default:
		s.writeError(w, http.StatusInternalServerError, "unexpected response type")
	}
}

// handleCheckEngramCompatibility handles POST /character/characters/{character_id}/engrams/compatibility/check
func (s *Server) handleCheckEngramCompatibility(w http.ResponseWriter, r *http.Request, characterID uuid.UUID) {
	var req CheckCompatibilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	params := CheckEngramCompatibilityParams{CharacterID: characterID, Request: req}
	res, err := s.handler.CheckEngramCompatibility(r.Context(), params)
	if err != nil {
		s.writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	switch v := res.(type) {
	case CheckEngramCompatibilityOK:
		s.writeJSON(w, http.StatusOK, map[string]interface{}{"data": v.Data})
	case CheckEngramCompatibilityBadRequest:
		s.writeJSON(w, http.StatusBadRequest, map[string]interface{}{"error": v.Error})
	case CheckEngramCompatibilityNotFound:
		s.writeJSON(w, http.StatusNotFound, map[string]interface{}{"error": v.Error})
	case CheckEngramCompatibilityUnauthorized:
		s.writeJSON(w, http.StatusUnauthorized, map[string]interface{}{"error": v.Error})
	default:
		s.writeError(w, http.StatusInternalServerError, "unexpected response type")
	}
}

// handleGetEngramConflicts handles GET /character/characters/{character_id}/engrams/conflicts
func (s *Server) handleGetEngramConflicts(w http.ResponseWriter, r *http.Request, characterID uuid.UUID) {
	params := GetEngramConflictsParams{CharacterID: characterID}
	res, err := s.handler.GetEngramConflicts(r.Context(), params)
	if err != nil {
		s.writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	switch v := res.(type) {
	case GetEngramConflictsOK:
		s.writeJSON(w, http.StatusOK, map[string]interface{}{"data": v.Data})
	case GetEngramConflictsNotFound:
		s.writeJSON(w, http.StatusNotFound, map[string]interface{}{"error": v.Error})
	case GetEngramConflictsUnauthorized:
		s.writeJSON(w, http.StatusUnauthorized, map[string]interface{}{"error": v.Error})
	default:
		s.writeError(w, http.StatusInternalServerError, "unexpected response type")
	}
}

// handleResolveEngramConflict handles POST /character/characters/{character_id}/engrams/conflicts/resolve
func (s *Server) handleResolveEngramConflict(w http.ResponseWriter, r *http.Request, characterID uuid.UUID) {
	var req ResolveConflictRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	params := ResolveEngramConflictParams{CharacterID: characterID, Request: req}
	res, err := s.handler.ResolveEngramConflict(r.Context(), params)
	if err != nil {
		s.writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	switch v := res.(type) {
	case ResolveEngramConflictOK:
		s.writeJSON(w, http.StatusOK, map[string]interface{}{"data": v.Data})
	case ResolveEngramConflictBadRequest:
		s.writeJSON(w, http.StatusBadRequest, map[string]interface{}{"error": v.Error})
	case ResolveEngramConflictNotFound:
		s.writeJSON(w, http.StatusNotFound, map[string]interface{}{"error": v.Error})
	case ResolveEngramConflictUnauthorized:
		s.writeJSON(w, http.StatusUnauthorized, map[string]interface{}{"error": v.Error})
	default:
		s.writeError(w, http.StatusInternalServerError, "unexpected response type")
	}
}

// handleCreateConflictEvent handles POST /character/characters/{character_id}/engrams/conflicts/events
func (s *Server) handleCreateConflictEvent(w http.ResponseWriter, r *http.Request, characterID uuid.UUID) {
	var req CreateConflictEventRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	params := CreateConflictEventParams{CharacterID: characterID, Request: req}
	res, err := s.handler.CreateConflictEvent(r.Context(), params)
	if err != nil {
		s.writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	switch v := res.(type) {
	case CreateConflictEventOK:
		s.writeJSON(w, http.StatusOK, map[string]interface{}{"data": v.Data})
	case CreateConflictEventBadRequest:
		s.writeJSON(w, http.StatusBadRequest, map[string]interface{}{"error": v.Error})
	case CreateConflictEventNotFound:
		s.writeJSON(w, http.StatusNotFound, map[string]interface{}{"error": v.Error})
	case CreateConflictEventUnauthorized:
		s.writeJSON(w, http.StatusUnauthorized, map[string]interface{}{"error": v.Error})
	default:
		s.writeError(w, http.StatusInternalServerError, "unexpected response type")
	}
}

// writeJSON writes JSON response
func (s *Server) writeJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

// writeError writes error response
func (s *Server) writeError(w http.ResponseWriter, status int, message string) {
	s.writeJSON(w, status, map[string]interface{}{
		"error": Error{
			Message: message,
			Code:    status,
		},
	})
}
