package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

func (s *CircuitBreakerService) ListDegradationPolicies(w http.ResponseWriter, r *http.Request) {
	policies := []*DegradationPolicySummary{}

	s.degradationPolicies.Range(func(key, value interface{}) bool {
		policy := value.(*DegradationPolicy)

		summary := &DegradationPolicySummary{
			PolicyID:         policy.PolicyID,
			ServiceName:      policy.ServiceName,
			Status:           policy.Status,
			TriggerCount:     policy.TriggerCount,
			RecoveryCount:    policy.RecoveryCount,
			LastTriggeredAt:  policy.LastTriggeredAt.Unix(),
			CreatedAt:        policy.CreatedAt.Unix(),
		}
		policies = append(policies, summary)
		return true
	})

	resp := &ListDegradationPoliciesResponse{
		Policies:    policies,
		TotalCount:  len(policies),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

// Metrics and monitoring methods
func (s *CircuitBreakerService) GetMetrics(w http.ResponseWriter, r *http.Request) {
	circuitID := r.URL.Query().Get("circuit_id")
	timeRange := r.URL.Query().Get("time_range")

	// Collect circuit metrics
	var circuitMetrics []*CircuitBreakerMetricsData
	s.circuits.Range(func(key, value interface{}) bool {
		circuit := value.(*CircuitBreaker)

		if circuitID != "" && circuit.CircuitID != circuitID {
			return true
		}

		circuitMetrics = append(circuitMetrics, &circuit.Metrics)
		return true
	})

	// Collect bulkhead metrics
	var bulkheadMetrics []*BulkheadMetricsData
	s.bulkheads.Range(func(key, value interface{}) bool {
		bulkhead := value.(*Bulkhead)
		bulkheadMetrics = append(bulkheadMetrics, &bulkhead.Metrics)
		return true
	})

	// Collect timeout metrics
	var timeoutMetrics []map[string]interface{}
	s.timeouts.Range(func(key, value interface{}) bool {
		timeout := value.(*TimeoutConfig)
		metric := map[string]interface{}{
			"timeout_id":        timeout.TimeoutID,
			"service_name":      timeout.ServiceName,
			"timeouts_triggered": timeout.TimeoutsTriggered,
			"average_response_time": timeout.AverageResponseTime.Milliseconds(),
		}
		timeoutMetrics = append(timeoutMetrics, metric)
		return true
	})

	// Collect degradation policy metrics
	var degradationMetrics []map[string]interface{}
	s.degradationPolicies.Range(func(key, value interface{}) bool {
		policy := value.(*DegradationPolicy)
		metric := map[string]interface{}{
			"policy_id":       policy.PolicyID,
			"status":          policy.Status,
			"trigger_count":   policy.TriggerCount,
			"recovery_count":  policy.RecoveryCount,
		}
		degradationMetrics = append(degradationMetrics, metric)
		return true
	})

	resp := &GetMetricsResponse{
		Circuits:           circuitMetrics,
		Bulkheads:          bulkheadMetrics,
		Timeouts:           timeoutMetrics,
		DegradationPolicies: degradationMetrics,
		TimeRange:          timeRange,
		GeneratedAt:        time.Now().Unix(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

func (s *CircuitBreakerService) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status":"healthy","service":"circuit-breaker-service","version":"1.0.0","active_circuits":15,"active_bulkheads":8,"degraded_services":2}`))
}

// Helper methods
func (s *CircuitBreakerService) calculateErrorRate(circuit *CircuitBreaker) float64 {
	total := circuit.FailureCount + circuit.SuccessCount
	if total == 0 {
		return 0.0
	}
	return float64(circuit.FailureCount) / float64(total)
}

func (s *CircuitBreakerService) persistCircuitState(circuit *CircuitBreaker) error {
	key := fmt.Sprintf("circuit:%s", circuit.CircuitID)

	data, err := json.Marshal(circuit)
	if err != nil {
		return err
	}

	return s.redisClient.Set(r.Context(), key, data, 24*time.Hour).Err()
}

func (s *CircuitBreakerService) metricsCollector() {
	ticker := time.NewTicker(s.config.MetricsInterval)
	defer ticker.Stop()

	for range ticker.C {
		s.collectCircuitMetrics()
		s.collectBulkheadMetrics()
		s.updateGlobalMetrics()
	}
}

func (s *CircuitBreakerService) collectCircuitMetrics() {
	totalErrorRate := 0.0
	totalResponseTime := int64(0)
	circuitCount := 0

	s.circuits.Range(func(key, value interface{}) bool {
		circuit := value.(*CircuitBreaker)

		errorRate := s.calculateErrorRate(circuit)
		totalErrorRate += errorRate
		totalResponseTime += int64(circuit.Metrics.AverageResponseTime)
		circuitCount++

		// Update circuit-specific metrics
		if errorRate > circuit.Config.AlertThresholds.ErrorRate {
			s.logger.WithFields(logrus.Fields{
				"circuit_id": circuit.CircuitID,
				"error_rate": errorRate,
			}).Warn("circuit breaker error rate threshold exceeded")
		}

		return true
	})

	if circuitCount > 0 {
		avgErrorRate := totalErrorRate / float64(circuitCount)
		avgResponseTime := totalResponseTime / int64(circuitCount)

		s.metrics.ErrorRate.Set(avgErrorRate)
		s.metrics.AverageResponseTime.Set(float64(avgResponseTime))
	}
}

func (s *CircuitBreakerService) collectBulkheadMetrics() {
	s.bulkheads.Range(func(key, value interface{}) bool {
		bulkhead := value.(*Bulkhead)

		if bulkhead.QueuedRequests > bulkhead.Config.QueueSize/2 {
			s.logger.WithFields(logrus.Fields{
				"bulkhead_id":     bulkhead.BulkheadID,
				"queued_requests": bulkhead.QueuedRequests,
				"max_queue_size":  bulkhead.Config.QueueSize,
			}).Warn("bulkhead queue utilization high")
		}

		return true
	})
}

func (s *CircuitBreakerService) updateGlobalMetrics() {
	// Update Prometheus metrics
	var activeCircuits, activeBulkheads float64

	s.circuits.Range(func(key, value interface{}) bool {
		activeCircuits++
		return true
	})

	s.bulkheads.Range(func(key, value interface{}) bool {
		activeBulkheads++
		return true
	})

	s.metrics.ActiveCircuits.Set(activeCircuits)
	s.metrics.ActiveBulkheads.Set(activeBulkheads)
}

func (s *CircuitBreakerService) stateSynchronizer() {
	ticker := time.NewTicker(s.config.StateSyncInterval)
	defer ticker.Stop()

	for range ticker.C {
		s.syncCircuitStates()
	}
}

func (s *CircuitBreakerService) syncCircuitStates() {
	s.circuits.Range(func(key, value interface{}) bool {
		circuit := value.(*CircuitBreaker)

		// Check if state needs to be synchronized with Redis
		key := fmt.Sprintf("circuit:%s", circuit.CircuitID)
		data, err := s.redisClient.Get(r.Context(), key).Result()
		if err == nil {
			var remoteCircuit CircuitBreaker
			if err := json.Unmarshal([]byte(data), &remoteCircuit); err == nil {
				// Merge states if needed
				if remoteCircuit.State != circuit.State {
					s.logger.WithFields(logrus.Fields{
						"circuit_id": circuit.CircuitID,
						"local_state": circuit.State,
						"remote_state": remoteCircuit.State,
					}).Info("circuit state synchronized from Redis")
					circuit.State = remoteCircuit.State
					circuit.StateChangedAt = remoteCircuit.StateChangedAt
				}
			}
		}

		return true
	})
}

func (s *CircuitBreakerService) cleanupProcess() {
	ticker := time.NewTicker(s.config.CleanupInterval)
	defer ticker.Stop()

	for range ticker.C {
		s.cleanupExpiredCircuits()
		s.cleanupExpiredBulkheads()
	}
}

func (s *CircuitBreakerService) cleanupExpiredCircuits() {
	// Clean up old circuit state history (keep last 100 entries)
	s.circuits.Range(func(key, value interface{}) bool {
		circuit := value.(*CircuitBreaker)

		if len(circuit.StateHistory) > 100 {
			circuit.StateHistory = circuit.StateHistory[len(circuit.StateHistory)-100:]
		}

		return true
	})
}

func (s *CircuitBreakerService) cleanupExpiredBulkheads() {
	// Clean up inactive bulkheads (no activity for 24 hours)
	cutoff := time.Now().Add(-24 * time.Hour)

	s.bulkheads.Range(func(key, value interface{}) bool {
		bulkhead := value.(*Bulkhead)

		if bulkhead.CreatedAt.Before(cutoff) &&
		   bulkhead.ActiveThreads == 0 &&
		   bulkhead.QueuedRequests == 0 {
			s.bulkheads.Delete(key)
			s.metrics.ActiveBulkheads.Dec()
			s.logger.WithField("bulkhead_id", bulkhead.BulkheadID).Info("inactive bulkhead cleaned up")
		}

		return true
	})
}
