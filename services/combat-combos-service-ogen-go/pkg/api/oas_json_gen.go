// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes ActivateComboBadRequest as json.
func (s *ActivateComboBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivateComboBadRequest from json.
func (s *ActivateComboBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivateComboBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateComboBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateComboInternalServerError as json.
func (s *ActivateComboInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivateComboInternalServerError from json.
func (s *ActivateComboInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivateComboInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateComboInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateComboNotFound as json.
func (s *ActivateComboNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivateComboNotFound from json.
func (s *ActivateComboNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivateComboNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateComboNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivateComboRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateComboRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("combo_id")
		json.EncodeUUID(e, s.ComboID)
	}
	{
		if s.Participants != nil {
			e.FieldStart("participants")
			e.ArrStart()
			for _, elem := range s.Participants {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivateComboRequest = [4]string{
	0: "character_id",
	1: "combo_id",
	2: "participants",
	3: "context",
}

// Decode decodes ActivateComboRequest from json.
func (s *ActivateComboRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "combo_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ComboID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo_id\"")
			}
		case "participants":
			if err := func() error {
				s.Participants = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateComboRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateComboRequest) {
					name = jsonFieldsNameOfActivateComboRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateComboRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ActivateComboRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ActivateComboRequestContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ActivateComboRequestContext from json.
func (s *ActivateComboRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboRequestContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateComboRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivateComboRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateComboUnauthorized as json.
func (s *ActivateComboUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivateComboUnauthorized from json.
func (s *ActivateComboUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateComboUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivateComboUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateComboUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateComboUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Analytics != nil {
			e.FieldStart("analytics")
			e.ArrStart()
			for _, elem := range s.Analytics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PeriodStart.Set {
			e.FieldStart("period_start")
			s.PeriodStart.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PeriodEnd.Set {
			e.FieldStart("period_end")
			s.PeriodEnd.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAnalyticsResponse = [3]string{
	0: "analytics",
	1: "period_start",
	2: "period_end",
}

// Decode decodes AnalyticsResponse from json.
func (s *AnalyticsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "analytics":
			if err := func() error {
				s.Analytics = make([]ComboAnalytics, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComboAnalytics
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Analytics = append(s.Analytics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analytics\"")
			}
		case "period_start":
			if err := func() error {
				s.PeriodStart.Reset()
				if err := s.PeriodStart.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period_start\"")
			}
		case "period_end":
			if err := func() error {
				s.PeriodEnd.Reset()
				if err := s.PeriodEnd.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period_end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplySynergyBadRequest as json.
func (s *ApplySynergyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplySynergyBadRequest from json.
func (s *ApplySynergyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplySynergyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplySynergyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplySynergyInternalServerError as json.
func (s *ApplySynergyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplySynergyInternalServerError from json.
func (s *ApplySynergyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplySynergyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplySynergyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplySynergyNotFound as json.
func (s *ApplySynergyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplySynergyNotFound from json.
func (s *ApplySynergyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplySynergyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplySynergyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplySynergyRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplySynergyRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activation_id")
		json.EncodeUUID(e, s.ActivationID)
	}
	{
		e.FieldStart("synergy_id")
		json.EncodeUUID(e, s.SynergyID)
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplySynergyRequest = [3]string{
	0: "activation_id",
	1: "synergy_id",
	2: "context",
}

// Decode decodes ApplySynergyRequest from json.
func (s *ApplySynergyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActivationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activation_id\"")
			}
		case "synergy_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SynergyID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_id\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplySynergyRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplySynergyRequest) {
					name = jsonFieldsNameOfApplySynergyRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplySynergyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ApplySynergyRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ApplySynergyRequestContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ApplySynergyRequestContext from json.
func (s *ApplySynergyRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyRequestContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplySynergyRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplySynergyRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplySynergyUnauthorized as json.
func (s *ApplySynergyUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ApplySynergyUnauthorized from json.
func (s *ApplySynergyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplySynergyUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplySynergyUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplySynergyUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplySynergyUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Combo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Combo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("combo_type")
		s.ComboType.Encode(e)
	}
	{
		e.FieldStart("complexity")
		s.Complexity.Encode(e)
	}
	{
		if s.Requirements.Set {
			e.FieldStart("requirements")
			s.Requirements.Encode(e)
		}
	}
	{
		if s.Sequence != nil {
			e.FieldStart("sequence")
			e.ArrStart()
			for _, elem := range s.Sequence {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Bonuses.Set {
			e.FieldStart("bonuses")
			s.Bonuses.Encode(e)
		}
	}
	{
		if s.Cooldown.Set {
			e.FieldStart("cooldown")
			s.Cooldown.Encode(e)
		}
	}
	{
		if s.ChainCompatible.Set {
			e.FieldStart("chain_compatible")
			s.ChainCompatible.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCombo = [11]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "combo_type",
	4:  "complexity",
	5:  "requirements",
	6:  "sequence",
	7:  "bonuses",
	8:  "cooldown",
	9:  "chain_compatible",
	10: "created_at",
}

// Decode decodes Combo from json.
func (s *Combo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Combo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "combo_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ComboType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo_type\"")
			}
		case "complexity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Complexity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complexity\"")
			}
		case "requirements":
			if err := func() error {
				s.Requirements.Reset()
				if err := s.Requirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "sequence":
			if err := func() error {
				s.Sequence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sequence = append(s.Sequence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sequence\"")
			}
		case "bonuses":
			if err := func() error {
				s.Bonuses.Reset()
				if err := s.Bonuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonuses\"")
			}
		case "cooldown":
			if err := func() error {
				s.Cooldown.Reset()
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "chain_compatible":
			if err := func() error {
				s.ChainCompatible.Reset()
				if err := s.ChainCompatible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_compatible\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Combo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombo) {
					name = jsonFieldsNameOfCombo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Combo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Combo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboActivationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboActivationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("activation_id")
		json.EncodeUUID(e, s.ActivationID)
	}
	{
		if s.Combo.Set {
			e.FieldStart("combo")
			s.Combo.Encode(e)
		}
	}
	{
		if s.AppliedSynergies != nil {
			e.FieldStart("applied_synergies")
			e.ArrStart()
			for _, elem := range s.AppliedSynergies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BonusesApplied.Set {
			e.FieldStart("bonuses_applied")
			s.BonusesApplied.Encode(e)
		}
	}
	{
		if s.ChainComboAvailable.Set {
			e.FieldStart("chain_combo_available")
			s.ChainComboAvailable.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboActivationResponse = [7]string{
	0: "success",
	1: "activation_id",
	2: "combo",
	3: "applied_synergies",
	4: "bonuses_applied",
	5: "chain_combo_available",
	6: "message",
}

// Decode decodes ComboActivationResponse from json.
func (s *ComboActivationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboActivationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "activation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActivationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activation_id\"")
			}
		case "combo":
			if err := func() error {
				s.Combo.Reset()
				if err := s.Combo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo\"")
			}
		case "applied_synergies":
			if err := func() error {
				s.AppliedSynergies = make([]Synergy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Synergy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AppliedSynergies = append(s.AppliedSynergies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_synergies\"")
			}
		case "bonuses_applied":
			if err := func() error {
				s.BonusesApplied.Reset()
				if err := s.BonusesApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonuses_applied\"")
			}
		case "chain_combo_available":
			if err := func() error {
				s.ChainComboAvailable.Reset()
				if err := s.ChainComboAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_combo_available\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboActivationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComboActivationResponse) {
					name = jsonFieldsNameOfComboActivationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboActivationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboActivationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboActivationResponseBonusesApplied) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboActivationResponseBonusesApplied) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownReduction.Set {
			e.FieldStart("cooldown_reduction")
			s.CooldownReduction.Encode(e)
		}
	}
	{
		if s.SpecialEffects != nil {
			e.FieldStart("special_effects")
			e.ArrStart()
			for _, elem := range s.SpecialEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComboActivationResponseBonusesApplied = [3]string{
	0: "damage_multiplier",
	1: "cooldown_reduction",
	2: "special_effects",
}

// Decode decodes ComboActivationResponseBonusesApplied from json.
func (s *ComboActivationResponseBonusesApplied) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboActivationResponseBonusesApplied to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "cooldown_reduction":
			if err := func() error {
				s.CooldownReduction.Reset()
				if err := s.CooldownReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_reduction\"")
			}
		case "special_effects":
			if err := func() error {
				s.SpecialEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialEffects = append(s.SpecialEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboActivationResponseBonusesApplied")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboActivationResponseBonusesApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboActivationResponseBonusesApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboAnalytics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboAnalytics) encodeFields(e *jx.Encoder) {
	{
		if s.ComboID.Set {
			e.FieldStart("combo_id")
			s.ComboID.Encode(e)
		}
	}
	{
		if s.TotalActivations.Set {
			e.FieldStart("total_activations")
			s.TotalActivations.Encode(e)
		}
	}
	{
		if s.SuccessRate.Set {
			e.FieldStart("success_rate")
			s.SuccessRate.Encode(e)
		}
	}
	{
		if s.AverageScore.Set {
			e.FieldStart("average_score")
			s.AverageScore.Encode(e)
		}
	}
	{
		if s.AverageCategory.Set {
			e.FieldStart("average_category")
			s.AverageCategory.Encode(e)
		}
	}
	{
		if s.MostUsedSynergies != nil {
			e.FieldStart("most_used_synergies")
			e.ArrStart()
			for _, elem := range s.MostUsedSynergies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ChainComboCount.Set {
			e.FieldStart("chain_combo_count")
			s.ChainComboCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboAnalytics = [7]string{
	0: "combo_id",
	1: "total_activations",
	2: "success_rate",
	3: "average_score",
	4: "average_category",
	5: "most_used_synergies",
	6: "chain_combo_count",
}

// Decode decodes ComboAnalytics from json.
func (s *ComboAnalytics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboAnalytics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "combo_id":
			if err := func() error {
				s.ComboID.Reset()
				if err := s.ComboID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo_id\"")
			}
		case "total_activations":
			if err := func() error {
				s.TotalActivations.Reset()
				if err := s.TotalActivations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_activations\"")
			}
		case "success_rate":
			if err := func() error {
				s.SuccessRate.Reset()
				if err := s.SuccessRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_rate\"")
			}
		case "average_score":
			if err := func() error {
				s.AverageScore.Reset()
				if err := s.AverageScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_score\"")
			}
		case "average_category":
			if err := func() error {
				s.AverageCategory.Reset()
				if err := s.AverageCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_category\"")
			}
		case "most_used_synergies":
			if err := func() error {
				s.MostUsedSynergies = make([]ComboAnalyticsMostUsedSynergiesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComboAnalyticsMostUsedSynergiesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MostUsedSynergies = append(s.MostUsedSynergies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_used_synergies\"")
			}
		case "chain_combo_count":
			if err := func() error {
				s.ChainComboCount.Reset()
				if err := s.ChainComboCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_combo_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboAnalytics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboAnalytics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboAnalytics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboAnalyticsMostUsedSynergiesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboAnalyticsMostUsedSynergiesItem) encodeFields(e *jx.Encoder) {
	{
		if s.SynergyID.Set {
			e.FieldStart("synergy_id")
			s.SynergyID.Encode(e)
		}
	}
	{
		if s.SynergyType.Set {
			e.FieldStart("synergy_type")
			s.SynergyType.Encode(e)
		}
	}
	{
		if s.UsageCount.Set {
			e.FieldStart("usage_count")
			s.UsageCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboAnalyticsMostUsedSynergiesItem = [3]string{
	0: "synergy_id",
	1: "synergy_type",
	2: "usage_count",
}

// Decode decodes ComboAnalyticsMostUsedSynergiesItem from json.
func (s *ComboAnalyticsMostUsedSynergiesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboAnalyticsMostUsedSynergiesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "synergy_id":
			if err := func() error {
				s.SynergyID.Reset()
				if err := s.SynergyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_id\"")
			}
		case "synergy_type":
			if err := func() error {
				s.SynergyType.Reset()
				if err := s.SynergyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_type\"")
			}
		case "usage_count":
			if err := func() error {
				s.UsageCount.Reset()
				if err := s.UsageCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboAnalyticsMostUsedSynergiesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboAnalyticsMostUsedSynergiesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboAnalyticsMostUsedSynergiesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboBonuses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboBonuses) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownReduction.Set {
			e.FieldStart("cooldown_reduction")
			s.CooldownReduction.Encode(e)
		}
	}
	{
		if s.SpecialEffects != nil {
			e.FieldStart("special_effects")
			e.ArrStart()
			for _, elem := range s.SpecialEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComboBonuses = [3]string{
	0: "damage_multiplier",
	1: "cooldown_reduction",
	2: "special_effects",
}

// Decode decodes ComboBonuses from json.
func (s *ComboBonuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboBonuses to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "cooldown_reduction":
			if err := func() error {
				s.CooldownReduction.Reset()
				if err := s.CooldownReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_reduction\"")
			}
		case "special_effects":
			if err := func() error {
				s.SpecialEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialEffects = append(s.SpecialEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboBonuses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboCatalogResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboCatalogResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Combos != nil {
			e.FieldStart("combos")
			e.ArrStart()
			for _, elem := range s.Combos {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboCatalogResponse = [2]string{
	0: "combos",
	1: "total",
}

// Decode decodes ComboCatalogResponse from json.
func (s *ComboCatalogResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboCatalogResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "combos":
			if err := func() error {
				s.Combos = make([]Combo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Combo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Combos = append(s.Combos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combos\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboCatalogResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboCatalogResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboCatalogResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboComplexity as json.
func (s ComboComplexity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ComboComplexity from json.
func (s *ComboComplexity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboComplexity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ComboComplexity(v) {
	case ComboComplexityBronze:
		*s = ComboComplexityBronze
	case ComboComplexitySilver:
		*s = ComboComplexitySilver
	case ComboComplexityGold:
		*s = ComboComplexityGold
	case ComboComplexityPlatinum:
		*s = ComboComplexityPlatinum
	case ComboComplexityLegendary:
		*s = ComboComplexityLegendary
	default:
		*s = ComboComplexity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ComboComplexity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboComplexity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("combo_type")
		s.ComboType.Encode(e)
	}
	{
		e.FieldStart("complexity")
		s.Complexity.Encode(e)
	}
	{
		if s.Requirements.Set {
			e.FieldStart("requirements")
			s.Requirements.Encode(e)
		}
	}
	{
		if s.Sequence != nil {
			e.FieldStart("sequence")
			e.ArrStart()
			for _, elem := range s.Sequence {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Bonuses.Set {
			e.FieldStart("bonuses")
			s.Bonuses.Encode(e)
		}
	}
	{
		if s.Cooldown.Set {
			e.FieldStart("cooldown")
			s.Cooldown.Encode(e)
		}
	}
	{
		if s.ChainCompatible.Set {
			e.FieldStart("chain_compatible")
			s.ChainCompatible.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Synergies != nil {
			e.FieldStart("synergies")
			e.ArrStart()
			for _, elem := range s.Synergies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ChainCompatibleCombos != nil {
			e.FieldStart("chain_compatible_combos")
			e.ArrStart()
			for _, elem := range s.ChainCompatibleCombos {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComboDetails = [13]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "combo_type",
	4:  "complexity",
	5:  "requirements",
	6:  "sequence",
	7:  "bonuses",
	8:  "cooldown",
	9:  "chain_compatible",
	10: "created_at",
	11: "synergies",
	12: "chain_compatible_combos",
}

// Decode decodes ComboDetails from json.
func (s *ComboDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboDetails to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "combo_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ComboType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo_type\"")
			}
		case "complexity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Complexity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complexity\"")
			}
		case "requirements":
			if err := func() error {
				s.Requirements.Reset()
				if err := s.Requirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "sequence":
			if err := func() error {
				s.Sequence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sequence = append(s.Sequence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sequence\"")
			}
		case "bonuses":
			if err := func() error {
				s.Bonuses.Reset()
				if err := s.Bonuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonuses\"")
			}
		case "cooldown":
			if err := func() error {
				s.Cooldown.Reset()
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "chain_compatible":
			if err := func() error {
				s.ChainCompatible.Reset()
				if err := s.ChainCompatible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_compatible\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "synergies":
			if err := func() error {
				s.Synergies = make([]Synergy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Synergy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Synergies = append(s.Synergies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergies\"")
			}
		case "chain_compatible_combos":
			if err := func() error {
				s.ChainCompatibleCombos = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ChainCompatibleCombos = append(s.ChainCompatibleCombos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_compatible_combos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComboDetails) {
					name = jsonFieldsNameOfComboDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboDetailsBonuses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboDetailsBonuses) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownReduction.Set {
			e.FieldStart("cooldown_reduction")
			s.CooldownReduction.Encode(e)
		}
	}
	{
		if s.SpecialEffects != nil {
			e.FieldStart("special_effects")
			e.ArrStart()
			for _, elem := range s.SpecialEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComboDetailsBonuses = [3]string{
	0: "damage_multiplier",
	1: "cooldown_reduction",
	2: "special_effects",
}

// Decode decodes ComboDetailsBonuses from json.
func (s *ComboDetailsBonuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboDetailsBonuses to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "cooldown_reduction":
			if err := func() error {
				s.CooldownReduction.Reset()
				if err := s.CooldownReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_reduction\"")
			}
		case "special_effects":
			if err := func() error {
				s.SpecialEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialEffects = append(s.SpecialEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboDetailsBonuses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboDetailsBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboDetailsBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboDetailsRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboDetailsRequirements) encodeFields(e *jx.Encoder) {
	{
		if s.MinLevel.Set {
			e.FieldStart("min_level")
			s.MinLevel.Encode(e)
		}
	}
	{
		if s.RequiredSkills != nil {
			e.FieldStart("required_skills")
			e.ArrStart()
			for _, elem := range s.RequiredSkills {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredAbilities != nil {
			e.FieldStart("required_abilities")
			e.ArrStart()
			for _, elem := range s.RequiredAbilities {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinParticipants.Set {
			e.FieldStart("min_participants")
			s.MinParticipants.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("max_participants")
			s.MaxParticipants.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboDetailsRequirements = [5]string{
	0: "min_level",
	1: "required_skills",
	2: "required_abilities",
	3: "min_participants",
	4: "max_participants",
}

// Decode decodes ComboDetailsRequirements from json.
func (s *ComboDetailsRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboDetailsRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "min_level":
			if err := func() error {
				s.MinLevel.Reset()
				if err := s.MinLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_level\"")
			}
		case "required_skills":
			if err := func() error {
				s.RequiredSkills = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredSkills = append(s.RequiredSkills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_skills\"")
			}
		case "required_abilities":
			if err := func() error {
				s.RequiredAbilities = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.RequiredAbilities = append(s.RequiredAbilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_abilities\"")
			}
		case "min_participants":
			if err := func() error {
				s.MinParticipants.Reset()
				if err := s.MinParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_participants\"")
			}
		case "max_participants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboDetailsRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboDetailsRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboDetailsRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboLoadout) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboLoadout) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		if s.ActiveCombos != nil {
			e.FieldStart("active_combos")
			e.ArrStart()
			for _, elem := range s.ActiveCombos {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Preferences.Set {
			e.FieldStart("preferences")
			s.Preferences.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfComboLoadout = [6]string{
	0: "id",
	1: "character_id",
	2: "active_combos",
	3: "preferences",
	4: "created_at",
	5: "updated_at",
}

// Decode decodes ComboLoadout from json.
func (s *ComboLoadout) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboLoadout to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "active_combos":
			if err := func() error {
				s.ActiveCombos = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveCombos = append(s.ActiveCombos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_combos\"")
			}
		case "preferences":
			if err := func() error {
				s.Preferences.Reset()
				if err := s.Preferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferences\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboLoadout")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComboLoadout) {
					name = jsonFieldsNameOfComboLoadout[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboLoadout) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboLoadout) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboLoadoutPreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboLoadoutPreferences) encodeFields(e *jx.Encoder) {
	{
		if s.AutoActivate.Set {
			e.FieldStart("auto_activate")
			s.AutoActivate.Encode(e)
		}
	}
	{
		if s.PriorityOrder != nil {
			e.FieldStart("priority_order")
			e.ArrStart()
			for _, elem := range s.PriorityOrder {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComboLoadoutPreferences = [2]string{
	0: "auto_activate",
	1: "priority_order",
}

// Decode decodes ComboLoadoutPreferences from json.
func (s *ComboLoadoutPreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboLoadoutPreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_activate":
			if err := func() error {
				s.AutoActivate.Reset()
				if err := s.AutoActivate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_activate\"")
			}
		case "priority_order":
			if err := func() error {
				s.PriorityOrder = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PriorityOrder = append(s.PriorityOrder, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority_order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboLoadoutPreferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboLoadoutPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboLoadoutPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboRequirements) encodeFields(e *jx.Encoder) {
	{
		if s.MinLevel.Set {
			e.FieldStart("min_level")
			s.MinLevel.Encode(e)
		}
	}
	{
		if s.RequiredSkills != nil {
			e.FieldStart("required_skills")
			e.ArrStart()
			for _, elem := range s.RequiredSkills {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredAbilities != nil {
			e.FieldStart("required_abilities")
			e.ArrStart()
			for _, elem := range s.RequiredAbilities {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinParticipants.Set {
			e.FieldStart("min_participants")
			s.MinParticipants.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("max_participants")
			s.MaxParticipants.Encode(e)
		}
	}
}

var jsonFieldsNameOfComboRequirements = [5]string{
	0: "min_level",
	1: "required_skills",
	2: "required_abilities",
	3: "min_participants",
	4: "max_participants",
}

// Decode decodes ComboRequirements from json.
func (s *ComboRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "min_level":
			if err := func() error {
				s.MinLevel.Reset()
				if err := s.MinLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_level\"")
			}
		case "required_skills":
			if err := func() error {
				s.RequiredSkills = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredSkills = append(s.RequiredSkills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_skills\"")
			}
		case "required_abilities":
			if err := func() error {
				s.RequiredAbilities = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.RequiredAbilities = append(s.RequiredAbilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_abilities\"")
			}
		case "min_participants":
			if err := func() error {
				s.MinParticipants.Reset()
				if err := s.MinParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_participants\"")
			}
		case "max_participants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComboScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComboScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activation_id")
		json.EncodeUUID(e, s.ActivationID)
	}
	{
		if s.ExecutionDifficulty.Set {
			e.FieldStart("execution_difficulty")
			s.ExecutionDifficulty.Encode(e)
		}
	}
	{
		if s.DamageOutput.Set {
			e.FieldStart("damage_output")
			s.DamageOutput.Encode(e)
		}
	}
	{
		if s.VisualImpact.Set {
			e.FieldStart("visual_impact")
			s.VisualImpact.Encode(e)
		}
	}
	{
		if s.TeamCoordination.Set {
			e.FieldStart("team_coordination")
			s.TeamCoordination.Encode(e)
		}
	}
	{
		e.FieldStart("total_score")
		e.Int(s.TotalScore)
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfComboScore = [8]string{
	0: "activation_id",
	1: "execution_difficulty",
	2: "damage_output",
	3: "visual_impact",
	4: "team_coordination",
	5: "total_score",
	6: "category",
	7: "timestamp",
}

// Decode decodes ComboScore from json.
func (s *ComboScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActivationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activation_id\"")
			}
		case "execution_difficulty":
			if err := func() error {
				s.ExecutionDifficulty.Reset()
				if err := s.ExecutionDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_difficulty\"")
			}
		case "damage_output":
			if err := func() error {
				s.DamageOutput.Reset()
				if err := s.DamageOutput.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_output\"")
			}
		case "visual_impact":
			if err := func() error {
				s.VisualImpact.Reset()
				if err := s.VisualImpact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visual_impact\"")
			}
		case "team_coordination":
			if err := func() error {
				s.TeamCoordination.Reset()
				if err := s.TeamCoordination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_coordination\"")
			}
		case "total_score":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalScore = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_score\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComboScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComboScore) {
					name = jsonFieldsNameOfComboScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComboScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboType as json.
func (s ComboType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ComboType from json.
func (s *ComboType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComboType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ComboType(v) {
	case ComboTypeSolo:
		*s = ComboTypeSolo
	case ComboTypeTeam:
		*s = ComboTypeTeam
	case ComboTypeLegendary:
		*s = ComboTypeLegendary
	default:
		*s = ComboType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ComboType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComboType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "error",
	1: "message",
	2: "code",
	3: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorDetails) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboAnalyticsBadRequest as json.
func (s *GetComboAnalyticsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboAnalyticsBadRequest from json.
func (s *GetComboAnalyticsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboAnalyticsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboAnalyticsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboAnalyticsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboAnalyticsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboAnalyticsInternalServerError as json.
func (s *GetComboAnalyticsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboAnalyticsInternalServerError from json.
func (s *GetComboAnalyticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboAnalyticsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboAnalyticsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboAnalyticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboAnalyticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboAnalyticsUnauthorized as json.
func (s *GetComboAnalyticsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboAnalyticsUnauthorized from json.
func (s *GetComboAnalyticsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboAnalyticsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboAnalyticsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboAnalyticsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboAnalyticsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboCatalogBadRequest as json.
func (s *GetComboCatalogBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboCatalogBadRequest from json.
func (s *GetComboCatalogBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboCatalogBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboCatalogBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboCatalogBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboCatalogBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboCatalogInternalServerError as json.
func (s *GetComboCatalogInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboCatalogInternalServerError from json.
func (s *GetComboCatalogInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboCatalogInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboCatalogInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboCatalogInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboCatalogInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboCatalogUnauthorized as json.
func (s *GetComboCatalogUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboCatalogUnauthorized from json.
func (s *GetComboCatalogUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboCatalogUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboCatalogUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboCatalogUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboCatalogUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboDetailsInternalServerError as json.
func (s *GetComboDetailsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboDetailsInternalServerError from json.
func (s *GetComboDetailsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboDetailsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboDetailsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboDetailsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboDetailsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboDetailsNotFound as json.
func (s *GetComboDetailsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboDetailsNotFound from json.
func (s *GetComboDetailsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboDetailsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboDetailsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboDetailsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboDetailsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboDetailsUnauthorized as json.
func (s *GetComboDetailsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboDetailsUnauthorized from json.
func (s *GetComboDetailsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboDetailsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboDetailsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboDetailsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboDetailsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboLoadoutInternalServerError as json.
func (s *GetComboLoadoutInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboLoadoutInternalServerError from json.
func (s *GetComboLoadoutInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboLoadoutInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboLoadoutInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboLoadoutInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboLoadoutInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboLoadoutNotFound as json.
func (s *GetComboLoadoutNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboLoadoutNotFound from json.
func (s *GetComboLoadoutNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboLoadoutNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboLoadoutNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboLoadoutNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboLoadoutNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComboLoadoutUnauthorized as json.
func (s *GetComboLoadoutUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComboLoadoutUnauthorized from json.
func (s *GetComboLoadoutUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComboLoadoutUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComboLoadoutUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComboLoadoutUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComboLoadoutUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateComboRequestContext as json.
func (o OptActivateComboRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivateComboRequestContext from json.
func (o *OptActivateComboRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivateComboRequestContext to nil")
	}
	o.Set = true
	o.Value = make(ActivateComboRequestContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivateComboRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivateComboRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplySynergyRequestContext as json.
func (o OptApplySynergyRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ApplySynergyRequestContext from json.
func (o *OptApplySynergyRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplySynergyRequestContext to nil")
	}
	o.Set = true
	o.Value = make(ApplySynergyRequestContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplySynergyRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplySynergyRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Combo as json.
func (o OptCombo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Combo from json.
func (o *OptCombo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboActivationResponseBonusesApplied as json.
func (o OptComboActivationResponseBonusesApplied) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboActivationResponseBonusesApplied from json.
func (o *OptComboActivationResponseBonusesApplied) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboActivationResponseBonusesApplied to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboActivationResponseBonusesApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboActivationResponseBonusesApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboBonuses as json.
func (o OptComboBonuses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboBonuses from json.
func (o *OptComboBonuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboBonuses to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboComplexity as json.
func (o OptComboComplexity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ComboComplexity from json.
func (o *OptComboComplexity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboComplexity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboComplexity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboComplexity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboDetailsBonuses as json.
func (o OptComboDetailsBonuses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboDetailsBonuses from json.
func (o *OptComboDetailsBonuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboDetailsBonuses to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboDetailsBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboDetailsBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboDetailsRequirements as json.
func (o OptComboDetailsRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboDetailsRequirements from json.
func (o *OptComboDetailsRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboDetailsRequirements to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboDetailsRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboDetailsRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboLoadoutPreferences as json.
func (o OptComboLoadoutPreferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboLoadoutPreferences from json.
func (o *OptComboLoadoutPreferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboLoadoutPreferences to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboLoadoutPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboLoadoutPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboRequirements as json.
func (o OptComboRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ComboRequirements from json.
func (o *OptComboRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboRequirements to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComboType as json.
func (o OptComboType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ComboType from json.
func (o *OptComboType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComboType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComboType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComboType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorDetails as json.
func (o OptNilErrorDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorDetails from json.
func (o *OptNilErrorDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilErrorDetails to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ErrorDetails
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(ErrorDetails)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScoreSubmissionResponseRewards as json.
func (o OptNilScoreSubmissionResponseRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScoreSubmissionResponseRewards from json.
func (o *OptNilScoreSubmissionResponseRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilScoreSubmissionResponseRewards to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ScoreSubmissionResponseRewards
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilScoreSubmissionResponseRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilScoreSubmissionResponseRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []uuid.UUID as json.
func (o OptNilUUIDArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		json.EncodeUUID(e, elem)
	}
	e.ArrEnd()
}

// Decode decodes []uuid.UUID from json.
func (o *OptNilUUIDArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUIDArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]uuid.UUID, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem uuid.UUID
		v, err := json.DecodeUUID(d)
		elem = v
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUIDArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUIDArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Synergy as json.
func (o OptSynergy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Synergy from json.
func (o *OptSynergy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSynergy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSynergy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSynergy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynergyApplicationResponseBonusesApplied as json.
func (o OptSynergyApplicationResponseBonusesApplied) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SynergyApplicationResponseBonusesApplied from json.
func (o *OptSynergyApplicationResponseBonusesApplied) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSynergyApplicationResponseBonusesApplied to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSynergyApplicationResponseBonusesApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSynergyApplicationResponseBonusesApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynergyBonuses as json.
func (o OptSynergyBonuses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SynergyBonuses from json.
func (o *OptSynergyBonuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSynergyBonuses to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSynergyBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSynergyBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynergyType as json.
func (o OptSynergyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SynergyType from json.
func (o *OptSynergyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSynergyType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSynergyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSynergyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLoadoutRequestPreferences as json.
func (o OptUpdateLoadoutRequestPreferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateLoadoutRequestPreferences from json.
func (o *OptUpdateLoadoutRequestPreferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateLoadoutRequestPreferences to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateLoadoutRequestPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateLoadoutRequestPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScoreSubmissionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScoreSubmissionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("score")
		s.Score.Encode(e)
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
}

var jsonFieldsNameOfScoreSubmissionResponse = [3]string{
	0: "success",
	1: "score",
	2: "rewards",
}

// Decode decodes ScoreSubmissionResponse from json.
func (s *ScoreSubmissionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScoreSubmissionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScoreSubmissionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScoreSubmissionResponse) {
					name = jsonFieldsNameOfScoreSubmissionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScoreSubmissionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScoreSubmissionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScoreSubmissionResponseRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScoreSubmissionResponseRewards) encodeFields(e *jx.Encoder) {
	{
		if s.Experience.Set {
			e.FieldStart("experience")
			s.Experience.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfScoreSubmissionResponseRewards = [3]string{
	0: "experience",
	1: "currency",
	2: "items",
}

// Decode decodes ScoreSubmissionResponseRewards from json.
func (s *ScoreSubmissionResponseRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScoreSubmissionResponseRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experience":
			if err := func() error {
				s.Experience.Reset()
				if err := s.Experience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScoreSubmissionResponseRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScoreSubmissionResponseRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScoreSubmissionResponseRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitComboScoreBadRequest as json.
func (s *SubmitComboScoreBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitComboScoreBadRequest from json.
func (s *SubmitComboScoreBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitComboScoreBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitComboScoreBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitComboScoreBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitComboScoreBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitComboScoreInternalServerError as json.
func (s *SubmitComboScoreInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitComboScoreInternalServerError from json.
func (s *SubmitComboScoreInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitComboScoreInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitComboScoreInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitComboScoreInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitComboScoreInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitComboScoreNotFound as json.
func (s *SubmitComboScoreNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitComboScoreNotFound from json.
func (s *SubmitComboScoreNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitComboScoreNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitComboScoreNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitComboScoreNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitComboScoreNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitComboScoreUnauthorized as json.
func (s *SubmitComboScoreUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitComboScoreUnauthorized from json.
func (s *SubmitComboScoreUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitComboScoreUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitComboScoreUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitComboScoreUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitComboScoreUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubmitScoreRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubmitScoreRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activation_id")
		json.EncodeUUID(e, s.ActivationID)
	}
	{
		e.FieldStart("execution_difficulty")
		e.Int(s.ExecutionDifficulty)
	}
	{
		e.FieldStart("damage_output")
		e.Int(s.DamageOutput)
	}
	{
		e.FieldStart("visual_impact")
		e.Int(s.VisualImpact)
	}
	{
		if s.TeamCoordination.Set {
			e.FieldStart("team_coordination")
			s.TeamCoordination.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubmitScoreRequest = [5]string{
	0: "activation_id",
	1: "execution_difficulty",
	2: "damage_output",
	3: "visual_impact",
	4: "team_coordination",
}

// Decode decodes SubmitScoreRequest from json.
func (s *SubmitScoreRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitScoreRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActivationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activation_id\"")
			}
		case "execution_difficulty":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ExecutionDifficulty = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_difficulty\"")
			}
		case "damage_output":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DamageOutput = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_output\"")
			}
		case "visual_impact":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.VisualImpact = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visual_impact\"")
			}
		case "team_coordination":
			if err := func() error {
				s.TeamCoordination.Reset()
				if err := s.TeamCoordination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_coordination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubmitScoreRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubmitScoreRequest) {
					name = jsonFieldsNameOfSubmitScoreRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitScoreRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitScoreRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Synergy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Synergy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("synergy_type")
		s.SynergyType.Encode(e)
	}
	{
		e.FieldStart("combo_id")
		json.EncodeUUID(e, s.ComboID)
	}
	{
		if s.AbilityIds.Set {
			e.FieldStart("ability_ids")
			s.AbilityIds.Encode(e)
		}
	}
	{
		if s.EquipmentIds.Set {
			e.FieldStart("equipment_ids")
			s.EquipmentIds.Encode(e)
		}
	}
	{
		if s.ImplantIds.Set {
			e.FieldStart("implant_ids")
			s.ImplantIds.Encode(e)
		}
	}
	{
		if s.TeamSize.Set {
			e.FieldStart("team_size")
			s.TeamSize.Encode(e)
		}
	}
	{
		if s.TimingWindow.Set {
			e.FieldStart("timing_window")
			s.TimingWindow.Encode(e)
		}
	}
	{
		if s.Bonuses.Set {
			e.FieldStart("bonuses")
			s.Bonuses.Encode(e)
		}
	}
	{
		if s.Requirements != nil {
			e.FieldStart("requirements")
			s.Requirements.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynergy = [10]string{
	0: "id",
	1: "synergy_type",
	2: "combo_id",
	3: "ability_ids",
	4: "equipment_ids",
	5: "implant_ids",
	6: "team_size",
	7: "timing_window",
	8: "bonuses",
	9: "requirements",
}

// Decode decodes Synergy from json.
func (s *Synergy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Synergy to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "synergy_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SynergyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_type\"")
			}
		case "combo_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ComboID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combo_id\"")
			}
		case "ability_ids":
			if err := func() error {
				s.AbilityIds.Reset()
				if err := s.AbilityIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability_ids\"")
			}
		case "equipment_ids":
			if err := func() error {
				s.EquipmentIds.Reset()
				if err := s.EquipmentIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"equipment_ids\"")
			}
		case "implant_ids":
			if err := func() error {
				s.ImplantIds.Reset()
				if err := s.ImplantIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_ids\"")
			}
		case "team_size":
			if err := func() error {
				s.TeamSize.Reset()
				if err := s.TeamSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_size\"")
			}
		case "timing_window":
			if err := func() error {
				s.TimingWindow.Reset()
				if err := s.TimingWindow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timing_window\"")
			}
		case "bonuses":
			if err := func() error {
				s.Bonuses.Reset()
				if err := s.Bonuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonuses\"")
			}
		case "requirements":
			if err := func() error {
				s.Requirements = nil
				var elem SynergyRequirements
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Requirements = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Synergy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynergy) {
					name = jsonFieldsNameOfSynergy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Synergy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Synergy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynergyApplicationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynergyApplicationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.Synergy.Set {
			e.FieldStart("synergy")
			s.Synergy.Encode(e)
		}
	}
	{
		if s.BonusesApplied.Set {
			e.FieldStart("bonuses_applied")
			s.BonusesApplied.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynergyApplicationResponse = [4]string{
	0: "success",
	1: "synergy",
	2: "bonuses_applied",
	3: "message",
}

// Decode decodes SynergyApplicationResponse from json.
func (s *SynergyApplicationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynergyApplicationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "synergy":
			if err := func() error {
				s.Synergy.Reset()
				if err := s.Synergy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy\"")
			}
		case "bonuses_applied":
			if err := func() error {
				s.BonusesApplied.Reset()
				if err := s.BonusesApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonuses_applied\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynergyApplicationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynergyApplicationResponse) {
					name = jsonFieldsNameOfSynergyApplicationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynergyApplicationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynergyApplicationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynergyApplicationResponseBonusesApplied) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynergyApplicationResponseBonusesApplied) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownReduction.Set {
			e.FieldStart("cooldown_reduction")
			s.CooldownReduction.Encode(e)
		}
	}
	{
		if s.SpecialEffects != nil {
			e.FieldStart("special_effects")
			e.ArrStart()
			for _, elem := range s.SpecialEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSynergyApplicationResponseBonusesApplied = [3]string{
	0: "damage_multiplier",
	1: "cooldown_reduction",
	2: "special_effects",
}

// Decode decodes SynergyApplicationResponseBonusesApplied from json.
func (s *SynergyApplicationResponseBonusesApplied) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynergyApplicationResponseBonusesApplied to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "cooldown_reduction":
			if err := func() error {
				s.CooldownReduction.Reset()
				if err := s.CooldownReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_reduction\"")
			}
		case "special_effects":
			if err := func() error {
				s.SpecialEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialEffects = append(s.SpecialEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynergyApplicationResponseBonusesApplied")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynergyApplicationResponseBonusesApplied) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynergyApplicationResponseBonusesApplied) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynergyBonuses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynergyBonuses) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownReduction.Set {
			e.FieldStart("cooldown_reduction")
			s.CooldownReduction.Encode(e)
		}
	}
	{
		if s.SpecialEffects != nil {
			e.FieldStart("special_effects")
			e.ArrStart()
			for _, elem := range s.SpecialEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSynergyBonuses = [3]string{
	0: "damage_multiplier",
	1: "cooldown_reduction",
	2: "special_effects",
}

// Decode decodes SynergyBonuses from json.
func (s *SynergyBonuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynergyBonuses to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "cooldown_reduction":
			if err := func() error {
				s.CooldownReduction.Reset()
				if err := s.CooldownReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_reduction\"")
			}
		case "special_effects":
			if err := func() error {
				s.SpecialEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialEffects = append(s.SpecialEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynergyBonuses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynergyBonuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynergyBonuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynergyRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynergyRequirements) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSynergyRequirements = [0]string{}

// Decode decodes SynergyRequirements from json.
func (s *SynergyRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynergyRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SynergyRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynergyRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynergyRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SynergyType as json.
func (s SynergyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SynergyType from json.
func (s *SynergyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynergyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SynergyType(v) {
	case SynergyTypeAbility:
		*s = SynergyTypeAbility
	case SynergyTypeTeam:
		*s = SynergyTypeTeam
	case SynergyTypeEquipment:
		*s = SynergyTypeEquipment
	case SynergyTypeImplant:
		*s = SynergyTypeImplant
	case SynergyTypeTiming:
		*s = SynergyTypeTiming
	default:
		*s = SynergyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SynergyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynergyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateComboLoadoutBadRequest as json.
func (s *UpdateComboLoadoutBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateComboLoadoutBadRequest from json.
func (s *UpdateComboLoadoutBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateComboLoadoutBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateComboLoadoutBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateComboLoadoutBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateComboLoadoutBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateComboLoadoutInternalServerError as json.
func (s *UpdateComboLoadoutInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateComboLoadoutInternalServerError from json.
func (s *UpdateComboLoadoutInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateComboLoadoutInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateComboLoadoutInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateComboLoadoutInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateComboLoadoutInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateComboLoadoutUnauthorized as json.
func (s *UpdateComboLoadoutUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateComboLoadoutUnauthorized from json.
func (s *UpdateComboLoadoutUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateComboLoadoutUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateComboLoadoutUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateComboLoadoutUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateComboLoadoutUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateLoadoutRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateLoadoutRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		if s.ActiveCombos != nil {
			e.FieldStart("active_combos")
			e.ArrStart()
			for _, elem := range s.ActiveCombos {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Preferences.Set {
			e.FieldStart("preferences")
			s.Preferences.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateLoadoutRequest = [3]string{
	0: "character_id",
	1: "active_combos",
	2: "preferences",
}

// Decode decodes UpdateLoadoutRequest from json.
func (s *UpdateLoadoutRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadoutRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "active_combos":
			if err := func() error {
				s.ActiveCombos = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveCombos = append(s.ActiveCombos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_combos\"")
			}
		case "preferences":
			if err := func() error {
				s.Preferences.Reset()
				if err := s.Preferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateLoadoutRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateLoadoutRequest) {
					name = jsonFieldsNameOfUpdateLoadoutRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLoadoutRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadoutRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateLoadoutRequestPreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateLoadoutRequestPreferences) encodeFields(e *jx.Encoder) {
	{
		if s.AutoActivate.Set {
			e.FieldStart("auto_activate")
			s.AutoActivate.Encode(e)
		}
	}
	{
		if s.PriorityOrder != nil {
			e.FieldStart("priority_order")
			e.ArrStart()
			for _, elem := range s.PriorityOrder {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateLoadoutRequestPreferences = [2]string{
	0: "auto_activate",
	1: "priority_order",
}

// Decode decodes UpdateLoadoutRequestPreferences from json.
func (s *UpdateLoadoutRequestPreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadoutRequestPreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_activate":
			if err := func() error {
				s.AutoActivate.Reset()
				if err := s.AutoActivate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_activate\"")
			}
		case "priority_order":
			if err := func() error {
				s.PriorityOrder = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PriorityOrder = append(s.PriorityOrder, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority_order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateLoadoutRequestPreferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLoadoutRequestPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadoutRequestPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
