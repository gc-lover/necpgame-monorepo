
// Code generated by ogen, DO NOT EDIT.

package api


import (
	 "bytes"
	 "context"
	 "encoding/base64"
	 "fmt"
	 "github.com/go-faster/errors"
	 "github.com/go-faster/jx"
	 "github.com/google/uuid"
	 "github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	 "github.com/ogen-go/ogen/json"
	 "github.com/ogen-go/ogen/middleware"
	 "github.com/ogen-go/ogen/ogenerrors"
	 "github.com/ogen-go/ogen/ogenregex"
	 "github.com/ogen-go/ogen/otelogen"
	 "github.com/ogen-go/ogen/uri"
	 "github.com/ogen-go/ogen/validate"
	 "github.com/shopspring/decimal"
	 "go.opentelemetry.io/otel"
	 "go.opentelemetry.io/otel/attribute"
	 "go.opentelemetry.io/otel/codes"
	 "go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	 "go.opentelemetry.io/otel/trace"
	 "go.uber.org/multierr"
	 "io"
	 "math"
	 "math/big"
	 "math/bits"
	 "mime"
	 "mime/multipart"
	 "net"
	 "net/http"
	 "net/netip"
	 "net/url"
	 "regexp"
	 "sort"
	 "strconv"
	 "strings"
	 "sync"
	 "time"
	
)




func trimTrailingSlashes(u *url.URL) {
    u.Path = strings.TrimRight(u.Path, "/")
    u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ApplyEffects invokes applyEffects operation.
	//
// Применяет эффекты (баффы, дебаффы, статусы) к
// участнику боя.
// **Типы эффектов:**
// - `buff` - положительный эффект (увеличение
// характеристик)
// - `debuff` - отрицательный эффект (снижение характеристик)
// - `status` - статус (яд, кровотечение, ожог, паралич,
// ослепление)
// **Примеры баффов:**
// - Увеличение силы/ловкости/интеллекта
// - Увеличение скорости
// - Регенерация здоровья
// - Щит/барьер
// **Примеры дебаффов:**
// - Снижение защиты
// - Замедление
// - Ослабление
// **Примеры статусов:**
// - Яд (урон каждый ход)
// - Кровотечение (урон каждый ход)
// - Ожог (урон каждый ход)
// - Паралич (пропуск хода)
// - Ослепление (снижение точности).
//
// POST /gameplay/combat/apply-effects
	ApplyEffects(ctx context.Context, request *ApplyEffectsRequest) ( ApplyEffectsRes,  error)
	// CalculateDamage invokes calculateDamage operation.
	//
// Рассчитывает урон на основе характеристик
// атакующего и защищающегося.
// **Учитывает:**
// - Базовый урон оружия/способности
// - Характеристики атакующего (сила, ловкость,
// интеллект)
// - Броню и сопротивления защищающегося
// - Модификаторы (критический удар, слабые места)
// - Баффы и дебаффы
// **Формула:**
// ```
// final_damage = (base_damage + attacker_modifiers) * critical_multiplier
// - (armor + resistances) * defense_multiplier
// ```
// **Защита от читов:**
// - Все расчёты на сервере
// - Валидация базового урона по оружию
// - Проверка модификаторов на адекватность
// - Логирование всех расчётов для аудита.
//
// POST /gameplay/combat/calculate-damage
	CalculateDamage(ctx context.Context, request *DamageCalculationRequest) ( CalculateDamageRes,  error)
	// ExtendEffect invokes extendEffect operation.
	//
// Продлевает длительность активного эффекта на
// указанное количество ходов.
//
// POST /gameplay/combat/effects/{effect_id}/extend
	ExtendEffect(ctx context.Context, request *ExtendEffectReq, params ExtendEffectParams ) ( ExtendEffectRes,  error)
	// RemoveEffect invokes removeEffect operation.
	//
// Удаляет активный эффект с участника боя.
// Используется для:
// - Снятия дебаффов/статусов через способности
// - Очистки эффектов при завершении боя
// - Ручного удаления эффектов (например, через предмет).
//
// DELETE /gameplay/combat/effects/{effect_id}
	RemoveEffect(ctx context.Context, params RemoveEffectParams ) ( RemoveEffectRes,  error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec 	  SecuritySource
	baseClient
}
var _ Handler = struct{
	
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string,sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL: u,
		sec: sec,
		baseClient: c,
	}, nil
}
type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}
	
// ApplyEffects invokes applyEffects operation.
//
// Применяет эффекты (баффы, дебаффы, статусы) к
// участнику боя.
// **Типы эффектов:**
// - `buff` - положительный эффект (увеличение
// характеристик)
// - `debuff` - отрицательный эффект (снижение характеристик)
// - `status` - статус (яд, кровотечение, ожог, паралич,
// ослепление)
// **Примеры баффов:**
// - Увеличение силы/ловкости/интеллекта
// - Увеличение скорости
// - Регенерация здоровья
// - Щит/барьер
// **Примеры дебаффов:**
// - Снижение защиты
// - Замедление
// - Ослабление
// **Примеры статусов:**
// - Яд (урон каждый ход)
// - Кровотечение (урон каждый ход)
// - Ожог (урон каждый ход)
// - Паралич (пропуск хода)
// - Ослепление (снижение точности).
//
// POST /gameplay/combat/apply-effects
func (c *Client) ApplyEffects(ctx context.Context, request *ApplyEffectsRequest) ( ApplyEffectsRes,  error) {
	res, err := c.sendApplyEffects(ctx,request)
	return res, err
}

func (c *Client) sendApplyEffects(ctx context.Context, request *ApplyEffectsRequest) (res ApplyEffectsRes, err error) {
		otelAttrs := []attribute.KeyValue{
			otelogen.OperationID("applyEffects"),
			semconv.HTTPRequestMethodKey.String("POST"),
			semconv.URLTemplateKey.String("/gameplay/combat/apply-effects"),
		}
		otelAttrs = append(otelAttrs, c.cfg.Attributes...)

		// Run stopwatch.
		startTime := time.Now()
		defer func() {
			// Use floating point division here for higher precision (instead of Millisecond method).
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
		}()

		// Increment request counter.
		c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

		// Start a span for this request.
		ctx, span := c.cfg.Tracer.Start(ctx, ApplyEffectsOperation,
			trace.WithAttributes(otelAttrs...),
			clientSpanKind,
		)
		// Track stage for error reporting.
		var stage string
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, stage)
				c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
			}
			span.End()
		}()

	

	stage = "BuildURL"
		u := uri.Clone(c.requestURL(ctx))
var pathParts [1]string
		pathParts[0] = "/gameplay/combat/apply-effects"
uri.AddPathParts(u, pathParts[:]...)

	

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
		if err := encodeApplyEffectsRequest(request, r); err != nil {
			return res, errors.Wrap(err, "encode request")
		}

	

	
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ApplyEffectsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
			nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001,},
			} {
				for i, mask := range requirement {
					if satisfied[i] & mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

    

	

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

    

	

	stage = "DecodeResponse"
	result, err := decodeApplyEffectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

	
// CalculateDamage invokes calculateDamage operation.
//
// Рассчитывает урон на основе характеристик
// атакующего и защищающегося.
// **Учитывает:**
// - Базовый урон оружия/способности
// - Характеристики атакующего (сила, ловкость,
// интеллект)
// - Броню и сопротивления защищающегося
// - Модификаторы (критический удар, слабые места)
// - Баффы и дебаффы
// **Формула:**
// ```
// final_damage = (base_damage + attacker_modifiers) * critical_multiplier
// - (armor + resistances) * defense_multiplier
// ```
// **Защита от читов:**
// - Все расчёты на сервере
// - Валидация базового урона по оружию
// - Проверка модификаторов на адекватность
// - Логирование всех расчётов для аудита.
//
// POST /gameplay/combat/calculate-damage
func (c *Client) CalculateDamage(ctx context.Context, request *DamageCalculationRequest) ( CalculateDamageRes,  error) {
	res, err := c.sendCalculateDamage(ctx,request)
	return res, err
}

func (c *Client) sendCalculateDamage(ctx context.Context, request *DamageCalculationRequest) (res CalculateDamageRes, err error) {
		otelAttrs := []attribute.KeyValue{
			otelogen.OperationID("calculateDamage"),
			semconv.HTTPRequestMethodKey.String("POST"),
			semconv.URLTemplateKey.String("/gameplay/combat/calculate-damage"),
		}
		otelAttrs = append(otelAttrs, c.cfg.Attributes...)

		// Run stopwatch.
		startTime := time.Now()
		defer func() {
			// Use floating point division here for higher precision (instead of Millisecond method).
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
		}()

		// Increment request counter.
		c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

		// Start a span for this request.
		ctx, span := c.cfg.Tracer.Start(ctx, CalculateDamageOperation,
			trace.WithAttributes(otelAttrs...),
			clientSpanKind,
		)
		// Track stage for error reporting.
		var stage string
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, stage)
				c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
			}
			span.End()
		}()

	

	stage = "BuildURL"
		u := uri.Clone(c.requestURL(ctx))
var pathParts [1]string
		pathParts[0] = "/gameplay/combat/calculate-damage"
uri.AddPathParts(u, pathParts[:]...)

	

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
		if err := encodeCalculateDamageRequest(request, r); err != nil {
			return res, errors.Wrap(err, "encode request")
		}

	

	
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CalculateDamageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
			nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001,},
			} {
				for i, mask := range requirement {
					if satisfied[i] & mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

    

	

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

    

	

	stage = "DecodeResponse"
	result, err := decodeCalculateDamageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

	
// ExtendEffect invokes extendEffect operation.
//
// Продлевает длительность активного эффекта на
// указанное количество ходов.
//
// POST /gameplay/combat/effects/{effect_id}/extend
func (c *Client) ExtendEffect(ctx context.Context, request *ExtendEffectReq, params ExtendEffectParams ) ( ExtendEffectRes,  error) {
	res, err := c.sendExtendEffect(ctx,request,params)
	return res, err
}

func (c *Client) sendExtendEffect(ctx context.Context, request *ExtendEffectReq, params ExtendEffectParams ) (res ExtendEffectRes, err error) {
		otelAttrs := []attribute.KeyValue{
			otelogen.OperationID("extendEffect"),
			semconv.HTTPRequestMethodKey.String("POST"),
			semconv.URLTemplateKey.String("/gameplay/combat/effects/{effect_id}/extend"),
		}
		otelAttrs = append(otelAttrs, c.cfg.Attributes...)

		// Run stopwatch.
		startTime := time.Now()
		defer func() {
			// Use floating point division here for higher precision (instead of Millisecond method).
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
		}()

		// Increment request counter.
		c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

		// Start a span for this request.
		ctx, span := c.cfg.Tracer.Start(ctx, ExtendEffectOperation,
			trace.WithAttributes(otelAttrs...),
			clientSpanKind,
		)
		// Track stage for error reporting.
		var stage string
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, stage)
				c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
			}
			span.End()
		}()

	

	stage = "BuildURL"
		u := uri.Clone(c.requestURL(ctx))
var pathParts [3]string
		pathParts[0] = "/gameplay/combat/effects/"
	{
		// Encode "effect_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param: "effect_id",
			Style: uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
	return e.EncodeValue(conv.UUIDToString(params.EffectID))
}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
		pathParts[2] = "/extend"
uri.AddPathParts(u, pathParts[:]...)

	

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
		if err := encodeExtendEffectRequest(request, r); err != nil {
			return res, errors.Wrap(err, "encode request")
		}

	

	
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ExtendEffectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
			nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001,},
			} {
				for i, mask := range requirement {
					if satisfied[i] & mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

    

	

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

    

	

	stage = "DecodeResponse"
	result, err := decodeExtendEffectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

	
// RemoveEffect invokes removeEffect operation.
//
// Удаляет активный эффект с участника боя.
// Используется для:
// - Снятия дебаффов/статусов через способности
// - Очистки эффектов при завершении боя
// - Ручного удаления эффектов (например, через предмет).
//
// DELETE /gameplay/combat/effects/{effect_id}
func (c *Client) RemoveEffect(ctx context.Context, params RemoveEffectParams ) ( RemoveEffectRes,  error) {
	res, err := c.sendRemoveEffect(ctx,params)
	return res, err
}

func (c *Client) sendRemoveEffect(ctx context.Context, params RemoveEffectParams ) (res RemoveEffectRes, err error) {
		otelAttrs := []attribute.KeyValue{
			otelogen.OperationID("removeEffect"),
			semconv.HTTPRequestMethodKey.String("DELETE"),
			semconv.URLTemplateKey.String("/gameplay/combat/effects/{effect_id}"),
		}
		otelAttrs = append(otelAttrs, c.cfg.Attributes...)

		// Run stopwatch.
		startTime := time.Now()
		defer func() {
			// Use floating point division here for higher precision (instead of Millisecond method).
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
		}()

		// Increment request counter.
		c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

		// Start a span for this request.
		ctx, span := c.cfg.Tracer.Start(ctx, RemoveEffectOperation,
			trace.WithAttributes(otelAttrs...),
			clientSpanKind,
		)
		// Track stage for error reporting.
		var stage string
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, stage)
				c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
			}
			span.End()
		}()

	

	stage = "BuildURL"
		u := uri.Clone(c.requestURL(ctx))
var pathParts [2]string
		pathParts[0] = "/gameplay/combat/effects/"
	{
		// Encode "effect_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param: "effect_id",
			Style: uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
	return e.EncodeValue(conv.UUIDToString(params.EffectID))
}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
uri.AddPathParts(u, pathParts[:]...)

	

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	

	
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, RemoveEffectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
			nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001,},
			} {
				for i, mask := range requirement {
					if satisfied[i] & mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

    

	

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

    

	

	stage = "DecodeResponse"
	result, err := decodeRemoveEffectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}


