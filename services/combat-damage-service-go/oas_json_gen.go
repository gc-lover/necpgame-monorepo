// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBadRequest) {
					name = jsonFieldsNameOfBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBadRequestDetails = [0]string{}

// Decode decodes BadRequestDetails from json.
func (s *BadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CriticalHitRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CriticalHitRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("weapon_id")
		e.Str(s.WeaponID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.AttackerSkills != nil {
			e.FieldStart("attacker_skills")
			e.ArrStart()
			for _, elem := range s.AttackerSkills {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TargetDebuffs != nil {
			e.FieldStart("target_debuffs")
			e.ArrStart()
			for _, elem := range s.TargetDebuffs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvironmentalBonus.Set {
			e.FieldStart("environmental_bonus")
			s.EnvironmentalBonus.Encode(e)
		}
	}
}

var jsonFieldsNameOfCriticalHitRequest = [6]string{
	0: "attacker_id",
	1: "weapon_id",
	2: "target_id",
	3: "attacker_skills",
	4: "target_debuffs",
	5: "environmental_bonus",
}

// Decode decodes CriticalHitRequest from json.
func (s *CriticalHitRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CriticalHitRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "weapon_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "attacker_skills":
			if err := func() error {
				s.AttackerSkills = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AttackerSkills = append(s.AttackerSkills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_skills\"")
			}
		case "target_debuffs":
			if err := func() error {
				s.TargetDebuffs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TargetDebuffs = append(s.TargetDebuffs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_debuffs\"")
			}
		case "environmental_bonus":
			if err := func() error {
				s.EnvironmentalBonus.Reset()
				if err := s.EnvironmentalBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_bonus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CriticalHitRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCriticalHitRequest) {
					name = jsonFieldsNameOfCriticalHitRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CriticalHitRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CriticalHitRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CriticalHitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CriticalHitResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("crit_chance")
		e.Float64(s.CritChance)
	}
	{
		e.FieldStart("crit_damage_multiplier")
		e.Float64(s.CritDamageMultiplier)
	}
	{
		if s.CritFactors.Set {
			e.FieldStart("crit_factors")
			s.CritFactors.Encode(e)
		}
	}
}

var jsonFieldsNameOfCriticalHitResponse = [3]string{
	0: "crit_chance",
	1: "crit_damage_multiplier",
	2: "crit_factors",
}

// Decode decodes CriticalHitResponse from json.
func (s *CriticalHitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CriticalHitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "crit_chance":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.CritChance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crit_chance\"")
			}
		case "crit_damage_multiplier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CritDamageMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crit_damage_multiplier\"")
			}
		case "crit_factors":
			if err := func() error {
				s.CritFactors.Reset()
				if err := s.CritFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crit_factors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CriticalHitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCriticalHitResponse) {
					name = jsonFieldsNameOfCriticalHitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CriticalHitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CriticalHitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CriticalHitResponseCritFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CriticalHitResponseCritFactors) encodeFields(e *jx.Encoder) {
	{
		if s.BaseChance.Set {
			e.FieldStart("base_chance")
			s.BaseChance.Encode(e)
		}
	}
	{
		if s.WeaponBonus.Set {
			e.FieldStart("weapon_bonus")
			s.WeaponBonus.Encode(e)
		}
	}
	{
		if s.SkillBonus.Set {
			e.FieldStart("skill_bonus")
			s.SkillBonus.Encode(e)
		}
	}
	{
		if s.DebuffBonus.Set {
			e.FieldStart("debuff_bonus")
			s.DebuffBonus.Encode(e)
		}
	}
	{
		if s.EnvironmentalBonus.Set {
			e.FieldStart("environmental_bonus")
			s.EnvironmentalBonus.Encode(e)
		}
	}
}

var jsonFieldsNameOfCriticalHitResponseCritFactors = [5]string{
	0: "base_chance",
	1: "weapon_bonus",
	2: "skill_bonus",
	3: "debuff_bonus",
	4: "environmental_bonus",
}

// Decode decodes CriticalHitResponseCritFactors from json.
func (s *CriticalHitResponseCritFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CriticalHitResponseCritFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_chance":
			if err := func() error {
				s.BaseChance.Reset()
				if err := s.BaseChance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_chance\"")
			}
		case "weapon_bonus":
			if err := func() error {
				s.WeaponBonus.Reset()
				if err := s.WeaponBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_bonus\"")
			}
		case "skill_bonus":
			if err := func() error {
				s.SkillBonus.Reset()
				if err := s.SkillBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_bonus\"")
			}
		case "debuff_bonus":
			if err := func() error {
				s.DebuffBonus.Reset()
				if err := s.DebuffBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuff_bonus\"")
			}
		case "environmental_bonus":
			if err := func() error {
				s.EnvironmentalBonus.Reset()
				if err := s.EnvironmentalBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_bonus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CriticalHitResponseCritFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CriticalHitResponseCritFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CriticalHitResponseCritFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageAnalyticsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageAnalyticsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("total_damage_dealt")
		e.Float64(s.TotalDamageDealt)
	}
	{
		e.FieldStart("total_damage_received")
		e.Float64(s.TotalDamageReceived)
	}
	{
		e.FieldStart("average_damage")
		e.Float64(s.AverageDamage)
	}
	{
		if s.DamageByType.Set {
			e.FieldStart("damage_by_type")
			s.DamageByType.Encode(e)
		}
	}
	{
		if s.CriticalHitStats.Set {
			e.FieldStart("critical_hit_stats")
			s.CriticalHitStats.Encode(e)
		}
	}
	{
		if s.MitigationStats.Set {
			e.FieldStart("mitigation_stats")
			s.MitigationStats.Encode(e)
		}
	}
	{
		if s.TimeRange.Set {
			e.FieldStart("time_range")
			s.TimeRange.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageAnalyticsResponse = [8]string{
	0: "session_id",
	1: "total_damage_dealt",
	2: "total_damage_received",
	3: "average_damage",
	4: "damage_by_type",
	5: "critical_hit_stats",
	6: "mitigation_stats",
	7: "time_range",
}

// Decode decodes DamageAnalyticsResponse from json.
func (s *DamageAnalyticsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageAnalyticsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "total_damage_dealt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalDamageDealt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_dealt\"")
			}
		case "total_damage_received":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalDamageReceived = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_received\"")
			}
		case "average_damage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.AverageDamage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_damage\"")
			}
		case "damage_by_type":
			if err := func() error {
				s.DamageByType.Reset()
				if err := s.DamageByType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_by_type\"")
			}
		case "critical_hit_stats":
			if err := func() error {
				s.CriticalHitStats.Reset()
				if err := s.CriticalHitStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_hit_stats\"")
			}
		case "mitigation_stats":
			if err := func() error {
				s.MitigationStats.Reset()
				if err := s.MitigationStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitigation_stats\"")
			}
		case "time_range":
			if err := func() error {
				s.TimeRange.Reset()
				if err := s.TimeRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_range\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageAnalyticsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageAnalyticsResponse) {
					name = jsonFieldsNameOfDamageAnalyticsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageAnalyticsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageAnalyticsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageAnalyticsResponseCriticalHitStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageAnalyticsResponseCriticalHitStats) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCrits.Set {
			e.FieldStart("total_crits")
			s.TotalCrits.Encode(e)
		}
	}
	{
		if s.CritRate.Set {
			e.FieldStart("crit_rate")
			s.CritRate.Encode(e)
		}
	}
	{
		if s.AverageCritMultiplier.Set {
			e.FieldStart("average_crit_multiplier")
			s.AverageCritMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageAnalyticsResponseCriticalHitStats = [3]string{
	0: "total_crits",
	1: "crit_rate",
	2: "average_crit_multiplier",
}

// Decode decodes DamageAnalyticsResponseCriticalHitStats from json.
func (s *DamageAnalyticsResponseCriticalHitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageAnalyticsResponseCriticalHitStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_crits":
			if err := func() error {
				s.TotalCrits.Reset()
				if err := s.TotalCrits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_crits\"")
			}
		case "crit_rate":
			if err := func() error {
				s.CritRate.Reset()
				if err := s.CritRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crit_rate\"")
			}
		case "average_crit_multiplier":
			if err := func() error {
				s.AverageCritMultiplier.Reset()
				if err := s.AverageCritMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_crit_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageAnalyticsResponseCriticalHitStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageAnalyticsResponseCriticalHitStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageAnalyticsResponseCriticalHitStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DamageAnalyticsResponseDamageByType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DamageAnalyticsResponseDamageByType) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes DamageAnalyticsResponseDamageByType from json.
func (s *DamageAnalyticsResponseDamageByType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageAnalyticsResponseDamageByType to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageAnalyticsResponseDamageByType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageAnalyticsResponseDamageByType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageAnalyticsResponseDamageByType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageAnalyticsResponseMitigationStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageAnalyticsResponseMitigationStats) encodeFields(e *jx.Encoder) {
	{
		if s.AverageMitigation.Set {
			e.FieldStart("average_mitigation")
			s.AverageMitigation.Encode(e)
		}
	}
	{
		if s.TotalDamageMitigated.Set {
			e.FieldStart("total_damage_mitigated")
			s.TotalDamageMitigated.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageAnalyticsResponseMitigationStats = [2]string{
	0: "average_mitigation",
	1: "total_damage_mitigated",
}

// Decode decodes DamageAnalyticsResponseMitigationStats from json.
func (s *DamageAnalyticsResponseMitigationStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageAnalyticsResponseMitigationStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "average_mitigation":
			if err := func() error {
				s.AverageMitigation.Reset()
				if err := s.AverageMitigation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_mitigation\"")
			}
		case "total_damage_mitigated":
			if err := func() error {
				s.TotalDamageMitigated.Reset()
				if err := s.TotalDamageMitigated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_mitigated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageAnalyticsResponseMitigationStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageAnalyticsResponseMitigationStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageAnalyticsResponseMitigationStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("base_damage")
		e.Float64(s.BaseDamage)
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		e.FieldStart("weapon_id")
		e.Str(s.WeaponID)
	}
	{
		if s.AttackModifiers != nil {
			e.FieldStart("attack_modifiers")
			e.ArrStart()
			for _, elem := range s.AttackModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvironmentalFactors.Set {
			e.FieldStart("environmental_factors")
			s.EnvironmentalFactors.Encode(e)
		}
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequest = [8]string{
	0: "attacker_id",
	1: "target_id",
	2: "base_damage",
	3: "damage_type",
	4: "weapon_id",
	5: "attack_modifiers",
	6: "environmental_factors",
	7: "session_id",
}

// Decode decodes DamageCalculationRequest from json.
func (s *DamageCalculationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "base_damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.BaseDamage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "weapon_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.WeaponID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_id\"")
			}
		case "attack_modifiers":
			if err := func() error {
				s.AttackModifiers = make([]DamageModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AttackModifiers = append(s.AttackModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_modifiers\"")
			}
		case "environmental_factors":
			if err := func() error {
				s.EnvironmentalFactors.Reset()
				if err := s.EnvironmentalFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_factors\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequest) {
					name = jsonFieldsNameOfDamageCalculationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestDamageType as json.
func (s DamageCalculationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestDamageType from json.
func (s *DamageCalculationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestDamageType(v) {
	case DamageCalculationRequestDamageTypePhysical:
		*s = DamageCalculationRequestDamageTypePhysical
	case DamageCalculationRequestDamageTypeEnergy:
		*s = DamageCalculationRequestDamageTypeEnergy
	case DamageCalculationRequestDamageTypeChemical:
		*s = DamageCalculationRequestDamageTypeChemical
	case DamageCalculationRequestDamageTypeThermal:
		*s = DamageCalculationRequestDamageTypeThermal
	case DamageCalculationRequestDamageTypeElectrical:
		*s = DamageCalculationRequestDamageTypeElectrical
	case DamageCalculationRequestDamageTypeCybernetic:
		*s = DamageCalculationRequestDamageTypeCybernetic
	case DamageCalculationRequestDamageTypeExplosive:
		*s = DamageCalculationRequestDamageTypeExplosive
	default:
		*s = DamageCalculationRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequestEnvironmentalFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequestEnvironmentalFactors) encodeFields(e *jx.Encoder) {
	{
		if s.Weather.Set {
			e.FieldStart("weather")
			s.Weather.Encode(e)
		}
	}
	{
		if s.Terrain.Set {
			e.FieldStart("terrain")
			s.Terrain.Encode(e)
		}
	}
	{
		if s.TimeOfDay.Set {
			e.FieldStart("time_of_day")
			s.TimeOfDay.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequestEnvironmentalFactors = [3]string{
	0: "weather",
	1: "terrain",
	2: "time_of_day",
}

// Decode decodes DamageCalculationRequestEnvironmentalFactors from json.
func (s *DamageCalculationRequestEnvironmentalFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestEnvironmentalFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather":
			if err := func() error {
				s.Weather.Reset()
				if err := s.Weather.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather\"")
			}
		case "terrain":
			if err := func() error {
				s.Terrain.Reset()
				if err := s.Terrain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain\"")
			}
		case "time_of_day":
			if err := func() error {
				s.TimeOfDay.Reset()
				if err := s.TimeOfDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequestEnvironmentalFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequestEnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestEnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsTerrain as json.
func (s DamageCalculationRequestEnvironmentalFactorsTerrain) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsTerrain from json.
func (s *DamageCalculationRequestEnvironmentalFactorsTerrain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestEnvironmentalFactorsTerrain to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestEnvironmentalFactorsTerrain(v) {
	case DamageCalculationRequestEnvironmentalFactorsTerrainUrban:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrainUrban
	case DamageCalculationRequestEnvironmentalFactorsTerrainRural:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrainRural
	case DamageCalculationRequestEnvironmentalFactorsTerrainIndustrial:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrainIndustrial
	case DamageCalculationRequestEnvironmentalFactorsTerrainWasteland:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrainWasteland
	case DamageCalculationRequestEnvironmentalFactorsTerrainCyberspace:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrainCyberspace
	default:
		*s = DamageCalculationRequestEnvironmentalFactorsTerrain(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestEnvironmentalFactorsTerrain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestEnvironmentalFactorsTerrain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsTimeOfDay as json.
func (s DamageCalculationRequestEnvironmentalFactorsTimeOfDay) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsTimeOfDay from json.
func (s *DamageCalculationRequestEnvironmentalFactorsTimeOfDay) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestEnvironmentalFactorsTimeOfDay to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestEnvironmentalFactorsTimeOfDay(v) {
	case DamageCalculationRequestEnvironmentalFactorsTimeOfDayDay:
		*s = DamageCalculationRequestEnvironmentalFactorsTimeOfDayDay
	case DamageCalculationRequestEnvironmentalFactorsTimeOfDayNight:
		*s = DamageCalculationRequestEnvironmentalFactorsTimeOfDayNight
	case DamageCalculationRequestEnvironmentalFactorsTimeOfDayDawn:
		*s = DamageCalculationRequestEnvironmentalFactorsTimeOfDayDawn
	case DamageCalculationRequestEnvironmentalFactorsTimeOfDayDusk:
		*s = DamageCalculationRequestEnvironmentalFactorsTimeOfDayDusk
	default:
		*s = DamageCalculationRequestEnvironmentalFactorsTimeOfDay(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestEnvironmentalFactorsTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestEnvironmentalFactorsTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsWeather as json.
func (s DamageCalculationRequestEnvironmentalFactorsWeather) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsWeather from json.
func (s *DamageCalculationRequestEnvironmentalFactorsWeather) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestEnvironmentalFactorsWeather to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestEnvironmentalFactorsWeather(v) {
	case DamageCalculationRequestEnvironmentalFactorsWeatherClear:
		*s = DamageCalculationRequestEnvironmentalFactorsWeatherClear
	case DamageCalculationRequestEnvironmentalFactorsWeatherRain:
		*s = DamageCalculationRequestEnvironmentalFactorsWeatherRain
	case DamageCalculationRequestEnvironmentalFactorsWeatherFog:
		*s = DamageCalculationRequestEnvironmentalFactorsWeatherFog
	case DamageCalculationRequestEnvironmentalFactorsWeatherStorm:
		*s = DamageCalculationRequestEnvironmentalFactorsWeatherStorm
	case DamageCalculationRequestEnvironmentalFactorsWeatherCyberstorm:
		*s = DamageCalculationRequestEnvironmentalFactorsWeatherCyberstorm
	default:
		*s = DamageCalculationRequestEnvironmentalFactorsWeather(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestEnvironmentalFactorsWeather) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestEnvironmentalFactorsWeather) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("final_damage")
		e.Float64(s.FinalDamage)
	}
	{
		e.FieldStart("was_critical")
		e.Bool(s.WasCritical)
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		e.FieldStart("mitigation_applied")
		e.Float64(s.MitigationApplied)
	}
	{
		if s.DamageBreakdown.Set {
			e.FieldStart("damage_breakdown")
			s.DamageBreakdown.Encode(e)
		}
	}
	{
		e.FieldStart("calculation_id")
		json.EncodeUUID(e, s.CalculationID)
	}
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponse = [7]string{
	0: "final_damage",
	1: "was_critical",
	2: "critical_multiplier",
	3: "mitigation_applied",
	4: "damage_breakdown",
	5: "calculation_id",
	6: "processing_time_ms",
}

// Decode decodes DamageCalculationResponse from json.
func (s *DamageCalculationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "final_damage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.FinalDamage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "was_critical":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.WasCritical = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "mitigation_applied":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.MitigationApplied = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitigation_applied\"")
			}
		case "damage_breakdown":
			if err := func() error {
				s.DamageBreakdown.Reset()
				if err := s.DamageBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_breakdown\"")
			}
		case "calculation_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CalculationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_id\"")
			}
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResponse) {
					name = jsonFieldsNameOfDamageCalculationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponseDamageBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponseDamageBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.AttackModifiers.Set {
			e.FieldStart("attack_modifiers")
			s.AttackModifiers.Encode(e)
		}
	}
	{
		if s.CriticalDamage.Set {
			e.FieldStart("critical_damage")
			s.CriticalDamage.Encode(e)
		}
	}
	{
		if s.MitigationReduction.Set {
			e.FieldStart("mitigation_reduction")
			s.MitigationReduction.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponseDamageBreakdown = [4]string{
	0: "base_damage",
	1: "attack_modifiers",
	2: "critical_damage",
	3: "mitigation_reduction",
}

// Decode decodes DamageCalculationResponseDamageBreakdown from json.
func (s *DamageCalculationResponseDamageBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponseDamageBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "attack_modifiers":
			if err := func() error {
				s.AttackModifiers.Reset()
				if err := s.AttackModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_modifiers\"")
			}
		case "critical_damage":
			if err := func() error {
				s.CriticalDamage.Reset()
				if err := s.CriticalDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_damage\"")
			}
		case "mitigation_reduction":
			if err := func() error {
				s.MitigationReduction.Reset()
				if err := s.MitigationReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitigation_reduction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponseDamageBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponseDamageBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponseDamageBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageMitigationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageMitigationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.ArmorRating.Set {
			e.FieldStart("armor_rating")
			s.ArmorRating.Encode(e)
		}
	}
	{
		if s.ShieldStrength.Set {
			e.FieldStart("shield_strength")
			s.ShieldStrength.Encode(e)
		}
	}
	{
		if s.ResistanceValues.Set {
			e.FieldStart("resistance_values")
			s.ResistanceValues.Encode(e)
		}
	}
	{
		if s.TemporaryModifiers != nil {
			e.FieldStart("temporary_modifiers")
			e.ArrStart()
			for _, elem := range s.TemporaryModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvironmentalProtection.Set {
			e.FieldStart("environmental_protection")
			s.EnvironmentalProtection.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageMitigationRequest = [7]string{
	0: "target_id",
	1: "damage_type",
	2: "armor_rating",
	3: "shield_strength",
	4: "resistance_values",
	5: "temporary_modifiers",
	6: "environmental_protection",
}

// Decode decodes DamageMitigationRequest from json.
func (s *DamageMitigationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageMitigationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "armor_rating":
			if err := func() error {
				s.ArmorRating.Reset()
				if err := s.ArmorRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_rating\"")
			}
		case "shield_strength":
			if err := func() error {
				s.ShieldStrength.Reset()
				if err := s.ShieldStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_strength\"")
			}
		case "resistance_values":
			if err := func() error {
				s.ResistanceValues.Reset()
				if err := s.ResistanceValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resistance_values\"")
			}
		case "temporary_modifiers":
			if err := func() error {
				s.TemporaryModifiers = make([]DamageModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TemporaryModifiers = append(s.TemporaryModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temporary_modifiers\"")
			}
		case "environmental_protection":
			if err := func() error {
				s.EnvironmentalProtection.Reset()
				if err := s.EnvironmentalProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_protection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageMitigationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageMitigationRequest) {
					name = jsonFieldsNameOfDamageMitigationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageMitigationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageMitigationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageMitigationRequestDamageType as json.
func (s DamageMitigationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageMitigationRequestDamageType from json.
func (s *DamageMitigationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageMitigationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageMitigationRequestDamageType(v) {
	case DamageMitigationRequestDamageTypePhysical:
		*s = DamageMitigationRequestDamageTypePhysical
	case DamageMitigationRequestDamageTypeEnergy:
		*s = DamageMitigationRequestDamageTypeEnergy
	case DamageMitigationRequestDamageTypeChemical:
		*s = DamageMitigationRequestDamageTypeChemical
	case DamageMitigationRequestDamageTypeThermal:
		*s = DamageMitigationRequestDamageTypeThermal
	case DamageMitigationRequestDamageTypeElectrical:
		*s = DamageMitigationRequestDamageTypeElectrical
	case DamageMitigationRequestDamageTypeCybernetic:
		*s = DamageMitigationRequestDamageTypeCybernetic
	case DamageMitigationRequestDamageTypeExplosive:
		*s = DamageMitigationRequestDamageTypeExplosive
	default:
		*s = DamageMitigationRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageMitigationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageMitigationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DamageMitigationRequestResistanceValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DamageMitigationRequestResistanceValues) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes DamageMitigationRequestResistanceValues from json.
func (s *DamageMitigationRequestResistanceValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageMitigationRequestResistanceValues to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageMitigationRequestResistanceValues")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageMitigationRequestResistanceValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageMitigationRequestResistanceValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageMitigationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageMitigationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_mitigation")
		e.Float64(s.TotalMitigation)
	}
	{
		e.FieldStart("damage_reduction")
		e.Float64(s.DamageReduction)
	}
	{
		if s.MitigationBreakdown.Set {
			e.FieldStart("mitigation_breakdown")
			s.MitigationBreakdown.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageMitigationResponse = [3]string{
	0: "total_mitigation",
	1: "damage_reduction",
	2: "mitigation_breakdown",
}

// Decode decodes DamageMitigationResponse from json.
func (s *DamageMitigationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageMitigationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_mitigation":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalMitigation = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_mitigation\"")
			}
		case "damage_reduction":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DamageReduction = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_reduction\"")
			}
		case "mitigation_breakdown":
			if err := func() error {
				s.MitigationBreakdown.Reset()
				if err := s.MitigationBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitigation_breakdown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageMitigationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageMitigationResponse) {
					name = jsonFieldsNameOfDamageMitigationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageMitigationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageMitigationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageMitigationResponseMitigationBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageMitigationResponseMitigationBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.ArmorReduction.Set {
			e.FieldStart("armor_reduction")
			s.ArmorReduction.Encode(e)
		}
	}
	{
		if s.ShieldReduction.Set {
			e.FieldStart("shield_reduction")
			s.ShieldReduction.Encode(e)
		}
	}
	{
		if s.ResistanceReduction.Set {
			e.FieldStart("resistance_reduction")
			s.ResistanceReduction.Encode(e)
		}
	}
	{
		if s.ModifierReduction.Set {
			e.FieldStart("modifier_reduction")
			s.ModifierReduction.Encode(e)
		}
	}
	{
		if s.EnvironmentalReduction.Set {
			e.FieldStart("environmental_reduction")
			s.EnvironmentalReduction.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageMitigationResponseMitigationBreakdown = [5]string{
	0: "armor_reduction",
	1: "shield_reduction",
	2: "resistance_reduction",
	3: "modifier_reduction",
	4: "environmental_reduction",
}

// Decode decodes DamageMitigationResponseMitigationBreakdown from json.
func (s *DamageMitigationResponseMitigationBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageMitigationResponseMitigationBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "armor_reduction":
			if err := func() error {
				s.ArmorReduction.Reset()
				if err := s.ArmorReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction\"")
			}
		case "shield_reduction":
			if err := func() error {
				s.ShieldReduction.Reset()
				if err := s.ShieldReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_reduction\"")
			}
		case "resistance_reduction":
			if err := func() error {
				s.ResistanceReduction.Reset()
				if err := s.ResistanceReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resistance_reduction\"")
			}
		case "modifier_reduction":
			if err := func() error {
				s.ModifierReduction.Reset()
				if err := s.ModifierReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifier_reduction\"")
			}
		case "environmental_reduction":
			if err := func() error {
				s.EnvironmentalReduction.Reset()
				if err := s.EnvironmentalReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_reduction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageMitigationResponseMitigationBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageMitigationResponseMitigationBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageMitigationResponseMitigationBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageModifier = [5]string{
	0: "type",
	1: "value",
	2: "source",
	3: "duration_ms",
	4: "stacks",
}

// Decode decodes DamageModifier from json.
func (s *DamageModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageModifier) {
					name = jsonFieldsNameOfDamageModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageModifierType as json.
func (s DamageModifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageModifierType from json.
func (s *DamageModifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageModifierType(v) {
	case DamageModifierTypeFlatAdd:
		*s = DamageModifierTypeFlatAdd
	case DamageModifierTypePercentageMultiply:
		*s = DamageModifierTypePercentageMultiply
	case DamageModifierTypePercentageAdd:
		*s = DamageModifierTypePercentageAdd
	case DamageModifierTypeFlatMultiply:
		*s = DamageModifierTypeFlatMultiply
	default:
		*s = DamageModifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageModifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("calculation_id")
		json.EncodeUUID(e, s.CalculationID)
	}
	{
		e.FieldStart("expected_damage")
		e.Float64(s.ExpectedDamage)
	}
	{
		e.FieldStart("client_hash")
		e.Str(s.ClientHash)
	}
	{
		if s.SessionData != nil {
			e.FieldStart("session_data")
			s.SessionData.Encode(e)
		}
	}
	{
		if s.PlayerID.Set {
			e.FieldStart("player_id")
			s.PlayerID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationRequest = [5]string{
	0: "calculation_id",
	1: "expected_damage",
	2: "client_hash",
	3: "session_data",
	4: "player_id",
}

// Decode decodes DamageValidationRequest from json.
func (s *DamageValidationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "calculation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CalculationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_id\"")
			}
		case "expected_damage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.ExpectedDamage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_damage\"")
			}
		case "client_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ClientHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_hash\"")
			}
		case "session_data":
			if err := func() error {
				s.SessionData = nil
				var elem DamageValidationRequestSessionData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.SessionData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_data\"")
			}
		case "player_id":
			if err := func() error {
				s.PlayerID.Reset()
				if err := s.PlayerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequest) {
					name = jsonFieldsNameOfDamageValidationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestSessionData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestSessionData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDamageValidationRequestSessionData = [0]string{}

// Decode decodes DamageValidationRequestSessionData from json.
func (s *DamageValidationRequestSessionData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestSessionData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestSessionData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestSessionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestSessionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("valid")
		e.Bool(s.Valid)
	}
	{
		e.FieldStart("server_damage")
		e.Float64(s.ServerDamage)
	}
	{
		if s.DiscrepancyDetected.Set {
			e.FieldStart("discrepancy_detected")
			s.DiscrepancyDetected.Encode(e)
		}
	}
	{
		if s.ValidationScore.Set {
			e.FieldStart("validation_score")
			s.ValidationScore.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDamageValidationResponse = [5]string{
	0: "valid",
	1: "server_damage",
	2: "discrepancy_detected",
	3: "validation_score",
	4: "flags",
}

// Decode decodes DamageValidationResponse from json.
func (s *DamageValidationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Valid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "server_damage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.ServerDamage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_damage\"")
			}
		case "discrepancy_detected":
			if err := func() error {
				s.DiscrepancyDetected.Reset()
				if err := s.DiscrepancyDetected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discrepancy_detected\"")
			}
		case "validation_score":
			if err := func() error {
				s.ValidationScore.Reset()
				if err := s.ValidationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_score\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResponse) {
					name = jsonFieldsNameOfDamageValidationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DotApplicationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DotApplicationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("dot_type")
		s.DotType.Encode(e)
	}
	{
		e.FieldStart("damage_per_tick")
		e.Float64(s.DamagePerTick)
	}
	{
		if s.TickIntervalMs.Set {
			e.FieldStart("tick_interval_ms")
			s.TickIntervalMs.Encode(e)
		}
	}
	{
		e.FieldStart("duration_ms")
		e.Int(s.DurationMs)
	}
	{
		if s.MaxStacks.Set {
			e.FieldStart("max_stacks")
			s.MaxStacks.Encode(e)
		}
	}
	{
		if s.SourceID.Set {
			e.FieldStart("source_id")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.CanRefresh.Set {
			e.FieldStart("can_refresh")
			s.CanRefresh.Encode(e)
		}
	}
}

var jsonFieldsNameOfDotApplicationRequest = [8]string{
	0: "target_id",
	1: "dot_type",
	2: "damage_per_tick",
	3: "tick_interval_ms",
	4: "duration_ms",
	5: "max_stacks",
	6: "source_id",
	7: "can_refresh",
}

// Decode decodes DotApplicationRequest from json.
func (s *DotApplicationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DotApplicationRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "dot_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DotType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dot_type\"")
			}
		case "damage_per_tick":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.DamagePerTick = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_per_tick\"")
			}
		case "tick_interval_ms":
			if err := func() error {
				s.TickIntervalMs.Reset()
				if err := s.TickIntervalMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tick_interval_ms\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DurationMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "max_stacks":
			if err := func() error {
				s.MaxStacks.Reset()
				if err := s.MaxStacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_stacks\"")
			}
		case "source_id":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "can_refresh":
			if err := func() error {
				s.CanRefresh.Reset()
				if err := s.CanRefresh.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_refresh\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DotApplicationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDotApplicationRequest) {
					name = jsonFieldsNameOfDotApplicationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DotApplicationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DotApplicationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DotApplicationRequestDotType as json.
func (s DotApplicationRequestDotType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DotApplicationRequestDotType from json.
func (s *DotApplicationRequestDotType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DotApplicationRequestDotType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DotApplicationRequestDotType(v) {
	case DotApplicationRequestDotTypeBurn:
		*s = DotApplicationRequestDotTypeBurn
	case DotApplicationRequestDotTypePoison:
		*s = DotApplicationRequestDotTypePoison
	case DotApplicationRequestDotTypeBleed:
		*s = DotApplicationRequestDotTypeBleed
	case DotApplicationRequestDotTypeCorrosion:
		*s = DotApplicationRequestDotTypeCorrosion
	case DotApplicationRequestDotTypeRadiation:
		*s = DotApplicationRequestDotTypeRadiation
	case DotApplicationRequestDotTypeElectric:
		*s = DotApplicationRequestDotTypeElectric
	case DotApplicationRequestDotTypeCyber:
		*s = DotApplicationRequestDotTypeCyber
	default:
		*s = DotApplicationRequestDotType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DotApplicationRequestDotType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DotApplicationRequestDotType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DotApplicationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DotApplicationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("applied")
		e.Bool(s.Applied)
	}
	{
		e.FieldStart("current_stacks")
		e.Int(s.CurrentStacks)
	}
	{
		e.FieldStart("remaining_duration_ms")
		e.Int(s.RemainingDurationMs)
	}
	{
		if s.TotalDamageExpected.Set {
			e.FieldStart("total_damage_expected")
			s.TotalDamageExpected.Encode(e)
		}
	}
	{
		if s.DotID.Set {
			e.FieldStart("dot_id")
			s.DotID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDotApplicationResponse = [5]string{
	0: "applied",
	1: "current_stacks",
	2: "remaining_duration_ms",
	3: "total_damage_expected",
	4: "dot_id",
}

// Decode decodes DotApplicationResponse from json.
func (s *DotApplicationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DotApplicationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "applied":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Applied = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied\"")
			}
		case "current_stacks":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CurrentStacks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_stacks\"")
			}
		case "remaining_duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RemainingDurationMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_duration_ms\"")
			}
		case "total_damage_expected":
			if err := func() error {
				s.TotalDamageExpected.Reset()
				if err := s.TotalDamageExpected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_expected\"")
			}
		case "dot_id":
			if err := func() error {
				s.DotID.Reset()
				if err := s.DotID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dot_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DotApplicationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDotApplicationResponse) {
					name = jsonFieldsNameOfDotApplicationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DotApplicationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DotApplicationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotFound) {
					name = jsonFieldsNameOfNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNotFoundDetails = [0]string{}

// Decode decodes NotFoundDetails from json.
func (s *NotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OK) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfOK = [2]string{
	0: "success",
	1: "message",
}

// Decode decodes OK from json.
func (s *OK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CriticalHitResponseCritFactors as json.
func (o OptCriticalHitResponseCritFactors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CriticalHitResponseCritFactors from json.
func (o *OptCriticalHitResponseCritFactors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCriticalHitResponseCritFactors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCriticalHitResponseCritFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCriticalHitResponseCritFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageAnalyticsResponseCriticalHitStats as json.
func (o OptDamageAnalyticsResponseCriticalHitStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageAnalyticsResponseCriticalHitStats from json.
func (o *OptDamageAnalyticsResponseCriticalHitStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageAnalyticsResponseCriticalHitStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageAnalyticsResponseCriticalHitStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageAnalyticsResponseCriticalHitStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageAnalyticsResponseDamageByType as json.
func (o OptDamageAnalyticsResponseDamageByType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageAnalyticsResponseDamageByType from json.
func (o *OptDamageAnalyticsResponseDamageByType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageAnalyticsResponseDamageByType to nil")
	}
	o.Set = true
	o.Value = make(DamageAnalyticsResponseDamageByType)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageAnalyticsResponseDamageByType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageAnalyticsResponseDamageByType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageAnalyticsResponseMitigationStats as json.
func (o OptDamageAnalyticsResponseMitigationStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageAnalyticsResponseMitigationStats from json.
func (o *OptDamageAnalyticsResponseMitigationStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageAnalyticsResponseMitigationStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageAnalyticsResponseMitigationStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageAnalyticsResponseMitigationStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactors as json.
func (o OptDamageCalculationRequestEnvironmentalFactors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationRequestEnvironmentalFactors from json.
func (o *OptDamageCalculationRequestEnvironmentalFactors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestEnvironmentalFactors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestEnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestEnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsTerrain as json.
func (o OptDamageCalculationRequestEnvironmentalFactorsTerrain) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsTerrain from json.
func (o *OptDamageCalculationRequestEnvironmentalFactorsTerrain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestEnvironmentalFactorsTerrain to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestEnvironmentalFactorsTerrain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestEnvironmentalFactorsTerrain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsTimeOfDay as json.
func (o OptDamageCalculationRequestEnvironmentalFactorsTimeOfDay) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsTimeOfDay from json.
func (o *OptDamageCalculationRequestEnvironmentalFactorsTimeOfDay) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestEnvironmentalFactorsTimeOfDay to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestEnvironmentalFactorsTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestEnvironmentalFactorsTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalFactorsWeather as json.
func (o OptDamageCalculationRequestEnvironmentalFactorsWeather) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageCalculationRequestEnvironmentalFactorsWeather from json.
func (o *OptDamageCalculationRequestEnvironmentalFactorsWeather) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestEnvironmentalFactorsWeather to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestEnvironmentalFactorsWeather) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestEnvironmentalFactorsWeather) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResponseDamageBreakdown as json.
func (o OptDamageCalculationResponseDamageBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationResponseDamageBreakdown from json.
func (o *OptDamageCalculationResponseDamageBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationResponseDamageBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationResponseDamageBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationResponseDamageBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageMitigationRequestResistanceValues as json.
func (o OptDamageMitigationRequestResistanceValues) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageMitigationRequestResistanceValues from json.
func (o *OptDamageMitigationRequestResistanceValues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageMitigationRequestResistanceValues to nil")
	}
	o.Set = true
	o.Value = make(DamageMitigationRequestResistanceValues)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageMitigationRequestResistanceValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageMitigationRequestResistanceValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageMitigationResponseMitigationBreakdown as json.
func (o OptDamageMitigationResponseMitigationBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageMitigationResponseMitigationBreakdown from json.
func (o *OptDamageMitigationResponseMitigationBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageMitigationResponseMitigationBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageMitigationResponseMitigationBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageMitigationResponseMitigationBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Unauthorized from json.
func (s *Unauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorized) {
					name = jsonFieldsNameOfUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUnauthorizedDetails = [0]string{}

// Decode decodes UnauthorizedDetails from json.
func (s *UnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
