


// Code generated by ogen, DO NOT EDIT.

package api


import (
	 "bytes"
	 "context"
	 "encoding/base64"
	 "fmt"
	 "github.com/go-faster/errors"
	 "github.com/go-faster/jx"
	 "github.com/google/uuid"
	 "github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	 "github.com/ogen-go/ogen/json"
	 "github.com/ogen-go/ogen/middleware"
	 "github.com/ogen-go/ogen/ogenerrors"
	 "github.com/ogen-go/ogen/ogenregex"
	 "github.com/ogen-go/ogen/otelogen"
	 "github.com/ogen-go/ogen/uri"
	 "github.com/ogen-go/ogen/validate"
	 "github.com/shopspring/decimal"
	 "go.opentelemetry.io/otel"
	 "go.opentelemetry.io/otel/attribute"
	 "go.opentelemetry.io/otel/codes"
	 "go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	 "go.opentelemetry.io/otel/trace"
	 "go.uber.org/multierr"
	 "io"
	 "math"
	 "math/big"
	 "math/bits"
	 "mime"
	 "mime/multipart"
	 "net"
	 "net/http"
	 "net/netip"
	 "net/url"
	 "regexp"
	 "sort"
	 "strconv"
	 "strings"
	 "sync"
	 "time"
	
)





// Encode encodes ApplyEffectsBadRequest as json.
func (s *ApplyEffectsBadRequest) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ApplyEffectsBadRequest from json.
func (s *ApplyEffectsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyEffectsBadRequest(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ApplyEffectsInternalServerError as json.
func (s *ApplyEffectsInternalServerError) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ApplyEffectsInternalServerError from json.
func (s *ApplyEffectsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyEffectsInternalServerError(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *ApplyEffectsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *ApplyEffectsOK) encodeFields(e *jx.Encoder) {
		{if s.Effects != nil {
e.FieldStart("effects")
	e.ArrStart()
	for _, elem := range s.Effects {
	elem.Encode(e)
	}
	e.ArrEnd()}
		}
}

var jsonFieldsNameOfApplyEffectsOK = [1]string{
	0: "effects",
}

// Decode decodes ApplyEffectsOK from json.
func (s *ApplyEffectsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effects":if err := func() error {
		s.Effects = make([]CombatEffect, 0)
if err := d.Arr(func(d *jx.Decoder) error {
	var elem CombatEffect
		if err := elem.Decode(d); err != nil {
			return err
		}
	s.Effects = append(s.Effects, elem)
	return nil
}); err != nil {
	return err
}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsOK")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *ApplyEffectsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *ApplyEffectsRequest) encodeFields(e *jx.Encoder) {
		{
e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
		}
		{
e.FieldStart("effects")
	e.ArrStart()
	for _, elem := range s.Effects {
	elem.Encode(e)
	}
	e.ArrEnd()
		}
}

var jsonFieldsNameOfApplyEffectsRequest = [2]string{
	0: "target_id",
	1: "effects",
}

// Decode decodes ApplyEffectsRequest from json.
func (s *ApplyEffectsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
		v, err := json.DecodeUUID(d)
		s.TargetID = v
		if err != nil {
			 return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
		s.Effects = make([]ApplyEffectsRequestEffectsItem, 0)
if err := d.Arr(func(d *jx.Decoder) error {
	var elem ApplyEffectsRequestEffectsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
	s.Effects = append(s.Effects, elem)
	return nil
}); err != nil {
	return err
}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i * 8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsRequest) {
					name = jsonFieldsNameOfApplyEffectsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *ApplyEffectsRequestEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *ApplyEffectsRequestEffectsItem) encodeFields(e *jx.Encoder) {
		{
e.FieldStart("effect_type")
	s.EffectType.Encode(e)
		}
		{
e.FieldStart("effect_name")
		e.Str(s.EffectName)
		}
		{
e.FieldStart("duration")
		e.Int(s.Duration)
		}
		{
e.FieldStart("value")
		e.Int(s.Value)
		}
}

var jsonFieldsNameOfApplyEffectsRequestEffectsItem = [4]string{
	0: "effect_type",
	1: "effect_name",
	2: "duration",
	3: "value",
}

// Decode decodes ApplyEffectsRequestEffectsItem from json.
func (s *ApplyEffectsRequestEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
		if err := s.EffectType.Decode(d); err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "effect_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
		v, err := d.Str()
		s.EffectName = string(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_name\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
		v, err := d.Int()
		s.Duration = int(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
		v, err := d.Int()
		s.Value = int(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsRequestEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i * 8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsRequestEffectsItem) {
					name = jsonFieldsNameOfApplyEffectsRequestEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsRequestEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ApplyEffectsRequestEffectsItemEffectType as json.
func (s ApplyEffectsRequestEffectsItemEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsRequestEffectsItemEffectType from json.
func (s *ApplyEffectsRequestEffectsItemEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestEffectsItemEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsRequestEffectsItemEffectType(v) {
	case ApplyEffectsRequestEffectsItemEffectTypeBuff:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuff
	case ApplyEffectsRequestEffectsItemEffectTypeDebuff:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuff
	case ApplyEffectsRequestEffectsItemEffectTypeStatus:
		*s = ApplyEffectsRequestEffectsItemEffectTypeStatus
	default:
		*s = ApplyEffectsRequestEffectsItemEffectType(v)
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsRequestEffectsItemEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestEffectsItemEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ApplyEffectsUnauthorized as json.
func (s *ApplyEffectsUnauthorized) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ApplyEffectsUnauthorized from json.
func (s *ApplyEffectsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplyEffectsUnauthorized(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes CalculateDamageBadRequest as json.
func (s *CalculateDamageBadRequest) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes CalculateDamageBadRequest from json.
func (s *CalculateDamageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageBadRequest(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes CalculateDamageInternalServerError as json.
func (s *CalculateDamageInternalServerError) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes CalculateDamageInternalServerError from json.
func (s *CalculateDamageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageInternalServerError(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes CalculateDamageUnauthorized as json.
func (s *CalculateDamageUnauthorized) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes CalculateDamageUnauthorized from json.
func (s *CalculateDamageUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageUnauthorized(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *CombatEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *CombatEffect) encodeFields(e *jx.Encoder) {
		{if s.ID.Set {
e.FieldStart("id")
	s.ID.Encode(e)
}
		}
		{if s.EffectType.Set {
e.FieldStart("effect_type")
	s.EffectType.Encode(e)
}
		}
		{if s.EffectName.Set {
e.FieldStart("effect_name")
	s.EffectName.Encode(e)
}
		}
		{if s.Duration.Set {
e.FieldStart("duration")
	s.Duration.Encode(e)
}
		}
		{if s.RemainingTurns.Set {
e.FieldStart("remaining_turns")
	s.RemainingTurns.Encode(e)
}
		}
		{if s.Value.Set {
e.FieldStart("value")
	s.Value.Encode(e)
}
		}
		{if s.AppliedAt.Set {
e.FieldStart("applied_at")
	s.AppliedAt.Encode(e, json.EncodeDateTime)
}
		}
}

var jsonFieldsNameOfCombatEffect = [7]string{
	0: "id",
	1: "effect_type",
	2: "effect_name",
	3: "duration",
	4: "remaining_turns",
	5: "value",
	6: "applied_at",
}

// Decode decodes CombatEffect from json.
func (s *CombatEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatEffect to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":if err := func() error {
	s.ID.Reset()
	if err := s.ID.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "effect_type":if err := func() error {
	s.EffectType.Reset()
	if err := s.EffectType.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "effect_name":if err := func() error {
	s.EffectName.Reset()
	if err := s.EffectName.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_name\"")
			}
		case "duration":if err := func() error {
	s.Duration.Reset()
	if err := s.Duration.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "remaining_turns":if err := func() error {
	s.RemainingTurns.Reset()
	if err := s.RemainingTurns.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_turns\"")
			}
		case "value":if err := func() error {
	s.Value.Reset()
	if err := s.Value.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "applied_at":if err := func() error {
	s.AppliedAt.Reset()
	if err := s.AppliedAt.Decode(d, json.DecodeDateTime); err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatEffect")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *CombatEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes CombatEffectEffectType as json.
func (s CombatEffectEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatEffectEffectType from json.
func (s *CombatEffectEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatEffectEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatEffectEffectType(v) {
	case CombatEffectEffectTypeBuff:
		*s = CombatEffectEffectTypeBuff
	case CombatEffectEffectTypeDebuff:
		*s = CombatEffectEffectTypeDebuff
	case CombatEffectEffectTypeStatus:
		*s = CombatEffectEffectTypeStatus
	default:
		*s = CombatEffectEffectType(v)
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s CombatEffectEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatEffectEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *DamageCalculationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *DamageCalculationRequest) encodeFields(e *jx.Encoder) {
		{
e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
		}
		{
e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
		}
		{
e.FieldStart("base_damage")
		e.Int(s.BaseDamage)
		}
		{
e.FieldStart("damage_type")
	s.DamageType.Encode(e)
		}
		{if s.Modifiers.Set {
e.FieldStart("modifiers")
	s.Modifiers.Encode(e)
}
		}
}

var jsonFieldsNameOfDamageCalculationRequest = [5]string{
	0: "attacker_id",
	1: "target_id",
	2: "base_damage",
	3: "damage_type",
	4: "modifiers",
}

// Decode decodes DamageCalculationRequest from json.
func (s *DamageCalculationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
		v, err := json.DecodeUUID(d)
		s.AttackerID = v
		if err != nil {
			 return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
		v, err := json.DecodeUUID(d)
		s.TargetID = v
		if err != nil {
			 return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "base_damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
		v, err := d.Int()
		s.BaseDamage = int(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
		if err := s.DamageType.Decode(d); err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "modifiers":if err := func() error {
	s.Modifiers.Reset()
	if err := s.Modifiers.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i * 8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequest) {
					name = jsonFieldsNameOfDamageCalculationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes DamageCalculationRequestDamageType as json.
func (s DamageCalculationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestDamageType from json.
func (s *DamageCalculationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestDamageType(v) {
	case DamageCalculationRequestDamageTypePhysical:
		*s = DamageCalculationRequestDamageTypePhysical
	case DamageCalculationRequestDamageTypeFire:
		*s = DamageCalculationRequestDamageTypeFire
	case DamageCalculationRequestDamageTypeCold:
		*s = DamageCalculationRequestDamageTypeCold
	case DamageCalculationRequestDamageTypeLightning:
		*s = DamageCalculationRequestDamageTypeLightning
	case DamageCalculationRequestDamageTypePoison:
		*s = DamageCalculationRequestDamageTypePoison
	case DamageCalculationRequestDamageTypeCyber:
		*s = DamageCalculationRequestDamageTypeCyber
	default:
		*s = DamageCalculationRequestDamageType(v)
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *DamageCalculationRequestModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *DamageCalculationRequestModifiers) encodeFields(e *jx.Encoder) {
		{if s.IsCritical.Set {
e.FieldStart("is_critical")
	s.IsCritical.Encode(e)
}
		}
		{if s.WeakSpot.Set {
e.FieldStart("weak_spot")
	s.WeakSpot.Encode(e)
}
		}
		{if s.RangeModifier.Set {
e.FieldStart("range_modifier")
	s.RangeModifier.Encode(e)
}
		}
}

var jsonFieldsNameOfDamageCalculationRequestModifiers = [3]string{
	0: "is_critical",
	1: "weak_spot",
	2: "range_modifier",
}

// Decode decodes DamageCalculationRequestModifiers from json.
func (s *DamageCalculationRequestModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_critical":if err := func() error {
	s.IsCritical.Reset()
	if err := s.IsCritical.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_critical\"")
			}
		case "weak_spot":if err := func() error {
	s.WeakSpot.Reset()
	if err := s.WeakSpot.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weak_spot\"")
			}
		case "range_modifier":if err := func() error {
	s.RangeModifier.Reset()
	if err := s.RangeModifier.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequestModifiers")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequestModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *DamageCalculationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *DamageCalculationResult) encodeFields(e *jx.Encoder) {
		{if s.AttackerID.Set {
e.FieldStart("attacker_id")
	s.AttackerID.Encode(e)
}
		}
		{if s.TargetID.Set {
e.FieldStart("target_id")
	s.TargetID.Encode(e)
}
		}
		{if s.BaseDamage.Set {
e.FieldStart("base_damage")
	s.BaseDamage.Encode(e)
}
		}
		{if s.FinalDamage.Set {
e.FieldStart("final_damage")
	s.FinalDamage.Encode(e)
}
		}
		{if s.DamageType.Set {
e.FieldStart("damage_type")
	s.DamageType.Encode(e)
}
		}
		{if s.ModifiersApplied != nil {
e.FieldStart("modifiers_applied")
	e.ArrStart()
	for _, elem := range s.ModifiersApplied {
	elem.Encode(e)
	}
	e.ArrEnd()}
		}
		{if s.WasCritical.Set {
e.FieldStart("was_critical")
	s.WasCritical.Encode(e)
}
		}
		{if s.WasBlocked.Set {
e.FieldStart("was_blocked")
	s.WasBlocked.Encode(e)
}
		}
		{if s.DamageReduction.Set {
e.FieldStart("damage_reduction")
	s.DamageReduction.Encode(e)
}
		}
}

var jsonFieldsNameOfDamageCalculationResult = [9]string{
	0: "attacker_id",
	1: "target_id",
	2: "base_damage",
	3: "final_damage",
	4: "damage_type",
	5: "modifiers_applied",
	6: "was_critical",
	7: "was_blocked",
	8: "damage_reduction",
}

// Decode decodes DamageCalculationResult from json.
func (s *DamageCalculationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":if err := func() error {
	s.AttackerID.Reset()
	if err := s.AttackerID.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":if err := func() error {
	s.TargetID.Reset()
	if err := s.TargetID.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "base_damage":if err := func() error {
	s.BaseDamage.Reset()
	if err := s.BaseDamage.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "final_damage":if err := func() error {
	s.FinalDamage.Reset()
	if err := s.FinalDamage.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "damage_type":if err := func() error {
	s.DamageType.Reset()
	if err := s.DamageType.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "modifiers_applied":if err := func() error {
		s.ModifiersApplied = make([]DamageCalculationResultModifiersAppliedItem, 0)
if err := d.Arr(func(d *jx.Decoder) error {
	var elem DamageCalculationResultModifiersAppliedItem
		if err := elem.Decode(d); err != nil {
			return err
		}
	s.ModifiersApplied = append(s.ModifiersApplied, elem)
	return nil
}); err != nil {
	return err
}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiers_applied\"")
			}
		case "was_critical":if err := func() error {
	s.WasCritical.Reset()
	if err := s.WasCritical.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "was_blocked":if err := func() error {
	s.WasBlocked.Reset()
	if err := s.WasBlocked.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_blocked\"")
			}
		case "damage_reduction":if err := func() error {
	s.DamageReduction.Reset()
	if err := s.DamageReduction.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_reduction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResult")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes DamageCalculationResultDamageType as json.
func (s DamageCalculationResultDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationResultDamageType from json.
func (s *DamageCalculationResultDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationResultDamageType(v) {
	case DamageCalculationResultDamageTypePhysical:
		*s = DamageCalculationResultDamageTypePhysical
	case DamageCalculationResultDamageTypeFire:
		*s = DamageCalculationResultDamageTypeFire
	case DamageCalculationResultDamageTypeCold:
		*s = DamageCalculationResultDamageTypeCold
	case DamageCalculationResultDamageTypeLightning:
		*s = DamageCalculationResultDamageTypeLightning
	case DamageCalculationResultDamageTypePoison:
		*s = DamageCalculationResultDamageTypePoison
	case DamageCalculationResultDamageTypeCyber:
		*s = DamageCalculationResultDamageTypeCyber
	default:
		*s = DamageCalculationResultDamageType(v)
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationResultDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *DamageCalculationResultModifiersAppliedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *DamageCalculationResultModifiersAppliedItem) encodeFields(e *jx.Encoder) {
		{if s.Name.Set {
e.FieldStart("name")
	s.Name.Encode(e)
}
		}
		{if s.Value.Set {
e.FieldStart("value")
	s.Value.Encode(e)
}
		}
}

var jsonFieldsNameOfDamageCalculationResultModifiersAppliedItem = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes DamageCalculationResultModifiersAppliedItem from json.
func (s *DamageCalculationResultModifiersAppliedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultModifiersAppliedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":if err := func() error {
	s.Name.Reset()
	if err := s.Name.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":if err := func() error {
	s.Value.Reset()
	if err := s.Value.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResultModifiersAppliedItem")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResultModifiersAppliedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultModifiersAppliedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
		{
e.FieldStart("error")
		e.Str(s.Error)
		}
		{
e.FieldStart("message")
		e.Str(s.Message)
		}
		{if s.Code.Set {
e.FieldStart("code")
	s.Code.Encode(e)
}
		}
		{if s.Details.Set {
e.FieldStart("details")
	s.Details.Encode(e)
}
		}
}

var jsonFieldsNameOfError = [4]string{
	0: "error",
	1: "message",
	2: "code",
	3: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
		v, err := d.Str()
		s.Error = string(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
		v, err := d.Str()
		s.Message = string(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":if err := func() error {
	s.Code.Reset()
	if err := s.Code.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "details":if err := func() error {
	s.Details.Reset()
	if err := s.Details.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i * 8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorDetails) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)
		
		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
		v, err := d.RawAppend(nil)
		elem = jx.Raw(v)
		if err != nil {
			return err
		}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ExtendEffectBadRequest as json.
func (s *ExtendEffectBadRequest) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ExtendEffectBadRequest from json.
func (s *ExtendEffectBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExtendEffectBadRequest(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ExtendEffectInternalServerError as json.
func (s *ExtendEffectInternalServerError) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ExtendEffectInternalServerError from json.
func (s *ExtendEffectInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExtendEffectInternalServerError(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ExtendEffectNotFound as json.
func (s *ExtendEffectNotFound) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ExtendEffectNotFound from json.
func (s *ExtendEffectNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExtendEffectNotFound(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *ExtendEffectOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *ExtendEffectOK) encodeFields(e *jx.Encoder) {
		{if s.Status.Set {
e.FieldStart("status")
	s.Status.Encode(e)
}
		}
}

var jsonFieldsNameOfExtendEffectOK = [1]string{
	0: "status",
}

// Decode decodes ExtendEffectOK from json.
func (s *ExtendEffectOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":if err := func() error {
	s.Status.Reset()
	if err := s.Status.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExtendEffectOK")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *ExtendEffectReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *ExtendEffectReq) encodeFields(e *jx.Encoder) {
		{
e.FieldStart("additional_turns")
		e.Int(s.AdditionalTurns)
		}
}

var jsonFieldsNameOfExtendEffectReq = [1]string{
	0: "additional_turns",
}

// Decode decodes ExtendEffectReq from json.
func (s *ExtendEffectReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additional_turns":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
		v, err := d.Int()
		s.AdditionalTurns = int(v)
		if err != nil {
			return err
		}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_turns\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExtendEffectReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i * 8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExtendEffectReq) {
					name = jsonFieldsNameOfExtendEffectReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes ExtendEffectUnauthorized as json.
func (s *ExtendEffectUnauthorized) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes ExtendEffectUnauthorized from json.
func (s *ExtendEffectUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExtendEffectUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExtendEffectUnauthorized(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *ExtendEffectUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExtendEffectUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes CombatEffectEffectType as json.
func (o OptCombatEffectEffectType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CombatEffectEffectType from json.
func (o *OptCombatEffectEffectType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatEffectEffectType to nil")
	}
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatEffectEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatEffectEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes DamageCalculationRequestModifiers as json.
func (o OptDamageCalculationRequestModifiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationRequestModifiers from json.
func (o *OptDamageCalculationRequestModifiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestModifiers to nil")
	}
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes DamageCalculationResultDamageType as json.
func (o OptDamageCalculationResultDamageType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageCalculationResultDamageType from json.
func (o *OptDamageCalculationResultDamageType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationResultDamageType to nil")
	}
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationResultDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationResultDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
		o.Set = true
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
		s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
		return s.Decode(d, json.DecodeDateTime)
}




// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
		o.Set = true
		v, err := d.Float32()
		if err != nil {
			return err
		}
		o.Value = float32(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes ErrorDetails as json.
func (o OptNilErrorDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorDetails from json.
func (o *OptNilErrorDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilErrorDetails to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ErrorDetails
		o.Value = v
			o.Set = true
		o.Null = true
		return nil
	}
		o.Set = true
		o.Null = false
		o.Value = make(ErrorDetails)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptNilErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
			o.Set = true
		o.Null = true
		return nil
	}
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
		o.Set = true
		v, err := json.DecodeUUID(d)
		if err != nil {
			return err
		}
		o.Value = v
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes RemoveEffectInternalServerError as json.
func (s *RemoveEffectInternalServerError) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes RemoveEffectInternalServerError from json.
func (s *RemoveEffectInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveEffectInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveEffectInternalServerError(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveEffectInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveEffectInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes RemoveEffectNotFound as json.
func (s *RemoveEffectNotFound) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes RemoveEffectNotFound from json.
func (s *RemoveEffectNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveEffectNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveEffectNotFound(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveEffectNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveEffectNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode implements json.Marshaler.
func (s *RemoveEffectOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}
// encodeFields encodes fields.
func (s *RemoveEffectOK) encodeFields(e *jx.Encoder) {
		{if s.Status.Set {
e.FieldStart("status")
	s.Status.Encode(e)
}
		}
}

var jsonFieldsNameOfRemoveEffectOK = [1]string{
	0: "status",
}

// Decode decodes RemoveEffectOK from json.
func (s *RemoveEffectOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveEffectOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":if err := func() error {
	s.Status.Reset()
	if err := s.Status.Decode(d); err != nil {
		return err
	}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveEffectOK")
	}

	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveEffectOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveEffectOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}


// Encode encodes RemoveEffectUnauthorized as json.
func (s *RemoveEffectUnauthorized) Encode(e *jx.Encoder) {
		unwrapped := (*Error)(s)
	
	unwrapped.Encode(e)}

// Decode decodes RemoveEffectUnauthorized from json.
func (s *RemoveEffectUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveEffectUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveEffectUnauthorized(unwrapped)
	return nil
}



// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveEffectUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveEffectUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}




