
// Code generated by ogen, DO NOT EDIT.

package api


import (
	 "bytes"
	 "context"
	 "encoding/base64"
	 "fmt"
	 "github.com/go-faster/errors"
	 "github.com/go-faster/jx"
	 "github.com/google/uuid"
	 "github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	 "github.com/ogen-go/ogen/json"
	 "github.com/ogen-go/ogen/middleware"
	 "github.com/ogen-go/ogen/ogenerrors"
	 "github.com/ogen-go/ogen/ogenregex"
	 "github.com/ogen-go/ogen/otelogen"
	 "github.com/ogen-go/ogen/uri"
	 "github.com/ogen-go/ogen/validate"
	 "github.com/shopspring/decimal"
	 "go.opentelemetry.io/otel"
	 "go.opentelemetry.io/otel/attribute"
	 "go.opentelemetry.io/otel/codes"
	 "go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	 "go.opentelemetry.io/otel/trace"
	 "go.uber.org/multierr"
	 "io"
	 "math"
	 "math/big"
	 "math/bits"
	 "mime"
	 "mime/multipart"
	 "net"
	 "net/http"
	 "net/netip"
	 "net/url"
	 "regexp"
	 "sort"
	 "strconv"
	 "strings"
	 "sync"
	 "time"
	
)






func (s *ApplyEffectsOK) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Effects {
			if err := func() error {
	if err := elem.Validate(); err != nil {
		return err
	}
	return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "effects",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ApplyEffectsRequest) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if s.Effects == nil {
		return errors.New("nil is invalid value")
	}
		var failures []validate.FieldError
		for i, elem := range s.Effects {
			if err := func() error {
	if err := elem.Validate(); err != nil {
		return err
	}
	return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "effects",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ApplyEffectsRequestEffectsItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if err := s.EffectType.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "effect_type",
				Error: err,
			})
		}
		if err := func() error {
		if err := (validate.Int{
			MinSet:       true,
			Min:          1,
			MaxSet:       true,
			Max:          10,
			MinExclusive: false,
			MaxExclusive: false,
			MultipleOfSet:false,
			MultipleOf:   0,
			Pattern:      nil,
		}).Validate(int64(s.Duration)); err != nil {
			return errors.Wrap(err, "int")
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "duration",
				Error: err,
			})
		}
		if err := func() error {
		if err := (validate.Int{
			MinSet:       true,
			Min:          0,
			MaxSet:       false,
			Max:          0,
			MinExclusive: false,
			MaxExclusive: false,
			MultipleOfSet:false,
			MultipleOf:   0,
			Pattern:      nil,
		}).Validate(int64(s.Value)); err != nil {
			return errors.Wrap(err, "int")
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "value",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s ApplyEffectsRequestEffectsItemEffectType) Validate() error {
switch s {
	case "buff": return nil
	case "debuff": return nil
	case "status": return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CombatEffect) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if value, ok := s.EffectType.Get(); ok {
		if err := func() error {
	if err := value.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "effect_type",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CombatEffectEffectType) Validate() error {
switch s {
	case "buff": return nil
	case "debuff": return nil
	case "status": return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DamageCalculationRequest) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
		if err := (validate.Int{
			MinSet:       true,
			Min:          0,
			MaxSet:       false,
			Max:          0,
			MinExclusive: false,
			MaxExclusive: false,
			MultipleOfSet:false,
			MultipleOf:   0,
			Pattern:      nil,
		}).Validate(int64(s.BaseDamage)); err != nil {
			return errors.Wrap(err, "int")
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "base_damage",
				Error: err,
			})
		}
		if err := func() error {
	if err := s.DamageType.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "damage_type",
				Error: err,
			})
		}
		if err := func() error {
	if value, ok := s.Modifiers.Get(); ok {
		if err := func() error {
	if err := value.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "modifiers",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DamageCalculationRequestDamageType) Validate() error {
switch s {
	case "physical": return nil
	case "fire": return nil
	case "cold": return nil
	case "lightning": return nil
	case "poison": return nil
	case "cyber": return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DamageCalculationRequestModifiers) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if value, ok := s.RangeModifier.Get(); ok {
		if err := func() error {
		if err := (validate.Float{ 
			MinSet:       true,
			Min:          0.5,
			MaxSet:       true,
			Max:          1.5,
			MinExclusive: false,
			MaxExclusive: false,
			MultipleOfSet:false,
			MultipleOf: nil,
			Pattern:      nil,
		 }).Validate(float64(value)); err != nil {
			return errors.Wrap(err, "float")
		}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "range_modifier",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DamageCalculationResult) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if value, ok := s.DamageType.Get(); ok {
		if err := func() error {
	if err := value.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "damage_type",
				Error: err,
			})
		}
		if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.ModifiersApplied {
			if err := func() error {
	if err := elem.Validate(); err != nil {
		return err
	}
	return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "modifiers_applied",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DamageCalculationResultDamageType) Validate() error {
switch s {
	case "physical": return nil
	case "fire": return nil
	case "cold": return nil
	case "lightning": return nil
	case "poison": return nil
	case "cyber": return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DamageCalculationResultModifiersAppliedItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
	if value, ok := s.Value.Get(); ok {
		if err := func() error {
		if err := (validate.Float{  }).Validate(float64(value)); err != nil {
			return errors.Wrap(err, "float")
		}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "value",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ExtendEffectReq) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
		if err := func() error {
		if err := (validate.Int{
			MinSet:       true,
			Min:          1,
			MaxSet:       true,
			Max:          10,
			MinExclusive: false,
			MaxExclusive: false,
			MultipleOfSet:false,
			MultipleOf:   0,
			Pattern:      nil,
		}).Validate(int64(s.AdditionalTurns)); err != nil {
			return errors.Wrap(err, "int")
		}
	return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name: "additional_turns",
				Error: err,
			})
		}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}


















