// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActiveEffects) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffects) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("effects")
		e.ArrStart()
		for _, elem := range s.Effects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("timestamp")
		e.Int64(s.Timestamp)
	}
	{
		if s.TotalEffects.Set {
			e.FieldStart("total_effects")
			s.TotalEffects.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.HasCriticalEffects.Set {
			e.FieldStart("has_critical_effects")
			s.HasCriticalEffects.Encode(e)
		}
	}
	{
		if s.ActiveEffect.Set {
			e.FieldStart("ActiveEffect")
			s.ActiveEffect.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffects = [7]string{
	0: "participant_id",
	1: "effects",
	2: "timestamp",
	3: "total_effects",
	4: "summary",
	5: "has_critical_effects",
	6: "ActiveEffect",
}

// Decode decodes ActiveEffects from json.
func (s *ActiveEffects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffects to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Effects = make([]ActiveEffectsEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveEffectsEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Timestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "total_effects":
			if err := func() error {
				s.TotalEffects.Reset()
				if err := s.TotalEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_effects\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "has_critical_effects":
			if err := func() error {
				s.HasCriticalEffects.Reset()
				if err := s.HasCriticalEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_critical_effects\"")
			}
		case "ActiveEffect":
			if err := func() error {
				s.ActiveEffect.Reset()
				if err := s.ActiveEffect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ActiveEffect\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffects")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEffects) {
					name = jsonFieldsNameOfActiveEffects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEffectsActiveEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsActiveEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("remaining_ms")
		e.Int32(s.RemainingMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
	{
		if s.AppliedAt.Set {
			e.FieldStart("applied_at")
			s.AppliedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsActiveEffect = [7]string{
	0: "effect_id",
	1: "effect_type",
	2: "remaining_ms",
	3: "source_id",
	4: "intensity",
	5: "stacks",
	6: "applied_at",
}

// Decode decodes ActiveEffectsActiveEffect from json.
func (s *ActiveEffectsActiveEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsActiveEffect to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "effect_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "remaining_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RemainingMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		case "applied_at":
			if err := func() error {
				s.AppliedAt.Reset()
				if err := s.AppliedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsActiveEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEffectsActiveEffect) {
					name = jsonFieldsNameOfActiveEffectsActiveEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsActiveEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsActiveEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsActiveEffectEffectType as json.
func (s ActiveEffectsActiveEffectEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveEffectsActiveEffectEffectType from json.
func (s *ActiveEffectsActiveEffectEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsActiveEffectEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveEffectsActiveEffectEffectType(v) {
	case ActiveEffectsActiveEffectEffectTypeBuffDamage:
		*s = ActiveEffectsActiveEffectEffectTypeBuffDamage
	case ActiveEffectsActiveEffectEffectTypeDebuffDamageReduction:
		*s = ActiveEffectsActiveEffectEffectTypeDebuffDamageReduction
	case ActiveEffectsActiveEffectEffectTypeBuffSpeed:
		*s = ActiveEffectsActiveEffectEffectTypeBuffSpeed
	case ActiveEffectsActiveEffectEffectTypeDebuffSlow:
		*s = ActiveEffectsActiveEffectEffectTypeDebuffSlow
	case ActiveEffectsActiveEffectEffectTypeBuffRegeneration:
		*s = ActiveEffectsActiveEffectEffectTypeBuffRegeneration
	case ActiveEffectsActiveEffectEffectTypeDebuffPoison:
		*s = ActiveEffectsActiveEffectEffectTypeDebuffPoison
	case ActiveEffectsActiveEffectEffectTypeBuffShield:
		*s = ActiveEffectsActiveEffectEffectTypeBuffShield
	case ActiveEffectsActiveEffectEffectTypeDebuffStun:
		*s = ActiveEffectsActiveEffectEffectTypeDebuffStun
	case ActiveEffectsActiveEffectEffectTypeBuffCriticalChance:
		*s = ActiveEffectsActiveEffectEffectTypeBuffCriticalChance
	case ActiveEffectsActiveEffectEffectTypeDebuffAccuracyReduction:
		*s = ActiveEffectsActiveEffectEffectTypeDebuffAccuracyReduction
	default:
		*s = ActiveEffectsActiveEffectEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveEffectsActiveEffectEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsActiveEffectEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEffectsEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("remaining_ms")
		e.Int32(s.RemainingMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
	{
		if s.AppliedAt.Set {
			e.FieldStart("applied_at")
			s.AppliedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsEffectsItem = [7]string{
	0: "effect_id",
	1: "effect_type",
	2: "remaining_ms",
	3: "source_id",
	4: "intensity",
	5: "stacks",
	6: "applied_at",
}

// Decode decodes ActiveEffectsEffectsItem from json.
func (s *ActiveEffectsEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "effect_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "remaining_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RemainingMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		case "applied_at":
			if err := func() error {
				s.AppliedAt.Reset()
				if err := s.AppliedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEffectsEffectsItem) {
					name = jsonFieldsNameOfActiveEffectsEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsEffectsItemEffectType as json.
func (s ActiveEffectsEffectsItemEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveEffectsEffectsItemEffectType from json.
func (s *ActiveEffectsEffectsItemEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsEffectsItemEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveEffectsEffectsItemEffectType(v) {
	case ActiveEffectsEffectsItemEffectTypeBuffDamage:
		*s = ActiveEffectsEffectsItemEffectTypeBuffDamage
	case ActiveEffectsEffectsItemEffectTypeDebuffDamageReduction:
		*s = ActiveEffectsEffectsItemEffectTypeDebuffDamageReduction
	case ActiveEffectsEffectsItemEffectTypeBuffSpeed:
		*s = ActiveEffectsEffectsItemEffectTypeBuffSpeed
	case ActiveEffectsEffectsItemEffectTypeDebuffSlow:
		*s = ActiveEffectsEffectsItemEffectTypeDebuffSlow
	case ActiveEffectsEffectsItemEffectTypeBuffRegeneration:
		*s = ActiveEffectsEffectsItemEffectTypeBuffRegeneration
	case ActiveEffectsEffectsItemEffectTypeDebuffPoison:
		*s = ActiveEffectsEffectsItemEffectTypeDebuffPoison
	case ActiveEffectsEffectsItemEffectTypeBuffShield:
		*s = ActiveEffectsEffectsItemEffectTypeBuffShield
	case ActiveEffectsEffectsItemEffectTypeDebuffStun:
		*s = ActiveEffectsEffectsItemEffectTypeDebuffStun
	case ActiveEffectsEffectsItemEffectTypeBuffCriticalChance:
		*s = ActiveEffectsEffectsItemEffectTypeBuffCriticalChance
	case ActiveEffectsEffectsItemEffectTypeDebuffAccuracyReduction:
		*s = ActiveEffectsEffectsItemEffectTypeDebuffAccuracyReduction
	default:
		*s = ActiveEffectsEffectsItemEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveEffectsEffectsItemEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsEffectsItemEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEffectsSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Buffs.Set {
			e.FieldStart("buffs")
			s.Buffs.Encode(e)
		}
	}
	{
		if s.Debuffs.Set {
			e.FieldStart("debuffs")
			s.Debuffs.Encode(e)
		}
	}
	{
		if s.StatusEffects.Set {
			e.FieldStart("status_effects")
			s.StatusEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsSummary = [3]string{
	0: "buffs",
	1: "debuffs",
	2: "status_effects",
}

// Decode decodes ActiveEffectsSummary from json.
func (s *ActiveEffectsSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "buffs":
			if err := func() error {
				s.Buffs.Reset()
				if err := s.Buffs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffs\"")
			}
		case "debuffs":
			if err := func() error {
				s.Debuffs.Reset()
				if err := s.Debuffs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuffs\"")
			}
		case "status_effects":
			if err := func() error {
				s.StatusEffects.Reset()
				if err := s.StatusEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalculateDamageBadRequest as json.
func (s *CalculateDamageBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CalculateDamageBadRequest from json.
func (s *CalculateDamageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalculateDamageTooManyRequests as json.
func (s *CalculateDamageTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CalculateDamageTooManyRequests from json.
func (s *CalculateDamageTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.WeaponModifiers != nil {
			e.FieldStart("weapon_modifiers")
			e.ArrStart()
			for _, elem := range s.WeaponModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImplantSynergies != nil {
			e.FieldStart("implant_synergies")
			e.ArrStart()
			for _, elem := range s.ImplantSynergies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvironmentalModifiers.Set {
			e.FieldStart("environmental_modifiers")
			s.EnvironmentalModifiers.Encode(e)
		}
	}
	{
		e.FieldStart("base_damage")
		e.Int32(s.BaseDamage)
	}
	{
		if s.AttackerLevel.Set {
			e.FieldStart("attacker_level")
			s.AttackerLevel.Encode(e)
		}
	}
	{
		if s.TargetLevel.Set {
			e.FieldStart("target_level")
			s.TargetLevel.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.WeaponType.Set {
			e.FieldStart("weapon_type")
			s.WeaponType.Encode(e)
		}
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		if s.RangeModifier.Set {
			e.FieldStart("range_modifier")
			s.RangeModifier.Encode(e)
		}
	}
	{
		if s.IsCriticalHit.Set {
			e.FieldStart("is_critical_hit")
			s.IsCriticalHit.Encode(e)
		}
	}
	{
		if s.IsWeakSpotHit.Set {
			e.FieldStart("is_weak_spot_hit")
			s.IsWeakSpotHit.Encode(e)
		}
	}
	{
		if s.IsBackstab.Set {
			e.FieldStart("is_backstab")
			s.IsBackstab.Encode(e)
		}
	}
	{
		if s.IgnoreArmor.Set {
			e.FieldStart("ignore_armor")
			s.IgnoreArmor.Encode(e)
		}
	}
	{
		if s.WeaponModifier.Set {
			e.FieldStart("WeaponModifier")
			s.WeaponModifier.Encode(e)
		}
	}
	{
		if s.ImplantSynergy.Set {
			e.FieldStart("ImplantSynergy")
			s.ImplantSynergy.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageRequest = [19]string{
	0:  "attacker_id",
	1:  "target_id",
	2:  "weapon_modifiers",
	3:  "implant_synergies",
	4:  "environmental_modifiers",
	5:  "base_damage",
	6:  "attacker_level",
	7:  "target_level",
	8:  "timestamp",
	9:  "damage_type",
	10: "weapon_type",
	11: "critical_multiplier",
	12: "range_modifier",
	13: "is_critical_hit",
	14: "is_weak_spot_hit",
	15: "is_backstab",
	16: "ignore_armor",
	17: "WeaponModifier",
	18: "ImplantSynergy",
}

// Decode decodes DamageRequest from json.
func (s *DamageRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "weapon_modifiers":
			if err := func() error {
				s.WeaponModifiers = make([]DamageRequestWeaponModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageRequestWeaponModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WeaponModifiers = append(s.WeaponModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_modifiers\"")
			}
		case "implant_synergies":
			if err := func() error {
				s.ImplantSynergies = make([]DamageRequestImplantSynergiesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageRequestImplantSynergiesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImplantSynergies = append(s.ImplantSynergies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_synergies\"")
			}
		case "environmental_modifiers":
			if err := func() error {
				s.EnvironmentalModifiers.Reset()
				if err := s.EnvironmentalModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_modifiers\"")
			}
		case "base_damage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.BaseDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "attacker_level":
			if err := func() error {
				s.AttackerLevel.Reset()
				if err := s.AttackerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_level\"")
			}
		case "target_level":
			if err := func() error {
				s.TargetLevel.Reset()
				if err := s.TargetLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_level\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "damage_type":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "weapon_type":
			if err := func() error {
				s.WeaponType.Reset()
				if err := s.WeaponType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_type\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "range_modifier":
			if err := func() error {
				s.RangeModifier.Reset()
				if err := s.RangeModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range_modifier\"")
			}
		case "is_critical_hit":
			if err := func() error {
				s.IsCriticalHit.Reset()
				if err := s.IsCriticalHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_critical_hit\"")
			}
		case "is_weak_spot_hit":
			if err := func() error {
				s.IsWeakSpotHit.Reset()
				if err := s.IsWeakSpotHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_weak_spot_hit\"")
			}
		case "is_backstab":
			if err := func() error {
				s.IsBackstab.Reset()
				if err := s.IsBackstab.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_backstab\"")
			}
		case "ignore_armor":
			if err := func() error {
				s.IgnoreArmor.Reset()
				if err := s.IgnoreArmor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_armor\"")
			}
		case "WeaponModifier":
			if err := func() error {
				s.WeaponModifier.Reset()
				if err := s.WeaponModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WeaponModifier\"")
			}
		case "ImplantSynergy":
			if err := func() error {
				s.ImplantSynergy.Reset()
				if err := s.ImplantSynergy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ImplantSynergy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100011,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRequest) {
					name = jsonFieldsNameOfDamageRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestDamageType as json.
func (s DamageRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageRequestDamageType from json.
func (s *DamageRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageRequestDamageType(v) {
	case DamageRequestDamageTypePhysical:
		*s = DamageRequestDamageTypePhysical
	case DamageRequestDamageTypeFire:
		*s = DamageRequestDamageTypeFire
	case DamageRequestDamageTypeCold:
		*s = DamageRequestDamageTypeCold
	case DamageRequestDamageTypeLightning:
		*s = DamageRequestDamageTypeLightning
	case DamageRequestDamageTypePoison:
		*s = DamageRequestDamageTypePoison
	case DamageRequestDamageTypeCyber:
		*s = DamageRequestDamageTypeCyber
	case DamageRequestDamageTypeRadiation:
		*s = DamageRequestDamageTypeRadiation
	case DamageRequestDamageTypeExplosive:
		*s = DamageRequestDamageTypeExplosive
	default:
		*s = DamageRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequestEnvironmentalModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequestEnvironmentalModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.WeatherMultiplier.Set {
			e.FieldStart("weather_multiplier")
			s.WeatherMultiplier.Encode(e)
		}
	}
	{
		if s.TerrainCover.Set {
			e.FieldStart("terrain_cover")
			s.TerrainCover.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageRequestEnvironmentalModifiers = [2]string{
	0: "weather_multiplier",
	1: "terrain_cover",
}

// Decode decodes DamageRequestEnvironmentalModifiers from json.
func (s *DamageRequestEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestEnvironmentalModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather_multiplier":
			if err := func() error {
				s.WeatherMultiplier.Reset()
				if err := s.WeatherMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_multiplier\"")
			}
		case "terrain_cover":
			if err := func() error {
				s.TerrainCover.Reset()
				if err := s.TerrainCover.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_cover\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequestEnvironmentalModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequestEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequestImplantSynergiesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequestImplantSynergiesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("implant_type")
		s.ImplantType.Encode(e)
	}
	{
		e.FieldStart("synergy_bonus")
		e.Float32(s.SynergyBonus)
	}
}

var jsonFieldsNameOfDamageRequestImplantSynergiesItem = [2]string{
	0: "implant_type",
	1: "synergy_bonus",
}

// Decode decodes DamageRequestImplantSynergiesItem from json.
func (s *DamageRequestImplantSynergiesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestImplantSynergiesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "implant_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ImplantType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_type\"")
			}
		case "synergy_bonus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.SynergyBonus = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_bonus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequestImplantSynergiesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRequestImplantSynergiesItem) {
					name = jsonFieldsNameOfDamageRequestImplantSynergiesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequestImplantSynergiesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestImplantSynergiesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestImplantSynergiesItemImplantType as json.
func (s DamageRequestImplantSynergiesItemImplantType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageRequestImplantSynergiesItemImplantType from json.
func (s *DamageRequestImplantSynergiesItemImplantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestImplantSynergiesItemImplantType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageRequestImplantSynergiesItemImplantType(v) {
	case DamageRequestImplantSynergiesItemImplantTypeGorillaArms:
		*s = DamageRequestImplantSynergiesItemImplantTypeGorillaArms
	case DamageRequestImplantSynergiesItemImplantTypeMantisBlades:
		*s = DamageRequestImplantSynergiesItemImplantTypeMantisBlades
	case DamageRequestImplantSynergiesItemImplantTypeKerenzikov:
		*s = DamageRequestImplantSynergiesItemImplantTypeKerenzikov
	case DamageRequestImplantSynergiesItemImplantTypeSandevistan:
		*s = DamageRequestImplantSynergiesItemImplantTypeSandevistan
	case DamageRequestImplantSynergiesItemImplantTypeProjectileLauncher:
		*s = DamageRequestImplantSynergiesItemImplantTypeProjectileLauncher
	default:
		*s = DamageRequestImplantSynergiesItemImplantType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageRequestImplantSynergiesItemImplantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestImplantSynergiesItemImplantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequestImplantSynergy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequestImplantSynergy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("implant_type")
		s.ImplantType.Encode(e)
	}
	{
		e.FieldStart("synergy_bonus")
		e.Float32(s.SynergyBonus)
	}
}

var jsonFieldsNameOfDamageRequestImplantSynergy = [2]string{
	0: "implant_type",
	1: "synergy_bonus",
}

// Decode decodes DamageRequestImplantSynergy from json.
func (s *DamageRequestImplantSynergy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestImplantSynergy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "implant_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ImplantType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_type\"")
			}
		case "synergy_bonus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.SynergyBonus = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_bonus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequestImplantSynergy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRequestImplantSynergy) {
					name = jsonFieldsNameOfDamageRequestImplantSynergy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequestImplantSynergy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestImplantSynergy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestImplantSynergyImplantType as json.
func (s DamageRequestImplantSynergyImplantType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageRequestImplantSynergyImplantType from json.
func (s *DamageRequestImplantSynergyImplantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestImplantSynergyImplantType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageRequestImplantSynergyImplantType(v) {
	case DamageRequestImplantSynergyImplantTypeGorillaArms:
		*s = DamageRequestImplantSynergyImplantTypeGorillaArms
	case DamageRequestImplantSynergyImplantTypeMantisBlades:
		*s = DamageRequestImplantSynergyImplantTypeMantisBlades
	case DamageRequestImplantSynergyImplantTypeKerenzikov:
		*s = DamageRequestImplantSynergyImplantTypeKerenzikov
	case DamageRequestImplantSynergyImplantTypeSandevistan:
		*s = DamageRequestImplantSynergyImplantTypeSandevistan
	case DamageRequestImplantSynergyImplantTypeProjectileLauncher:
		*s = DamageRequestImplantSynergyImplantTypeProjectileLauncher
	default:
		*s = DamageRequestImplantSynergyImplantType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageRequestImplantSynergyImplantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestImplantSynergyImplantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequestWeaponModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequestWeaponModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageRequestWeaponModifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageRequestWeaponModifier from json.
func (s *DamageRequestWeaponModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestWeaponModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequestWeaponModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRequestWeaponModifier) {
					name = jsonFieldsNameOfDamageRequestWeaponModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequestWeaponModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestWeaponModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestWeaponModifierType as json.
func (s DamageRequestWeaponModifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageRequestWeaponModifierType from json.
func (s *DamageRequestWeaponModifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestWeaponModifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageRequestWeaponModifierType(v) {
	case DamageRequestWeaponModifierTypeDamageBoost:
		*s = DamageRequestWeaponModifierTypeDamageBoost
	case DamageRequestWeaponModifierTypeAccuracyBonus:
		*s = DamageRequestWeaponModifierTypeAccuracyBonus
	case DamageRequestWeaponModifierTypeArmorPenetration:
		*s = DamageRequestWeaponModifierTypeArmorPenetration
	case DamageRequestWeaponModifierTypeElementalDamage:
		*s = DamageRequestWeaponModifierTypeElementalDamage
	default:
		*s = DamageRequestWeaponModifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageRequestWeaponModifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestWeaponModifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRequestWeaponModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRequestWeaponModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageRequestWeaponModifiersItem = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageRequestWeaponModifiersItem from json.
func (s *DamageRequestWeaponModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestWeaponModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRequestWeaponModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRequestWeaponModifiersItem) {
					name = jsonFieldsNameOfDamageRequestWeaponModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRequestWeaponModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestWeaponModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestWeaponModifiersItemType as json.
func (s DamageRequestWeaponModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageRequestWeaponModifiersItemType from json.
func (s *DamageRequestWeaponModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRequestWeaponModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageRequestWeaponModifiersItemType(v) {
	case DamageRequestWeaponModifiersItemTypeDamageBoost:
		*s = DamageRequestWeaponModifiersItemTypeDamageBoost
	case DamageRequestWeaponModifiersItemTypeAccuracyBonus:
		*s = DamageRequestWeaponModifiersItemTypeAccuracyBonus
	case DamageRequestWeaponModifiersItemTypeArmorPenetration:
		*s = DamageRequestWeaponModifiersItemTypeArmorPenetration
	case DamageRequestWeaponModifiersItemTypeElementalDamage:
		*s = DamageRequestWeaponModifiersItemTypeElementalDamage
	default:
		*s = DamageRequestWeaponModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageRequestWeaponModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRequestWeaponModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("calculation_id")
		json.EncodeUUID(e, s.CalculationID)
	}
	{
		if s.AppliedModifiers != nil {
			e.FieldStart("applied_modifiers")
			e.ArrStart()
			for _, elem := range s.AppliedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DamageBreakdown != nil {
			e.FieldStart("damage_breakdown")
			e.ArrStart()
			for _, elem := range s.DamageBreakdown {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("final_damage")
		e.Int32(s.FinalDamage)
	}
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.ArmorReduction.Set {
			e.FieldStart("armor_reduction")
			s.ArmorReduction.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		if s.TotalMultiplier.Set {
			e.FieldStart("total_multiplier")
			s.TotalMultiplier.Encode(e)
		}
	}
	{
		if s.TargetStats.Set {
			e.FieldStart("target_stats")
			s.TargetStats.Encode(e)
		}
	}
	{
		if s.WasCritical.Set {
			e.FieldStart("was_critical")
			s.WasCritical.Encode(e)
		}
	}
	{
		if s.WasDodged.Set {
			e.FieldStart("was_dodged")
			s.WasDodged.Encode(e)
		}
	}
	{
		if s.WasBlocked.Set {
			e.FieldStart("was_blocked")
			s.WasBlocked.Encode(e)
		}
	}
	{
		if s.TargetAlive.Set {
			e.FieldStart("target_alive")
			s.TargetAlive.Encode(e)
		}
	}
	{
		if s.AppliedModifier.Set {
			e.FieldStart("AppliedModifier")
			s.AppliedModifier.Encode(e)
		}
	}
	{
		if s.DamageComponent.Set {
			e.FieldStart("DamageComponent")
			s.DamageComponent.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageResult = [20]string{
	0:  "attacker_id",
	1:  "target_id",
	2:  "calculation_id",
	3:  "applied_modifiers",
	4:  "damage_breakdown",
	5:  "final_damage",
	6:  "base_damage",
	7:  "armor_reduction",
	8:  "timestamp",
	9:  "processing_time_ns",
	10: "damage_type",
	11: "critical_multiplier",
	12: "total_multiplier",
	13: "target_stats",
	14: "was_critical",
	15: "was_dodged",
	16: "was_blocked",
	17: "target_alive",
	18: "AppliedModifier",
	19: "DamageComponent",
}

// Decode decodes DamageResult from json.
func (s *DamageResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResult to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "calculation_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CalculationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_id\"")
			}
		case "applied_modifiers":
			if err := func() error {
				s.AppliedModifiers = make([]DamageResultAppliedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageResultAppliedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AppliedModifiers = append(s.AppliedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_modifiers\"")
			}
		case "damage_breakdown":
			if err := func() error {
				s.DamageBreakdown = make([]DamageResultDamageBreakdownItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageResultDamageBreakdownItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DamageBreakdown = append(s.DamageBreakdown, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_breakdown\"")
			}
		case "final_damage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.FinalDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "armor_reduction":
			if err := func() error {
				s.ArmorReduction.Reset()
				if err := s.ArmorReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "damage_type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "total_multiplier":
			if err := func() error {
				s.TotalMultiplier.Reset()
				if err := s.TotalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_multiplier\"")
			}
		case "target_stats":
			if err := func() error {
				s.TargetStats.Reset()
				if err := s.TargetStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_stats\"")
			}
		case "was_critical":
			if err := func() error {
				s.WasCritical.Reset()
				if err := s.WasCritical.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "was_dodged":
			if err := func() error {
				s.WasDodged.Reset()
				if err := s.WasDodged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_dodged\"")
			}
		case "was_blocked":
			if err := func() error {
				s.WasBlocked.Reset()
				if err := s.WasBlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_blocked\"")
			}
		case "target_alive":
			if err := func() error {
				s.TargetAlive.Reset()
				if err := s.TargetAlive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_alive\"")
			}
		case "AppliedModifier":
			if err := func() error {
				s.AppliedModifier.Reset()
				if err := s.AppliedModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AppliedModifier\"")
			}
		case "DamageComponent":
			if err := func() error {
				s.DamageComponent.Reset()
				if err := s.DamageComponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DamageComponent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100111,
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageResult) {
					name = jsonFieldsNameOfDamageResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResultAppliedModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResultAppliedModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
}

var jsonFieldsNameOfDamageResultAppliedModifier = [3]string{
	0: "type",
	1: "value",
	2: "source",
}

// Decode decodes DamageResultAppliedModifier from json.
func (s *DamageResultAppliedModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultAppliedModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResultAppliedModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageResultAppliedModifier) {
					name = jsonFieldsNameOfDamageResultAppliedModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResultAppliedModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultAppliedModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultAppliedModifierType as json.
func (s DamageResultAppliedModifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageResultAppliedModifierType from json.
func (s *DamageResultAppliedModifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultAppliedModifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageResultAppliedModifierType(v) {
	case DamageResultAppliedModifierTypeCriticalHit:
		*s = DamageResultAppliedModifierTypeCriticalHit
	case DamageResultAppliedModifierTypeWeakSpot:
		*s = DamageResultAppliedModifierTypeWeakSpot
	case DamageResultAppliedModifierTypeArmorReduction:
		*s = DamageResultAppliedModifierTypeArmorReduction
	case DamageResultAppliedModifierTypeElementalBonus:
		*s = DamageResultAppliedModifierTypeElementalBonus
	case DamageResultAppliedModifierTypeImplantSynergy:
		*s = DamageResultAppliedModifierTypeImplantSynergy
	case DamageResultAppliedModifierTypeEnvironmental:
		*s = DamageResultAppliedModifierTypeEnvironmental
	case DamageResultAppliedModifierTypeBackstab:
		*s = DamageResultAppliedModifierTypeBackstab
	default:
		*s = DamageResultAppliedModifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageResultAppliedModifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultAppliedModifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResultAppliedModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResultAppliedModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
}

var jsonFieldsNameOfDamageResultAppliedModifiersItem = [3]string{
	0: "type",
	1: "value",
	2: "source",
}

// Decode decodes DamageResultAppliedModifiersItem from json.
func (s *DamageResultAppliedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultAppliedModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResultAppliedModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageResultAppliedModifiersItem) {
					name = jsonFieldsNameOfDamageResultAppliedModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResultAppliedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultAppliedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultAppliedModifiersItemType as json.
func (s DamageResultAppliedModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageResultAppliedModifiersItemType from json.
func (s *DamageResultAppliedModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultAppliedModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageResultAppliedModifiersItemType(v) {
	case DamageResultAppliedModifiersItemTypeCriticalHit:
		*s = DamageResultAppliedModifiersItemTypeCriticalHit
	case DamageResultAppliedModifiersItemTypeWeakSpot:
		*s = DamageResultAppliedModifiersItemTypeWeakSpot
	case DamageResultAppliedModifiersItemTypeArmorReduction:
		*s = DamageResultAppliedModifiersItemTypeArmorReduction
	case DamageResultAppliedModifiersItemTypeElementalBonus:
		*s = DamageResultAppliedModifiersItemTypeElementalBonus
	case DamageResultAppliedModifiersItemTypeImplantSynergy:
		*s = DamageResultAppliedModifiersItemTypeImplantSynergy
	case DamageResultAppliedModifiersItemTypeEnvironmental:
		*s = DamageResultAppliedModifiersItemTypeEnvironmental
	case DamageResultAppliedModifiersItemTypeBackstab:
		*s = DamageResultAppliedModifiersItemTypeBackstab
	default:
		*s = DamageResultAppliedModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageResultAppliedModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultAppliedModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResultDamageBreakdownItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResultDamageBreakdownItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("amount")
		e.Int32(s.Amount)
	}
}

var jsonFieldsNameOfDamageResultDamageBreakdownItem = [2]string{
	0: "type",
	1: "amount",
}

// Decode decodes DamageResultDamageBreakdownItem from json.
func (s *DamageResultDamageBreakdownItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultDamageBreakdownItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Amount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResultDamageBreakdownItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageResultDamageBreakdownItem) {
					name = jsonFieldsNameOfDamageResultDamageBreakdownItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResultDamageBreakdownItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultDamageBreakdownItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultDamageBreakdownItemType as json.
func (s DamageResultDamageBreakdownItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageResultDamageBreakdownItemType from json.
func (s *DamageResultDamageBreakdownItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultDamageBreakdownItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageResultDamageBreakdownItemType(v) {
	case DamageResultDamageBreakdownItemTypeBaseDamage:
		*s = DamageResultDamageBreakdownItemTypeBaseDamage
	case DamageResultDamageBreakdownItemTypeCriticalBonus:
		*s = DamageResultDamageBreakdownItemTypeCriticalBonus
	case DamageResultDamageBreakdownItemTypeWeakSpotBonus:
		*s = DamageResultDamageBreakdownItemTypeWeakSpotBonus
	case DamageResultDamageBreakdownItemTypeArmorPenetration:
		*s = DamageResultDamageBreakdownItemTypeArmorPenetration
	case DamageResultDamageBreakdownItemTypeElementalDamage:
		*s = DamageResultDamageBreakdownItemTypeElementalDamage
	case DamageResultDamageBreakdownItemTypeSynergyBonus:
		*s = DamageResultDamageBreakdownItemTypeSynergyBonus
	case DamageResultDamageBreakdownItemTypeEnvironmentalModifier:
		*s = DamageResultDamageBreakdownItemTypeEnvironmentalModifier
	default:
		*s = DamageResultDamageBreakdownItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageResultDamageBreakdownItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultDamageBreakdownItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResultDamageComponent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResultDamageComponent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("amount")
		e.Int32(s.Amount)
	}
}

var jsonFieldsNameOfDamageResultDamageComponent = [2]string{
	0: "type",
	1: "amount",
}

// Decode decodes DamageResultDamageComponent from json.
func (s *DamageResultDamageComponent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultDamageComponent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Amount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResultDamageComponent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageResultDamageComponent) {
					name = jsonFieldsNameOfDamageResultDamageComponent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResultDamageComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultDamageComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultDamageComponentType as json.
func (s DamageResultDamageComponentType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageResultDamageComponentType from json.
func (s *DamageResultDamageComponentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultDamageComponentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageResultDamageComponentType(v) {
	case DamageResultDamageComponentTypeBaseDamage:
		*s = DamageResultDamageComponentTypeBaseDamage
	case DamageResultDamageComponentTypeCriticalBonus:
		*s = DamageResultDamageComponentTypeCriticalBonus
	case DamageResultDamageComponentTypeWeakSpotBonus:
		*s = DamageResultDamageComponentTypeWeakSpotBonus
	case DamageResultDamageComponentTypeArmorPenetration:
		*s = DamageResultDamageComponentTypeArmorPenetration
	case DamageResultDamageComponentTypeElementalDamage:
		*s = DamageResultDamageComponentTypeElementalDamage
	case DamageResultDamageComponentTypeSynergyBonus:
		*s = DamageResultDamageComponentTypeSynergyBonus
	case DamageResultDamageComponentTypeEnvironmentalModifier:
		*s = DamageResultDamageComponentTypeEnvironmentalModifier
	default:
		*s = DamageResultDamageComponentType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageResultDamageComponentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultDamageComponentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultDamageType as json.
func (s DamageResultDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageResultDamageType from json.
func (s *DamageResultDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageResultDamageType(v) {
	case DamageResultDamageTypePhysical:
		*s = DamageResultDamageTypePhysical
	case DamageResultDamageTypeFire:
		*s = DamageResultDamageTypeFire
	case DamageResultDamageTypeCold:
		*s = DamageResultDamageTypeCold
	case DamageResultDamageTypeLightning:
		*s = DamageResultDamageTypeLightning
	case DamageResultDamageTypePoison:
		*s = DamageResultDamageTypePoison
	case DamageResultDamageTypeCyber:
		*s = DamageResultDamageTypeCyber
	case DamageResultDamageTypeRadiation:
		*s = DamageResultDamageTypeRadiation
	case DamageResultDamageTypeExplosive:
		*s = DamageResultDamageTypeExplosive
	default:
		*s = DamageResultDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageResultDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageResultTargetStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageResultTargetStats) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentHp.Set {
			e.FieldStart("current_hp")
			s.CurrentHp.Encode(e)
		}
	}
	{
		if s.MaxHp.Set {
			e.FieldStart("max_hp")
			s.MaxHp.Encode(e)
		}
	}
	{
		if s.ArmorRating.Set {
			e.FieldStart("armor_rating")
			s.ArmorRating.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageResultTargetStats = [3]string{
	0: "current_hp",
	1: "max_hp",
	2: "armor_rating",
}

// Decode decodes DamageResultTargetStats from json.
func (s *DamageResultTargetStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageResultTargetStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_hp":
			if err := func() error {
				s.CurrentHp.Reset()
				if err := s.CurrentHp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_hp\"")
			}
		case "max_hp":
			if err := func() error {
				s.MaxHp.Reset()
				if err := s.MaxHp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "armor_rating":
			if err := func() error {
				s.ArmorRating.Reset()
				if err := s.ArmorRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_rating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageResultTargetStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageResultTargetStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageResultTargetStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.ClientModifiers != nil {
			e.FieldStart("client_modifiers")
			e.ArrStart()
			for _, elem := range s.ClientModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("reported_damage")
		e.Int32(s.ReportedDamage)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.SequenceNumber.Set {
			e.FieldStart("sequence_number")
			s.SequenceNumber.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.WeaponHash.Set {
			e.FieldStart("weapon_hash")
			s.WeaponHash.Encode(e)
		}
	}
	{
		if s.PositionData.Set {
			e.FieldStart("position_data")
			s.PositionData.Encode(e)
		}
	}
	{
		if s.WasCritical.Set {
			e.FieldStart("was_critical")
			s.WasCritical.Encode(e)
		}
	}
	{
		if s.WasHeadshot.Set {
			e.FieldStart("was_headshot")
			s.WasHeadshot.Encode(e)
		}
	}
	{
		if s.ClientModifier.Set {
			e.FieldStart("ClientModifier")
			s.ClientModifier.Encode(e)
		}
	}
	{
		if s.Vector3.Set {
			e.FieldStart("Vector3")
			s.Vector3.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationRequest = [14]string{
	0:  "session_id",
	1:  "attacker_id",
	2:  "target_id",
	3:  "client_modifiers",
	4:  "reported_damage",
	5:  "timestamp",
	6:  "sequence_number",
	7:  "damage_type",
	8:  "weapon_hash",
	9:  "position_data",
	10: "was_critical",
	11: "was_headshot",
	12: "ClientModifier",
	13: "Vector3",
}

// Decode decodes DamageValidationRequest from json.
func (s *DamageValidationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "attacker_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "client_modifiers":
			if err := func() error {
				s.ClientModifiers = make([]DamageValidationRequestClientModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationRequestClientModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClientModifiers = append(s.ClientModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_modifiers\"")
			}
		case "reported_damage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.ReportedDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_damage\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "sequence_number":
			if err := func() error {
				s.SequenceNumber.Reset()
				if err := s.SequenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sequence_number\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "weapon_hash":
			if err := func() error {
				s.WeaponHash.Reset()
				if err := s.WeaponHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_hash\"")
			}
		case "position_data":
			if err := func() error {
				s.PositionData.Reset()
				if err := s.PositionData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position_data\"")
			}
		case "was_critical":
			if err := func() error {
				s.WasCritical.Reset()
				if err := s.WasCritical.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "was_headshot":
			if err := func() error {
				s.WasHeadshot.Reset()
				if err := s.WasHeadshot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_headshot\"")
			}
		case "ClientModifier":
			if err := func() error {
				s.ClientModifier.Reset()
				if err := s.ClientModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ClientModifier\"")
			}
		case "Vector3":
			if err := func() error {
				s.Vector3.Reset()
				if err := s.Vector3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Vector3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10010111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequest) {
					name = jsonFieldsNameOfDamageValidationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestClientModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestClientModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageValidationRequestClientModifier = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageValidationRequestClientModifier from json.
func (s *DamageValidationRequestClientModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestClientModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestClientModifier) {
					name = jsonFieldsNameOfDamageValidationRequestClientModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestClientModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestClientModifierType as json.
func (s DamageValidationRequestClientModifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationRequestClientModifierType from json.
func (s *DamageValidationRequestClientModifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationRequestClientModifierType(v) {
	case DamageValidationRequestClientModifierTypeCriticalMultiplier:
		*s = DamageValidationRequestClientModifierTypeCriticalMultiplier
	case DamageValidationRequestClientModifierTypeRangeModifier:
		*s = DamageValidationRequestClientModifierTypeRangeModifier
	case DamageValidationRequestClientModifierTypeWeakSpotBonus:
		*s = DamageValidationRequestClientModifierTypeWeakSpotBonus
	case DamageValidationRequestClientModifierTypeArmorPenetration:
		*s = DamageValidationRequestClientModifierTypeArmorPenetration
	case DamageValidationRequestClientModifierTypeElementalDamage:
		*s = DamageValidationRequestClientModifierTypeElementalDamage
	default:
		*s = DamageValidationRequestClientModifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationRequestClientModifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestClientModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestClientModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageValidationRequestClientModifiersItem = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageValidationRequestClientModifiersItem from json.
func (s *DamageValidationRequestClientModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestClientModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestClientModifiersItem) {
					name = jsonFieldsNameOfDamageValidationRequestClientModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestClientModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestClientModifiersItemType as json.
func (s DamageValidationRequestClientModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationRequestClientModifiersItemType from json.
func (s *DamageValidationRequestClientModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationRequestClientModifiersItemType(v) {
	case DamageValidationRequestClientModifiersItemTypeCriticalMultiplier:
		*s = DamageValidationRequestClientModifiersItemTypeCriticalMultiplier
	case DamageValidationRequestClientModifiersItemTypeRangeModifier:
		*s = DamageValidationRequestClientModifiersItemTypeRangeModifier
	case DamageValidationRequestClientModifiersItemTypeWeakSpotBonus:
		*s = DamageValidationRequestClientModifiersItemTypeWeakSpotBonus
	case DamageValidationRequestClientModifiersItemTypeArmorPenetration:
		*s = DamageValidationRequestClientModifiersItemTypeArmorPenetration
	case DamageValidationRequestClientModifiersItemTypeElementalDamage:
		*s = DamageValidationRequestClientModifiersItemTypeElementalDamage
	default:
		*s = DamageValidationRequestClientModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationRequestClientModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestDamageType as json.
func (s DamageValidationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationRequestDamageType from json.
func (s *DamageValidationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationRequestDamageType(v) {
	case DamageValidationRequestDamageTypePhysical:
		*s = DamageValidationRequestDamageTypePhysical
	case DamageValidationRequestDamageTypeFire:
		*s = DamageValidationRequestDamageTypeFire
	case DamageValidationRequestDamageTypeCold:
		*s = DamageValidationRequestDamageTypeCold
	case DamageValidationRequestDamageTypeLightning:
		*s = DamageValidationRequestDamageTypeLightning
	case DamageValidationRequestDamageTypePoison:
		*s = DamageValidationRequestDamageTypePoison
	case DamageValidationRequestDamageTypeCyber:
		*s = DamageValidationRequestDamageTypeCyber
	case DamageValidationRequestDamageTypeRadiation:
		*s = DamageValidationRequestDamageTypeRadiation
	case DamageValidationRequestDamageTypeExplosive:
		*s = DamageValidationRequestDamageTypeExplosive
	default:
		*s = DamageValidationRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_pos")
		s.AttackerPos.Encode(e)
	}
	{
		e.FieldStart("target_pos")
		s.TargetPos.Encode(e)
	}
	{
		if s.AttackerYaw.Set {
			e.FieldStart("attacker_yaw")
			s.AttackerYaw.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionData = [3]string{
	0: "attacker_pos",
	1: "target_pos",
	2: "attacker_yaw",
}

// Decode decodes DamageValidationRequestPositionData from json.
func (s *DamageValidationRequestPositionData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_pos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AttackerPos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_pos\"")
			}
		case "target_pos":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TargetPos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_pos\"")
			}
		case "attacker_yaw":
			if err := func() error {
				s.AttackerYaw.Reset()
				if err := s.AttackerYaw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_yaw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionData) {
					name = jsonFieldsNameOfDamageValidationRequestPositionData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionDataAttackerPos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes DamageValidationRequestPositionDataAttackerPos from json.
func (s *DamageValidationRequestPositionDataAttackerPos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionDataAttackerPos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionDataAttackerPos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos) {
					name = jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionDataTargetPos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionDataTargetPos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes DamageValidationRequestPositionDataTargetPos from json.
func (s *DamageValidationRequestPositionDataTargetPos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionDataTargetPos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionDataTargetPos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos) {
					name = jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionDataTargetPos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionDataTargetPos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestVector3) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestVector3) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfDamageValidationRequestVector3 = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes DamageValidationRequestVector3 from json.
func (s *DamageValidationRequestVector3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestVector3 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestVector3")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestVector3) {
					name = jsonFieldsNameOfDamageValidationRequestVector3[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestVector3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestVector3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		if s.ValidationIssues != nil {
			e.FieldStart("validation_issues")
			e.ArrStart()
			for _, elem := range s.ValidationIssues {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("server_calculated_damage")
		e.Int32(s.ServerCalculatedDamage)
	}
	{
		e.FieldStart("validation_score")
		e.Int32(s.ValidationScore)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
	{
		if s.CorrectedValues.Set {
			e.FieldStart("corrected_values")
			s.CorrectedValues.Encode(e)
		}
	}
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
	{
		if s.RequiresServerCorrection.Set {
			e.FieldStart("requires_server_correction")
			s.RequiresServerCorrection.Encode(e)
		}
	}
	{
		if s.FlaggedForReview.Set {
			e.FieldStart("flagged_for_review")
			s.FlaggedForReview.Encode(e)
		}
	}
	{
		if s.ValidationIssue.Set {
			e.FieldStart("ValidationIssue")
			s.ValidationIssue.Encode(e)
		}
	}
	{
		if s.CorrectedModifier.Set {
			e.FieldStart("CorrectedModifier")
			s.CorrectedModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResult = [13]string{
	0:  "session_id",
	1:  "validation_issues",
	2:  "server_calculated_damage",
	3:  "validation_score",
	4:  "timestamp",
	5:  "processing_time_ns",
	6:  "validation_status",
	7:  "corrected_values",
	8:  "is_valid",
	9:  "requires_server_correction",
	10: "flagged_for_review",
	11: "ValidationIssue",
	12: "CorrectedModifier",
}

// Decode decodes DamageValidationResult from json.
func (s *DamageValidationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "validation_issues":
			if err := func() error {
				s.ValidationIssues = make([]DamageValidationResultValidationIssuesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationResultValidationIssuesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ValidationIssues = append(s.ValidationIssues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_issues\"")
			}
		case "server_calculated_damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.ServerCalculatedDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_calculated_damage\"")
			}
		case "validation_score":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.ValidationScore = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_score\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		case "corrected_values":
			if err := func() error {
				s.CorrectedValues.Reset()
				if err := s.CorrectedValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_values\"")
			}
		case "is_valid":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "requires_server_correction":
			if err := func() error {
				s.RequiresServerCorrection.Reset()
				if err := s.RequiresServerCorrection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_server_correction\"")
			}
		case "flagged_for_review":
			if err := func() error {
				s.FlaggedForReview.Reset()
				if err := s.FlaggedForReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flagged_for_review\"")
			}
		case "ValidationIssue":
			if err := func() error {
				s.ValidationIssue.Reset()
				if err := s.ValidationIssue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ValidationIssue\"")
			}
		case "CorrectedModifier":
			if err := func() error {
				s.CorrectedModifier.Reset()
				if err := s.CorrectedModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CorrectedModifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001101,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResult) {
					name = jsonFieldsNameOfDamageValidationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultCorrectedModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultCorrectedModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("correct_value")
		e.Float32(s.CorrectValue)
	}
	{
		if s.ReportedValue.Set {
			e.FieldStart("reported_value")
			s.ReportedValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultCorrectedModifier = [3]string{
	0: "type",
	1: "correct_value",
	2: "reported_value",
}

// Decode decodes DamageValidationResultCorrectedModifier from json.
func (s *DamageValidationResultCorrectedModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultCorrectedModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "correct_value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CorrectValue = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_value\"")
			}
		case "reported_value":
			if err := func() error {
				s.ReportedValue.Reset()
				if err := s.ReportedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultCorrectedModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultCorrectedModifier) {
					name = jsonFieldsNameOfDamageValidationResultCorrectedModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultCorrectedModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultCorrectedModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultCorrectedValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultCorrectedValues) encodeFields(e *jx.Encoder) {
	{
		if s.CorrectedDamage.Set {
			e.FieldStart("corrected_damage")
			s.CorrectedDamage.Encode(e)
		}
	}
	{
		if s.CorrectedModifiers != nil {
			e.FieldStart("corrected_modifiers")
			e.ArrStart()
			for _, elem := range s.CorrectedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDamageValidationResultCorrectedValues = [2]string{
	0: "corrected_damage",
	1: "corrected_modifiers",
}

// Decode decodes DamageValidationResultCorrectedValues from json.
func (s *DamageValidationResultCorrectedValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultCorrectedValues to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "corrected_damage":
			if err := func() error {
				s.CorrectedDamage.Reset()
				if err := s.CorrectedDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_damage\"")
			}
		case "corrected_modifiers":
			if err := func() error {
				s.CorrectedModifiers = make([]DamageValidationResultCorrectedValuesCorrectedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationResultCorrectedValuesCorrectedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CorrectedModifiers = append(s.CorrectedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultCorrectedValues")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultCorrectedValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultCorrectedValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("correct_value")
		e.Float32(s.CorrectValue)
	}
	{
		if s.ReportedValue.Set {
			e.FieldStart("reported_value")
			s.ReportedValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem = [3]string{
	0: "type",
	1: "correct_value",
	2: "reported_value",
}

// Decode decodes DamageValidationResultCorrectedValuesCorrectedModifiersItem from json.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultCorrectedValuesCorrectedModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "correct_value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CorrectValue = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_value\"")
			}
		case "reported_value":
			if err := func() error {
				s.ReportedValue.Reset()
				if err := s.ReportedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultCorrectedValuesCorrectedModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem) {
					name = jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultValidationIssue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultValidationIssue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("issue_type")
		s.IssueType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.EvidenceValue.Set {
			e.FieldStart("evidence_value")
			s.EvidenceValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultValidationIssue = [4]string{
	0: "issue_type",
	1: "severity",
	2: "description",
	3: "evidence_value",
}

// Decode decodes DamageValidationResultValidationIssue from json.
func (s *DamageValidationResultValidationIssue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issue_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IssueType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "evidence_value":
			if err := func() error {
				s.EvidenceValue.Reset()
				if err := s.EvidenceValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultValidationIssue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultValidationIssue) {
					name = jsonFieldsNameOfDamageValidationResultValidationIssue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultValidationIssue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssueIssueType as json.
func (s DamageValidationResultValidationIssueIssueType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssueIssueType from json.
func (s *DamageValidationResultValidationIssueIssueType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssueIssueType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssueIssueType(v) {
	case DamageValidationResultValidationIssueIssueTypeDamageMismatch:
		*s = DamageValidationResultValidationIssueIssueTypeDamageMismatch
	case DamageValidationResultValidationIssueIssueTypeInvalidModifier:
		*s = DamageValidationResultValidationIssueIssueTypeInvalidModifier
	case DamageValidationResultValidationIssueIssueTypeLineOfSightBlocked:
		*s = DamageValidationResultValidationIssueIssueTypeLineOfSightBlocked
	case DamageValidationResultValidationIssueIssueTypeImpossibleTiming:
		*s = DamageValidationResultValidationIssueIssueTypeImpossibleTiming
	case DamageValidationResultValidationIssueIssueTypeSuspiciousPattern:
		*s = DamageValidationResultValidationIssueIssueTypeSuspiciousPattern
	case DamageValidationResultValidationIssueIssueTypeWeaponHashMismatch:
		*s = DamageValidationResultValidationIssueIssueTypeWeaponHashMismatch
	case DamageValidationResultValidationIssueIssueTypePositionInconsistency:
		*s = DamageValidationResultValidationIssueIssueTypePositionInconsistency
	default:
		*s = DamageValidationResultValidationIssueIssueType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssueIssueType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssueIssueType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssueSeverity as json.
func (s DamageValidationResultValidationIssueSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssueSeverity from json.
func (s *DamageValidationResultValidationIssueSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssueSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssueSeverity(v) {
	case DamageValidationResultValidationIssueSeverityLow:
		*s = DamageValidationResultValidationIssueSeverityLow
	case DamageValidationResultValidationIssueSeverityMedium:
		*s = DamageValidationResultValidationIssueSeverityMedium
	case DamageValidationResultValidationIssueSeverityHigh:
		*s = DamageValidationResultValidationIssueSeverityHigh
	case DamageValidationResultValidationIssueSeverityCritical:
		*s = DamageValidationResultValidationIssueSeverityCritical
	default:
		*s = DamageValidationResultValidationIssueSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssueSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssueSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultValidationIssuesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultValidationIssuesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("issue_type")
		s.IssueType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.EvidenceValue.Set {
			e.FieldStart("evidence_value")
			s.EvidenceValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultValidationIssuesItem = [4]string{
	0: "issue_type",
	1: "severity",
	2: "description",
	3: "evidence_value",
}

// Decode decodes DamageValidationResultValidationIssuesItem from json.
func (s *DamageValidationResultValidationIssuesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issue_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IssueType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "evidence_value":
			if err := func() error {
				s.EvidenceValue.Reset()
				if err := s.EvidenceValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultValidationIssuesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultValidationIssuesItem) {
					name = jsonFieldsNameOfDamageValidationResultValidationIssuesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultValidationIssuesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssuesItemIssueType as json.
func (s DamageValidationResultValidationIssuesItemIssueType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssuesItemIssueType from json.
func (s *DamageValidationResultValidationIssuesItemIssueType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItemIssueType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssuesItemIssueType(v) {
	case DamageValidationResultValidationIssuesItemIssueTypeDamageMismatch:
		*s = DamageValidationResultValidationIssuesItemIssueTypeDamageMismatch
	case DamageValidationResultValidationIssuesItemIssueTypeInvalidModifier:
		*s = DamageValidationResultValidationIssuesItemIssueTypeInvalidModifier
	case DamageValidationResultValidationIssuesItemIssueTypeLineOfSightBlocked:
		*s = DamageValidationResultValidationIssuesItemIssueTypeLineOfSightBlocked
	case DamageValidationResultValidationIssuesItemIssueTypeImpossibleTiming:
		*s = DamageValidationResultValidationIssuesItemIssueTypeImpossibleTiming
	case DamageValidationResultValidationIssuesItemIssueTypeSuspiciousPattern:
		*s = DamageValidationResultValidationIssuesItemIssueTypeSuspiciousPattern
	case DamageValidationResultValidationIssuesItemIssueTypeWeaponHashMismatch:
		*s = DamageValidationResultValidationIssuesItemIssueTypeWeaponHashMismatch
	case DamageValidationResultValidationIssuesItemIssueTypePositionInconsistency:
		*s = DamageValidationResultValidationIssuesItemIssueTypePositionInconsistency
	default:
		*s = DamageValidationResultValidationIssuesItemIssueType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssuesItemIssueType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItemIssueType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssuesItemSeverity as json.
func (s DamageValidationResultValidationIssuesItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssuesItemSeverity from json.
func (s *DamageValidationResultValidationIssuesItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssuesItemSeverity(v) {
	case DamageValidationResultValidationIssuesItemSeverityLow:
		*s = DamageValidationResultValidationIssuesItemSeverityLow
	case DamageValidationResultValidationIssuesItemSeverityMedium:
		*s = DamageValidationResultValidationIssuesItemSeverityMedium
	case DamageValidationResultValidationIssuesItemSeverityHigh:
		*s = DamageValidationResultValidationIssuesItemSeverityHigh
	case DamageValidationResultValidationIssuesItemSeverityCritical:
		*s = DamageValidationResultValidationIssuesItemSeverityCritical
	default:
		*s = DamageValidationResultValidationIssuesItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssuesItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationStatus as json.
func (s DamageValidationResultValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationStatus from json.
func (s *DamageValidationResultValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationStatus(v) {
	case DamageValidationResultValidationStatusValid:
		*s = DamageValidationResultValidationStatusValid
	case DamageValidationResultValidationStatusSuspicious:
		*s = DamageValidationResultValidationStatusSuspicious
	case DamageValidationResultValidationStatusInvalid:
		*s = DamageValidationResultValidationStatusInvalid
	case DamageValidationResultValidationStatusRequiresReview:
		*s = DamageValidationResultValidationStatusRequiresReview
	default:
		*s = DamageValidationResultValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("effects")
		e.ArrStart()
		for _, elem := range s.Effects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.SourceType.Set {
			e.FieldStart("source_type")
			s.SourceType.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.OverrideExisting.Set {
			e.FieldStart("override_existing")
			s.OverrideExisting.Encode(e)
		}
	}
	{
		if s.StackEffects.Set {
			e.FieldStart("stack_effects")
			s.StackEffects.Encode(e)
		}
	}
	{
		if s.CombatEffect.Set {
			e.FieldStart("CombatEffect")
			s.CombatEffect.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsRequest = [9]string{
	0: "participant_id",
	1: "effects",
	2: "session_id",
	3: "timestamp",
	4: "source_type",
	5: "context",
	6: "override_existing",
	7: "stack_effects",
	8: "CombatEffect",
}

// Decode decodes EffectsRequest from json.
func (s *EffectsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Effects = make([]EffectsRequestEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EffectsRequestEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "source_type":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_type\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "override_existing":
			if err := func() error {
				s.OverrideExisting.Reset()
				if err := s.OverrideExisting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_existing\"")
			}
		case "stack_effects":
			if err := func() error {
				s.StackEffects.Reset()
				if err := s.StackEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack_effects\"")
			}
		case "CombatEffect":
			if err := func() error {
				s.CombatEffect.Reset()
				if err := s.CombatEffect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CombatEffect\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsRequest) {
					name = jsonFieldsNameOfEffectsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsRequestCombatEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsRequestCombatEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsRequestCombatEffect = [5]string{
	0: "effect_type",
	1: "duration_ms",
	2: "source_id",
	3: "intensity",
	4: "stacks",
}

// Decode decodes EffectsRequestCombatEffect from json.
func (s *EffectsRequestCombatEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestCombatEffect to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsRequestCombatEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsRequestCombatEffect) {
					name = jsonFieldsNameOfEffectsRequestCombatEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsRequestCombatEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestCombatEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestCombatEffectEffectType as json.
func (s EffectsRequestCombatEffectEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsRequestCombatEffectEffectType from json.
func (s *EffectsRequestCombatEffectEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestCombatEffectEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsRequestCombatEffectEffectType(v) {
	case EffectsRequestCombatEffectEffectTypeBuffDamage:
		*s = EffectsRequestCombatEffectEffectTypeBuffDamage
	case EffectsRequestCombatEffectEffectTypeDebuffDamageReduction:
		*s = EffectsRequestCombatEffectEffectTypeDebuffDamageReduction
	case EffectsRequestCombatEffectEffectTypeBuffSpeed:
		*s = EffectsRequestCombatEffectEffectTypeBuffSpeed
	case EffectsRequestCombatEffectEffectTypeDebuffSlow:
		*s = EffectsRequestCombatEffectEffectTypeDebuffSlow
	case EffectsRequestCombatEffectEffectTypeBuffRegeneration:
		*s = EffectsRequestCombatEffectEffectTypeBuffRegeneration
	case EffectsRequestCombatEffectEffectTypeDebuffPoison:
		*s = EffectsRequestCombatEffectEffectTypeDebuffPoison
	case EffectsRequestCombatEffectEffectTypeBuffShield:
		*s = EffectsRequestCombatEffectEffectTypeBuffShield
	case EffectsRequestCombatEffectEffectTypeDebuffStun:
		*s = EffectsRequestCombatEffectEffectTypeDebuffStun
	case EffectsRequestCombatEffectEffectTypeBuffCriticalChance:
		*s = EffectsRequestCombatEffectEffectTypeBuffCriticalChance
	case EffectsRequestCombatEffectEffectTypeDebuffAccuracyReduction:
		*s = EffectsRequestCombatEffectEffectTypeDebuffAccuracyReduction
	default:
		*s = EffectsRequestCombatEffectEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsRequestCombatEffectEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestCombatEffectEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsRequestContext) encodeFields(e *jx.Encoder) {
	{
		if s.AreaID.Set {
			e.FieldStart("area_id")
			s.AreaID.Encode(e)
		}
	}
	{
		if s.WeatherConditions.Set {
			e.FieldStart("weather_conditions")
			s.WeatherConditions.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsRequestContext = [2]string{
	0: "area_id",
	1: "weather_conditions",
}

// Decode decodes EffectsRequestContext from json.
func (s *EffectsRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "area_id":
			if err := func() error {
				s.AreaID.Reset()
				if err := s.AreaID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"area_id\"")
			}
		case "weather_conditions":
			if err := func() error {
				s.WeatherConditions.Reset()
				if err := s.WeatherConditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestContextWeatherConditions as json.
func (s EffectsRequestContextWeatherConditions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsRequestContextWeatherConditions from json.
func (s *EffectsRequestContextWeatherConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestContextWeatherConditions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsRequestContextWeatherConditions(v) {
	case EffectsRequestContextWeatherConditionsClear:
		*s = EffectsRequestContextWeatherConditionsClear
	case EffectsRequestContextWeatherConditionsRain:
		*s = EffectsRequestContextWeatherConditionsRain
	case EffectsRequestContextWeatherConditionsStorm:
		*s = EffectsRequestContextWeatherConditionsStorm
	case EffectsRequestContextWeatherConditionsFog:
		*s = EffectsRequestContextWeatherConditionsFog
	default:
		*s = EffectsRequestContextWeatherConditions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsRequestContextWeatherConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestContextWeatherConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsRequestEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsRequestEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsRequestEffectsItem = [5]string{
	0: "effect_type",
	1: "duration_ms",
	2: "source_id",
	3: "intensity",
	4: "stacks",
}

// Decode decodes EffectsRequestEffectsItem from json.
func (s *EffectsRequestEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestEffectsItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsRequestEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsRequestEffectsItem) {
					name = jsonFieldsNameOfEffectsRequestEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsRequestEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestEffectsItemEffectType as json.
func (s EffectsRequestEffectsItemEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsRequestEffectsItemEffectType from json.
func (s *EffectsRequestEffectsItemEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestEffectsItemEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsRequestEffectsItemEffectType(v) {
	case EffectsRequestEffectsItemEffectTypeBuffDamage:
		*s = EffectsRequestEffectsItemEffectTypeBuffDamage
	case EffectsRequestEffectsItemEffectTypeDebuffDamageReduction:
		*s = EffectsRequestEffectsItemEffectTypeDebuffDamageReduction
	case EffectsRequestEffectsItemEffectTypeBuffSpeed:
		*s = EffectsRequestEffectsItemEffectTypeBuffSpeed
	case EffectsRequestEffectsItemEffectTypeDebuffSlow:
		*s = EffectsRequestEffectsItemEffectTypeDebuffSlow
	case EffectsRequestEffectsItemEffectTypeBuffRegeneration:
		*s = EffectsRequestEffectsItemEffectTypeBuffRegeneration
	case EffectsRequestEffectsItemEffectTypeDebuffPoison:
		*s = EffectsRequestEffectsItemEffectTypeDebuffPoison
	case EffectsRequestEffectsItemEffectTypeBuffShield:
		*s = EffectsRequestEffectsItemEffectTypeBuffShield
	case EffectsRequestEffectsItemEffectTypeDebuffStun:
		*s = EffectsRequestEffectsItemEffectTypeDebuffStun
	case EffectsRequestEffectsItemEffectTypeBuffCriticalChance:
		*s = EffectsRequestEffectsItemEffectTypeBuffCriticalChance
	case EffectsRequestEffectsItemEffectTypeDebuffAccuracyReduction:
		*s = EffectsRequestEffectsItemEffectTypeDebuffAccuracyReduction
	default:
		*s = EffectsRequestEffectsItemEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsRequestEffectsItemEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestEffectsItemEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestSourceType as json.
func (s EffectsRequestSourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsRequestSourceType from json.
func (s *EffectsRequestSourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsRequestSourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsRequestSourceType(v) {
	case EffectsRequestSourceTypeWeapon:
		*s = EffectsRequestSourceTypeWeapon
	case EffectsRequestSourceTypeAbility:
		*s = EffectsRequestSourceTypeAbility
	case EffectsRequestSourceTypeImplant:
		*s = EffectsRequestSourceTypeImplant
	case EffectsRequestSourceTypeEnvironmental:
		*s = EffectsRequestSourceTypeEnvironmental
	case EffectsRequestSourceTypeStatusEffect:
		*s = EffectsRequestSourceTypeStatusEffect
	default:
		*s = EffectsRequestSourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsRequestSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsRequestSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("applied_effects")
		e.ArrStart()
		for _, elem := range s.AppliedEffects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RejectedEffects != nil {
			e.FieldStart("rejected_effects")
			e.ArrStart()
			for _, elem := range s.RejectedEffects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.AppliedEffectInfo.Set {
			e.FieldStart("AppliedEffectInfo")
			s.AppliedEffectInfo.Encode(e)
		}
	}
	{
		if s.RejectedEffectInfo.Set {
			e.FieldStart("RejectedEffectInfo")
			s.RejectedEffectInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsResult = [10]string{
	0: "participant_id",
	1: "applied_effects",
	2: "rejected_effects",
	3: "timestamp",
	4: "processing_time_ns",
	5: "status",
	6: "summary",
	7: "success",
	8: "AppliedEffectInfo",
	9: "RejectedEffectInfo",
}

// Decode decodes EffectsResult from json.
func (s *EffectsResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "applied_effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.AppliedEffects = make([]EffectsResultAppliedEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EffectsResultAppliedEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AppliedEffects = append(s.AppliedEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_effects\"")
			}
		case "rejected_effects":
			if err := func() error {
				s.RejectedEffects = make([]EffectsResultRejectedEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EffectsResultRejectedEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RejectedEffects = append(s.RejectedEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejected_effects\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "AppliedEffectInfo":
			if err := func() error {
				s.AppliedEffectInfo.Reset()
				if err := s.AppliedEffectInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AppliedEffectInfo\"")
			}
		case "RejectedEffectInfo":
			if err := func() error {
				s.RejectedEffectInfo.Reset()
				if err := s.RejectedEffectInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RejectedEffectInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsResult) {
					name = jsonFieldsNameOfEffectsResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResultAppliedEffectInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResultAppliedEffectInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsResultAppliedEffectInfo = [4]string{
	0: "effect_type",
	1: "effect_id",
	2: "duration_ms",
	3: "stacks",
}

// Decode decodes EffectsResultAppliedEffectInfo from json.
func (s *EffectsResultAppliedEffectInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultAppliedEffectInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "effect_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResultAppliedEffectInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsResultAppliedEffectInfo) {
					name = jsonFieldsNameOfEffectsResultAppliedEffectInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResultAppliedEffectInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultAppliedEffectInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResultAppliedEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResultAppliedEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsResultAppliedEffectsItem = [4]string{
	0: "effect_type",
	1: "effect_id",
	2: "duration_ms",
	3: "stacks",
}

// Decode decodes EffectsResultAppliedEffectsItem from json.
func (s *EffectsResultAppliedEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultAppliedEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "effect_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResultAppliedEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsResultAppliedEffectsItem) {
					name = jsonFieldsNameOfEffectsResultAppliedEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResultAppliedEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultAppliedEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResultRejectedEffectInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResultRejectedEffectInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfEffectsResultRejectedEffectInfo = [2]string{
	0: "effect_type",
	1: "reason",
}

// Decode decodes EffectsResultRejectedEffectInfo from json.
func (s *EffectsResultRejectedEffectInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultRejectedEffectInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResultRejectedEffectInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsResultRejectedEffectInfo) {
					name = jsonFieldsNameOfEffectsResultRejectedEffectInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResultRejectedEffectInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultRejectedEffectInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultRejectedEffectInfoReason as json.
func (s EffectsResultRejectedEffectInfoReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsResultRejectedEffectInfoReason from json.
func (s *EffectsResultRejectedEffectInfoReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultRejectedEffectInfoReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsResultRejectedEffectInfoReason(v) {
	case EffectsResultRejectedEffectInfoReasonEffectLimitReached:
		*s = EffectsResultRejectedEffectInfoReasonEffectLimitReached
	case EffectsResultRejectedEffectInfoReasonConflictingEffect:
		*s = EffectsResultRejectedEffectInfoReasonConflictingEffect
	case EffectsResultRejectedEffectInfoReasonInvalidParameters:
		*s = EffectsResultRejectedEffectInfoReasonInvalidParameters
	case EffectsResultRejectedEffectInfoReasonParticipantNotFound:
		*s = EffectsResultRejectedEffectInfoReasonParticipantNotFound
	case EffectsResultRejectedEffectInfoReasonEffectAlreadyActive:
		*s = EffectsResultRejectedEffectInfoReasonEffectAlreadyActive
	default:
		*s = EffectsResultRejectedEffectInfoReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsResultRejectedEffectInfoReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultRejectedEffectInfoReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResultRejectedEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResultRejectedEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfEffectsResultRejectedEffectsItem = [2]string{
	0: "effect_type",
	1: "reason",
}

// Decode decodes EffectsResultRejectedEffectsItem from json.
func (s *EffectsResultRejectedEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultRejectedEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResultRejectedEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectsResultRejectedEffectsItem) {
					name = jsonFieldsNameOfEffectsResultRejectedEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResultRejectedEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultRejectedEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultRejectedEffectsItemReason as json.
func (s EffectsResultRejectedEffectsItemReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsResultRejectedEffectsItemReason from json.
func (s *EffectsResultRejectedEffectsItemReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultRejectedEffectsItemReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsResultRejectedEffectsItemReason(v) {
	case EffectsResultRejectedEffectsItemReasonEffectLimitReached:
		*s = EffectsResultRejectedEffectsItemReasonEffectLimitReached
	case EffectsResultRejectedEffectsItemReasonConflictingEffect:
		*s = EffectsResultRejectedEffectsItemReasonConflictingEffect
	case EffectsResultRejectedEffectsItemReasonInvalidParameters:
		*s = EffectsResultRejectedEffectsItemReasonInvalidParameters
	case EffectsResultRejectedEffectsItemReasonParticipantNotFound:
		*s = EffectsResultRejectedEffectsItemReasonParticipantNotFound
	case EffectsResultRejectedEffectsItemReasonEffectAlreadyActive:
		*s = EffectsResultRejectedEffectsItemReasonEffectAlreadyActive
	default:
		*s = EffectsResultRejectedEffectsItemReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsResultRejectedEffectsItemReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultRejectedEffectsItemReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultStatus as json.
func (s EffectsResultStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectsResultStatus from json.
func (s *EffectsResultStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectsResultStatus(v) {
	case EffectsResultStatusSuccess:
		*s = EffectsResultStatusSuccess
	case EffectsResultStatusPartialSuccess:
		*s = EffectsResultStatusPartialSuccess
	case EffectsResultStatusFailed:
		*s = EffectsResultStatusFailed
	default:
		*s = EffectsResultStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectsResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectsResultSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectsResultSummary) encodeFields(e *jx.Encoder) {
	{
		if s.TotalRequested.Set {
			e.FieldStart("total_requested")
			s.TotalRequested.Encode(e)
		}
	}
	{
		if s.SuccessfullyApplied.Set {
			e.FieldStart("successfully_applied")
			s.SuccessfullyApplied.Encode(e)
		}
	}
	{
		if s.RejectedCount.Set {
			e.FieldStart("rejected_count")
			s.RejectedCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectsResultSummary = [3]string{
	0: "total_requested",
	1: "successfully_applied",
	2: "rejected_count",
}

// Decode decodes EffectsResultSummary from json.
func (s *EffectsResultSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectsResultSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_requested":
			if err := func() error {
				s.TotalRequested.Reset()
				if err := s.TotalRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_requested\"")
			}
		case "successfully_applied":
			if err := func() error {
				s.SuccessfullyApplied.Reset()
				if err := s.SuccessfullyApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfully_applied\"")
			}
		case "rejected_count":
			if err := func() error {
				s.RejectedCount.Reset()
				if err := s.RejectedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejected_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectsResultSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectsResultSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectsResultSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
}

var jsonFieldsNameOfHealthResponse = [3]string{
	0: "version",
	1: "status",
	2: "timestamp",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsActiveEffect as json.
func (o OptActiveEffectsActiveEffect) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActiveEffectsActiveEffect from json.
func (o *OptActiveEffectsActiveEffect) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActiveEffectsActiveEffect to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActiveEffectsActiveEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActiveEffectsActiveEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsSummary as json.
func (o OptActiveEffectsSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActiveEffectsSummary from json.
func (o *OptActiveEffectsSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActiveEffectsSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActiveEffectsSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActiveEffectsSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestEnvironmentalModifiers as json.
func (o OptDamageRequestEnvironmentalModifiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRequestEnvironmentalModifiers from json.
func (o *OptDamageRequestEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRequestEnvironmentalModifiers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRequestEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRequestEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestImplantSynergy as json.
func (o OptDamageRequestImplantSynergy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRequestImplantSynergy from json.
func (o *OptDamageRequestImplantSynergy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRequestImplantSynergy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRequestImplantSynergy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRequestImplantSynergy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRequestWeaponModifier as json.
func (o OptDamageRequestWeaponModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRequestWeaponModifier from json.
func (o *OptDamageRequestWeaponModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRequestWeaponModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRequestWeaponModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRequestWeaponModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultAppliedModifier as json.
func (o OptDamageResultAppliedModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageResultAppliedModifier from json.
func (o *OptDamageResultAppliedModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageResultAppliedModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageResultAppliedModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageResultAppliedModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultDamageComponent as json.
func (o OptDamageResultDamageComponent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageResultDamageComponent from json.
func (o *OptDamageResultDamageComponent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageResultDamageComponent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageResultDamageComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageResultDamageComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageResultTargetStats as json.
func (o OptDamageResultTargetStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageResultTargetStats from json.
func (o *OptDamageResultTargetStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageResultTargetStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageResultTargetStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageResultTargetStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestClientModifier as json.
func (o OptDamageValidationRequestClientModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationRequestClientModifier from json.
func (o *OptDamageValidationRequestClientModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationRequestClientModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationRequestClientModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationRequestClientModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestPositionData as json.
func (o OptDamageValidationRequestPositionData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationRequestPositionData from json.
func (o *OptDamageValidationRequestPositionData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationRequestPositionData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationRequestPositionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationRequestPositionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestVector3 as json.
func (o OptDamageValidationRequestVector3) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationRequestVector3 from json.
func (o *OptDamageValidationRequestVector3) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationRequestVector3 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationRequestVector3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationRequestVector3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultCorrectedModifier as json.
func (o OptDamageValidationResultCorrectedModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationResultCorrectedModifier from json.
func (o *OptDamageValidationResultCorrectedModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultCorrectedModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultCorrectedModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultCorrectedModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultCorrectedValues as json.
func (o OptDamageValidationResultCorrectedValues) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationResultCorrectedValues from json.
func (o *OptDamageValidationResultCorrectedValues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultCorrectedValues to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultCorrectedValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultCorrectedValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssue as json.
func (o OptDamageValidationResultValidationIssue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationResultValidationIssue from json.
func (o *OptDamageValidationResultValidationIssue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultValidationIssue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultValidationIssue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultValidationIssue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationStatus as json.
func (o OptDamageValidationResultValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageValidationResultValidationStatus from json.
func (o *OptDamageValidationResultValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestCombatEffect as json.
func (o OptEffectsRequestCombatEffect) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectsRequestCombatEffect from json.
func (o *OptEffectsRequestCombatEffect) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsRequestCombatEffect to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsRequestCombatEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsRequestCombatEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestContext as json.
func (o OptEffectsRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectsRequestContext from json.
func (o *OptEffectsRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsRequestContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestContextWeatherConditions as json.
func (o OptEffectsRequestContextWeatherConditions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EffectsRequestContextWeatherConditions from json.
func (o *OptEffectsRequestContextWeatherConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsRequestContextWeatherConditions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsRequestContextWeatherConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsRequestContextWeatherConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsRequestSourceType as json.
func (o OptEffectsRequestSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EffectsRequestSourceType from json.
func (o *OptEffectsRequestSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsRequestSourceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsRequestSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsRequestSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultAppliedEffectInfo as json.
func (o OptEffectsResultAppliedEffectInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectsResultAppliedEffectInfo from json.
func (o *OptEffectsResultAppliedEffectInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsResultAppliedEffectInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsResultAppliedEffectInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsResultAppliedEffectInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultRejectedEffectInfo as json.
func (o OptEffectsResultRejectedEffectInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectsResultRejectedEffectInfo from json.
func (o *OptEffectsResultRejectedEffectInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsResultRejectedEffectInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsResultRejectedEffectInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsResultRejectedEffectInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultStatus as json.
func (o OptEffectsResultStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EffectsResultStatus from json.
func (o *OptEffectsResultStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsResultStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectsResultSummary as json.
func (o OptEffectsResultSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectsResultSummary from json.
func (o *OptEffectsResultSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectsResultSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectsResultSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectsResultSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
