// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActiveEffectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("effects")
		e.ArrStart()
		for _, elem := range s.Effects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("timestamp")
		e.Int64(s.Timestamp)
	}
	{
		if s.TotalEffects.Set {
			e.FieldStart("total_effects")
			s.TotalEffects.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.HasCriticalEffects.Set {
			e.FieldStart("has_critical_effects")
			s.HasCriticalEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsResponse = [6]string{
	0: "participant_id",
	1: "effects",
	2: "timestamp",
	3: "total_effects",
	4: "summary",
	5: "has_critical_effects",
}

// Decode decodes ActiveEffectsResponse from json.
func (s *ActiveEffectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Effects = make([]ActiveEffectsResponseEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveEffectsResponseEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Timestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "total_effects":
			if err := func() error {
				s.TotalEffects.Reset()
				if err := s.TotalEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_effects\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "has_critical_effects":
			if err := func() error {
				s.HasCriticalEffects.Reset()
				if err := s.HasCriticalEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_critical_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEffectsResponse) {
					name = jsonFieldsNameOfActiveEffectsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEffectsResponseEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsResponseEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("remaining_ms")
		e.Int32(s.RemainingMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
	{
		if s.AppliedAt.Set {
			e.FieldStart("applied_at")
			s.AppliedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsResponseEffectsItem = [7]string{
	0: "effect_id",
	1: "effect_type",
	2: "remaining_ms",
	3: "source_id",
	4: "intensity",
	5: "stacks",
	6: "applied_at",
}

// Decode decodes ActiveEffectsResponseEffectsItem from json.
func (s *ActiveEffectsResponseEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsResponseEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "effect_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "remaining_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RemainingMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		case "applied_at":
			if err := func() error {
				s.AppliedAt.Reset()
				if err := s.AppliedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsResponseEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEffectsResponseEffectsItem) {
					name = jsonFieldsNameOfActiveEffectsResponseEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsResponseEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsResponseEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsResponseEffectsItemEffectType as json.
func (s ActiveEffectsResponseEffectsItemEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveEffectsResponseEffectsItemEffectType from json.
func (s *ActiveEffectsResponseEffectsItemEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsResponseEffectsItemEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveEffectsResponseEffectsItemEffectType(v) {
	case ActiveEffectsResponseEffectsItemEffectTypeBuffDamage:
		*s = ActiveEffectsResponseEffectsItemEffectTypeBuffDamage
	case ActiveEffectsResponseEffectsItemEffectTypeDebuffDamageReduction:
		*s = ActiveEffectsResponseEffectsItemEffectTypeDebuffDamageReduction
	case ActiveEffectsResponseEffectsItemEffectTypeBuffSpeed:
		*s = ActiveEffectsResponseEffectsItemEffectTypeBuffSpeed
	case ActiveEffectsResponseEffectsItemEffectTypeDebuffSlow:
		*s = ActiveEffectsResponseEffectsItemEffectTypeDebuffSlow
	case ActiveEffectsResponseEffectsItemEffectTypeBuffRegeneration:
		*s = ActiveEffectsResponseEffectsItemEffectTypeBuffRegeneration
	case ActiveEffectsResponseEffectsItemEffectTypeDebuffPoison:
		*s = ActiveEffectsResponseEffectsItemEffectTypeDebuffPoison
	case ActiveEffectsResponseEffectsItemEffectTypeBuffShield:
		*s = ActiveEffectsResponseEffectsItemEffectTypeBuffShield
	case ActiveEffectsResponseEffectsItemEffectTypeDebuffStun:
		*s = ActiveEffectsResponseEffectsItemEffectTypeDebuffStun
	case ActiveEffectsResponseEffectsItemEffectTypeBuffCriticalChance:
		*s = ActiveEffectsResponseEffectsItemEffectTypeBuffCriticalChance
	case ActiveEffectsResponseEffectsItemEffectTypeDebuffAccuracyReduction:
		*s = ActiveEffectsResponseEffectsItemEffectTypeDebuffAccuracyReduction
	default:
		*s = ActiveEffectsResponseEffectsItemEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveEffectsResponseEffectsItemEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsResponseEffectsItemEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEffectsResponseSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEffectsResponseSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Buffs.Set {
			e.FieldStart("buffs")
			s.Buffs.Encode(e)
		}
	}
	{
		if s.Debuffs.Set {
			e.FieldStart("debuffs")
			s.Debuffs.Encode(e)
		}
	}
	{
		if s.StatusEffects.Set {
			e.FieldStart("status_effects")
			s.StatusEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveEffectsResponseSummary = [3]string{
	0: "buffs",
	1: "debuffs",
	2: "status_effects",
}

// Decode decodes ActiveEffectsResponseSummary from json.
func (s *ActiveEffectsResponseSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEffectsResponseSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "buffs":
			if err := func() error {
				s.Buffs.Reset()
				if err := s.Buffs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffs\"")
			}
		case "debuffs":
			if err := func() error {
				s.Debuffs.Reset()
				if err := s.Debuffs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuffs\"")
			}
		case "status_effects":
			if err := func() error {
				s.StatusEffects.Reset()
				if err := s.StatusEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEffectsResponseSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEffectsResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEffectsResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("effects")
		e.ArrStart()
		for _, elem := range s.Effects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.SourceType.Set {
			e.FieldStart("source_type")
			s.SourceType.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.OverrideExisting.Set {
			e.FieldStart("override_existing")
			s.OverrideExisting.Encode(e)
		}
	}
	{
		if s.StackEffects.Set {
			e.FieldStart("stack_effects")
			s.StackEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplyEffectsRequest = [8]string{
	0: "participant_id",
	1: "effects",
	2: "session_id",
	3: "timestamp",
	4: "source_type",
	5: "context",
	6: "override_existing",
	7: "stack_effects",
}

// Decode decodes ApplyEffectsRequest from json.
func (s *ApplyEffectsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Effects = make([]ApplyEffectsRequestEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApplyEffectsRequestEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "source_type":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_type\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "override_existing":
			if err := func() error {
				s.OverrideExisting.Reset()
				if err := s.OverrideExisting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_existing\"")
			}
		case "stack_effects":
			if err := func() error {
				s.StackEffects.Reset()
				if err := s.StackEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsRequest) {
					name = jsonFieldsNameOfApplyEffectsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsRequestContext) encodeFields(e *jx.Encoder) {
	{
		if s.AreaID.Set {
			e.FieldStart("area_id")
			s.AreaID.Encode(e)
		}
	}
	{
		if s.WeatherConditions.Set {
			e.FieldStart("weather_conditions")
			s.WeatherConditions.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplyEffectsRequestContext = [2]string{
	0: "area_id",
	1: "weather_conditions",
}

// Decode decodes ApplyEffectsRequestContext from json.
func (s *ApplyEffectsRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "area_id":
			if err := func() error {
				s.AreaID.Reset()
				if err := s.AreaID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"area_id\"")
			}
		case "weather_conditions":
			if err := func() error {
				s.WeatherConditions.Reset()
				if err := s.WeatherConditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestContextWeatherConditions as json.
func (s ApplyEffectsRequestContextWeatherConditions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsRequestContextWeatherConditions from json.
func (s *ApplyEffectsRequestContextWeatherConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestContextWeatherConditions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsRequestContextWeatherConditions(v) {
	case ApplyEffectsRequestContextWeatherConditionsClear:
		*s = ApplyEffectsRequestContextWeatherConditionsClear
	case ApplyEffectsRequestContextWeatherConditionsRain:
		*s = ApplyEffectsRequestContextWeatherConditionsRain
	case ApplyEffectsRequestContextWeatherConditionsStorm:
		*s = ApplyEffectsRequestContextWeatherConditionsStorm
	case ApplyEffectsRequestContextWeatherConditionsFog:
		*s = ApplyEffectsRequestContextWeatherConditionsFog
	default:
		*s = ApplyEffectsRequestContextWeatherConditions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsRequestContextWeatherConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestContextWeatherConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsRequestEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsRequestEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		e.FieldStart("source_id")
		json.EncodeUUID(e, s.SourceID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplyEffectsRequestEffectsItem = [5]string{
	0: "effect_type",
	1: "duration_ms",
	2: "source_id",
	3: "intensity",
	4: "stacks",
}

// Decode decodes ApplyEffectsRequestEffectsItem from json.
func (s *ApplyEffectsRequestEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestEffectsItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SourceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsRequestEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsRequestEffectsItem) {
					name = jsonFieldsNameOfApplyEffectsRequestEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsRequestEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestEffectsItemEffectType as json.
func (s ApplyEffectsRequestEffectsItemEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsRequestEffectsItemEffectType from json.
func (s *ApplyEffectsRequestEffectsItemEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestEffectsItemEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsRequestEffectsItemEffectType(v) {
	case ApplyEffectsRequestEffectsItemEffectTypeBuffDamage:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuffDamage
	case ApplyEffectsRequestEffectsItemEffectTypeDebuffDamageReduction:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuffDamageReduction
	case ApplyEffectsRequestEffectsItemEffectTypeBuffSpeed:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuffSpeed
	case ApplyEffectsRequestEffectsItemEffectTypeDebuffSlow:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuffSlow
	case ApplyEffectsRequestEffectsItemEffectTypeBuffRegeneration:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuffRegeneration
	case ApplyEffectsRequestEffectsItemEffectTypeDebuffPoison:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuffPoison
	case ApplyEffectsRequestEffectsItemEffectTypeBuffShield:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuffShield
	case ApplyEffectsRequestEffectsItemEffectTypeDebuffStun:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuffStun
	case ApplyEffectsRequestEffectsItemEffectTypeBuffCriticalChance:
		*s = ApplyEffectsRequestEffectsItemEffectTypeBuffCriticalChance
	case ApplyEffectsRequestEffectsItemEffectTypeDebuffAccuracyReduction:
		*s = ApplyEffectsRequestEffectsItemEffectTypeDebuffAccuracyReduction
	default:
		*s = ApplyEffectsRequestEffectsItemEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsRequestEffectsItemEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestEffectsItemEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestSourceType as json.
func (s ApplyEffectsRequestSourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsRequestSourceType from json.
func (s *ApplyEffectsRequestSourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsRequestSourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsRequestSourceType(v) {
	case ApplyEffectsRequestSourceTypeWeapon:
		*s = ApplyEffectsRequestSourceTypeWeapon
	case ApplyEffectsRequestSourceTypeAbility:
		*s = ApplyEffectsRequestSourceTypeAbility
	case ApplyEffectsRequestSourceTypeImplant:
		*s = ApplyEffectsRequestSourceTypeImplant
	case ApplyEffectsRequestSourceTypeEnvironmental:
		*s = ApplyEffectsRequestSourceTypeEnvironmental
	case ApplyEffectsRequestSourceTypeStatusEffect:
		*s = ApplyEffectsRequestSourceTypeStatusEffect
	default:
		*s = ApplyEffectsRequestSourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsRequestSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsRequestSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participant_id")
		json.EncodeUUID(e, s.ParticipantID)
	}
	{
		e.FieldStart("applied_effects")
		e.ArrStart()
		for _, elem := range s.AppliedEffects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RejectedEffects != nil {
			e.FieldStart("rejected_effects")
			e.ArrStart()
			for _, elem := range s.RejectedEffects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfApplyEffectsResult = [8]string{
	0: "participant_id",
	1: "applied_effects",
	2: "rejected_effects",
	3: "timestamp",
	4: "processing_time_ns",
	5: "status",
	6: "summary",
	7: "success",
}

// Decode decodes ApplyEffectsResult from json.
func (s *ApplyEffectsResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipantID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "applied_effects":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.AppliedEffects = make([]ApplyEffectsResultAppliedEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApplyEffectsResultAppliedEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AppliedEffects = append(s.AppliedEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_effects\"")
			}
		case "rejected_effects":
			if err := func() error {
				s.RejectedEffects = make([]ApplyEffectsResultRejectedEffectsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApplyEffectsResultRejectedEffectsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RejectedEffects = append(s.RejectedEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejected_effects\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsResult) {
					name = jsonFieldsNameOfApplyEffectsResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsResultAppliedEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsResultAppliedEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("effect_id")
		json.EncodeUUID(e, s.EffectID)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplyEffectsResultAppliedEffectsItem = [4]string{
	0: "effect_type",
	1: "effect_id",
	2: "duration_ms",
	3: "stacks",
}

// Decode decodes ApplyEffectsResultAppliedEffectsItem from json.
func (s *ApplyEffectsResultAppliedEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResultAppliedEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "effect_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EffectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsResultAppliedEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsResultAppliedEffectsItem) {
					name = jsonFieldsNameOfApplyEffectsResultAppliedEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsResultAppliedEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResultAppliedEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsResultRejectedEffectsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsResultRejectedEffectsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		e.Str(s.EffectType)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfApplyEffectsResultRejectedEffectsItem = [2]string{
	0: "effect_type",
	1: "reason",
}

// Decode decodes ApplyEffectsResultRejectedEffectsItem from json.
func (s *ApplyEffectsResultRejectedEffectsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResultRejectedEffectsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EffectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsResultRejectedEffectsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplyEffectsResultRejectedEffectsItem) {
					name = jsonFieldsNameOfApplyEffectsResultRejectedEffectsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsResultRejectedEffectsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResultRejectedEffectsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsResultRejectedEffectsItemReason as json.
func (s ApplyEffectsResultRejectedEffectsItemReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsResultRejectedEffectsItemReason from json.
func (s *ApplyEffectsResultRejectedEffectsItemReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResultRejectedEffectsItemReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsResultRejectedEffectsItemReason(v) {
	case ApplyEffectsResultRejectedEffectsItemReasonEffectLimitReached:
		*s = ApplyEffectsResultRejectedEffectsItemReasonEffectLimitReached
	case ApplyEffectsResultRejectedEffectsItemReasonConflictingEffect:
		*s = ApplyEffectsResultRejectedEffectsItemReasonConflictingEffect
	case ApplyEffectsResultRejectedEffectsItemReasonInvalidParameters:
		*s = ApplyEffectsResultRejectedEffectsItemReasonInvalidParameters
	case ApplyEffectsResultRejectedEffectsItemReasonParticipantNotFound:
		*s = ApplyEffectsResultRejectedEffectsItemReasonParticipantNotFound
	case ApplyEffectsResultRejectedEffectsItemReasonEffectAlreadyActive:
		*s = ApplyEffectsResultRejectedEffectsItemReasonEffectAlreadyActive
	default:
		*s = ApplyEffectsResultRejectedEffectsItemReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsResultRejectedEffectsItemReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResultRejectedEffectsItemReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsResultStatus as json.
func (s ApplyEffectsResultStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ApplyEffectsResultStatus from json.
func (s *ApplyEffectsResultStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResultStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ApplyEffectsResultStatus(v) {
	case ApplyEffectsResultStatusSuccess:
		*s = ApplyEffectsResultStatusSuccess
	case ApplyEffectsResultStatusPartialSuccess:
		*s = ApplyEffectsResultStatusPartialSuccess
	case ApplyEffectsResultStatusFailed:
		*s = ApplyEffectsResultStatusFailed
	default:
		*s = ApplyEffectsResultStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplyEffectsResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplyEffectsResultSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplyEffectsResultSummary) encodeFields(e *jx.Encoder) {
	{
		if s.TotalRequested.Set {
			e.FieldStart("total_requested")
			s.TotalRequested.Encode(e)
		}
	}
	{
		if s.SuccessfullyApplied.Set {
			e.FieldStart("successfully_applied")
			s.SuccessfullyApplied.Encode(e)
		}
	}
	{
		if s.RejectedCount.Set {
			e.FieldStart("rejected_count")
			s.RejectedCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplyEffectsResultSummary = [3]string{
	0: "total_requested",
	1: "successfully_applied",
	2: "rejected_count",
}

// Decode decodes ApplyEffectsResultSummary from json.
func (s *ApplyEffectsResultSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplyEffectsResultSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_requested":
			if err := func() error {
				s.TotalRequested.Reset()
				if err := s.TotalRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_requested\"")
			}
		case "successfully_applied":
			if err := func() error {
				s.SuccessfullyApplied.Reset()
				if err := s.SuccessfullyApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfully_applied\"")
			}
		case "rejected_count":
			if err := func() error {
				s.RejectedCount.Reset()
				if err := s.RejectedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejected_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplyEffectsResultSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplyEffectsResultSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplyEffectsResultSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalculateDamageBadRequest as json.
func (s *CalculateDamageBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CalculateDamageBadRequest from json.
func (s *CalculateDamageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalculateDamageTooManyRequests as json.
func (s *CalculateDamageTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CalculateDamageTooManyRequests from json.
func (s *CalculateDamageTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalculateDamageTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CalculateDamageTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalculateDamageTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalculateDamageTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.WeaponModifiers != nil {
			e.FieldStart("weapon_modifiers")
			e.ArrStart()
			for _, elem := range s.WeaponModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImplantSynergies != nil {
			e.FieldStart("implant_synergies")
			e.ArrStart()
			for _, elem := range s.ImplantSynergies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvironmentalModifiers.Set {
			e.FieldStart("environmental_modifiers")
			s.EnvironmentalModifiers.Encode(e)
		}
	}
	{
		e.FieldStart("base_damage")
		e.Int32(s.BaseDamage)
	}
	{
		if s.AttackerLevel.Set {
			e.FieldStart("attacker_level")
			s.AttackerLevel.Encode(e)
		}
	}
	{
		if s.TargetLevel.Set {
			e.FieldStart("target_level")
			s.TargetLevel.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.WeaponType.Set {
			e.FieldStart("weapon_type")
			s.WeaponType.Encode(e)
		}
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		if s.RangeModifier.Set {
			e.FieldStart("range_modifier")
			s.RangeModifier.Encode(e)
		}
	}
	{
		if s.IsCriticalHit.Set {
			e.FieldStart("is_critical_hit")
			s.IsCriticalHit.Encode(e)
		}
	}
	{
		if s.IsWeakSpotHit.Set {
			e.FieldStart("is_weak_spot_hit")
			s.IsWeakSpotHit.Encode(e)
		}
	}
	{
		if s.IsBackstab.Set {
			e.FieldStart("is_backstab")
			s.IsBackstab.Encode(e)
		}
	}
	{
		if s.IgnoreArmor.Set {
			e.FieldStart("ignore_armor")
			s.IgnoreArmor.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequest = [17]string{
	0:  "attacker_id",
	1:  "target_id",
	2:  "weapon_modifiers",
	3:  "implant_synergies",
	4:  "environmental_modifiers",
	5:  "base_damage",
	6:  "attacker_level",
	7:  "target_level",
	8:  "timestamp",
	9:  "damage_type",
	10: "weapon_type",
	11: "critical_multiplier",
	12: "range_modifier",
	13: "is_critical_hit",
	14: "is_weak_spot_hit",
	15: "is_backstab",
	16: "ignore_armor",
}

// Decode decodes DamageCalculationRequest from json.
func (s *DamageCalculationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "weapon_modifiers":
			if err := func() error {
				s.WeaponModifiers = make([]DamageCalculationRequestWeaponModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageCalculationRequestWeaponModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WeaponModifiers = append(s.WeaponModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_modifiers\"")
			}
		case "implant_synergies":
			if err := func() error {
				s.ImplantSynergies = make([]DamageCalculationRequestImplantSynergiesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageCalculationRequestImplantSynergiesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImplantSynergies = append(s.ImplantSynergies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_synergies\"")
			}
		case "environmental_modifiers":
			if err := func() error {
				s.EnvironmentalModifiers.Reset()
				if err := s.EnvironmentalModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_modifiers\"")
			}
		case "base_damage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.BaseDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "attacker_level":
			if err := func() error {
				s.AttackerLevel.Reset()
				if err := s.AttackerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_level\"")
			}
		case "target_level":
			if err := func() error {
				s.TargetLevel.Reset()
				if err := s.TargetLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_level\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "damage_type":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "weapon_type":
			if err := func() error {
				s.WeaponType.Reset()
				if err := s.WeaponType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_type\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "range_modifier":
			if err := func() error {
				s.RangeModifier.Reset()
				if err := s.RangeModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range_modifier\"")
			}
		case "is_critical_hit":
			if err := func() error {
				s.IsCriticalHit.Reset()
				if err := s.IsCriticalHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_critical_hit\"")
			}
		case "is_weak_spot_hit":
			if err := func() error {
				s.IsWeakSpotHit.Reset()
				if err := s.IsWeakSpotHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_weak_spot_hit\"")
			}
		case "is_backstab":
			if err := func() error {
				s.IsBackstab.Reset()
				if err := s.IsBackstab.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_backstab\"")
			}
		case "ignore_armor":
			if err := func() error {
				s.IgnoreArmor.Reset()
				if err := s.IgnoreArmor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_armor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100011,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequest) {
					name = jsonFieldsNameOfDamageCalculationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestDamageType as json.
func (s DamageCalculationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestDamageType from json.
func (s *DamageCalculationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestDamageType(v) {
	case DamageCalculationRequestDamageTypePhysical:
		*s = DamageCalculationRequestDamageTypePhysical
	case DamageCalculationRequestDamageTypeFire:
		*s = DamageCalculationRequestDamageTypeFire
	case DamageCalculationRequestDamageTypeCold:
		*s = DamageCalculationRequestDamageTypeCold
	case DamageCalculationRequestDamageTypeLightning:
		*s = DamageCalculationRequestDamageTypeLightning
	case DamageCalculationRequestDamageTypePoison:
		*s = DamageCalculationRequestDamageTypePoison
	case DamageCalculationRequestDamageTypeCyber:
		*s = DamageCalculationRequestDamageTypeCyber
	case DamageCalculationRequestDamageTypeRadiation:
		*s = DamageCalculationRequestDamageTypeRadiation
	case DamageCalculationRequestDamageTypeExplosive:
		*s = DamageCalculationRequestDamageTypeExplosive
	default:
		*s = DamageCalculationRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequestEnvironmentalModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequestEnvironmentalModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.WeatherMultiplier.Set {
			e.FieldStart("weather_multiplier")
			s.WeatherMultiplier.Encode(e)
		}
	}
	{
		if s.TerrainCover.Set {
			e.FieldStart("terrain_cover")
			s.TerrainCover.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequestEnvironmentalModifiers = [2]string{
	0: "weather_multiplier",
	1: "terrain_cover",
}

// Decode decodes DamageCalculationRequestEnvironmentalModifiers from json.
func (s *DamageCalculationRequestEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestEnvironmentalModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather_multiplier":
			if err := func() error {
				s.WeatherMultiplier.Reset()
				if err := s.WeatherMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_multiplier\"")
			}
		case "terrain_cover":
			if err := func() error {
				s.TerrainCover.Reset()
				if err := s.TerrainCover.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_cover\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequestEnvironmentalModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequestEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequestImplantSynergiesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequestImplantSynergiesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("implant_type")
		s.ImplantType.Encode(e)
	}
	{
		e.FieldStart("synergy_bonus")
		e.Float32(s.SynergyBonus)
	}
}

var jsonFieldsNameOfDamageCalculationRequestImplantSynergiesItem = [2]string{
	0: "implant_type",
	1: "synergy_bonus",
}

// Decode decodes DamageCalculationRequestImplantSynergiesItem from json.
func (s *DamageCalculationRequestImplantSynergiesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestImplantSynergiesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "implant_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ImplantType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_type\"")
			}
		case "synergy_bonus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.SynergyBonus = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synergy_bonus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequestImplantSynergiesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequestImplantSynergiesItem) {
					name = jsonFieldsNameOfDamageCalculationRequestImplantSynergiesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequestImplantSynergiesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestImplantSynergiesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestImplantSynergiesItemImplantType as json.
func (s DamageCalculationRequestImplantSynergiesItemImplantType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestImplantSynergiesItemImplantType from json.
func (s *DamageCalculationRequestImplantSynergiesItemImplantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestImplantSynergiesItemImplantType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestImplantSynergiesItemImplantType(v) {
	case DamageCalculationRequestImplantSynergiesItemImplantTypeGorillaArms:
		*s = DamageCalculationRequestImplantSynergiesItemImplantTypeGorillaArms
	case DamageCalculationRequestImplantSynergiesItemImplantTypeMantisBlades:
		*s = DamageCalculationRequestImplantSynergiesItemImplantTypeMantisBlades
	case DamageCalculationRequestImplantSynergiesItemImplantTypeKerenzikov:
		*s = DamageCalculationRequestImplantSynergiesItemImplantTypeKerenzikov
	case DamageCalculationRequestImplantSynergiesItemImplantTypeSandevistan:
		*s = DamageCalculationRequestImplantSynergiesItemImplantTypeSandevistan
	case DamageCalculationRequestImplantSynergiesItemImplantTypeProjectileLauncher:
		*s = DamageCalculationRequestImplantSynergiesItemImplantTypeProjectileLauncher
	default:
		*s = DamageCalculationRequestImplantSynergiesItemImplantType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestImplantSynergiesItemImplantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestImplantSynergiesItemImplantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequestWeaponModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequestWeaponModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageCalculationRequestWeaponModifiersItem = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageCalculationRequestWeaponModifiersItem from json.
func (s *DamageCalculationRequestWeaponModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestWeaponModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequestWeaponModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequestWeaponModifiersItem) {
					name = jsonFieldsNameOfDamageCalculationRequestWeaponModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequestWeaponModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestWeaponModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestWeaponModifiersItemType as json.
func (s DamageCalculationRequestWeaponModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestWeaponModifiersItemType from json.
func (s *DamageCalculationRequestWeaponModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestWeaponModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestWeaponModifiersItemType(v) {
	case DamageCalculationRequestWeaponModifiersItemTypeDamageBoost:
		*s = DamageCalculationRequestWeaponModifiersItemTypeDamageBoost
	case DamageCalculationRequestWeaponModifiersItemTypeAccuracyBonus:
		*s = DamageCalculationRequestWeaponModifiersItemTypeAccuracyBonus
	case DamageCalculationRequestWeaponModifiersItemTypeArmorPenetration:
		*s = DamageCalculationRequestWeaponModifiersItemTypeArmorPenetration
	case DamageCalculationRequestWeaponModifiersItemTypeElementalDamage:
		*s = DamageCalculationRequestWeaponModifiersItemTypeElementalDamage
	default:
		*s = DamageCalculationRequestWeaponModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestWeaponModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestWeaponModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("calculation_id")
		json.EncodeUUID(e, s.CalculationID)
	}
	{
		if s.AppliedModifiers != nil {
			e.FieldStart("applied_modifiers")
			e.ArrStart()
			for _, elem := range s.AppliedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DamageBreakdown != nil {
			e.FieldStart("damage_breakdown")
			e.ArrStart()
			for _, elem := range s.DamageBreakdown {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("final_damage")
		e.Int32(s.FinalDamage)
	}
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.ArmorReduction.Set {
			e.FieldStart("armor_reduction")
			s.ArmorReduction.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		if s.TotalMultiplier.Set {
			e.FieldStart("total_multiplier")
			s.TotalMultiplier.Encode(e)
		}
	}
	{
		if s.TargetStats.Set {
			e.FieldStart("target_stats")
			s.TargetStats.Encode(e)
		}
	}
	{
		if s.WasCritical.Set {
			e.FieldStart("was_critical")
			s.WasCritical.Encode(e)
		}
	}
	{
		if s.WasDodged.Set {
			e.FieldStart("was_dodged")
			s.WasDodged.Encode(e)
		}
	}
	{
		if s.WasBlocked.Set {
			e.FieldStart("was_blocked")
			s.WasBlocked.Encode(e)
		}
	}
	{
		if s.TargetAlive.Set {
			e.FieldStart("target_alive")
			s.TargetAlive.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResult = [18]string{
	0:  "attacker_id",
	1:  "target_id",
	2:  "calculation_id",
	3:  "applied_modifiers",
	4:  "damage_breakdown",
	5:  "final_damage",
	6:  "base_damage",
	7:  "armor_reduction",
	8:  "timestamp",
	9:  "processing_time_ns",
	10: "damage_type",
	11: "critical_multiplier",
	12: "total_multiplier",
	13: "target_stats",
	14: "was_critical",
	15: "was_dodged",
	16: "was_blocked",
	17: "target_alive",
}

// Decode decodes DamageCalculationResult from json.
func (s *DamageCalculationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResult to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "calculation_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CalculationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_id\"")
			}
		case "applied_modifiers":
			if err := func() error {
				s.AppliedModifiers = make([]DamageCalculationResultAppliedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageCalculationResultAppliedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AppliedModifiers = append(s.AppliedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applied_modifiers\"")
			}
		case "damage_breakdown":
			if err := func() error {
				s.DamageBreakdown = make([]DamageCalculationResultDamageBreakdownItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageCalculationResultDamageBreakdownItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DamageBreakdown = append(s.DamageBreakdown, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_breakdown\"")
			}
		case "final_damage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.FinalDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "armor_reduction":
			if err := func() error {
				s.ArmorReduction.Reset()
				if err := s.ArmorReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "damage_type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "total_multiplier":
			if err := func() error {
				s.TotalMultiplier.Reset()
				if err := s.TotalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_multiplier\"")
			}
		case "target_stats":
			if err := func() error {
				s.TargetStats.Reset()
				if err := s.TargetStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_stats\"")
			}
		case "was_critical":
			if err := func() error {
				s.WasCritical.Reset()
				if err := s.WasCritical.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "was_dodged":
			if err := func() error {
				s.WasDodged.Reset()
				if err := s.WasDodged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_dodged\"")
			}
		case "was_blocked":
			if err := func() error {
				s.WasBlocked.Reset()
				if err := s.WasBlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_blocked\"")
			}
		case "target_alive":
			if err := func() error {
				s.TargetAlive.Reset()
				if err := s.TargetAlive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_alive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100111,
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResult) {
					name = jsonFieldsNameOfDamageCalculationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResultAppliedModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResultAppliedModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
}

var jsonFieldsNameOfDamageCalculationResultAppliedModifiersItem = [3]string{
	0: "type",
	1: "value",
	2: "source",
}

// Decode decodes DamageCalculationResultAppliedModifiersItem from json.
func (s *DamageCalculationResultAppliedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultAppliedModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResultAppliedModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResultAppliedModifiersItem) {
					name = jsonFieldsNameOfDamageCalculationResultAppliedModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResultAppliedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultAppliedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResultAppliedModifiersItemType as json.
func (s DamageCalculationResultAppliedModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationResultAppliedModifiersItemType from json.
func (s *DamageCalculationResultAppliedModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultAppliedModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationResultAppliedModifiersItemType(v) {
	case DamageCalculationResultAppliedModifiersItemTypeCriticalHit:
		*s = DamageCalculationResultAppliedModifiersItemTypeCriticalHit
	case DamageCalculationResultAppliedModifiersItemTypeWeakSpot:
		*s = DamageCalculationResultAppliedModifiersItemTypeWeakSpot
	case DamageCalculationResultAppliedModifiersItemTypeArmorReduction:
		*s = DamageCalculationResultAppliedModifiersItemTypeArmorReduction
	case DamageCalculationResultAppliedModifiersItemTypeElementalBonus:
		*s = DamageCalculationResultAppliedModifiersItemTypeElementalBonus
	case DamageCalculationResultAppliedModifiersItemTypeImplantSynergy:
		*s = DamageCalculationResultAppliedModifiersItemTypeImplantSynergy
	case DamageCalculationResultAppliedModifiersItemTypeEnvironmental:
		*s = DamageCalculationResultAppliedModifiersItemTypeEnvironmental
	case DamageCalculationResultAppliedModifiersItemTypeBackstab:
		*s = DamageCalculationResultAppliedModifiersItemTypeBackstab
	default:
		*s = DamageCalculationResultAppliedModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationResultAppliedModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultAppliedModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResultDamageBreakdownItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResultDamageBreakdownItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("amount")
		e.Int32(s.Amount)
	}
}

var jsonFieldsNameOfDamageCalculationResultDamageBreakdownItem = [2]string{
	0: "type",
	1: "amount",
}

// Decode decodes DamageCalculationResultDamageBreakdownItem from json.
func (s *DamageCalculationResultDamageBreakdownItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultDamageBreakdownItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Amount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResultDamageBreakdownItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResultDamageBreakdownItem) {
					name = jsonFieldsNameOfDamageCalculationResultDamageBreakdownItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResultDamageBreakdownItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultDamageBreakdownItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResultDamageBreakdownItemType as json.
func (s DamageCalculationResultDamageBreakdownItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationResultDamageBreakdownItemType from json.
func (s *DamageCalculationResultDamageBreakdownItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultDamageBreakdownItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationResultDamageBreakdownItemType(v) {
	case DamageCalculationResultDamageBreakdownItemTypeBaseDamage:
		*s = DamageCalculationResultDamageBreakdownItemTypeBaseDamage
	case DamageCalculationResultDamageBreakdownItemTypeCriticalBonus:
		*s = DamageCalculationResultDamageBreakdownItemTypeCriticalBonus
	case DamageCalculationResultDamageBreakdownItemTypeWeakSpotBonus:
		*s = DamageCalculationResultDamageBreakdownItemTypeWeakSpotBonus
	case DamageCalculationResultDamageBreakdownItemTypeArmorPenetration:
		*s = DamageCalculationResultDamageBreakdownItemTypeArmorPenetration
	case DamageCalculationResultDamageBreakdownItemTypeElementalDamage:
		*s = DamageCalculationResultDamageBreakdownItemTypeElementalDamage
	case DamageCalculationResultDamageBreakdownItemTypeSynergyBonus:
		*s = DamageCalculationResultDamageBreakdownItemTypeSynergyBonus
	case DamageCalculationResultDamageBreakdownItemTypeEnvironmentalModifier:
		*s = DamageCalculationResultDamageBreakdownItemTypeEnvironmentalModifier
	default:
		*s = DamageCalculationResultDamageBreakdownItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationResultDamageBreakdownItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultDamageBreakdownItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResultDamageType as json.
func (s DamageCalculationResultDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationResultDamageType from json.
func (s *DamageCalculationResultDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationResultDamageType(v) {
	case DamageCalculationResultDamageTypePhysical:
		*s = DamageCalculationResultDamageTypePhysical
	case DamageCalculationResultDamageTypeFire:
		*s = DamageCalculationResultDamageTypeFire
	case DamageCalculationResultDamageTypeCold:
		*s = DamageCalculationResultDamageTypeCold
	case DamageCalculationResultDamageTypeLightning:
		*s = DamageCalculationResultDamageTypeLightning
	case DamageCalculationResultDamageTypePoison:
		*s = DamageCalculationResultDamageTypePoison
	case DamageCalculationResultDamageTypeCyber:
		*s = DamageCalculationResultDamageTypeCyber
	case DamageCalculationResultDamageTypeRadiation:
		*s = DamageCalculationResultDamageTypeRadiation
	case DamageCalculationResultDamageTypeExplosive:
		*s = DamageCalculationResultDamageTypeExplosive
	default:
		*s = DamageCalculationResultDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationResultDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResultTargetStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResultTargetStats) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentHp.Set {
			e.FieldStart("current_hp")
			s.CurrentHp.Encode(e)
		}
	}
	{
		if s.MaxHp.Set {
			e.FieldStart("max_hp")
			s.MaxHp.Encode(e)
		}
	}
	{
		if s.ArmorRating.Set {
			e.FieldStart("armor_rating")
			s.ArmorRating.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResultTargetStats = [3]string{
	0: "current_hp",
	1: "max_hp",
	2: "armor_rating",
}

// Decode decodes DamageCalculationResultTargetStats from json.
func (s *DamageCalculationResultTargetStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResultTargetStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_hp":
			if err := func() error {
				s.CurrentHp.Reset()
				if err := s.CurrentHp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_hp\"")
			}
		case "max_hp":
			if err := func() error {
				s.MaxHp.Reset()
				if err := s.MaxHp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "armor_rating":
			if err := func() error {
				s.ArmorRating.Reset()
				if err := s.ArmorRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_rating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResultTargetStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResultTargetStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResultTargetStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.ClientModifiers != nil {
			e.FieldStart("client_modifiers")
			e.ArrStart()
			for _, elem := range s.ClientModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("reported_damage")
		e.Int32(s.ReportedDamage)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.SequenceNumber.Set {
			e.FieldStart("sequence_number")
			s.SequenceNumber.Encode(e)
		}
	}
	{
		e.FieldStart("damage_type")
		s.DamageType.Encode(e)
	}
	{
		if s.WeaponHash.Set {
			e.FieldStart("weapon_hash")
			s.WeaponHash.Encode(e)
		}
	}
	{
		if s.PositionData.Set {
			e.FieldStart("position_data")
			s.PositionData.Encode(e)
		}
	}
	{
		if s.WasCritical.Set {
			e.FieldStart("was_critical")
			s.WasCritical.Encode(e)
		}
	}
	{
		if s.WasHeadshot.Set {
			e.FieldStart("was_headshot")
			s.WasHeadshot.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationRequest = [12]string{
	0:  "session_id",
	1:  "attacker_id",
	2:  "target_id",
	3:  "client_modifiers",
	4:  "reported_damage",
	5:  "timestamp",
	6:  "sequence_number",
	7:  "damage_type",
	8:  "weapon_hash",
	9:  "position_data",
	10: "was_critical",
	11: "was_headshot",
}

// Decode decodes DamageValidationRequest from json.
func (s *DamageValidationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "attacker_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "client_modifiers":
			if err := func() error {
				s.ClientModifiers = make([]DamageValidationRequestClientModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationRequestClientModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClientModifiers = append(s.ClientModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_modifiers\"")
			}
		case "reported_damage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.ReportedDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_damage\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "sequence_number":
			if err := func() error {
				s.SequenceNumber.Reset()
				if err := s.SequenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sequence_number\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "weapon_hash":
			if err := func() error {
				s.WeaponHash.Reset()
				if err := s.WeaponHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_hash\"")
			}
		case "position_data":
			if err := func() error {
				s.PositionData.Reset()
				if err := s.PositionData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position_data\"")
			}
		case "was_critical":
			if err := func() error {
				s.WasCritical.Reset()
				if err := s.WasCritical.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_critical\"")
			}
		case "was_headshot":
			if err := func() error {
				s.WasHeadshot.Reset()
				if err := s.WasHeadshot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_headshot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10010111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequest) {
					name = jsonFieldsNameOfDamageValidationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestClientModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestClientModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
}

var jsonFieldsNameOfDamageValidationRequestClientModifiersItem = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes DamageValidationRequestClientModifiersItem from json.
func (s *DamageValidationRequestClientModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestClientModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestClientModifiersItem) {
					name = jsonFieldsNameOfDamageValidationRequestClientModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestClientModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestClientModifiersItemType as json.
func (s DamageValidationRequestClientModifiersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationRequestClientModifiersItemType from json.
func (s *DamageValidationRequestClientModifiersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestClientModifiersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationRequestClientModifiersItemType(v) {
	case DamageValidationRequestClientModifiersItemTypeCriticalMultiplier:
		*s = DamageValidationRequestClientModifiersItemTypeCriticalMultiplier
	case DamageValidationRequestClientModifiersItemTypeRangeModifier:
		*s = DamageValidationRequestClientModifiersItemTypeRangeModifier
	case DamageValidationRequestClientModifiersItemTypeWeakSpotBonus:
		*s = DamageValidationRequestClientModifiersItemTypeWeakSpotBonus
	case DamageValidationRequestClientModifiersItemTypeArmorPenetration:
		*s = DamageValidationRequestClientModifiersItemTypeArmorPenetration
	case DamageValidationRequestClientModifiersItemTypeElementalDamage:
		*s = DamageValidationRequestClientModifiersItemTypeElementalDamage
	default:
		*s = DamageValidationRequestClientModifiersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationRequestClientModifiersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestClientModifiersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestDamageType as json.
func (s DamageValidationRequestDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationRequestDamageType from json.
func (s *DamageValidationRequestDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationRequestDamageType(v) {
	case DamageValidationRequestDamageTypePhysical:
		*s = DamageValidationRequestDamageTypePhysical
	case DamageValidationRequestDamageTypeFire:
		*s = DamageValidationRequestDamageTypeFire
	case DamageValidationRequestDamageTypeCold:
		*s = DamageValidationRequestDamageTypeCold
	case DamageValidationRequestDamageTypeLightning:
		*s = DamageValidationRequestDamageTypeLightning
	case DamageValidationRequestDamageTypePoison:
		*s = DamageValidationRequestDamageTypePoison
	case DamageValidationRequestDamageTypeCyber:
		*s = DamageValidationRequestDamageTypeCyber
	case DamageValidationRequestDamageTypeRadiation:
		*s = DamageValidationRequestDamageTypeRadiation
	case DamageValidationRequestDamageTypeExplosive:
		*s = DamageValidationRequestDamageTypeExplosive
	default:
		*s = DamageValidationRequestDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationRequestDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_pos")
		s.AttackerPos.Encode(e)
	}
	{
		e.FieldStart("target_pos")
		s.TargetPos.Encode(e)
	}
	{
		if s.AttackerYaw.Set {
			e.FieldStart("attacker_yaw")
			s.AttackerYaw.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionData = [3]string{
	0: "attacker_pos",
	1: "target_pos",
	2: "attacker_yaw",
}

// Decode decodes DamageValidationRequestPositionData from json.
func (s *DamageValidationRequestPositionData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_pos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AttackerPos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_pos\"")
			}
		case "target_pos":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TargetPos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_pos\"")
			}
		case "attacker_yaw":
			if err := func() error {
				s.AttackerYaw.Reset()
				if err := s.AttackerYaw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_yaw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionData) {
					name = jsonFieldsNameOfDamageValidationRequestPositionData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionDataAttackerPos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes DamageValidationRequestPositionDataAttackerPos from json.
func (s *DamageValidationRequestPositionDataAttackerPos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionDataAttackerPos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionDataAttackerPos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos) {
					name = jsonFieldsNameOfDamageValidationRequestPositionDataAttackerPos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionDataAttackerPos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationRequestPositionDataTargetPos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationRequestPositionDataTargetPos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Float32(s.X)
	}
	{
		e.FieldStart("y")
		e.Float32(s.Y)
	}
	{
		e.FieldStart("z")
		e.Float32(s.Z)
	}
}

var jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos = [3]string{
	0: "x",
	1: "y",
	2: "z",
}

// Decode decodes DamageValidationRequestPositionDataTargetPos from json.
func (s *DamageValidationRequestPositionDataTargetPos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationRequestPositionDataTargetPos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.X = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Y = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Z = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationRequestPositionDataTargetPos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos) {
					name = jsonFieldsNameOfDamageValidationRequestPositionDataTargetPos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationRequestPositionDataTargetPos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationRequestPositionDataTargetPos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		if s.ValidationIssues != nil {
			e.FieldStart("validation_issues")
			e.ArrStart()
			for _, elem := range s.ValidationIssues {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("server_calculated_damage")
		e.Int32(s.ServerCalculatedDamage)
	}
	{
		e.FieldStart("validation_score")
		e.Int32(s.ValidationScore)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.ProcessingTimeNs.Set {
			e.FieldStart("processing_time_ns")
			s.ProcessingTimeNs.Encode(e)
		}
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
	{
		if s.CorrectedValues.Set {
			e.FieldStart("corrected_values")
			s.CorrectedValues.Encode(e)
		}
	}
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
	{
		if s.RequiresServerCorrection.Set {
			e.FieldStart("requires_server_correction")
			s.RequiresServerCorrection.Encode(e)
		}
	}
	{
		if s.FlaggedForReview.Set {
			e.FieldStart("flagged_for_review")
			s.FlaggedForReview.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResult = [11]string{
	0:  "session_id",
	1:  "validation_issues",
	2:  "server_calculated_damage",
	3:  "validation_score",
	4:  "timestamp",
	5:  "processing_time_ns",
	6:  "validation_status",
	7:  "corrected_values",
	8:  "is_valid",
	9:  "requires_server_correction",
	10: "flagged_for_review",
}

// Decode decodes DamageValidationResult from json.
func (s *DamageValidationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "validation_issues":
			if err := func() error {
				s.ValidationIssues = make([]DamageValidationResultValidationIssuesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationResultValidationIssuesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ValidationIssues = append(s.ValidationIssues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_issues\"")
			}
		case "server_calculated_damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.ServerCalculatedDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_calculated_damage\"")
			}
		case "validation_score":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.ValidationScore = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_score\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "processing_time_ns":
			if err := func() error {
				s.ProcessingTimeNs.Reset()
				if err := s.ProcessingTimeNs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ns\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		case "corrected_values":
			if err := func() error {
				s.CorrectedValues.Reset()
				if err := s.CorrectedValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_values\"")
			}
		case "is_valid":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "requires_server_correction":
			if err := func() error {
				s.RequiresServerCorrection.Reset()
				if err := s.RequiresServerCorrection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_server_correction\"")
			}
		case "flagged_for_review":
			if err := func() error {
				s.FlaggedForReview.Reset()
				if err := s.FlaggedForReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flagged_for_review\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001101,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResult) {
					name = jsonFieldsNameOfDamageValidationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultCorrectedValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultCorrectedValues) encodeFields(e *jx.Encoder) {
	{
		if s.CorrectedDamage.Set {
			e.FieldStart("corrected_damage")
			s.CorrectedDamage.Encode(e)
		}
	}
	{
		if s.CorrectedModifiers != nil {
			e.FieldStart("corrected_modifiers")
			e.ArrStart()
			for _, elem := range s.CorrectedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDamageValidationResultCorrectedValues = [2]string{
	0: "corrected_damage",
	1: "corrected_modifiers",
}

// Decode decodes DamageValidationResultCorrectedValues from json.
func (s *DamageValidationResultCorrectedValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultCorrectedValues to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "corrected_damage":
			if err := func() error {
				s.CorrectedDamage.Reset()
				if err := s.CorrectedDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_damage\"")
			}
		case "corrected_modifiers":
			if err := func() error {
				s.CorrectedModifiers = make([]DamageValidationResultCorrectedValuesCorrectedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageValidationResultCorrectedValuesCorrectedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CorrectedModifiers = append(s.CorrectedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corrected_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultCorrectedValues")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultCorrectedValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultCorrectedValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("correct_value")
		e.Float32(s.CorrectValue)
	}
	{
		if s.ReportedValue.Set {
			e.FieldStart("reported_value")
			s.ReportedValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem = [3]string{
	0: "type",
	1: "correct_value",
	2: "reported_value",
}

// Decode decodes DamageValidationResultCorrectedValuesCorrectedModifiersItem from json.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultCorrectedValuesCorrectedModifiersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "correct_value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CorrectValue = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_value\"")
			}
		case "reported_value":
			if err := func() error {
				s.ReportedValue.Reset()
				if err := s.ReportedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reported_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultCorrectedValuesCorrectedModifiersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem) {
					name = jsonFieldsNameOfDamageValidationResultCorrectedValuesCorrectedModifiersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultCorrectedValuesCorrectedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageValidationResultValidationIssuesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageValidationResultValidationIssuesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("issue_type")
		s.IssueType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.EvidenceValue.Set {
			e.FieldStart("evidence_value")
			s.EvidenceValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageValidationResultValidationIssuesItem = [4]string{
	0: "issue_type",
	1: "severity",
	2: "description",
	3: "evidence_value",
}

// Decode decodes DamageValidationResultValidationIssuesItem from json.
func (s *DamageValidationResultValidationIssuesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issue_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IssueType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "evidence_value":
			if err := func() error {
				s.EvidenceValue.Reset()
				if err := s.EvidenceValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageValidationResultValidationIssuesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageValidationResultValidationIssuesItem) {
					name = jsonFieldsNameOfDamageValidationResultValidationIssuesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageValidationResultValidationIssuesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssuesItemIssueType as json.
func (s DamageValidationResultValidationIssuesItemIssueType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssuesItemIssueType from json.
func (s *DamageValidationResultValidationIssuesItemIssueType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItemIssueType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssuesItemIssueType(v) {
	case DamageValidationResultValidationIssuesItemIssueTypeDamageMismatch:
		*s = DamageValidationResultValidationIssuesItemIssueTypeDamageMismatch
	case DamageValidationResultValidationIssuesItemIssueTypeInvalidModifier:
		*s = DamageValidationResultValidationIssuesItemIssueTypeInvalidModifier
	case DamageValidationResultValidationIssuesItemIssueTypeLineOfSightBlocked:
		*s = DamageValidationResultValidationIssuesItemIssueTypeLineOfSightBlocked
	case DamageValidationResultValidationIssuesItemIssueTypeImpossibleTiming:
		*s = DamageValidationResultValidationIssuesItemIssueTypeImpossibleTiming
	case DamageValidationResultValidationIssuesItemIssueTypeSuspiciousPattern:
		*s = DamageValidationResultValidationIssuesItemIssueTypeSuspiciousPattern
	case DamageValidationResultValidationIssuesItemIssueTypeWeaponHashMismatch:
		*s = DamageValidationResultValidationIssuesItemIssueTypeWeaponHashMismatch
	case DamageValidationResultValidationIssuesItemIssueTypePositionInconsistency:
		*s = DamageValidationResultValidationIssuesItemIssueTypePositionInconsistency
	default:
		*s = DamageValidationResultValidationIssuesItemIssueType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssuesItemIssueType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItemIssueType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationIssuesItemSeverity as json.
func (s DamageValidationResultValidationIssuesItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationIssuesItemSeverity from json.
func (s *DamageValidationResultValidationIssuesItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationIssuesItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationIssuesItemSeverity(v) {
	case DamageValidationResultValidationIssuesItemSeverityLow:
		*s = DamageValidationResultValidationIssuesItemSeverityLow
	case DamageValidationResultValidationIssuesItemSeverityMedium:
		*s = DamageValidationResultValidationIssuesItemSeverityMedium
	case DamageValidationResultValidationIssuesItemSeverityHigh:
		*s = DamageValidationResultValidationIssuesItemSeverityHigh
	case DamageValidationResultValidationIssuesItemSeverityCritical:
		*s = DamageValidationResultValidationIssuesItemSeverityCritical
	default:
		*s = DamageValidationResultValidationIssuesItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationIssuesItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationIssuesItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationStatus as json.
func (s DamageValidationResultValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageValidationResultValidationStatus from json.
func (s *DamageValidationResultValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageValidationResultValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageValidationResultValidationStatus(v) {
	case DamageValidationResultValidationStatusValid:
		*s = DamageValidationResultValidationStatusValid
	case DamageValidationResultValidationStatusSuspicious:
		*s = DamageValidationResultValidationStatusSuspicious
	case DamageValidationResultValidationStatusInvalid:
		*s = DamageValidationResultValidationStatusInvalid
	case DamageValidationResultValidationStatusRequiresReview:
		*s = DamageValidationResultValidationStatusRequiresReview
	default:
		*s = DamageValidationResultValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageValidationResultValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageValidationResultValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
}

var jsonFieldsNameOfHealthResponse = [3]string{
	0: "version",
	1: "status",
	2: "timestamp",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEffectsResponseSummary as json.
func (o OptActiveEffectsResponseSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActiveEffectsResponseSummary from json.
func (o *OptActiveEffectsResponseSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActiveEffectsResponseSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActiveEffectsResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActiveEffectsResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestContext as json.
func (o OptApplyEffectsRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ApplyEffectsRequestContext from json.
func (o *OptApplyEffectsRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplyEffectsRequestContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplyEffectsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplyEffectsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestContextWeatherConditions as json.
func (o OptApplyEffectsRequestContextWeatherConditions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ApplyEffectsRequestContextWeatherConditions from json.
func (o *OptApplyEffectsRequestContextWeatherConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplyEffectsRequestContextWeatherConditions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplyEffectsRequestContextWeatherConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplyEffectsRequestContextWeatherConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsRequestSourceType as json.
func (o OptApplyEffectsRequestSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ApplyEffectsRequestSourceType from json.
func (o *OptApplyEffectsRequestSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplyEffectsRequestSourceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplyEffectsRequestSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplyEffectsRequestSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsResultStatus as json.
func (o OptApplyEffectsResultStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ApplyEffectsResultStatus from json.
func (o *OptApplyEffectsResultStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplyEffectsResultStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplyEffectsResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplyEffectsResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplyEffectsResultSummary as json.
func (o OptApplyEffectsResultSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ApplyEffectsResultSummary from json.
func (o *OptApplyEffectsResultSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplyEffectsResultSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplyEffectsResultSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplyEffectsResultSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestEnvironmentalModifiers as json.
func (o OptDamageCalculationRequestEnvironmentalModifiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationRequestEnvironmentalModifiers from json.
func (o *OptDamageCalculationRequestEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationRequestEnvironmentalModifiers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationRequestEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationRequestEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResultTargetStats as json.
func (o OptDamageCalculationResultTargetStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationResultTargetStats from json.
func (o *OptDamageCalculationResultTargetStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationResultTargetStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationResultTargetStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationResultTargetStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationRequestPositionData as json.
func (o OptDamageValidationRequestPositionData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationRequestPositionData from json.
func (o *OptDamageValidationRequestPositionData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationRequestPositionData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationRequestPositionData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationRequestPositionData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultCorrectedValues as json.
func (o OptDamageValidationResultCorrectedValues) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageValidationResultCorrectedValues from json.
func (o *OptDamageValidationResultCorrectedValues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultCorrectedValues to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultCorrectedValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultCorrectedValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageValidationResultValidationStatus as json.
func (o OptDamageValidationResultValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageValidationResultValidationStatus from json.
func (o *OptDamageValidationResultValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageValidationResultValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageValidationResultValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageValidationResultValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
