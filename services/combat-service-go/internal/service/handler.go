// Code generated by NECPGAME backend agent. Enterprise-grade Combat handler.
// PERFORMANCE: Optimized request handling with context timeouts and combat session management
// Issue: #2278 - Mass ogen Migration - 80+ Services Performance Upgrade

package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/combat-service-go/pkg/api"
)

// Handler implements the API handler interface
type Handler struct {
	service *Service
}

// NewHandler creates new optimized handler
func NewHandler(svc *Service) *Handler {
	return &Handler{service: svc}
}

// withTimeout creates context with timeout for operation safety
// PERFORMANCE: Prevents hanging operations in combat sessions
func (h *Handler) withTimeout(ctx context.Context, operation string, timeout time.Duration) (context.Context, context.CancelFunc) {
	return context.WithTimeout(ctx, timeout)
}

// CombatServiceCreateSession creates a new combat session
// PERFORMANCE: Context timeout prevents slow session creation operations
func (h *Handler) CombatServiceCreateSession(ctx context.Context, req *api.CreateCombatSessionRequest) (api.CombatServiceCreateSessionRes, error) {
	ctx, cancel := h.withTimeout(ctx, "CreateSession", 50*time.Second)
	defer cancel()

	h.service.logger.Info("Processing CreateCombatSession request",
		zap.String("game_mode", req.GameMode),
		zap.Int("max_participants", req.MaxParticipants))

	// Generate session ID
	sessionID := uuid.New()

	// Create session in database
	query := `
		INSERT INTO combat.sessions (
			session_id, game_mode, status, max_participants,
			created_at, last_activity, metadata
		) VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id
	`

	var dbID uuid.UUID
	now := time.Now()
	err := h.service.db.QueryRow(ctx, query,
		sessionID.String(),
		req.GameMode,
		"active",
		req.MaxParticipants,
		now,
		now,
		"{}", // Empty metadata for now
	).Scan(&dbID)

	if err != nil {
		h.service.logger.Error("Failed to create combat session in database",
			zap.String("session_id", sessionID.String()),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to create combat session")
	}

	h.service.logger.Info("Combat session created in database",
		zap.String("session_id", sessionID.String()),
		zap.String("db_id", dbID.String()),
		zap.String("game_mode", req.GameMode),
		zap.Int("max_participants", req.MaxParticipants))

	return &api.CombatServiceCreateSessionOK{
		Data: &api.CombatSessionResponse{
			SessionID: sessionID.String(),
			Status:    "active",
			GameMode:  req.GameMode,
			CreatedAt: now.Format(time.RFC3339),
		},
	}, nil
}

// CombatServiceGetSession retrieves combat session details
// PERFORMANCE: Optimized for frequent session status queries
func (h *Handler) CombatServiceGetSession(ctx context.Context, params api.CombatServiceGetSessionParams) (api.CombatServiceGetSessionRes, error) {
	ctx, cancel := h.withTimeout(ctx, "GetSession", 25*time.Second)
	defer cancel()

	sessionID, err := uuid.Parse(params.SessionID)
	if err != nil {
		return &api.CombatServiceGetSessionBadRequest{Error: "Invalid session ID"}, nil
	}

	h.service.logger.Info("Processing GetCombatSession request",
		zap.String("session_id", sessionID.String()))

	// Retrieve session from database
	query := `
		SELECT session_id, game_mode, status, max_participants, current_participants,
			   created_at, started_at, completed_at, participants, spectators,
			   current_round, max_rounds, score, game_state
		FROM combat.sessions
		WHERE session_id = $1
	`

	var session api.CombatSessionResponse
	var participants, spectators, score, gameState []byte
	var startedAt, completedAt sql.NullTime

	err := h.service.db.QueryRow(ctx, query, sessionID.String()).Scan(
		&session.SessionID,
		&session.GameMode,
		&session.Status,
		&session.MaxParticipants,
		&session.CurrentParticipants,
		&session.CreatedAt,
		&startedAt,
		&completedAt,
		&participants,
		&spectators,
		&session.CurrentRound,
		&session.MaxRounds,
		&score,
		&gameState,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			h.service.logger.Info("Combat session not found",
				zap.String("session_id", sessionID.String()))
			return &api.CombatServiceGetSessionNotFound{}, nil
		}
		h.service.logger.Error("Failed to retrieve combat session",
			zap.String("session_id", sessionID.String()),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to retrieve combat session")
	}

	// Parse JSON fields
	if len(participants) > 0 {
		if err := json.Unmarshal(participants, &session.Participants); err != nil {
			h.service.logger.Warn("Failed to unmarshal participants",
				zap.Error(err))
		}
	}

	if len(spectators) > 0 {
		if err := json.Unmarshal(spectators, &session.Spectators); err != nil {
			h.service.logger.Warn("Failed to unmarshal spectators",
				zap.Error(err))
		}
	}

	if len(score) > 0 {
		if err := json.Unmarshal(score, &session.Score); err != nil {
			h.service.logger.Warn("Failed to unmarshal score",
				zap.Error(err))
		}
	}

	if len(gameState) > 0 {
		if err := json.Unmarshal(gameState, &session.GameState); err != nil {
			h.service.logger.Warn("Failed to unmarshal game state",
				zap.Error(err))
		}
	}

	// Set timestamps
	if startedAt.Valid {
		session.StartedAt = &startedAt.Time
	}
	if completedAt.Valid {
		session.CompletedAt = &completedAt.Time
	}

	h.service.logger.Info("Combat session retrieved successfully",
		zap.String("session_id", sessionID.String()),
		zap.String("status", string(session.Status)),
		zap.String("game_mode", string(session.GameMode)))

	return &api.CombatServiceGetSessionOK{
		Data: &session,
	}, nil
}

// CombatServiceExecuteAction processes combat actions in a session
// PERFORMANCE: High-throughput endpoint for real-time combat actions
func (h *Handler) CombatServiceExecuteAction(ctx context.Context, req *api.CombatActionRequest, params api.CombatServiceExecuteActionParams) (api.CombatServiceExecuteActionRes, error) {
	ctx, cancel := h.withTimeout(ctx, "ExecuteAction", 15*time.Second)
	defer cancel()

	sessionID, err := uuid.Parse(params.SessionID)
	if err != nil {
		return &api.CombatServiceExecuteActionBadRequest{Error: "Invalid session ID"}, nil
	}

	h.service.logger.Info("Processing ExecuteCombatAction request",
		zap.String("session_id", sessionID.String()),
		zap.String("action_type", req.ActionType),
		zap.String("player_id", req.PlayerID))

	// Step 1: Validate session exists and is active
	sessionCheckQuery := `
		SELECT status, participants FROM combat.sessions
		WHERE session_id = $1
	`
	var sessionStatus string
	var participants []byte
	err := h.service.db.QueryRow(ctx, sessionCheckQuery, sessionID.String()).Scan(&sessionStatus, &participants)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			h.service.logger.Warn("Combat session not found",
				zap.String("session_id", sessionID.String()))
			return &api.CombatServiceExecuteActionNotFound{}, nil
		}
		h.service.logger.Error("Failed to check combat session",
			zap.String("session_id", sessionID.String()),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to check combat session")
	}

	if sessionStatus != "active" {
		h.service.logger.Warn("Combat session not active",
			zap.String("session_id", sessionID.String()),
			zap.String("status", sessionStatus))
		return &api.CombatServiceExecuteActionBadRequest{
			Data: api.Error{
				Code:    "SESSION_NOT_ACTIVE",
				Message: "Combat session is not active",
			},
		}, nil
	}

	// Step 2: Validate player is participant
	var participantList []string
	if len(participants) > 0 {
		if err := json.Unmarshal(participants, &participantList); err != nil {
			h.service.logger.Error("Failed to parse participants",
				zap.Error(err))
			return nil, errors.Wrap(err, "failed to parse participants")
		}
	}

	playerFound := false
	for _, participant := range participantList {
		if participant == req.PlayerID {
			playerFound = true
			break
		}
	}

	if !playerFound {
		h.service.logger.Warn("Player not in combat session",
			zap.String("session_id", sessionID.String()),
			zap.String("player_id", req.PlayerID))
		return &api.CombatServiceExecuteActionForbidden{
			Data: api.Error{
				Code:    "PLAYER_NOT_PARTICIPANT",
				Message: "Player is not a participant in this combat session",
			},
		}, nil
	}

	// Step 3: Validate action based on type
	if err := h.validateCombatAction(req); err != nil {
		h.service.logger.Warn("Invalid combat action",
			zap.String("action_type", req.ActionType),
			zap.Error(err))
		return &api.CombatServiceExecuteActionBadRequest{
			Data: api.Error{
				Code:    "INVALID_ACTION",
				Message: err.Error(),
			},
		}, nil
	}

	// Step 4: Execute action and calculate results
	actionResult, err := h.executeCombatAction(ctx, sessionID, req)
	if err != nil {
		h.service.logger.Error("Failed to execute combat action",
			zap.String("session_id", sessionID.String()),
			zap.String("action_type", req.ActionType),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to execute combat action")
	}

	// Step 5: Update session state in database
	if err := h.updateCombatSessionState(ctx, sessionID, actionResult); err != nil {
		h.service.logger.Error("Failed to update session state",
			zap.String("session_id", sessionID.String()),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to update session state")
	}

	actionID := uuid.New()
	h.service.logger.Info("Combat action executed successfully",
		zap.String("action_id", actionID.String()),
		zap.String("session_id", sessionID.String()),
		zap.String("action_type", req.ActionType),
		zap.String("player_id", req.PlayerID))

	return &api.CombatServiceExecuteActionOK{
		Data: &api.CombatActionResponse{
			ActionID:   actionID.String(),
			SessionID:  sessionID.String(),
			ActionType: req.ActionType,
			Status:     "executed",
			Result:     actionResult,
			Timestamp:  time.Now().Format(time.RFC3339),
		},
	}, nil
}

// CombatServiceGetSessionState retrieves real-time combat session state
// PERFORMANCE: Optimized for live combat state monitoring
func (h *Handler) CombatServiceGetSessionState(ctx context.Context, params api.CombatServiceGetSessionStateParams) (api.CombatServiceGetSessionStateRes, error) {
	ctx, cancel := h.withTimeout(ctx, "GetSessionState", 10*time.Second)
	defer cancel()

	sessionID, err := uuid.Parse(params.SessionID)
	if err != nil {
		return &api.CombatServiceGetSessionStateBadRequest{Error: "Invalid session ID"}, nil
	}

	h.service.logger.Info("Processing GetCombatSessionState request",
		zap.String("session_id", sessionID.String()))

	// Retrieve real-time session state from database
	query := `
		SELECT status, participants, spectators, current_round, max_rounds,
			   score, game_state, last_activity
		FROM combat.sessions
		WHERE session_id = $1
	`

	var sessionStatus string
	var participants, spectators, score, gameState []byte
	var currentRound, maxRounds int
	var lastActivity time.Time

	err = h.service.db.QueryRow(ctx, query, sessionID.String()).Scan(
		&sessionStatus, &participants, &spectators, &currentRound,
		&maxRounds, &score, &gameState, &lastActivity,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			h.service.logger.Info("Combat session not found",
				zap.String("session_id", sessionID.String()))
			return &api.CombatServiceGetSessionStateNotFound{}, nil
		}
		h.service.logger.Error("Failed to retrieve combat session state",
			zap.String("session_id", sessionID.String()),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to retrieve combat session state")
	}

	// Parse participants
	var participantList []string
	if len(participants) > 0 {
		if err := json.Unmarshal(participants, &participantList); err != nil {
			h.service.logger.Error("Failed to parse participants",
				zap.Error(err))
			return nil, errors.Wrap(err, "failed to parse participants")
		}
	}

	// Build participant states from game state
	participantsState := h.buildParticipantStates(participantList, gameState)

	// Parse game state for additional info
	var gameStateData map[string]interface{}
	if len(gameState) > 0 {
		if err := json.Unmarshal(gameState, &gameStateData); err != nil {
			h.service.logger.Warn("Failed to parse game state",
				zap.Error(err))
		}
	}

	// Calculate active effects and other real-time data
	activeEffects := h.extractActiveEffects(gameStateData)

	return &api.CombatServiceGetSessionStateOK{
		Data: &api.CombatSessionState{
			SessionID:     sessionID.String(),
			Status:        api.CombatSessionStateStatus(sessionStatus),
			CurrentRound:  currentRound,
			MaxRounds:     maxRounds,
			Participants:  participantsState,
			ActiveEffects: activeEffects,
			CurrentTurn: 1,
			Timestamp:   time.Now().Format(time.RFC3339),
		},
	}, nil
}

// Placeholder implementations for remaining operations
// TODO: Implement all combat operations with proper business logic

func (h *Handler) CombatServiceBatchHealthCheck(ctx context.Context, req *api.CombatServiceBatchHealthCheckReq) (api.CombatServiceBatchHealthCheckRes, error) {
	return &api.CombatServiceBatchHealthCheckOK{}, nil
}

func (h *Handler) CombatServiceCalculateDamage(ctx context.Context, req *api.DamageCalculationRequest) (api.CombatServiceCalculateDamageRes, error) {
	return &api.CombatServiceCalculateDamageOK{}, nil
}

func (h *Handler) CombatServiceGetWeaponAnalytics(ctx context.Context, params api.CombatServiceGetWeaponAnalyticsParams) (api.CombatServiceGetWeaponAnalyticsRes, error) {
	return &api.CombatServiceGetWeaponAnalyticsOK{}, nil
}

func (h *Handler) CombatServiceHealthCheck(ctx context.Context) (api.CombatServiceHealthCheckRes, error) {
	return &api.CombatServiceHealthCheckOK{}, nil
}

func (h *Handler) CombatServiceHealthWebSocket(ctx context.Context) (api.CombatServiceHealthWebSocketRes, error) {
	return &api.CombatServiceHealthWebSocketOK{}, nil
}

// validateCombatAction validates combat action based on type and parameters
func (h *Handler) validateCombatAction(req *api.CombatActionRequest) error {
	switch req.ActionType {
	case "attack":
		if req.TargetID.IsNull() {
			return errors.New("attack action requires target_id")
		}
	case "ability":
		if req.AbilityID.IsNull() {
			return errors.New("ability action requires ability_id")
		}
	case "move":
		if req.Position.IsNull() {
			return errors.New("move action requires position")
		}
	case "defend":
		// Defense doesn't require additional parameters
	case "item":
		if req.Parameters == nil {
			return errors.New("item action requires parameters")
		}
	default:
		return errors.New("unknown action type")
	}
	return nil
}

// executeCombatAction executes the combat action and calculates results
func (h *Handler) executeCombatAction(ctx context.Context, sessionID uuid.UUID, req *api.CombatActionRequest) (*api.CombatActionResult, error) {
	// Basic action execution logic - can be extended with complex combat mechanics
	result := &api.CombatActionResult{
		Success: true,
	}

	switch req.ActionType {
	case "attack":
		// Calculate damage based on attacker stats vs defender stats
		result.Damage = &api.CombatDamage{
			Amount:     25, // Placeholder damage calculation
			Type:       "physical",
			Critical:   false,
			Elemental:  nil,
		}
		result.Effects = []api.CombatEffect{} // No effects for basic attack

	case "ability":
		// Execute ability with effects
		result.Damage = &api.CombatDamage{
			Amount:     40, // Higher damage for abilities
			Type:       "magical",
			Critical:   true,
			Elemental:  &[]string{"fire"}[0],
		}
		result.Effects = []api.CombatEffect{
			{
				Type:       "burn",
				Duration:   3,
				Intensity:  5,
				Stackable:  true,
			},
		}

	case "move":
		// Movement action - no damage, just position update
		result.Damage = nil
		result.Effects = []api.CombatEffect{}

	case "defend":
		// Defense action - no damage, defensive buff
		result.Damage = nil
		result.Effects = []api.CombatEffect{
			{
				Type:       "defense_buff",
				Duration:   2,
				Intensity:  20, // 20% damage reduction
				Stackable:  false,
			},
		}

	case "item":
		// Item usage - varies by item type
		result.Damage = &api.CombatDamage{
			Amount:     30,
			Type:       "item",
			Critical:   false,
			Elemental:  nil,
		}
		result.Effects = []api.CombatEffect{
			{
				Type:       "heal",
				Duration:   1,
				Intensity:  15, // Heal 15 HP
				Stackable:  false,
			},
		}
	}

	return result, nil
}

// updateCombatSessionState updates the combat session state after action execution
func (h *Handler) updateCombatSessionState(ctx context.Context, sessionID uuid.UUID, result *api.CombatActionResult) error {
	// Update session last activity and game state
	updateQuery := `
		UPDATE combat.sessions
		SET last_activity = $1,
		    game_state = jsonb_set(
		        COALESCE(game_state, '{}'),
		        '{last_action}',
		        $2::jsonb
		    )
		WHERE session_id = $3
	`

	gameStateUpdate := map[string]interface{}{
		"timestamp": time.Now().Format(time.RFC3339),
		"result":    result,
	}

	gameStateJSON, err := json.Marshal(gameStateUpdate)
	if err != nil {
		return errors.Wrap(err, "failed to marshal game state update")
	}

	_, err = h.service.db.Exec(ctx, updateQuery, time.Now(), gameStateJSON, sessionID.String())
	if err != nil {
		return errors.Wrap(err, "failed to update session state")
	}

	return nil
}

// buildParticipantStates creates participant state objects from participant list and game state
func (h *Handler) buildParticipantStates(participantIDs []string, gameState []byte) []*api.CombatParticipant {
	participants := make([]*api.CombatParticipant, 0, len(participantIDs))

	// Parse game state for participant data
	var gameStateData map[string]interface{}
	if len(gameState) > 0 {
		if err := json.Unmarshal(gameState, &gameStateData); err != nil {
			h.service.logger.Warn("Failed to parse game state for participants",
				zap.Error(err))
		}
	}

	for _, participantID := range participantIDs {
		participant := &api.CombatParticipant{
			PlayerID:  participantID,
			Health:    1000, // Default max health
			MaxHealth: 1000,
			Position:  &api.Position{X: 0, Y: 0, Z: 0}, // Default position
		}

		// Try to get real data from game state
		if gameStateData != nil {
			if participantData, ok := gameStateData["participants"].(map[string]interface{}); ok {
				if playerData, ok := participantData[participantID].(map[string]interface{}); ok {
					if health, ok := playerData["health"].(float64); ok {
						participant.Health = int(health)
					}
					if maxHealth, ok := playerData["max_health"].(float64); ok {
						participant.MaxHealth = int(maxHealth)
					}
					if position, ok := playerData["position"].(map[string]interface{}); ok {
						if x, ok := position["x"].(float64); ok {
							participant.Position.X = float32(x)
						}
						if y, ok := position["y"].(float64); ok {
							participant.Position.Y = float32(y)
						}
						if z, ok := position["z"].(float64); ok {
							participant.Position.Z = float32(z)
						}
					}
				}
			}
		}

		participants = append(participants, participant)
	}

	return participants
}

// extractActiveEffects extracts active effects from game state
func (h *Handler) extractActiveEffects(gameStateData map[string]interface{}) []*api.CombatEffect {
	effects := []*api.CombatEffect{}

	if gameStateData == nil {
		return effects
	}

	// Extract effects from game state
	if effectsData, ok := gameStateData["active_effects"].([]interface{}); ok {
		for _, effectData := range effectsData {
			if effectMap, ok := effectData.(map[string]interface{}); ok {
				effect := &api.CombatEffect{}

				if effectType, ok := effectMap["type"].(string); ok {
					effect.Type = effectType
				}
				if duration, ok := effectMap["duration"].(float64); ok {
					effect.Duration = int(duration)
				}
				if intensity, ok := effectMap["intensity"].(float64); ok {
					effect.Intensity = int(intensity)
				}
				if stackable, ok := effectMap["stackable"].(bool); ok {
					effect.Stackable = stackable
				}

				effects = append(effects, effect)
			}
		}
	}

	return effects
}
