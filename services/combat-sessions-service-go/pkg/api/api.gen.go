// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ActionType.
const (
	ActionTypeAbility ActionType = "ability"
	ActionTypeAttack  ActionType = "attack"
	ActionTypeExtract ActionType = "extract"
	ActionTypeHeal    ActionType = "heal"
	ActionTypeMove    ActionType = "move"
	ActionTypeReload  ActionType = "reload"
	ActionTypeRevive  ActionType = "revive"
)

// Defines values for CombatLogEventType.
const (
	CombatLogEventTypeAbility CombatLogEventType = "ability"
	CombatLogEventTypeAttack  CombatLogEventType = "attack"
	CombatLogEventTypeDeath   CombatLogEventType = "death"
	CombatLogEventTypeExtract CombatLogEventType = "extract"
	CombatLogEventTypeMove    CombatLogEventType = "move"
	CombatLogEventTypeReload  CombatLogEventType = "reload"
)

// Defines values for Difficulty.
const (
	Elite  Difficulty = "elite"
	Hard   Difficulty = "hard"
	Normal Difficulty = "normal"
)

// Defines values for ParticipantRole.
const (
	Assault ParticipantRole = "assault"
	Stealth ParticipantRole = "stealth"
	Support ParticipantRole = "support"
	Tech    ParticipantRole = "tech"
)

// Defines values for ParticipantStatus.
const (
	ParticipantStatusAlive        ParticipantStatus = "alive"
	ParticipantStatusDead         ParticipantStatus = "dead"
	ParticipantStatusDisconnected ParticipantStatus = "disconnected"
	ParticipantStatusExtracted    ParticipantStatus = "extracted"
)

// Defines values for ParticipantTeam.
const (
	Solo  ParticipantTeam = "solo"
	TeamA ParticipantTeam = "team_a"
	TeamB ParticipantTeam = "team_b"
)

// Defines values for ParticipantStateStatus.
const (
	ParticipantStateStatusAlive        ParticipantStateStatus = "alive"
	ParticipantStateStatusDead         ParticipantStateStatus = "dead"
	ParticipantStateStatusDisconnected ParticipantStateStatus = "disconnected"
	ParticipantStateStatusExtracted    ParticipantStateStatus = "extracted"
)

// Defines values for SessionStatus.
const (
	Aborted SessionStatus = "aborted"
	Active  SessionStatus = "active"
	Ended   SessionStatus = "ended"
	Pending SessionStatus = "pending"
)

// Defines values for SessionType.
const (
	ExtractZone SessionType = "extract_zone"
	GuildWar    SessionType = "guild_war"
	PveRaid     SessionType = "pve_raid"
	PvpArena    SessionType = "pvp_arena"
)

// Defines values for StatusEffectEffectType.
const (
	Bleeding StatusEffectEffectType = "bleeding"
	Buffed   StatusEffectEffectType = "buffed"
	Burning  StatusEffectEffectType = "burning"
	Debuffed StatusEffectEffectType = "debuffed"
	Poisoned StatusEffectEffectType = "poisoned"
	Slowed   StatusEffectEffectType = "slowed"
	Stunned  StatusEffectEffectType = "stunned"
)

// ActionRequest defines model for ActionRequest.
type ActionRequest struct {
	AbilityId  *string             `json:"ability_id,omitempty"`
	ActionType ActionType          `json:"action_type"`
	Position   *Position3D         `json:"position,omitempty"`
	TargetId   *openapi_types.UUID `json:"target_id,omitempty"`
	WeaponId   *openapi_types.UUID `json:"weapon_id,omitempty"`
}

// ActionResponse defines model for ActionResponse.
type ActionResponse struct {
	ActionType     ActionType        `json:"action_type"`
	DamageDealt    *int              `json:"damage_dealt,omitempty"`
	EffectsApplied *[]StatusEffect   `json:"effects_applied,omitempty"`
	Success        bool              `json:"success"`
	Timestamp      time.Time         `json:"timestamp"`
	Validation     *ActionValidation `json:"validation,omitempty"`
}

// ActionType defines model for ActionType.
type ActionType string

// ActionValidation defines model for ActionValidation.
type ActionValidation struct {
	AntiCheatPassed bool    `json:"anti_cheat_passed"`
	CooldownValid   bool    `json:"cooldown_valid"`
	Details         *string `json:"details,omitempty"`
	PositionValid   bool    `json:"position_valid"`
}

// BaseEntity defines model for BaseEntity.
type BaseEntity struct {
	// Id Уникальный идентификатор
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// BaseEntityWithTimestamps defines model for BaseEntityWithTimestamps.
type BaseEntityWithTimestamps struct {
	// CreatedAt Дата создания
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt Дата истечения
	ExpiresAt *time.Time `json:"expires_at"`

	// Id Уникальный идентификатор
	Id *openapi_types.UUID `json:"id,omitempty"`

	// UpdatedAt Дата обновления
	UpdatedAt *time.Time `json:"updated_at"`
}

// CombatLog defines model for CombatLog.
type CombatLog struct {
	ActionData     *map[string]interface{} `json:"action_data,omitempty"`
	ActorId        *openapi_types.UUID     `json:"actor_id,omitempty"`
	EventType      CombatLogEventType      `json:"event_type"`
	Id             int64                   `json:"id"`
	ResultData     *map[string]interface{} `json:"result_data,omitempty"`
	SequenceNumber int64                   `json:"sequence_number"`
	TargetId       *openapi_types.UUID     `json:"target_id,omitempty"`
	Timestamp      time.Time               `json:"timestamp"`
}

// CombatLogEventType defines model for CombatLog.EventType.
type CombatLogEventType string

// CombatSessionResponse defines model for CombatSessionResponse.
type CombatSessionResponse struct {
	// CreatedAt Дата создания
	CreatedAt  *time.Time  `json:"created_at,omitempty"`
	Difficulty *Difficulty `json:"difficulty,omitempty"`

	// ExpiresAt Дата истечения
	ExpiresAt *time.Time `json:"expires_at"`

	// Id Уникальный идентификатор
	Id           *openapi_types.UUID `json:"id,omitempty"`
	Participants []Participant       `json:"participants"`
	SessionType  SessionType         `json:"session_type"`
	Status       SessionStatus       `json:"status"`

	// UpdatedAt Дата обновления
	UpdatedAt  *time.Time `json:"updated_at"`
	WinnerTeam *string    `json:"winner_team"`
	ZoneId     *string    `json:"zone_id,omitempty"`
}

// CombatState defines model for CombatState.
type CombatState struct {
	CurrentTurn       openapi_types.UUID `json:"current_turn"`
	ParticipantsState []ParticipantState `json:"participants_state"`
	SessionId         openapi_types.UUID `json:"session_id"`
	TurnNumber        *int               `json:"turn_number,omitempty"`
}

// CreateSessionRequest defines model for CreateSessionRequest.
type CreateSessionRequest struct {
	Difficulty   *Difficulty             `json:"difficulty,omitempty"`
	Participants []openapi_types.UUID    `json:"participants"`
	SessionType  SessionType             `json:"session_type"`
	Settings     *map[string]interface{} `json:"settings,omitempty"`
	ZoneId       *string                 `json:"zone_id,omitempty"`
}

// Difficulty defines model for Difficulty.
type Difficulty string

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// LogsResponse defines model for LogsResponse.
type LogsResponse struct {
	Logs       []CombatLog        `json:"logs"`
	Pagination PaginationResponse `json:"pagination"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// HasMore Есть ли еще элементы
	HasMore *bool `json:"has_more,omitempty"`

	// Items Список элементов
	Items []interface{} `json:"items"`

	// Limit Количество элементов на странице
	Limit *int `json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *int `json:"offset,omitempty"`

	// Total Общее количество элементов
	Total int `json:"total"`
}

// Participant defines model for Participant.
type Participant struct {
	Assists     *int               `json:"assists,omitempty"`
	CharacterId openapi_types.UUID `json:"character_id"`
	DamageDealt *int64             `json:"damage_dealt,omitempty"`
	DamageTaken *int64             `json:"damage_taken,omitempty"`
	Deaths      *int               `json:"deaths,omitempty"`
	HealingDone *int64             `json:"healing_done,omitempty"`
	Health      int                `json:"health"`
	Kills       *int               `json:"kills,omitempty"`
	MaxHealth   int                `json:"max_health"`
	PlayerId    openapi_types.UUID `json:"player_id"`
	Role        ParticipantRole    `json:"role"`
	Status      ParticipantStatus  `json:"status"`
	Team        ParticipantTeam    `json:"team"`
}

// ParticipantRole defines model for Participant.Role.
type ParticipantRole string

// ParticipantStatus defines model for Participant.Status.
type ParticipantStatus string

// ParticipantTeam defines model for Participant.Team.
type ParticipantTeam string

// ParticipantState defines model for ParticipantState.
type ParticipantState struct {
	ActiveEffects *[]StatusEffect        `json:"active_effects,omitempty"`
	Health        int                    `json:"health"`
	MaxHealth     *int                   `json:"max_health,omitempty"`
	PlayerId      openapi_types.UUID     `json:"player_id"`
	Position      *Position3D            `json:"position,omitempty"`
	Status        ParticipantStateStatus `json:"status"`
}

// ParticipantStateStatus defines model for ParticipantState.Status.
type ParticipantStateStatus string

// ParticipantStats defines model for ParticipantStats.
type ParticipantStats struct {
	Accuracy    *float32           `json:"accuracy,omitempty"`
	Assists     *int               `json:"assists,omitempty"`
	DamageDealt int64              `json:"damage_dealt"`
	DamageTaken *int64             `json:"damage_taken,omitempty"`
	Deaths      int                `json:"deaths"`
	HealingDone *int64             `json:"healing_done,omitempty"`
	Kills       int                `json:"kills"`
	PlayerId    openapi_types.UUID `json:"player_id"`
	ShotsFired  *int               `json:"shots_fired,omitempty"`
	ShotsHit    *int               `json:"shots_hit,omitempty"`
}

// Position3D defines model for Position3D.
type Position3D struct {
	// X Координата X
	X float32 `json:"x"`

	// Y Координата Y
	Y float32 `json:"y"`

	// Z Координата Z
	Z float32 `json:"z"`
}

// Reward defines model for Reward.
type Reward struct {
	Currency struct {
		Cryptos     *int `json:"cryptos,omitempty"`
		Eurodollars *int `json:"eurodollars,omitempty"`
	} `json:"currency"`
	Experience int `json:"experience"`
	Items      *[]struct {
		ItemId   openapi_types.UUID `json:"item_id"`
		Quantity int                `json:"quantity"`
	} `json:"items,omitempty"`
	PlayerId openapi_types.UUID `json:"player_id"`
}

// SessionEndResponse defines model for SessionEndResponse.
type SessionEndResponse struct {
	Rewards    *[]Reward          `json:"rewards,omitempty"`
	SessionId  openapi_types.UUID `json:"session_id"`
	Status     SessionStatus      `json:"status"`
	WinnerTeam *string            `json:"winner_team"`
}

// SessionListResponse defines model for SessionListResponse.
type SessionListResponse struct {
	Items      []SessionSummary   `json:"items"`
	Pagination PaginationResponse `json:"pagination"`
}

// SessionStatus defines model for SessionStatus.
type SessionStatus string

// SessionSummary defines model for SessionSummary.
type SessionSummary struct {
	CreatedAt        time.Time          `json:"created_at"`
	Id               openapi_types.UUID `json:"id"`
	ParticipantCount *int               `json:"participant_count,omitempty"`
	SessionType      SessionType        `json:"session_type"`
	Status           SessionStatus      `json:"status"`
}

// SessionType defines model for SessionType.
type SessionType string

// StatsResponse defines model for StatsResponse.
type StatsResponse struct {
	ParticipantsStats []ParticipantStats `json:"participants_stats"`
	SessionId         openapi_types.UUID `json:"session_id"`
	TotalDamage       *int64             `json:"total_damage,omitempty"`
}

// StatusEffect defines model for StatusEffect.
type StatusEffect struct {
	DurationSeconds int                    `json:"duration_seconds"`
	EffectType      StatusEffectEffectType `json:"effect_type"`
	Strength        *float32               `json:"strength,omitempty"`
}

// StatusEffectEffectType defines model for StatusEffect.EffectType.
type StatusEffectEffectType string

// TimestampFields defines model for TimestampFields.
type TimestampFields struct {
	// CreatedAt Дата создания
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt Дата истечения
	ExpiresAt *time.Time `json:"expires_at"`

	// UpdatedAt Дата обновления
	UpdatedAt *time.Time `json:"updated_at"`
}

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// SessionId defines model for SessionId.
type SessionId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListCombatSessionsParams defines parameters for ListCombatSessions.
type ListCombatSessionsParams struct {
	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset      *Offset        `form:"offset,omitempty" json:"offset,omitempty"`
	Status      *SessionStatus `form:"status,omitempty" json:"status,omitempty"`
	SessionType *SessionType   `form:"session_type,omitempty" json:"session_type,omitempty"`
}

// GetCombatLogsParams defines parameters for GetCombatLogs.
type GetCombatLogsParams struct {
	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateCombatSessionJSONRequestBody defines body for CreateCombatSession for application/json ContentType.
type CreateCombatSessionJSONRequestBody = CreateSessionRequest

// ExecuteCombatActionJSONRequestBody defines body for ExecuteCombatAction for application/json ContentType.
type ExecuteCombatActionJSONRequestBody = ActionRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Список сессий
	// (GET /gameplay/combat/sessions)
	ListCombatSessions(w http.ResponseWriter, r *http.Request, params ListCombatSessionsParams)
	// Создать боевую сессию
	// (POST /gameplay/combat/sessions)
	CreateCombatSession(w http.ResponseWriter, r *http.Request)
	// Завершить сессию
	// (DELETE /gameplay/combat/sessions/{sessionId})
	EndCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId)
	// Получить сессию
	// (GET /gameplay/combat/sessions/{sessionId})
	GetCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId)
	// Выполнить действие
	// (POST /gameplay/combat/sessions/{sessionId}/actions)
	ExecuteCombatAction(w http.ResponseWriter, r *http.Request, sessionId SessionId)
	// Логи сессии
	// (GET /gameplay/combat/sessions/{sessionId}/logs)
	GetCombatLogs(w http.ResponseWriter, r *http.Request, sessionId SessionId, params GetCombatLogsParams)
	// Получить realtime состояние
	// (GET /gameplay/combat/sessions/{sessionId}/state)
	GetCombatState(w http.ResponseWriter, r *http.Request, sessionId SessionId)
	// Статистика сессии
	// (GET /gameplay/combat/sessions/{sessionId}/stats)
	GetCombatStats(w http.ResponseWriter, r *http.Request, sessionId SessionId)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Список сессий
// (GET /gameplay/combat/sessions)
func (_ Unimplemented) ListCombatSessions(w http.ResponseWriter, r *http.Request, params ListCombatSessionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создать боевую сессию
// (POST /gameplay/combat/sessions)
func (_ Unimplemented) CreateCombatSession(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Завершить сессию
// (DELETE /gameplay/combat/sessions/{sessionId})
func (_ Unimplemented) EndCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить сессию
// (GET /gameplay/combat/sessions/{sessionId})
func (_ Unimplemented) GetCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Выполнить действие
// (POST /gameplay/combat/sessions/{sessionId}/actions)
func (_ Unimplemented) ExecuteCombatAction(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Логи сессии
// (GET /gameplay/combat/sessions/{sessionId}/logs)
func (_ Unimplemented) GetCombatLogs(w http.ResponseWriter, r *http.Request, sessionId SessionId, params GetCombatLogsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить realtime состояние
// (GET /gameplay/combat/sessions/{sessionId}/state)
func (_ Unimplemented) GetCombatState(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Статистика сессии
// (GET /gameplay/combat/sessions/{sessionId}/stats)
func (_ Unimplemented) GetCombatStats(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListCombatSessions operation middleware
func (siw *ServerInterfaceWrapper) ListCombatSessions(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCombatSessionsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "session_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_type", r.URL.Query(), &params.SessionType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "session_type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCombatSessions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateCombatSession operation middleware
func (siw *ServerInterfaceWrapper) CreateCombatSession(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCombatSession(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EndCombatSession operation middleware
func (siw *ServerInterfaceWrapper) EndCombatSession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EndCombatSession(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCombatSession operation middleware
func (siw *ServerInterfaceWrapper) GetCombatSession(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCombatSession(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExecuteCombatAction operation middleware
func (siw *ServerInterfaceWrapper) ExecuteCombatAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteCombatAction(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCombatLogs operation middleware
func (siw *ServerInterfaceWrapper) GetCombatLogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCombatLogsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCombatLogs(w, r, sessionId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCombatState operation middleware
func (siw *ServerInterfaceWrapper) GetCombatState(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCombatState(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCombatStats operation middleware
func (siw *ServerInterfaceWrapper) GetCombatStats(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCombatStats(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/combat/sessions", wrapper.ListCombatSessions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/combat/sessions", wrapper.CreateCombatSession)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/gameplay/combat/sessions/{sessionId}", wrapper.EndCombatSession)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/combat/sessions/{sessionId}", wrapper.GetCombatSession)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/combat/sessions/{sessionId}/actions", wrapper.ExecuteCombatAction)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/combat/sessions/{sessionId}/logs", wrapper.GetCombatLogs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/combat/sessions/{sessionId}/state", wrapper.GetCombatState)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/combat/sessions/{sessionId}/stats", wrapper.GetCombatStats)
	})

	return r
}

type BadRequestJSONResponse Error

type ForbiddenJSONResponse Error

type NotFoundJSONResponse Error

type UnauthorizedJSONResponse Error

type ListCombatSessionsRequestObject struct {
	Params ListCombatSessionsParams
}

type ListCombatSessionsResponseObject interface {
	VisitListCombatSessionsResponse(w http.ResponseWriter) error
}

type ListCombatSessions200JSONResponse SessionListResponse

func (response ListCombatSessions200JSONResponse) VisitListCombatSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateCombatSessionRequestObject struct {
	Body *CreateCombatSessionJSONRequestBody
}

type CreateCombatSessionResponseObject interface {
	VisitCreateCombatSessionResponse(w http.ResponseWriter) error
}

type CreateCombatSession201JSONResponse CombatSessionResponse

func (response CreateCombatSession201JSONResponse) VisitCreateCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateCombatSession400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateCombatSession400JSONResponse) VisitCreateCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateCombatSession401JSONResponse struct{ UnauthorizedJSONResponse }

func (response CreateCombatSession401JSONResponse) VisitCreateCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EndCombatSessionRequestObject struct {
	SessionId SessionId `json:"sessionId"`
}

type EndCombatSessionResponseObject interface {
	VisitEndCombatSessionResponse(w http.ResponseWriter) error
}

type EndCombatSession200JSONResponse SessionEndResponse

func (response EndCombatSession200JSONResponse) VisitEndCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type EndCombatSession403JSONResponse struct{ ForbiddenJSONResponse }

func (response EndCombatSession403JSONResponse) VisitEndCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetCombatSessionRequestObject struct {
	SessionId SessionId `json:"sessionId"`
}

type GetCombatSessionResponseObject interface {
	VisitGetCombatSessionResponse(w http.ResponseWriter) error
}

type GetCombatSession200JSONResponse CombatSessionResponse

func (response GetCombatSession200JSONResponse) VisitGetCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetCombatSession404JSONResponse struct{ NotFoundJSONResponse }

func (response GetCombatSession404JSONResponse) VisitGetCombatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ExecuteCombatActionRequestObject struct {
	SessionId SessionId `json:"sessionId"`
	Body      *ExecuteCombatActionJSONRequestBody
}

type ExecuteCombatActionResponseObject interface {
	VisitExecuteCombatActionResponse(w http.ResponseWriter) error
}

type ExecuteCombatAction200JSONResponse ActionResponse

func (response ExecuteCombatAction200JSONResponse) VisitExecuteCombatActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ExecuteCombatAction400JSONResponse struct{ BadRequestJSONResponse }

func (response ExecuteCombatAction400JSONResponse) VisitExecuteCombatActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ExecuteCombatAction403JSONResponse Error

func (response ExecuteCombatAction403JSONResponse) VisitExecuteCombatActionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetCombatLogsRequestObject struct {
	SessionId SessionId `json:"sessionId"`
	Params    GetCombatLogsParams
}

type GetCombatLogsResponseObject interface {
	VisitGetCombatLogsResponse(w http.ResponseWriter) error
}

type GetCombatLogs200JSONResponse LogsResponse

func (response GetCombatLogs200JSONResponse) VisitGetCombatLogsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetCombatStateRequestObject struct {
	SessionId SessionId `json:"sessionId"`
}

type GetCombatStateResponseObject interface {
	VisitGetCombatStateResponse(w http.ResponseWriter) error
}

type GetCombatState200JSONResponse CombatState

func (response GetCombatState200JSONResponse) VisitGetCombatStateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetCombatStatsRequestObject struct {
	SessionId SessionId `json:"sessionId"`
}

type GetCombatStatsResponseObject interface {
	VisitGetCombatStatsResponse(w http.ResponseWriter) error
}

type GetCombatStats200JSONResponse StatsResponse

func (response GetCombatStats200JSONResponse) VisitGetCombatStatsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Список сессий
	// (GET /gameplay/combat/sessions)
	ListCombatSessions(ctx context.Context, request ListCombatSessionsRequestObject) (ListCombatSessionsResponseObject, error)
	// Создать боевую сессию
	// (POST /gameplay/combat/sessions)
	CreateCombatSession(ctx context.Context, request CreateCombatSessionRequestObject) (CreateCombatSessionResponseObject, error)
	// Завершить сессию
	// (DELETE /gameplay/combat/sessions/{sessionId})
	EndCombatSession(ctx context.Context, request EndCombatSessionRequestObject) (EndCombatSessionResponseObject, error)
	// Получить сессию
	// (GET /gameplay/combat/sessions/{sessionId})
	GetCombatSession(ctx context.Context, request GetCombatSessionRequestObject) (GetCombatSessionResponseObject, error)
	// Выполнить действие
	// (POST /gameplay/combat/sessions/{sessionId}/actions)
	ExecuteCombatAction(ctx context.Context, request ExecuteCombatActionRequestObject) (ExecuteCombatActionResponseObject, error)
	// Логи сессии
	// (GET /gameplay/combat/sessions/{sessionId}/logs)
	GetCombatLogs(ctx context.Context, request GetCombatLogsRequestObject) (GetCombatLogsResponseObject, error)
	// Получить realtime состояние
	// (GET /gameplay/combat/sessions/{sessionId}/state)
	GetCombatState(ctx context.Context, request GetCombatStateRequestObject) (GetCombatStateResponseObject, error)
	// Статистика сессии
	// (GET /gameplay/combat/sessions/{sessionId}/stats)
	GetCombatStats(ctx context.Context, request GetCombatStatsRequestObject) (GetCombatStatsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ListCombatSessions operation middleware
func (sh *strictHandler) ListCombatSessions(w http.ResponseWriter, r *http.Request, params ListCombatSessionsParams) {
	var request ListCombatSessionsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListCombatSessions(ctx, request.(ListCombatSessionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListCombatSessions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListCombatSessionsResponseObject); ok {
		if err := validResponse.VisitListCombatSessionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateCombatSession operation middleware
func (sh *strictHandler) CreateCombatSession(w http.ResponseWriter, r *http.Request) {
	var request CreateCombatSessionRequestObject

	var body CreateCombatSessionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateCombatSession(ctx, request.(CreateCombatSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateCombatSession")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateCombatSessionResponseObject); ok {
		if err := validResponse.VisitCreateCombatSessionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EndCombatSession operation middleware
func (sh *strictHandler) EndCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	var request EndCombatSessionRequestObject

	request.SessionId = sessionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EndCombatSession(ctx, request.(EndCombatSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EndCombatSession")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EndCombatSessionResponseObject); ok {
		if err := validResponse.VisitEndCombatSessionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCombatSession operation middleware
func (sh *strictHandler) GetCombatSession(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	var request GetCombatSessionRequestObject

	request.SessionId = sessionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCombatSession(ctx, request.(GetCombatSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCombatSession")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCombatSessionResponseObject); ok {
		if err := validResponse.VisitGetCombatSessionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ExecuteCombatAction operation middleware
func (sh *strictHandler) ExecuteCombatAction(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	var request ExecuteCombatActionRequestObject

	request.SessionId = sessionId

	var body ExecuteCombatActionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ExecuteCombatAction(ctx, request.(ExecuteCombatActionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ExecuteCombatAction")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ExecuteCombatActionResponseObject); ok {
		if err := validResponse.VisitExecuteCombatActionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCombatLogs operation middleware
func (sh *strictHandler) GetCombatLogs(w http.ResponseWriter, r *http.Request, sessionId SessionId, params GetCombatLogsParams) {
	var request GetCombatLogsRequestObject

	request.SessionId = sessionId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCombatLogs(ctx, request.(GetCombatLogsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCombatLogs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCombatLogsResponseObject); ok {
		if err := validResponse.VisitGetCombatLogsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCombatState operation middleware
func (sh *strictHandler) GetCombatState(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	var request GetCombatStateRequestObject

	request.SessionId = sessionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCombatState(ctx, request.(GetCombatStateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCombatState")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCombatStateResponseObject); ok {
		if err := validResponse.VisitGetCombatStateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCombatStats operation middleware
func (sh *strictHandler) GetCombatStats(w http.ResponseWriter, r *http.Request, sessionId SessionId) {
	var request GetCombatStatsRequestObject

	request.SessionId = sessionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCombatStats(ctx, request.(GetCombatStatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCombatStats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCombatStatsResponseObject); ok {
		if err := validResponse.VisitGetCombatStatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
