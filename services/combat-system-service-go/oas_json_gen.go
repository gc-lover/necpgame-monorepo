// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AbilityConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("ability_type")
		s.AbilityType.Encode(e)
	}
	{
		e.FieldStart("power_level")
		e.Int(s.PowerLevel)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		e.FieldStart("resource_cost")
		e.Int(s.ResourceCost)
	}
	{
		if s.StatRequirements.Set {
			e.FieldStart("stat_requirements")
			s.StatRequirements.Encode(e)
		}
	}
	{
		if s.DamageScaling.Set {
			e.FieldStart("damage_scaling")
			s.DamageScaling.Encode(e)
		}
	}
	{
		if s.EffectModifiers != nil {
			e.FieldStart("effect_modifiers")
			e.ArrStart()
			for _, elem := range s.EffectModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TargetingRules.Set {
			e.FieldStart("targeting_rules")
			s.TargetingRules.Encode(e)
		}
	}
	{
		if s.BalanceNotes.Set {
			e.FieldStart("balance_notes")
			s.BalanceNotes.Encode(e)
		}
	}
	{
		if s.IsEnabled.Set {
			e.FieldStart("is_enabled")
			s.IsEnabled.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAbilityConfiguration = [15]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "ability_type",
	4:  "power_level",
	5:  "cooldown",
	6:  "resource_cost",
	7:  "stat_requirements",
	8:  "damage_scaling",
	9:  "effect_modifiers",
	10: "targeting_rules",
	11: "balance_notes",
	12: "is_enabled",
	13: "created_at",
	14: "updated_at",
}

// Decode decodes AbilityConfiguration from json.
func (s *AbilityConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfiguration to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "ability_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.AbilityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability_type\"")
			}
		case "power_level":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.PowerLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"power_level\"")
			}
		case "cooldown":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "resource_cost":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResourceCost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_cost\"")
			}
		case "stat_requirements":
			if err := func() error {
				s.StatRequirements.Reset()
				if err := s.StatRequirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stat_requirements\"")
			}
		case "damage_scaling":
			if err := func() error {
				s.DamageScaling.Reset()
				if err := s.DamageScaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_scaling\"")
			}
		case "effect_modifiers":
			if err := func() error {
				s.EffectModifiers = make([]AbilityEffect, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AbilityEffect
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EffectModifiers = append(s.EffectModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_modifiers\"")
			}
		case "targeting_rules":
			if err := func() error {
				s.TargetingRules.Reset()
				if err := s.TargetingRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targeting_rules\"")
			}
		case "balance_notes":
			if err := func() error {
				s.BalanceNotes.Reset()
				if err := s.BalanceNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_notes\"")
			}
		case "is_enabled":
			if err := func() error {
				s.IsEnabled.Reset()
				if err := s.IsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_enabled\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityConfiguration) {
					name = jsonFieldsNameOfAbilityConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationAbilityType as json.
func (s AbilityConfigurationAbilityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityConfigurationAbilityType from json.
func (s *AbilityConfigurationAbilityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationAbilityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityConfigurationAbilityType(v) {
	case AbilityConfigurationAbilityTypeOffensive:
		*s = AbilityConfigurationAbilityTypeOffensive
	case AbilityConfigurationAbilityTypeDefensive:
		*s = AbilityConfigurationAbilityTypeDefensive
	case AbilityConfigurationAbilityTypeUtility:
		*s = AbilityConfigurationAbilityTypeUtility
	case AbilityConfigurationAbilityTypeUltimate:
		*s = AbilityConfigurationAbilityTypeUltimate
	default:
		*s = AbilityConfigurationAbilityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationAbilityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationAbilityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationDamageScaling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationDamageScaling) encodeFields(e *jx.Encoder) {
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.DamageType.Set {
			e.FieldStart("damage_type")
			s.DamageType.Encode(e)
		}
	}
	{
		if s.ScalingStat.Set {
			e.FieldStart("scaling_stat")
			s.ScalingStat.Encode(e)
		}
	}
	{
		if s.ScalingFactor.Set {
			e.FieldStart("scaling_factor")
			s.ScalingFactor.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityConfigurationDamageScaling = [4]string{
	0: "base_damage",
	1: "damage_type",
	2: "scaling_stat",
	3: "scaling_factor",
}

// Decode decodes AbilityConfigurationDamageScaling from json.
func (s *AbilityConfigurationDamageScaling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationDamageScaling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "damage_type":
			if err := func() error {
				s.DamageType.Reset()
				if err := s.DamageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "scaling_stat":
			if err := func() error {
				s.ScalingStat.Reset()
				if err := s.ScalingStat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaling_stat\"")
			}
		case "scaling_factor":
			if err := func() error {
				s.ScalingFactor.Reset()
				if err := s.ScalingFactor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaling_factor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationDamageScaling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationDamageScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationDamageScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationDamageScalingDamageType as json.
func (s AbilityConfigurationDamageScalingDamageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityConfigurationDamageScalingDamageType from json.
func (s *AbilityConfigurationDamageScalingDamageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationDamageScalingDamageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityConfigurationDamageScalingDamageType(v) {
	case AbilityConfigurationDamageScalingDamageTypePhysical:
		*s = AbilityConfigurationDamageScalingDamageTypePhysical
	case AbilityConfigurationDamageScalingDamageTypeMagical:
		*s = AbilityConfigurationDamageScalingDamageTypeMagical
	case AbilityConfigurationDamageScalingDamageTypePure:
		*s = AbilityConfigurationDamageScalingDamageTypePure
	default:
		*s = AbilityConfigurationDamageScalingDamageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationDamageScalingDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationDamageScalingDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationDamageScalingScalingStat as json.
func (s AbilityConfigurationDamageScalingScalingStat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityConfigurationDamageScalingScalingStat from json.
func (s *AbilityConfigurationDamageScalingScalingStat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationDamageScalingScalingStat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityConfigurationDamageScalingScalingStat(v) {
	case AbilityConfigurationDamageScalingScalingStatStrength:
		*s = AbilityConfigurationDamageScalingScalingStatStrength
	case AbilityConfigurationDamageScalingScalingStatIntelligence:
		*s = AbilityConfigurationDamageScalingScalingStatIntelligence
	case AbilityConfigurationDamageScalingScalingStatDexterity:
		*s = AbilityConfigurationDamageScalingScalingStatDexterity
	default:
		*s = AbilityConfigurationDamageScalingScalingStat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationDamageScalingScalingStat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationDamageScalingScalingStat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationStatRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationStatRequirements) encodeFields(e *jx.Encoder) {
	{
		if s.MinimumLevel.Set {
			e.FieldStart("minimum_level")
			s.MinimumLevel.Encode(e)
		}
	}
	{
		if s.RequiredStats.Set {
			e.FieldStart("required_stats")
			s.RequiredStats.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityConfigurationStatRequirements = [2]string{
	0: "minimum_level",
	1: "required_stats",
}

// Decode decodes AbilityConfigurationStatRequirements from json.
func (s *AbilityConfigurationStatRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationStatRequirements to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minimum_level":
			if err := func() error {
				s.MinimumLevel.Reset()
				if err := s.MinimumLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_level\"")
			}
		case "required_stats":
			if err := func() error {
				s.RequiredStats.Reset()
				if err := s.RequiredStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationStatRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationStatRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationStatRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationStatRequirementsRequiredStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationStatRequirementsRequiredStats) encodeFields(e *jx.Encoder) {
	{
		if s.Strength.Set {
			e.FieldStart("strength")
			s.Strength.Encode(e)
		}
	}
	{
		if s.Intelligence.Set {
			e.FieldStart("intelligence")
			s.Intelligence.Encode(e)
		}
	}
	{
		if s.Dexterity.Set {
			e.FieldStart("dexterity")
			s.Dexterity.Encode(e)
		}
	}
	{
		if s.Wisdom.Set {
			e.FieldStart("wisdom")
			s.Wisdom.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityConfigurationStatRequirementsRequiredStats = [4]string{
	0: "strength",
	1: "intelligence",
	2: "dexterity",
	3: "wisdom",
}

// Decode decodes AbilityConfigurationStatRequirementsRequiredStats from json.
func (s *AbilityConfigurationStatRequirementsRequiredStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationStatRequirementsRequiredStats to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strength":
			if err := func() error {
				s.Strength.Reset()
				if err := s.Strength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strength\"")
			}
		case "intelligence":
			if err := func() error {
				s.Intelligence.Reset()
				if err := s.Intelligence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intelligence\"")
			}
		case "dexterity":
			if err := func() error {
				s.Dexterity.Reset()
				if err := s.Dexterity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dexterity\"")
			}
		case "wisdom":
			if err := func() error {
				s.Wisdom.Reset()
				if err := s.Wisdom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wisdom\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationStatRequirementsRequiredStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationStatRequirementsRequiredStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationStatRequirementsRequiredStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationTargetingRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationTargetingRules) encodeFields(e *jx.Encoder) {
	{
		if s.Range.Set {
			e.FieldStart("range")
			s.Range.Encode(e)
		}
	}
	{
		if s.TargetType.Set {
			e.FieldStart("target_type")
			s.TargetType.Encode(e)
		}
	}
	{
		if s.MaxTargets.Set {
			e.FieldStart("max_targets")
			s.MaxTargets.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityConfigurationTargetingRules = [3]string{
	0: "range",
	1: "target_type",
	2: "max_targets",
}

// Decode decodes AbilityConfigurationTargetingRules from json.
func (s *AbilityConfigurationTargetingRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationTargetingRules to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "range":
			if err := func() error {
				s.Range.Reset()
				if err := s.Range.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		case "target_type":
			if err := func() error {
				s.TargetType.Reset()
				if err := s.TargetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_type\"")
			}
		case "max_targets":
			if err := func() error {
				s.MaxTargets.Reset()
				if err := s.MaxTargets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_targets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationTargetingRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationTargetingRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationTargetingRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationTargetingRulesTargetType as json.
func (s AbilityConfigurationTargetingRulesTargetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityConfigurationTargetingRulesTargetType from json.
func (s *AbilityConfigurationTargetingRulesTargetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationTargetingRulesTargetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityConfigurationTargetingRulesTargetType(v) {
	case AbilityConfigurationTargetingRulesTargetTypeSelf:
		*s = AbilityConfigurationTargetingRulesTargetTypeSelf
	case AbilityConfigurationTargetingRulesTargetTypeSingleTarget:
		*s = AbilityConfigurationTargetingRulesTargetTypeSingleTarget
	case AbilityConfigurationTargetingRulesTargetTypeAoe:
		*s = AbilityConfigurationTargetingRulesTargetTypeAoe
	case AbilityConfigurationTargetingRulesTargetTypeLine:
		*s = AbilityConfigurationTargetingRulesTargetTypeLine
	case AbilityConfigurationTargetingRulesTargetTypeCone:
		*s = AbilityConfigurationTargetingRulesTargetTypeCone
	default:
		*s = AbilityConfigurationTargetingRulesTargetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationTargetingRulesTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationTargetingRulesTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("abilities")
		e.ArrStart()
		for _, elem := range s.Abilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfAbilityConfigurationsResponse = [2]string{
	0: "abilities",
	1: "pagination",
}

// Decode decodes AbilityConfigurationsResponse from json.
func (s *AbilityConfigurationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "abilities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Abilities = make([]AbilityConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AbilityConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Abilities = append(s.Abilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilities\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityConfigurationsResponse) {
					name = jsonFieldsNameOfAbilityConfigurationsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationsResponsePagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationsResponsePagination) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
	{
		if s.HasNext.Set {
			e.FieldStart("has_next")
			s.HasNext.Encode(e)
		}
	}
	{
		if s.HasPrevious.Set {
			e.FieldStart("has_previous")
			s.HasPrevious.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityConfigurationsResponsePagination = [6]string{
	0: "page",
	1: "limit",
	2: "total_count",
	3: "total_pages",
	4: "has_next",
	5: "has_previous",
}

// Decode decodes AbilityConfigurationsResponsePagination from json.
func (s *AbilityConfigurationsResponsePagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationsResponsePagination to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "has_next":
			if err := func() error {
				s.HasNext.Reset()
				if err := s.HasNext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_next\"")
			}
		case "has_previous":
			if err := func() error {
				s.HasPrevious.Reset()
				if err := s.HasPrevious.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_previous\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationsResponsePagination")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationsResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationsResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect_type")
		s.EffectType.Encode(e)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Magnitude.Set {
			e.FieldStart("magnitude")
			s.Magnitude.Encode(e)
		}
	}
	{
		if s.TickRate.Set {
			e.FieldStart("tick_rate")
			s.TickRate.Encode(e)
		}
	}
	{
		if s.StatModifier.Set {
			e.FieldStart("stat_modifier")
			s.StatModifier.Encode(e)
		}
	}
	{
		if s.Stacks.Set {
			e.FieldStart("stacks")
			s.Stacks.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbilityEffect = [6]string{
	0: "effect_type",
	1: "duration",
	2: "magnitude",
	3: "tick_rate",
	4: "stat_modifier",
	5: "stacks",
}

// Decode decodes AbilityEffect from json.
func (s *AbilityEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityEffect to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EffectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_type\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "magnitude":
			if err := func() error {
				s.Magnitude.Reset()
				if err := s.Magnitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magnitude\"")
			}
		case "tick_rate":
			if err := func() error {
				s.TickRate.Reset()
				if err := s.TickRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tick_rate\"")
			}
		case "stat_modifier":
			if err := func() error {
				s.StatModifier.Reset()
				if err := s.StatModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stat_modifier\"")
			}
		case "stacks":
			if err := func() error {
				s.Stacks.Reset()
				if err := s.Stacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityEffect) {
					name = jsonFieldsNameOfAbilityEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityEffectEffectType as json.
func (s AbilityEffectEffectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityEffectEffectType from json.
func (s *AbilityEffectEffectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityEffectEffectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityEffectEffectType(v) {
	case AbilityEffectEffectTypeDamageOverTime:
		*s = AbilityEffectEffectTypeDamageOverTime
	case AbilityEffectEffectTypeHealOverTime:
		*s = AbilityEffectEffectTypeHealOverTime
	case AbilityEffectEffectTypeBuff:
		*s = AbilityEffectEffectTypeBuff
	case AbilityEffectEffectTypeDebuff:
		*s = AbilityEffectEffectTypeDebuff
	case AbilityEffectEffectTypeStun:
		*s = AbilityEffectEffectTypeStun
	case AbilityEffectEffectTypeSilence:
		*s = AbilityEffectEffectTypeSilence
	case AbilityEffectEffectTypeRoot:
		*s = AbilityEffectEffectTypeRoot
	case AbilityEffectEffectTypeSpeedBoost:
		*s = AbilityEffectEffectTypeSpeedBoost
	default:
		*s = AbilityEffectEffectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityEffectEffectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityEffectEffectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityEffectStatModifier as json.
func (s AbilityEffectStatModifier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityEffectStatModifier from json.
func (s *AbilityEffectStatModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityEffectStatModifier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityEffectStatModifier(v) {
	case AbilityEffectStatModifierHealth:
		*s = AbilityEffectStatModifierHealth
	case AbilityEffectStatModifierDamage:
		*s = AbilityEffectStatModifierDamage
	case AbilityEffectStatModifierDefense:
		*s = AbilityEffectStatModifierDefense
	case AbilityEffectStatModifierSpeed:
		*s = AbilityEffectStatModifierSpeed
	case AbilityEffectStatModifierCriticalChance:
		*s = AbilityEffectStatModifierCriticalChance
	default:
		*s = AbilityEffectStatModifier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityEffectStatModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityEffectStatModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppliedModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppliedModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("modifier")
		s.Modifier.Encode(e)
	}
	{
		e.FieldStart("value_change")
		e.Float32(s.ValueChange)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppliedModifier = [3]string{
	0: "modifier",
	1: "value_change",
	2: "order",
}

// Decode decodes AppliedModifier from json.
func (s *AppliedModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppliedModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Modifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifier\"")
			}
		case "value_change":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.ValueChange = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_change\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppliedModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppliedModifier) {
					name = jsonFieldsNameOfAppliedModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppliedModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppliedModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalanceParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalanceParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("difficulty_scaling")
		s.DifficultyScaling.Encode(e)
	}
	{
		e.FieldStart("player_advantages")
		s.PlayerAdvantages.Encode(e)
	}
	{
		e.FieldStart("npc_modifiers")
		s.NpcModifiers.Encode(e)
	}
}

var jsonFieldsNameOfBalanceParameters = [3]string{
	0: "difficulty_scaling",
	1: "player_advantages",
	2: "npc_modifiers",
}

// Decode decodes BalanceParameters from json.
func (s *BalanceParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalanceParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "difficulty_scaling":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DifficultyScaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_scaling\"")
			}
		case "player_advantages":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PlayerAdvantages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_advantages\"")
			}
		case "npc_modifiers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.NpcModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalanceParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalanceParameters) {
					name = jsonFieldsNameOfBalanceParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalanceParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalanceParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalanceParametersDifficultyScaling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalanceParametersDifficultyScaling) encodeFields(e *jx.Encoder) {
	{
		if s.ScalingFactor.Set {
			e.FieldStart("scaling_factor")
			s.ScalingFactor.Encode(e)
		}
	}
	{
		if s.LevelDifferenceModifier.Set {
			e.FieldStart("level_difference_modifier")
			s.LevelDifferenceModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfBalanceParametersDifficultyScaling = [2]string{
	0: "scaling_factor",
	1: "level_difference_modifier",
}

// Decode decodes BalanceParametersDifficultyScaling from json.
func (s *BalanceParametersDifficultyScaling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalanceParametersDifficultyScaling to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scaling_factor":
			if err := func() error {
				s.ScalingFactor.Reset()
				if err := s.ScalingFactor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaling_factor\"")
			}
		case "level_difference_modifier":
			if err := func() error {
				s.LevelDifferenceModifier.Reset()
				if err := s.LevelDifferenceModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level_difference_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalanceParametersDifficultyScaling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalanceParametersDifficultyScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalanceParametersDifficultyScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalanceParametersNpcModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalanceParametersNpcModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.EliteMultiplier.Set {
			e.FieldStart("elite_multiplier")
			s.EliteMultiplier.Encode(e)
		}
	}
	{
		if s.BossMultiplier.Set {
			e.FieldStart("boss_multiplier")
			s.BossMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfBalanceParametersNpcModifiers = [2]string{
	0: "elite_multiplier",
	1: "boss_multiplier",
}

// Decode decodes BalanceParametersNpcModifiers from json.
func (s *BalanceParametersNpcModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalanceParametersNpcModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elite_multiplier":
			if err := func() error {
				s.EliteMultiplier.Reset()
				if err := s.EliteMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elite_multiplier\"")
			}
		case "boss_multiplier":
			if err := func() error {
				s.BossMultiplier.Reset()
				if err := s.BossMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boss_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalanceParametersNpcModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalanceParametersNpcModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalanceParametersNpcModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalanceParametersPlayerAdvantages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalanceParametersPlayerAdvantages) encodeFields(e *jx.Encoder) {
	{
		if s.FirstStrikeBonus.Set {
			e.FieldStart("first_strike_bonus")
			s.FirstStrikeBonus.Encode(e)
		}
	}
	{
		if s.PositionalAdvantage.Set {
			e.FieldStart("positional_advantage")
			s.PositionalAdvantage.Encode(e)
		}
	}
}

var jsonFieldsNameOfBalanceParametersPlayerAdvantages = [2]string{
	0: "first_strike_bonus",
	1: "positional_advantage",
}

// Decode decodes BalanceParametersPlayerAdvantages from json.
func (s *BalanceParametersPlayerAdvantages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalanceParametersPlayerAdvantages to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "first_strike_bonus":
			if err := func() error {
				s.FirstStrikeBonus.Reset()
				if err := s.FirstStrikeBonus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_strike_bonus\"")
			}
		case "positional_advantage":
			if err := func() error {
				s.PositionalAdvantage.Reset()
				if err := s.PositionalAdvantage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positional_advantage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalanceParametersPlayerAdvantages")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalanceParametersPlayerAdvantages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalanceParametersPlayerAdvantages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterBalance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("class_modifiers")
		e.ArrStart()
		for _, elem := range s.ClassModifiers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("level_scaling")
		s.LevelScaling.Encode(e)
	}
	{
		if s.StatProgression.Set {
			e.FieldStart("stat_progression")
			s.StatProgression.Encode(e)
		}
	}
}

var jsonFieldsNameOfCharacterBalance = [3]string{
	0: "class_modifiers",
	1: "level_scaling",
	2: "stat_progression",
}

// Decode decodes CharacterBalance from json.
func (s *CharacterBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "class_modifiers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ClassModifiers = make([]ClassModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClassModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClassModifiers = append(s.ClassModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"class_modifiers\"")
			}
		case "level_scaling":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LevelScaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level_scaling\"")
			}
		case "stat_progression":
			if err := func() error {
				s.StatProgression.Reset()
				if err := s.StatProgression.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stat_progression\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterBalance) {
					name = jsonFieldsNameOfCharacterBalance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterBalanceLevelScaling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterBalanceLevelScaling) encodeFields(e *jx.Encoder) {
	{
		if s.ScalingCurve.Set {
			e.FieldStart("scaling_curve")
			s.ScalingCurve.Encode(e)
		}
	}
	{
		if s.MaxLevel.Set {
			e.FieldStart("max_level")
			s.MaxLevel.Encode(e)
		}
	}
	{
		if s.PowerCurve.Set {
			e.FieldStart("power_curve")
			s.PowerCurve.Encode(e)
		}
	}
}

var jsonFieldsNameOfCharacterBalanceLevelScaling = [3]string{
	0: "scaling_curve",
	1: "max_level",
	2: "power_curve",
}

// Decode decodes CharacterBalanceLevelScaling from json.
func (s *CharacterBalanceLevelScaling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalanceLevelScaling to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scaling_curve":
			if err := func() error {
				s.ScalingCurve.Reset()
				if err := s.ScalingCurve.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaling_curve\"")
			}
		case "max_level":
			if err := func() error {
				s.MaxLevel.Reset()
				if err := s.MaxLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_level\"")
			}
		case "power_curve":
			if err := func() error {
				s.PowerCurve.Reset()
				if err := s.PowerCurve.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"power_curve\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalanceLevelScaling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterBalanceLevelScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalanceLevelScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalanceLevelScalingScalingCurve as json.
func (s CharacterBalanceLevelScalingScalingCurve) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterBalanceLevelScalingScalingCurve from json.
func (s *CharacterBalanceLevelScalingScalingCurve) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalanceLevelScalingScalingCurve to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterBalanceLevelScalingScalingCurve(v) {
	case CharacterBalanceLevelScalingScalingCurveLinear:
		*s = CharacterBalanceLevelScalingScalingCurveLinear
	case CharacterBalanceLevelScalingScalingCurveExponential:
		*s = CharacterBalanceLevelScalingScalingCurveExponential
	case CharacterBalanceLevelScalingScalingCurveLogarithmic:
		*s = CharacterBalanceLevelScalingScalingCurveLogarithmic
	default:
		*s = CharacterBalanceLevelScalingScalingCurve(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterBalanceLevelScalingScalingCurve) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalanceLevelScalingScalingCurve) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterBalanceStatProgression) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterBalanceStatProgression) encodeFields(e *jx.Encoder) {
	{
		if s.HealthPerLevel.Set {
			e.FieldStart("health_per_level")
			s.HealthPerLevel.Encode(e)
		}
	}
	{
		if s.DamagePerLevel.Set {
			e.FieldStart("damage_per_level")
			s.DamagePerLevel.Encode(e)
		}
	}
	{
		if s.DefensePerLevel.Set {
			e.FieldStart("defense_per_level")
			s.DefensePerLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfCharacterBalanceStatProgression = [3]string{
	0: "health_per_level",
	1: "damage_per_level",
	2: "defense_per_level",
}

// Decode decodes CharacterBalanceStatProgression from json.
func (s *CharacterBalanceStatProgression) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalanceStatProgression to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_per_level":
			if err := func() error {
				s.HealthPerLevel.Reset()
				if err := s.HealthPerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_per_level\"")
			}
		case "damage_per_level":
			if err := func() error {
				s.DamagePerLevel.Reset()
				if err := s.DamagePerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_per_level\"")
			}
		case "defense_per_level":
			if err := func() error {
				s.DefensePerLevel.Reset()
				if err := s.DefensePerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defense_per_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalanceStatProgression")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterBalanceStatProgression) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalanceStatProgression) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClassModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClassModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("class_name")
		s.ClassName.Encode(e)
	}
	{
		e.FieldStart("damage_modifier")
		e.Float32(s.DamageModifier)
	}
	{
		e.FieldStart("defense_modifier")
		e.Float32(s.DefenseModifier)
	}
	{
		if s.HealthModifier.Set {
			e.FieldStart("health_modifier")
			s.HealthModifier.Encode(e)
		}
	}
	{
		if s.SpecialAbilitiesModifier.Set {
			e.FieldStart("special_abilities_modifier")
			s.SpecialAbilitiesModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfClassModifier = [5]string{
	0: "class_name",
	1: "damage_modifier",
	2: "defense_modifier",
	3: "health_modifier",
	4: "special_abilities_modifier",
}

// Decode decodes ClassModifier from json.
func (s *ClassModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClassModifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "class_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"class_name\"")
			}
		case "damage_modifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.DamageModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_modifier\"")
			}
		case "defense_modifier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.DefenseModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defense_modifier\"")
			}
		case "health_modifier":
			if err := func() error {
				s.HealthModifier.Reset()
				if err := s.HealthModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_modifier\"")
			}
		case "special_abilities_modifier":
			if err := func() error {
				s.SpecialAbilitiesModifier.Reset()
				if err := s.SpecialAbilitiesModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_abilities_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClassModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClassModifier) {
					name = jsonFieldsNameOfClassModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClassModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClassModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClassModifierClassName as json.
func (s ClassModifierClassName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClassModifierClassName from json.
func (s *ClassModifierClassName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClassModifierClassName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClassModifierClassName(v) {
	case ClassModifierClassNameWarrior:
		*s = ClassModifierClassNameWarrior
	case ClassModifierClassNameMage:
		*s = ClassModifierClassNameMage
	case ClassModifierClassNameRogue:
		*s = ClassModifierClassNameRogue
	case ClassModifierClassNameRanger:
		*s = ClassModifierClassNameRanger
	case ClassModifierClassNamePaladin:
		*s = ClassModifierClassNamePaladin
	case ClassModifierClassNameNecromancer:
		*s = ClassModifierClassNameNecromancer
	default:
		*s = ClassModifierClassName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClassModifierClassName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClassModifierClassName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatBalanceConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatBalanceConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		e.FieldStart("global_multipliers")
		s.GlobalMultipliers.Encode(e)
	}
	{
		e.FieldStart("character_balance")
		s.CharacterBalance.Encode(e)
	}
	{
		e.FieldStart("environment_balance")
		s.EnvironmentBalance.Encode(e)
	}
	{
		if s.FactionModifiers != nil {
			e.FieldStart("faction_modifiers")
			e.ArrStart()
			for _, elem := range s.FactionModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RegionModifiers != nil {
			e.FieldStart("region_modifiers")
			e.ArrStart()
			for _, elem := range s.RegionModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCombatBalanceConfig = [9]string{
	0: "id",
	1: "version",
	2: "global_multipliers",
	3: "character_balance",
	4: "environment_balance",
	5: "faction_modifiers",
	6: "region_modifiers",
	7: "created_at",
	8: "updated_at",
}

// Decode decodes CombatBalanceConfig from json.
func (s *CombatBalanceConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatBalanceConfig to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "global_multipliers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.GlobalMultipliers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"global_multipliers\"")
			}
		case "character_balance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CharacterBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_balance\"")
			}
		case "environment_balance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EnvironmentBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_balance\"")
			}
		case "faction_modifiers":
			if err := func() error {
				s.FactionModifiers = make([]FactionModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactionModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FactionModifiers = append(s.FactionModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_modifiers\"")
			}
		case "region_modifiers":
			if err := func() error {
				s.RegionModifiers = make([]RegionModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RegionModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RegionModifiers = append(s.RegionModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region_modifiers\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatBalanceConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatBalanceConfig) {
					name = jsonFieldsNameOfCombatBalanceConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatBalanceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatBalanceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatMechanics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatMechanics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("turn_based_enabled")
		e.Bool(s.TurnBasedEnabled)
	}
	{
		e.FieldStart("action_points_system")
		s.ActionPointsSystem.Encode(e)
	}
	{
		e.FieldStart("interruption_rules")
		s.InterruptionRules.Encode(e)
	}
}

var jsonFieldsNameOfCombatMechanics = [3]string{
	0: "turn_based_enabled",
	1: "action_points_system",
	2: "interruption_rules",
}

// Decode decodes CombatMechanics from json.
func (s *CombatMechanics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatMechanics to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "turn_based_enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.TurnBasedEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turn_based_enabled\"")
			}
		case "action_points_system":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ActionPointsSystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_points_system\"")
			}
		case "interruption_rules":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.InterruptionRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interruption_rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatMechanics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatMechanics) {
					name = jsonFieldsNameOfCombatMechanics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatMechanics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatMechanics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatMechanicsActionPointsSystem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatMechanicsActionPointsSystem) encodeFields(e *jx.Encoder) {
	{
		if s.MaxActionPoints.Set {
			e.FieldStart("max_action_points")
			s.MaxActionPoints.Encode(e)
		}
	}
	{
		if s.PointsPerTurn.Set {
			e.FieldStart("points_per_turn")
			s.PointsPerTurn.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatMechanicsActionPointsSystem = [2]string{
	0: "max_action_points",
	1: "points_per_turn",
}

// Decode decodes CombatMechanicsActionPointsSystem from json.
func (s *CombatMechanicsActionPointsSystem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatMechanicsActionPointsSystem to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_action_points":
			if err := func() error {
				s.MaxActionPoints.Reset()
				if err := s.MaxActionPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_action_points\"")
			}
		case "points_per_turn":
			if err := func() error {
				s.PointsPerTurn.Reset()
				if err := s.PointsPerTurn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_per_turn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatMechanicsActionPointsSystem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatMechanicsActionPointsSystem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatMechanicsActionPointsSystem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatMechanicsInterruptionRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatMechanicsInterruptionRules) encodeFields(e *jx.Encoder) {
	{
		if s.AllowInterruptions.Set {
			e.FieldStart("allow_interruptions")
			s.AllowInterruptions.Encode(e)
		}
	}
	{
		if s.InterruptionPenalty.Set {
			e.FieldStart("interruption_penalty")
			s.InterruptionPenalty.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatMechanicsInterruptionRules = [2]string{
	0: "allow_interruptions",
	1: "interruption_penalty",
}

// Decode decodes CombatMechanicsInterruptionRules from json.
func (s *CombatMechanicsInterruptionRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatMechanicsInterruptionRules to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_interruptions":
			if err := func() error {
				s.AllowInterruptions.Reset()
				if err := s.AllowInterruptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_interruptions\"")
			}
		case "interruption_penalty":
			if err := func() error {
				s.InterruptionPenalty.Reset()
				if err := s.InterruptionPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interruption_penalty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatMechanicsInterruptionRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatMechanicsInterruptionRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatMechanicsInterruptionRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemRules) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		e.FieldStart("damage_rules")
		s.DamageRules.Encode(e)
	}
	{
		e.FieldStart("combat_mechanics")
		s.CombatMechanics.Encode(e)
	}
	{
		e.FieldStart("balance_parameters")
		s.BalanceParameters.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemRules = [8]string{
	0: "id",
	1: "version",
	2: "damage_rules",
	3: "combat_mechanics",
	4: "balance_parameters",
	5: "created_at",
	6: "updated_at",
	7: "created_by",
}

// Decode decodes CombatSystemRules from json.
func (s *CombatSystemRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "damage_rules":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DamageRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_rules\"")
			}
		case "combat_mechanics":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CombatMechanics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_mechanics\"")
			}
		case "balance_parameters":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BalanceParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_parameters\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemRules) {
					name = jsonFieldsNameOfCombatSystemRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceCalculateDamageBadRequest from json.
func (s *CombatSystemServiceCalculateDamageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceCalculateDamageBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceCalculateDamageBadRequest) {
					name = jsonFieldsNameOfCombatSystemServiceCalculateDamageBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageBadRequestDetails = [0]string{}

// Decode decodes CombatSystemServiceCalculateDamageBadRequestDetails from json.
func (s *CombatSystemServiceCalculateDamageBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageInternalServerError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceCalculateDamageInternalServerError from json.
func (s *CombatSystemServiceCalculateDamageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceCalculateDamageInternalServerErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceCalculateDamageInternalServerError) {
					name = jsonFieldsNameOfCombatSystemServiceCalculateDamageInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageInternalServerErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageInternalServerErrorDetails = [0]string{}

// Decode decodes CombatSystemServiceCalculateDamageInternalServerErrorDetails from json.
func (s *CombatSystemServiceCalculateDamageInternalServerErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageInternalServerErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageInternalServerErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageInternalServerErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceCalculateDamageTooManyRequests from json.
func (s *CombatSystemServiceCalculateDamageTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceCalculateDamageTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceCalculateDamageTooManyRequests) {
					name = jsonFieldsNameOfCombatSystemServiceCalculateDamageTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageTooManyRequestsDetails = [0]string{}

// Decode decodes CombatSystemServiceCalculateDamageTooManyRequestsDetails from json.
func (s *CombatSystemServiceCalculateDamageTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceCalculateDamageUnauthorized from json.
func (s *CombatSystemServiceCalculateDamageUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceCalculateDamageUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceCalculateDamageUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceCalculateDamageUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceCalculateDamageUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceCalculateDamageUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceCalculateDamageUnauthorizedDetails from json.
func (s *CombatSystemServiceCalculateDamageUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceCalculateDamageUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceCalculateDamageUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceCalculateDamageUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceGetBalanceUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceGetBalanceUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceGetBalanceUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceGetBalanceUnauthorized from json.
func (s *CombatSystemServiceGetBalanceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceGetBalanceUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceGetBalanceUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceGetBalanceUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceGetBalanceUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceGetBalanceUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceGetBalanceUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceGetBalanceUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceGetBalanceUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceGetBalanceUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceGetBalanceUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceGetBalanceUnauthorizedDetails from json.
func (s *CombatSystemServiceGetBalanceUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceGetBalanceUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceGetBalanceUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceGetBalanceUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceGetBalanceUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceGetRulesUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceGetRulesUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceGetRulesUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceGetRulesUnauthorized from json.
func (s *CombatSystemServiceGetRulesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceGetRulesUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceGetRulesUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceGetRulesUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceGetRulesUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceGetRulesUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceGetRulesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceGetRulesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceGetRulesUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceGetRulesUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceGetRulesUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceGetRulesUnauthorizedDetails from json.
func (s *CombatSystemServiceGetRulesUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceGetRulesUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceGetRulesUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceGetRulesUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceGetRulesUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Uptime.Set {
			e.FieldStart("uptime")
			s.Uptime.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckOK = [6]string{
	0: "status",
	1: "message",
	2: "timestamp",
	3: "version",
	4: "uptime",
	5: "checks",
}

// Decode decodes CombatSystemServiceHealthCheckOK from json.
func (s *CombatSystemServiceHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime":
			if err := func() error {
				s.Uptime.Reset()
				if err := s.Uptime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceHealthCheckOK) {
					name = jsonFieldsNameOfCombatSystemServiceHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CombatSystemServiceHealthCheckOKChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CombatSystemServiceHealthCheckOKChecks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CombatSystemServiceHealthCheckOKChecks from json.
func (s *CombatSystemServiceHealthCheckOKChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOKChecks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem CombatSystemServiceHealthCheckOKChecksItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckOKChecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckOKChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOKChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckOKChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckOKChecksItem) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ResponseTime.Set {
			e.FieldStart("response_time")
			s.ResponseTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckOKChecksItem = [3]string{
	0: "status",
	1: "message",
	2: "response_time",
}

// Decode decodes CombatSystemServiceHealthCheckOKChecksItem from json.
func (s *CombatSystemServiceHealthCheckOKChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOKChecksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "response_time":
			if err := func() error {
				s.ResponseTime.Reset()
				if err := s.ResponseTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckOKChecksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckOKChecksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOKChecksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckOKChecksItemStatus as json.
func (s CombatSystemServiceHealthCheckOKChecksItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatSystemServiceHealthCheckOKChecksItemStatus from json.
func (s *CombatSystemServiceHealthCheckOKChecksItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOKChecksItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatSystemServiceHealthCheckOKChecksItemStatus(v) {
	case CombatSystemServiceHealthCheckOKChecksItemStatusOk:
		*s = CombatSystemServiceHealthCheckOKChecksItemStatusOk
	case CombatSystemServiceHealthCheckOKChecksItemStatusDegraded:
		*s = CombatSystemServiceHealthCheckOKChecksItemStatusDegraded
	case CombatSystemServiceHealthCheckOKChecksItemStatusCritical:
		*s = CombatSystemServiceHealthCheckOKChecksItemStatusCritical
	default:
		*s = CombatSystemServiceHealthCheckOKChecksItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckOKChecksItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOKChecksItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckOKStatus as json.
func (s CombatSystemServiceHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatSystemServiceHealthCheckOKStatus from json.
func (s *CombatSystemServiceHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatSystemServiceHealthCheckOKStatus(v) {
	case CombatSystemServiceHealthCheckOKStatusOk:
		*s = CombatSystemServiceHealthCheckOKStatusOk
	case CombatSystemServiceHealthCheckOKStatusDegraded:
		*s = CombatSystemServiceHealthCheckOKStatusDegraded
	case CombatSystemServiceHealthCheckOKStatusCritical:
		*s = CombatSystemServiceHealthCheckOKStatusCritical
	default:
		*s = CombatSystemServiceHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Uptime.Set {
			e.FieldStart("uptime")
			s.Uptime.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckServiceUnavailable = [6]string{
	0: "status",
	1: "message",
	2: "timestamp",
	3: "version",
	4: "uptime",
	5: "checks",
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailable from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime":
			if err := func() error {
				s.Uptime.Reset()
				if err := s.Uptime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckServiceUnavailable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceHealthCheckServiceUnavailable) {
					name = jsonFieldsNameOfCombatSystemServiceHealthCheckServiceUnavailable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CombatSystemServiceHealthCheckServiceUnavailableChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CombatSystemServiceHealthCheckServiceUnavailableChecks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableChecks from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailableChecks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem CombatSystemServiceHealthCheckServiceUnavailableChecksItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckServiceUnavailableChecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckServiceUnavailableChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItem) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ResponseTime.Set {
			e.FieldStart("response_time")
			s.ResponseTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckServiceUnavailableChecksItem = [3]string{
	0: "status",
	1: "message",
	2: "response_time",
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableChecksItem from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailableChecksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "response_time":
			if err := func() error {
				s.ResponseTime.Reset()
				if err := s.ResponseTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckServiceUnavailableChecksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus as json.
func (s CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus(v) {
	case CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusOk:
		*s = CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusOk
	case CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusDegraded:
		*s = CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusDegraded
	case CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusCritical:
		*s = CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatusCritical
	default:
		*s = CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckServiceUnavailableStatus as json.
func (s CombatSystemServiceHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableStatus from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CombatSystemServiceHealthCheckServiceUnavailableStatus(v) {
	case CombatSystemServiceHealthCheckServiceUnavailableStatusOk:
		*s = CombatSystemServiceHealthCheckServiceUnavailableStatusOk
	case CombatSystemServiceHealthCheckServiceUnavailableStatusDegraded:
		*s = CombatSystemServiceHealthCheckServiceUnavailableStatusDegraded
	case CombatSystemServiceHealthCheckServiceUnavailableStatusCritical:
		*s = CombatSystemServiceHealthCheckServiceUnavailableStatusCritical
	default:
		*s = CombatSystemServiceHealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceHealthCheckTooManyRequests from json.
func (s *CombatSystemServiceHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfCombatSystemServiceHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes CombatSystemServiceHealthCheckTooManyRequestsDetails from json.
func (s *CombatSystemServiceHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceListAbilitiesUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceListAbilitiesUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceListAbilitiesUnauthorized from json.
func (s *CombatSystemServiceListAbilitiesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceListAbilitiesUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceListAbilitiesUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceListAbilitiesUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceListAbilitiesUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceListAbilitiesUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceListAbilitiesUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceListAbilitiesUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceListAbilitiesUnauthorizedDetails from json.
func (s *CombatSystemServiceListAbilitiesUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceListAbilitiesUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceListAbilitiesUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceListAbilitiesUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateBalanceBadRequest from json.
func (s *CombatSystemServiceUpdateBalanceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateBalanceBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateBalanceBadRequest) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateBalanceBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceBadRequestDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateBalanceBadRequestDetails from json.
func (s *CombatSystemServiceUpdateBalanceBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceUpdateBalanceConflictApplicationJSON as json.
func (s CombatSystemServiceUpdateBalanceConflictApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes CombatSystemServiceUpdateBalanceConflictApplicationJSON from json.
func (s *CombatSystemServiceUpdateBalanceConflictApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceConflictApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CombatSystemServiceUpdateBalanceConflictApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceUpdateBalanceConflictApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceConflictApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateBalanceTooManyRequests from json.
func (s *CombatSystemServiceUpdateBalanceTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateBalanceTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateBalanceTooManyRequests) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateBalanceTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceTooManyRequestsDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateBalanceTooManyRequestsDetails from json.
func (s *CombatSystemServiceUpdateBalanceTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateBalanceUnauthorized from json.
func (s *CombatSystemServiceUpdateBalanceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateBalanceUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateBalanceUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateBalanceUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateBalanceUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateBalanceUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateBalanceUnauthorizedDetails from json.
func (s *CombatSystemServiceUpdateBalanceUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateBalanceUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateBalanceUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateBalanceUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateRulesBadRequest from json.
func (s *CombatSystemServiceUpdateRulesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateRulesBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateRulesBadRequest) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateRulesBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesBadRequestDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateRulesBadRequestDetails from json.
func (s *CombatSystemServiceUpdateRulesBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceUpdateRulesConflictApplicationJSON as json.
func (s CombatSystemServiceUpdateRulesConflictApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes CombatSystemServiceUpdateRulesConflictApplicationJSON from json.
func (s *CombatSystemServiceUpdateRulesConflictApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesConflictApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CombatSystemServiceUpdateRulesConflictApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CombatSystemServiceUpdateRulesConflictApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesConflictApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateRulesTooManyRequests from json.
func (s *CombatSystemServiceUpdateRulesTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateRulesTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateRulesTooManyRequests) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateRulesTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesTooManyRequestsDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateRulesTooManyRequestsDetails from json.
func (s *CombatSystemServiceUpdateRulesTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CombatSystemServiceUpdateRulesUnauthorized from json.
func (s *CombatSystemServiceUpdateRulesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CombatSystemServiceUpdateRulesUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemServiceUpdateRulesUnauthorized) {
					name = jsonFieldsNameOfCombatSystemServiceUpdateRulesUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemServiceUpdateRulesUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCombatSystemServiceUpdateRulesUnauthorizedDetails = [0]string{}

// Decode decodes CombatSystemServiceUpdateRulesUnauthorizedDetails from json.
func (s *CombatSystemServiceUpdateRulesUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceUpdateRulesUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemServiceUpdateRulesUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceUpdateRulesUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("defender_id")
		json.EncodeUUID(e, s.DefenderID)
	}
	{
		e.FieldStart("weapon_id")
		e.Str(s.WeaponID)
	}
	{
		e.FieldStart("hit_location")
		s.HitLocation.Encode(e)
	}
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.AttackerStats.Set {
			e.FieldStart("attacker_stats")
			s.AttackerStats.Encode(e)
		}
	}
	{
		if s.DefenderStats.Set {
			e.FieldStart("defender_stats")
			s.DefenderStats.Encode(e)
		}
	}
	{
		if s.EnvironmentalFactors.Set {
			e.FieldStart("environmental_factors")
			s.EnvironmentalFactors.Encode(e)
		}
	}
	{
		if s.Modifiers != nil {
			e.FieldStart("modifiers")
			e.ArrStart()
			for _, elem := range s.Modifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequest = [9]string{
	0: "attacker_id",
	1: "defender_id",
	2: "weapon_id",
	3: "hit_location",
	4: "base_damage",
	5: "attacker_stats",
	6: "defender_stats",
	7: "environmental_factors",
	8: "modifiers",
}

// Decode decodes DamageCalculationRequest from json.
func (s *DamageCalculationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "defender_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DefenderID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_id\"")
			}
		case "weapon_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WeaponID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_id\"")
			}
		case "hit_location":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HitLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hit_location\"")
			}
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "attacker_stats":
			if err := func() error {
				s.AttackerStats.Reset()
				if err := s.AttackerStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_stats\"")
			}
		case "defender_stats":
			if err := func() error {
				s.DefenderStats.Reset()
				if err := s.DefenderStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_stats\"")
			}
		case "environmental_factors":
			if err := func() error {
				s.EnvironmentalFactors.Reset()
				if err := s.EnvironmentalFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_factors\"")
			}
		case "modifiers":
			if err := func() error {
				s.Modifiers = make([]DamageModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Modifiers = append(s.Modifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequest) {
					name = jsonFieldsNameOfDamageCalculationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationRequestHitLocation as json.
func (s DamageCalculationRequestHitLocation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageCalculationRequestHitLocation from json.
func (s *DamageCalculationRequestHitLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequestHitLocation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageCalculationRequestHitLocation(v) {
	case DamageCalculationRequestHitLocationHead:
		*s = DamageCalculationRequestHitLocationHead
	case DamageCalculationRequestHitLocationTorso:
		*s = DamageCalculationRequestHitLocationTorso
	case DamageCalculationRequestHitLocationLeftArm:
		*s = DamageCalculationRequestHitLocationLeftArm
	case DamageCalculationRequestHitLocationRightArm:
		*s = DamageCalculationRequestHitLocationRightArm
	case DamageCalculationRequestHitLocationLeftLeg:
		*s = DamageCalculationRequestHitLocationLeftLeg
	case DamageCalculationRequestHitLocationRightLeg:
		*s = DamageCalculationRequestHitLocationRightLeg
	default:
		*s = DamageCalculationRequestHitLocation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageCalculationRequestHitLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequestHitLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_damage")
		e.Int(s.TotalDamage)
	}
	{
		e.FieldStart("final_damage")
		e.Int(s.FinalDamage)
	}
	{
		e.FieldStart("critical_hit")
		e.Bool(s.CriticalHit)
	}
	{
		e.FieldStart("modifiers_applied")
		e.ArrStart()
		for _, elem := range s.ModifiersApplied {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DamageBreakdown.Set {
			e.FieldStart("damage_breakdown")
			s.DamageBreakdown.Encode(e)
		}
	}
	{
		if s.CalculationMetadata.Set {
			e.FieldStart("calculation_metadata")
			s.CalculationMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponse = [6]string{
	0: "total_damage",
	1: "final_damage",
	2: "critical_hit",
	3: "modifiers_applied",
	4: "damage_breakdown",
	5: "calculation_metadata",
}

// Decode decodes DamageCalculationResponse from json.
func (s *DamageCalculationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_damage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalDamage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage\"")
			}
		case "final_damage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.FinalDamage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "critical_hit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CriticalHit = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_hit\"")
			}
		case "modifiers_applied":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.ModifiersApplied = make([]AppliedModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AppliedModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ModifiersApplied = append(s.ModifiersApplied, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiers_applied\"")
			}
		case "damage_breakdown":
			if err := func() error {
				s.DamageBreakdown.Reset()
				if err := s.DamageBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_breakdown\"")
			}
		case "calculation_metadata":
			if err := func() error {
				s.CalculationMetadata.Reset()
				if err := s.CalculationMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResponse) {
					name = jsonFieldsNameOfDamageCalculationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponseCalculationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponseCalculationMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
	{
		if s.RulesVersion.Set {
			e.FieldStart("rules_version")
			s.RulesVersion.Encode(e)
		}
	}
	{
		if s.CalculationID.Set {
			e.FieldStart("calculation_id")
			s.CalculationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponseCalculationMetadata = [3]string{
	0: "processing_time_ms",
	1: "rules_version",
	2: "calculation_id",
}

// Decode decodes DamageCalculationResponseCalculationMetadata from json.
func (s *DamageCalculationResponseCalculationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponseCalculationMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		case "rules_version":
			if err := func() error {
				s.RulesVersion.Reset()
				if err := s.RulesVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules_version\"")
			}
		case "calculation_id":
			if err := func() error {
				s.CalculationID.Reset()
				if err := s.CalculationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponseCalculationMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponseCalculationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponseCalculationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponseDamageBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponseDamageBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.BaseDamage.Set {
			e.FieldStart("base_damage")
			s.BaseDamage.Encode(e)
		}
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
	{
		if s.ArmorReduction.Set {
			e.FieldStart("armor_reduction")
			s.ArmorReduction.Encode(e)
		}
	}
	{
		if s.EnvironmentalModifier.Set {
			e.FieldStart("environmental_modifier")
			s.EnvironmentalModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponseDamageBreakdown = [4]string{
	0: "base_damage",
	1: "critical_multiplier",
	2: "armor_reduction",
	3: "environmental_modifier",
}

// Decode decodes DamageCalculationResponseDamageBreakdown from json.
func (s *DamageCalculationResponseDamageBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponseDamageBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_damage":
			if err := func() error {
				s.BaseDamage.Reset()
				if err := s.BaseDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		case "armor_reduction":
			if err := func() error {
				s.ArmorReduction.Reset()
				if err := s.ArmorReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction\"")
			}
		case "environmental_modifier":
			if err := func() error {
				s.EnvironmentalModifier.Reset()
				if err := s.EnvironmentalModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponseDamageBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponseDamageBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponseDamageBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageModifier = [4]string{
	0: "type",
	1: "value",
	2: "source",
	3: "description",
}

// Decode decodes DamageModifier from json.
func (s *DamageModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageModifier) {
					name = jsonFieldsNameOfDamageModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageModifierSource as json.
func (s DamageModifierSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageModifierSource from json.
func (s *DamageModifierSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifierSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageModifierSource(v) {
	case DamageModifierSourceWeapon:
		*s = DamageModifierSourceWeapon
	case DamageModifierSourceAbility:
		*s = DamageModifierSourceAbility
	case DamageModifierSourceImplant:
		*s = DamageModifierSourceImplant
	case DamageModifierSourceEnvironmental:
		*s = DamageModifierSourceEnvironmental
	case DamageModifierSourceStatusEffect:
		*s = DamageModifierSourceStatusEffect
	default:
		*s = DamageModifierSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageModifierSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifierSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageModifierType as json.
func (s DamageModifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DamageModifierType from json.
func (s *DamageModifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DamageModifierType(v) {
	case DamageModifierTypeAdditive:
		*s = DamageModifierTypeAdditive
	case DamageModifierTypeMultiplicative:
		*s = DamageModifierTypeMultiplicative
	case DamageModifierTypePercentage:
		*s = DamageModifierTypePercentage
	case DamageModifierTypeFixed:
		*s = DamageModifierTypeFixed
	default:
		*s = DamageModifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DamageModifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("base_damage_multiplier")
		e.Float32(s.BaseDamageMultiplier)
	}
	{
		e.FieldStart("critical_hit_multiplier")
		e.Float32(s.CriticalHitMultiplier)
	}
	{
		e.FieldStart("armor_reduction_factor")
		e.Float32(s.ArmorReductionFactor)
	}
	{
		if s.EnvironmentalModifiers.Set {
			e.FieldStart("environmental_modifiers")
			s.EnvironmentalModifiers.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageRules = [4]string{
	0: "base_damage_multiplier",
	1: "critical_hit_multiplier",
	2: "armor_reduction_factor",
	3: "environmental_modifiers",
}

// Decode decodes DamageRules from json.
func (s *DamageRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRules to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_damage_multiplier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.BaseDamageMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage_multiplier\"")
			}
		case "critical_hit_multiplier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CriticalHitMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_hit_multiplier\"")
			}
		case "armor_reduction_factor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.ArmorReductionFactor = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction_factor\"")
			}
		case "environmental_modifiers":
			if err := func() error {
				s.EnvironmentalModifiers.Reset()
				if err := s.EnvironmentalModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRules) {
					name = jsonFieldsNameOfDamageRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRulesEnvironmentalModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRulesEnvironmentalModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.WeatherDamageModifier.Set {
			e.FieldStart("weather_damage_modifier")
			s.WeatherDamageModifier.Encode(e)
		}
	}
	{
		if s.TimeOfDayModifier.Set {
			e.FieldStart("time_of_day_modifier")
			s.TimeOfDayModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageRulesEnvironmentalModifiers = [2]string{
	0: "weather_damage_modifier",
	1: "time_of_day_modifier",
}

// Decode decodes DamageRulesEnvironmentalModifiers from json.
func (s *DamageRulesEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRulesEnvironmentalModifiers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather_damage_modifier":
			if err := func() error {
				s.WeatherDamageModifier.Reset()
				if err := s.WeatherDamageModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_damage_modifier\"")
			}
		case "time_of_day_modifier":
			if err := func() error {
				s.TimeOfDayModifier.Reset()
				if err := s.TimeOfDayModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRulesEnvironmentalModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRulesEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRulesEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("strength")
		e.Int(s.Strength)
	}
	{
		e.FieldStart("defense")
		e.Int(s.Defense)
	}
	{
		e.FieldStart("armor_rating")
		e.Int(s.ArmorRating)
	}
	{
		if s.CriticalChance.Set {
			e.FieldStart("critical_chance")
			s.CriticalChance.Encode(e)
		}
	}
	{
		if s.CriticalMultiplier.Set {
			e.FieldStart("critical_multiplier")
			s.CriticalMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfEntityStats = [6]string{
	0: "level",
	1: "strength",
	2: "defense",
	3: "armor_rating",
	4: "critical_chance",
	5: "critical_multiplier",
}

// Decode decodes EntityStats from json.
func (s *EntityStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityStats to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "strength":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Strength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strength\"")
			}
		case "defense":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Defense = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defense\"")
			}
		case "armor_rating":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ArmorRating = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_rating\"")
			}
		case "critical_chance":
			if err := func() error {
				s.CriticalChance.Reset()
				if err := s.CriticalChance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_chance\"")
			}
		case "critical_multiplier":
			if err := func() error {
				s.CriticalMultiplier.Reset()
				if err := s.CriticalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEntityStats) {
					name = jsonFieldsNameOfEntityStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentBalance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("terrain_modifiers")
		s.TerrainModifiers.Encode(e)
	}
	{
		e.FieldStart("weather_modifiers")
		s.WeatherModifiers.Encode(e)
	}
	{
		e.FieldStart("time_modifiers")
		s.TimeModifiers.Encode(e)
	}
}

var jsonFieldsNameOfEnvironmentBalance = [3]string{
	0: "terrain_modifiers",
	1: "weather_modifiers",
	2: "time_modifiers",
}

// Decode decodes EnvironmentBalance from json.
func (s *EnvironmentBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentBalance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "terrain_modifiers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TerrainModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_modifiers\"")
			}
		case "weather_modifiers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.WeatherModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_modifiers\"")
			}
		case "time_modifiers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TimeModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentBalance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnvironmentBalance) {
					name = jsonFieldsNameOfEnvironmentBalance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentBalanceTerrainModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentBalanceTerrainModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.OpenField.Set {
			e.FieldStart("open_field")
			s.OpenField.Encode(e)
		}
	}
	{
		if s.Urban.Set {
			e.FieldStart("urban")
			s.Urban.Encode(e)
		}
	}
	{
		if s.Forest.Set {
			e.FieldStart("forest")
			s.Forest.Encode(e)
		}
	}
	{
		if s.Mountain.Set {
			e.FieldStart("mountain")
			s.Mountain.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentBalanceTerrainModifiers = [4]string{
	0: "open_field",
	1: "urban",
	2: "forest",
	3: "mountain",
}

// Decode decodes EnvironmentBalanceTerrainModifiers from json.
func (s *EnvironmentBalanceTerrainModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentBalanceTerrainModifiers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "open_field":
			if err := func() error {
				s.OpenField.Reset()
				if err := s.OpenField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_field\"")
			}
		case "urban":
			if err := func() error {
				s.Urban.Reset()
				if err := s.Urban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urban\"")
			}
		case "forest":
			if err := func() error {
				s.Forest.Reset()
				if err := s.Forest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forest\"")
			}
		case "mountain":
			if err := func() error {
				s.Mountain.Reset()
				if err := s.Mountain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentBalanceTerrainModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentBalanceTerrainModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentBalanceTerrainModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentBalanceTimeModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentBalanceTimeModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.Day.Set {
			e.FieldStart("day")
			s.Day.Encode(e)
		}
	}
	{
		if s.Night.Set {
			e.FieldStart("night")
			s.Night.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentBalanceTimeModifiers = [2]string{
	0: "day",
	1: "night",
}

// Decode decodes EnvironmentBalanceTimeModifiers from json.
func (s *EnvironmentBalanceTimeModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentBalanceTimeModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "day":
			if err := func() error {
				s.Day.Reset()
				if err := s.Day.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"day\"")
			}
		case "night":
			if err := func() error {
				s.Night.Reset()
				if err := s.Night.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"night\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentBalanceTimeModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentBalanceTimeModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentBalanceTimeModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentBalanceWeatherModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentBalanceWeatherModifiers) encodeFields(e *jx.Encoder) {
	{
		if s.Clear.Set {
			e.FieldStart("clear")
			s.Clear.Encode(e)
		}
	}
	{
		if s.Rain.Set {
			e.FieldStart("rain")
			s.Rain.Encode(e)
		}
	}
	{
		if s.Snow.Set {
			e.FieldStart("snow")
			s.Snow.Encode(e)
		}
	}
	{
		if s.Storm.Set {
			e.FieldStart("storm")
			s.Storm.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentBalanceWeatherModifiers = [4]string{
	0: "clear",
	1: "rain",
	2: "snow",
	3: "storm",
}

// Decode decodes EnvironmentBalanceWeatherModifiers from json.
func (s *EnvironmentBalanceWeatherModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentBalanceWeatherModifiers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clear":
			if err := func() error {
				s.Clear.Reset()
				if err := s.Clear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clear\"")
			}
		case "rain":
			if err := func() error {
				s.Rain.Reset()
				if err := s.Rain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rain\"")
			}
		case "snow":
			if err := func() error {
				s.Snow.Reset()
				if err := s.Snow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snow\"")
			}
		case "storm":
			if err := func() error {
				s.Storm.Reset()
				if err := s.Storm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentBalanceWeatherModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentBalanceWeatherModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentBalanceWeatherModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentalFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentalFactors) encodeFields(e *jx.Encoder) {
	{
		if s.WeatherCondition.Set {
			e.FieldStart("weather_condition")
			s.WeatherCondition.Encode(e)
		}
	}
	{
		if s.TimeOfDay.Set {
			e.FieldStart("time_of_day")
			s.TimeOfDay.Encode(e)
		}
	}
	{
		if s.TerrainType.Set {
			e.FieldStart("terrain_type")
			s.TerrainType.Encode(e)
		}
	}
	{
		if s.CoverType.Set {
			e.FieldStart("cover_type")
			s.CoverType.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentalFactors = [4]string{
	0: "weather_condition",
	1: "time_of_day",
	2: "terrain_type",
	3: "cover_type",
}

// Decode decodes EnvironmentalFactors from json.
func (s *EnvironmentalFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather_condition":
			if err := func() error {
				s.WeatherCondition.Reset()
				if err := s.WeatherCondition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_condition\"")
			}
		case "time_of_day":
			if err := func() error {
				s.TimeOfDay.Reset()
				if err := s.TimeOfDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day\"")
			}
		case "terrain_type":
			if err := func() error {
				s.TerrainType.Reset()
				if err := s.TerrainType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_type\"")
			}
		case "cover_type":
			if err := func() error {
				s.CoverType.Reset()
				if err := s.CoverType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cover_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsCoverType as json.
func (s EnvironmentalFactorsCoverType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentalFactorsCoverType from json.
func (s *EnvironmentalFactorsCoverType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactorsCoverType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentalFactorsCoverType(v) {
	case EnvironmentalFactorsCoverTypeNone:
		*s = EnvironmentalFactorsCoverTypeNone
	case EnvironmentalFactorsCoverTypeLight:
		*s = EnvironmentalFactorsCoverTypeLight
	case EnvironmentalFactorsCoverTypeMedium:
		*s = EnvironmentalFactorsCoverTypeMedium
	case EnvironmentalFactorsCoverTypeHeavy:
		*s = EnvironmentalFactorsCoverTypeHeavy
	default:
		*s = EnvironmentalFactorsCoverType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalFactorsCoverType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactorsCoverType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsTerrainType as json.
func (s EnvironmentalFactorsTerrainType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentalFactorsTerrainType from json.
func (s *EnvironmentalFactorsTerrainType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactorsTerrainType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentalFactorsTerrainType(v) {
	case EnvironmentalFactorsTerrainTypeOpen:
		*s = EnvironmentalFactorsTerrainTypeOpen
	case EnvironmentalFactorsTerrainTypeUrban:
		*s = EnvironmentalFactorsTerrainTypeUrban
	case EnvironmentalFactorsTerrainTypeForest:
		*s = EnvironmentalFactorsTerrainTypeForest
	case EnvironmentalFactorsTerrainTypeMountain:
		*s = EnvironmentalFactorsTerrainTypeMountain
	case EnvironmentalFactorsTerrainTypeWater:
		*s = EnvironmentalFactorsTerrainTypeWater
	default:
		*s = EnvironmentalFactorsTerrainType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalFactorsTerrainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactorsTerrainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsTimeOfDay as json.
func (s EnvironmentalFactorsTimeOfDay) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentalFactorsTimeOfDay from json.
func (s *EnvironmentalFactorsTimeOfDay) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactorsTimeOfDay to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentalFactorsTimeOfDay(v) {
	case EnvironmentalFactorsTimeOfDayDawn:
		*s = EnvironmentalFactorsTimeOfDayDawn
	case EnvironmentalFactorsTimeOfDayDay:
		*s = EnvironmentalFactorsTimeOfDayDay
	case EnvironmentalFactorsTimeOfDayDusk:
		*s = EnvironmentalFactorsTimeOfDayDusk
	case EnvironmentalFactorsTimeOfDayNight:
		*s = EnvironmentalFactorsTimeOfDayNight
	default:
		*s = EnvironmentalFactorsTimeOfDay(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalFactorsTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactorsTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsWeatherCondition as json.
func (s EnvironmentalFactorsWeatherCondition) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentalFactorsWeatherCondition from json.
func (s *EnvironmentalFactorsWeatherCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactorsWeatherCondition to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentalFactorsWeatherCondition(v) {
	case EnvironmentalFactorsWeatherConditionClear:
		*s = EnvironmentalFactorsWeatherConditionClear
	case EnvironmentalFactorsWeatherConditionRain:
		*s = EnvironmentalFactorsWeatherConditionRain
	case EnvironmentalFactorsWeatherConditionSnow:
		*s = EnvironmentalFactorsWeatherConditionSnow
	case EnvironmentalFactorsWeatherConditionFog:
		*s = EnvironmentalFactorsWeatherConditionFog
	case EnvironmentalFactorsWeatherConditionStorm:
		*s = EnvironmentalFactorsWeatherConditionStorm
	default:
		*s = EnvironmentalFactorsWeatherCondition(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalFactorsWeatherCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactorsWeatherCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactionModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactionModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("faction_name")
		e.Str(s.FactionName)
	}
	{
		e.FieldStart("reputation_modifier")
		e.Float32(s.ReputationModifier)
	}
	{
		if s.DamageModifier.Set {
			e.FieldStart("damage_modifier")
			s.DamageModifier.Encode(e)
		}
	}
	{
		if s.RewardModifier.Set {
			e.FieldStart("reward_modifier")
			s.RewardModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfFactionModifier = [4]string{
	0: "faction_name",
	1: "reputation_modifier",
	2: "damage_modifier",
	3: "reward_modifier",
}

// Decode decodes FactionModifier from json.
func (s *FactionModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactionModifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "faction_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FactionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_name\"")
			}
		case "reputation_modifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.ReputationModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_modifier\"")
			}
		case "damage_modifier":
			if err := func() error {
				s.DamageModifier.Reset()
				if err := s.DamageModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_modifier\"")
			}
		case "reward_modifier":
			if err := func() error {
				s.RewardModifier.Reset()
				if err := s.RewardModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactionModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFactionModifier) {
					name = jsonFieldsNameOfFactionModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactionModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactionModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GlobalMultipliers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GlobalMultipliers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("damage_multiplier")
		e.Float32(s.DamageMultiplier)
	}
	{
		e.FieldStart("experience_multiplier")
		e.Float32(s.ExperienceMultiplier)
	}
	{
		e.FieldStart("loot_multiplier")
		e.Float32(s.LootMultiplier)
	}
	{
		if s.CurrencyMultiplier.Set {
			e.FieldStart("currency_multiplier")
			s.CurrencyMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfGlobalMultipliers = [4]string{
	0: "damage_multiplier",
	1: "experience_multiplier",
	2: "loot_multiplier",
	3: "currency_multiplier",
}

// Decode decodes GlobalMultipliers from json.
func (s *GlobalMultipliers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GlobalMultipliers to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.DamageMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "experience_multiplier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.ExperienceMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience_multiplier\"")
			}
		case "loot_multiplier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.LootMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loot_multiplier\"")
			}
		case "currency_multiplier":
			if err := func() error {
				s.CurrencyMultiplier.Reset()
				if err := s.CurrencyMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GlobalMultipliers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGlobalMultipliers) {
					name = jsonFieldsNameOfGlobalMultipliers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GlobalMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GlobalMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationDamageScaling as json.
func (o OptAbilityConfigurationDamageScaling) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbilityConfigurationDamageScaling from json.
func (o *OptAbilityConfigurationDamageScaling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationDamageScaling to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationDamageScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationDamageScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationDamageScalingDamageType as json.
func (o OptAbilityConfigurationDamageScalingDamageType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbilityConfigurationDamageScalingDamageType from json.
func (o *OptAbilityConfigurationDamageScalingDamageType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationDamageScalingDamageType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationDamageScalingDamageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationDamageScalingDamageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationDamageScalingScalingStat as json.
func (o OptAbilityConfigurationDamageScalingScalingStat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbilityConfigurationDamageScalingScalingStat from json.
func (o *OptAbilityConfigurationDamageScalingScalingStat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationDamageScalingScalingStat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationDamageScalingScalingStat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationDamageScalingScalingStat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationStatRequirements as json.
func (o OptAbilityConfigurationStatRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbilityConfigurationStatRequirements from json.
func (o *OptAbilityConfigurationStatRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationStatRequirements to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationStatRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationStatRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationStatRequirementsRequiredStats as json.
func (o OptAbilityConfigurationStatRequirementsRequiredStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbilityConfigurationStatRequirementsRequiredStats from json.
func (o *OptAbilityConfigurationStatRequirementsRequiredStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationStatRequirementsRequiredStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationStatRequirementsRequiredStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationStatRequirementsRequiredStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationTargetingRules as json.
func (o OptAbilityConfigurationTargetingRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbilityConfigurationTargetingRules from json.
func (o *OptAbilityConfigurationTargetingRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationTargetingRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationTargetingRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationTargetingRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationTargetingRulesTargetType as json.
func (o OptAbilityConfigurationTargetingRulesTargetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbilityConfigurationTargetingRulesTargetType from json.
func (o *OptAbilityConfigurationTargetingRulesTargetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationTargetingRulesTargetType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationTargetingRulesTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationTargetingRulesTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityEffectStatModifier as json.
func (o OptAbilityEffectStatModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AbilityEffectStatModifier from json.
func (o *OptAbilityEffectStatModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityEffectStatModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityEffectStatModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityEffectStatModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BalanceParameters as json.
func (o OptBalanceParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BalanceParameters from json.
func (o *OptBalanceParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBalanceParameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBalanceParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBalanceParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalance as json.
func (o OptCharacterBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterBalance from json.
func (o *OptCharacterBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalanceLevelScalingScalingCurve as json.
func (o OptCharacterBalanceLevelScalingScalingCurve) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CharacterBalanceLevelScalingScalingCurve from json.
func (o *OptCharacterBalanceLevelScalingScalingCurve) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalanceLevelScalingScalingCurve to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalanceLevelScalingScalingCurve) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalanceLevelScalingScalingCurve) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalanceStatProgression as json.
func (o OptCharacterBalanceStatProgression) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterBalanceStatProgression from json.
func (o *OptCharacterBalanceStatProgression) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalanceStatProgression to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalanceStatProgression) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalanceStatProgression) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatMechanics as json.
func (o OptCombatMechanics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CombatMechanics from json.
func (o *OptCombatMechanics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatMechanics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatMechanics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatMechanics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckOKChecks as json.
func (o OptCombatSystemServiceHealthCheckOKChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CombatSystemServiceHealthCheckOKChecks from json.
func (o *OptCombatSystemServiceHealthCheckOKChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatSystemServiceHealthCheckOKChecks to nil")
	}
	o.Set = true
	o.Value = make(CombatSystemServiceHealthCheckOKChecks)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatSystemServiceHealthCheckOKChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatSystemServiceHealthCheckOKChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckOKChecksItemStatus as json.
func (o OptCombatSystemServiceHealthCheckOKChecksItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CombatSystemServiceHealthCheckOKChecksItemStatus from json.
func (o *OptCombatSystemServiceHealthCheckOKChecksItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatSystemServiceHealthCheckOKChecksItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatSystemServiceHealthCheckOKChecksItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatSystemServiceHealthCheckOKChecksItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckServiceUnavailableChecks as json.
func (o OptCombatSystemServiceHealthCheckServiceUnavailableChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableChecks from json.
func (o *OptCombatSystemServiceHealthCheckServiceUnavailableChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatSystemServiceHealthCheckServiceUnavailableChecks to nil")
	}
	o.Set = true
	o.Value = make(CombatSystemServiceHealthCheckServiceUnavailableChecks)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatSystemServiceHealthCheckServiceUnavailableChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatSystemServiceHealthCheckServiceUnavailableChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus as json.
func (o OptCombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus from json.
func (o *OptCombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatSystemServiceHealthCheckServiceUnavailableChecksItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResponseCalculationMetadata as json.
func (o OptDamageCalculationResponseCalculationMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationResponseCalculationMetadata from json.
func (o *OptDamageCalculationResponseCalculationMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationResponseCalculationMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationResponseCalculationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationResponseCalculationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageCalculationResponseDamageBreakdown as json.
func (o OptDamageCalculationResponseDamageBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageCalculationResponseDamageBreakdown from json.
func (o *OptDamageCalculationResponseDamageBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageCalculationResponseDamageBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageCalculationResponseDamageBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageCalculationResponseDamageBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageModifierSource as json.
func (o OptDamageModifierSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DamageModifierSource from json.
func (o *OptDamageModifierSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageModifierSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageModifierSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageModifierSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRules as json.
func (o OptDamageRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRules from json.
func (o *OptDamageRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRulesEnvironmentalModifiers as json.
func (o OptDamageRulesEnvironmentalModifiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRulesEnvironmentalModifiers from json.
func (o *OptDamageRulesEnvironmentalModifiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRulesEnvironmentalModifiers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRulesEnvironmentalModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRulesEnvironmentalModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EntityStats as json.
func (o OptEntityStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityStats from json.
func (o *OptEntityStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentBalance as json.
func (o OptEnvironmentBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentBalance from json.
func (o *OptEnvironmentBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactors as json.
func (o OptEnvironmentalFactors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalFactors from json.
func (o *OptEnvironmentalFactors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsCoverType as json.
func (o OptEnvironmentalFactorsCoverType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnvironmentalFactorsCoverType from json.
func (o *OptEnvironmentalFactorsCoverType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactorsCoverType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactorsCoverType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactorsCoverType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsTerrainType as json.
func (o OptEnvironmentalFactorsTerrainType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnvironmentalFactorsTerrainType from json.
func (o *OptEnvironmentalFactorsTerrainType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactorsTerrainType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactorsTerrainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactorsTerrainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsTimeOfDay as json.
func (o OptEnvironmentalFactorsTimeOfDay) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnvironmentalFactorsTimeOfDay from json.
func (o *OptEnvironmentalFactorsTimeOfDay) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactorsTimeOfDay to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactorsTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactorsTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactorsWeatherCondition as json.
func (o OptEnvironmentalFactorsWeatherCondition) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnvironmentalFactorsWeatherCondition from json.
func (o *OptEnvironmentalFactorsWeatherCondition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactorsWeatherCondition to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactorsWeatherCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactorsWeatherCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GlobalMultipliers as json.
func (o OptGlobalMultipliers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GlobalMultipliers from json.
func (o *OptGlobalMultipliers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGlobalMultipliers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGlobalMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGlobalMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TerrainModifier as json.
func (o OptTerrainModifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TerrainModifier from json.
func (o *OptTerrainModifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTerrainModifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTerrainModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTerrainModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegionModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegionModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("region_name")
		e.Str(s.RegionName)
	}
	{
		e.FieldStart("difficulty_modifier")
		e.Float32(s.DifficultyModifier)
	}
	{
		if s.ExperienceModifier.Set {
			e.FieldStart("experience_modifier")
			s.ExperienceModifier.Encode(e)
		}
	}
	{
		if s.LootQualityModifier.Set {
			e.FieldStart("loot_quality_modifier")
			s.LootQualityModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegionModifier = [4]string{
	0: "region_name",
	1: "difficulty_modifier",
	2: "experience_modifier",
	3: "loot_quality_modifier",
}

// Decode decodes RegionModifier from json.
func (s *RegionModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegionModifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "region_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RegionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region_name\"")
			}
		case "difficulty_modifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.DifficultyModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_modifier\"")
			}
		case "experience_modifier":
			if err := func() error {
				s.ExperienceModifier.Reset()
				if err := s.ExperienceModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience_modifier\"")
			}
		case "loot_quality_modifier":
			if err := func() error {
				s.LootQualityModifier.Reset()
				if err := s.LootQualityModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loot_quality_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegionModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegionModifier) {
					name = jsonFieldsNameOfRegionModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegionModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegionModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerrainModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerrainModifier) encodeFields(e *jx.Encoder) {
	{
		if s.MovementSpeedModifier.Set {
			e.FieldStart("movement_speed_modifier")
			s.MovementSpeedModifier.Encode(e)
		}
	}
	{
		if s.CoverEffectiveness.Set {
			e.FieldStart("cover_effectiveness")
			s.CoverEffectiveness.Encode(e)
		}
	}
	{
		if s.VisibilityModifier.Set {
			e.FieldStart("visibility_modifier")
			s.VisibilityModifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerrainModifier = [3]string{
	0: "movement_speed_modifier",
	1: "cover_effectiveness",
	2: "visibility_modifier",
}

// Decode decodes TerrainModifier from json.
func (s *TerrainModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerrainModifier to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "movement_speed_modifier":
			if err := func() error {
				s.MovementSpeedModifier.Reset()
				if err := s.MovementSpeedModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"movement_speed_modifier\"")
			}
		case "cover_effectiveness":
			if err := func() error {
				s.CoverEffectiveness.Reset()
				if err := s.CoverEffectiveness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cover_effectiveness\"")
			}
		case "visibility_modifier":
			if err := func() error {
				s.VisibilityModifier.Reset()
				if err := s.VisibilityModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility_modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerrainModifier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerrainModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerrainModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCombatBalanceConfigRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCombatBalanceConfigRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		if s.GlobalMultipliers.Set {
			e.FieldStart("global_multipliers")
			s.GlobalMultipliers.Encode(e)
		}
	}
	{
		if s.CharacterBalance.Set {
			e.FieldStart("character_balance")
			s.CharacterBalance.Encode(e)
		}
	}
	{
		if s.EnvironmentBalance.Set {
			e.FieldStart("environment_balance")
			s.EnvironmentBalance.Encode(e)
		}
	}
	{
		if s.FactionModifiers != nil {
			e.FieldStart("faction_modifiers")
			e.ArrStart()
			for _, elem := range s.FactionModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RegionModifiers != nil {
			e.FieldStart("region_modifiers")
			e.ArrStart()
			for _, elem := range s.RegionModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateCombatBalanceConfigRequest = [6]string{
	0: "version",
	1: "global_multipliers",
	2: "character_balance",
	3: "environment_balance",
	4: "faction_modifiers",
	5: "region_modifiers",
}

// Decode decodes UpdateCombatBalanceConfigRequest from json.
func (s *UpdateCombatBalanceConfigRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCombatBalanceConfigRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "global_multipliers":
			if err := func() error {
				s.GlobalMultipliers.Reset()
				if err := s.GlobalMultipliers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"global_multipliers\"")
			}
		case "character_balance":
			if err := func() error {
				s.CharacterBalance.Reset()
				if err := s.CharacterBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_balance\"")
			}
		case "environment_balance":
			if err := func() error {
				s.EnvironmentBalance.Reset()
				if err := s.EnvironmentBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_balance\"")
			}
		case "faction_modifiers":
			if err := func() error {
				s.FactionModifiers = make([]FactionModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactionModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FactionModifiers = append(s.FactionModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_modifiers\"")
			}
		case "region_modifiers":
			if err := func() error {
				s.RegionModifiers = make([]RegionModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RegionModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RegionModifiers = append(s.RegionModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCombatBalanceConfigRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCombatBalanceConfigRequest) {
					name = jsonFieldsNameOfUpdateCombatBalanceConfigRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCombatBalanceConfigRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCombatBalanceConfigRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCombatSystemRulesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCombatSystemRulesRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		if s.DamageRules.Set {
			e.FieldStart("damage_rules")
			s.DamageRules.Encode(e)
		}
	}
	{
		if s.CombatMechanics.Set {
			e.FieldStart("combat_mechanics")
			s.CombatMechanics.Encode(e)
		}
	}
	{
		if s.BalanceParameters.Set {
			e.FieldStart("balance_parameters")
			s.BalanceParameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCombatSystemRulesRequest = [4]string{
	0: "version",
	1: "damage_rules",
	2: "combat_mechanics",
	3: "balance_parameters",
}

// Decode decodes UpdateCombatSystemRulesRequest from json.
func (s *UpdateCombatSystemRulesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCombatSystemRulesRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "damage_rules":
			if err := func() error {
				s.DamageRules.Reset()
				if err := s.DamageRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_rules\"")
			}
		case "combat_mechanics":
			if err := func() error {
				s.CombatMechanics.Reset()
				if err := s.CombatMechanics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_mechanics\"")
			}
		case "balance_parameters":
			if err := func() error {
				s.BalanceParameters.Reset()
				if err := s.BalanceParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCombatSystemRulesRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCombatSystemRulesRequest) {
					name = jsonFieldsNameOfUpdateCombatSystemRulesRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCombatSystemRulesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCombatSystemRulesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
