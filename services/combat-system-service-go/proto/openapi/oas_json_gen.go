// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AbilityConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Damage.Set {
			e.FieldStart("damage")
			s.Damage.Encode(e)
		}
	}
	{
		e.FieldStart("cooldown_ms")
		e.Int(s.CooldownMs)
	}
	{
		if s.ManaCost.Set {
			e.FieldStart("mana_cost")
			s.ManaCost.Encode(e)
		}
	}
	{
		if s.Range.Set {
			e.FieldStart("range")
			s.Range.Encode(e)
		}
	}
	{
		if s.CastTimeMs.Set {
			e.FieldStart("cast_time_ms")
			s.CastTimeMs.Encode(e)
		}
	}
	{
		if s.BalanceNotes.Set {
			e.FieldStart("balance_notes")
			s.BalanceNotes.Encode(e)
		}
	}
	{
		if s.StatRequirements.Set {
			e.FieldStart("stat_requirements")
			s.StatRequirements.Encode(e)
		}
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAbilityConfiguration = [14]string{
	0:  "id",
	1:  "name",
	2:  "type",
	3:  "description",
	4:  "damage",
	5:  "cooldown_ms",
	6:  "mana_cost",
	7:  "range",
	8:  "cast_time_ms",
	9:  "balance_notes",
	10: "stat_requirements",
	11: "effects",
	12: "created_at",
	13: "updated_at",
}

// Decode decodes AbilityConfiguration from json.
func (s *AbilityConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfiguration to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "damage":
			if err := func() error {
				s.Damage.Reset()
				if err := s.Damage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "cooldown_ms":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.CooldownMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_ms\"")
			}
		case "mana_cost":
			if err := func() error {
				s.ManaCost.Reset()
				if err := s.ManaCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mana_cost\"")
			}
		case "range":
			if err := func() error {
				s.Range.Reset()
				if err := s.Range.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		case "cast_time_ms":
			if err := func() error {
				s.CastTimeMs.Reset()
				if err := s.CastTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cast_time_ms\"")
			}
		case "balance_notes":
			if err := func() error {
				s.BalanceNotes.Reset()
				if err := s.BalanceNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_notes\"")
			}
		case "stat_requirements":
			if err := func() error {
				s.StatRequirements.Reset()
				if err := s.StatRequirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stat_requirements\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]AbilityEffect, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AbilityEffect
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityConfiguration) {
					name = jsonFieldsNameOfAbilityConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AbilityConfigurationStatRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AbilityConfigurationStatRequirements) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes AbilityConfigurationStatRequirements from json.
func (s *AbilityConfigurationStatRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationStatRequirements to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationStatRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationStatRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationStatRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationType as json.
func (s AbilityConfigurationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AbilityConfigurationType from json.
func (s *AbilityConfigurationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AbilityConfigurationType(v) {
	case AbilityConfigurationTypeOffensive:
		*s = AbilityConfigurationTypeOffensive
	case AbilityConfigurationTypeDefensive:
		*s = AbilityConfigurationTypeDefensive
	case AbilityConfigurationTypeUtility:
		*s = AbilityConfigurationTypeUtility
	case AbilityConfigurationTypeUltimate:
		*s = AbilityConfigurationTypeUltimate
	default:
		*s = AbilityConfigurationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityConfigurationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("abilities")
		e.ArrStart()
		for _, elem := range s.Abilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfAbilityConfigurationsResponse = [2]string{
	0: "abilities",
	1: "pagination",
}

// Decode decodes AbilityConfigurationsResponse from json.
func (s *AbilityConfigurationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "abilities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Abilities = make([]AbilityConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AbilityConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Abilities = append(s.Abilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilities\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityConfigurationsResponse) {
					name = jsonFieldsNameOfAbilityConfigurationsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityConfigurationsResponsePagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityConfigurationsResponsePagination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("page")
		e.Int(s.Page)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("total_pages")
		e.Int(s.TotalPages)
	}
}

var jsonFieldsNameOfAbilityConfigurationsResponsePagination = [4]string{
	0: "page",
	1: "limit",
	2: "total_count",
	3: "total_pages",
}

// Decode decodes AbilityConfigurationsResponsePagination from json.
func (s *AbilityConfigurationsResponsePagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityConfigurationsResponsePagination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Page = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "total_pages":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityConfigurationsResponsePagination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityConfigurationsResponsePagination) {
					name = jsonFieldsNameOfAbilityConfigurationsResponsePagination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityConfigurationsResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityConfigurationsResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbilityEffect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbilityEffect) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		e.FieldStart("target")
		e.Str(s.Target)
	}
}

var jsonFieldsNameOfAbilityEffect = [4]string{
	0: "type",
	1: "duration_ms",
	2: "value",
	3: "target",
}

// Decode decodes AbilityEffect from json.
func (s *AbilityEffect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityEffect to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Target = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityEffect")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbilityEffect) {
					name = jsonFieldsNameOfAbilityEffect[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbilityEffect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityEffect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AbilityEffectValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AbilityEffectValue) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AbilityEffectValue from json.
func (s *AbilityEffectValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbilityEffectValue to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbilityEffectValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AbilityEffectValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbilityEffectValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionPointsSystem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionPointsSystem) encodeFields(e *jx.Encoder) {
	{
		if s.MaxActionPoints.Set {
			e.FieldStart("max_action_points")
			s.MaxActionPoints.Encode(e)
		}
	}
	{
		if s.PointsPerTurn.Set {
			e.FieldStart("points_per_turn")
			s.PointsPerTurn.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionPointsSystem = [2]string{
	0: "max_action_points",
	1: "points_per_turn",
}

// Decode decodes ActionPointsSystem from json.
func (s *ActionPointsSystem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionPointsSystem to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_action_points":
			if err := func() error {
				s.MaxActionPoints.Reset()
				if err := s.MaxActionPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_action_points\"")
			}
		case "points_per_turn":
			if err := func() error {
				s.PointsPerTurn.Reset()
				if err := s.PointsPerTurn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points_per_turn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionPointsSystem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionPointsSystem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionPointsSystem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalanceParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalanceParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("difficulty_scaling")
		s.DifficultyScaling.Encode(e)
	}
	{
		e.FieldStart("class_balance")
		s.ClassBalance.Encode(e)
	}
	{
		e.FieldStart("level_scaling")
		s.LevelScaling.Encode(e)
	}
}

var jsonFieldsNameOfBalanceParameters = [3]string{
	0: "difficulty_scaling",
	1: "class_balance",
	2: "level_scaling",
}

// Decode decodes BalanceParameters from json.
func (s *BalanceParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalanceParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "difficulty_scaling":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DifficultyScaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_scaling\"")
			}
		case "class_balance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClassBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"class_balance\"")
			}
		case "level_scaling":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LevelScaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level_scaling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalanceParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalanceParameters) {
					name = jsonFieldsNameOfBalanceParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalanceParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalanceParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterBalance) encodeFields(e *jx.Encoder) {
	{
		if s.LevelScalingEnabled.Set {
			e.FieldStart("level_scaling_enabled")
			s.LevelScalingEnabled.Encode(e)
		}
	}
	{
		if s.ClassMultipliers.Set {
			e.FieldStart("class_multipliers")
			s.ClassMultipliers.Encode(e)
		}
	}
	{
		if s.StatWeights.Set {
			e.FieldStart("stat_weights")
			s.StatWeights.Encode(e)
		}
	}
}

var jsonFieldsNameOfCharacterBalance = [3]string{
	0: "level_scaling_enabled",
	1: "class_multipliers",
	2: "stat_weights",
}

// Decode decodes CharacterBalance from json.
func (s *CharacterBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level_scaling_enabled":
			if err := func() error {
				s.LevelScalingEnabled.Reset()
				if err := s.LevelScalingEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level_scaling_enabled\"")
			}
		case "class_multipliers":
			if err := func() error {
				s.ClassMultipliers.Reset()
				if err := s.ClassMultipliers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"class_multipliers\"")
			}
		case "stat_weights":
			if err := func() error {
				s.StatWeights.Reset()
				if err := s.StatWeights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stat_weights\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CharacterBalanceClassMultipliers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CharacterBalanceClassMultipliers) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes CharacterBalanceClassMultipliers from json.
func (s *CharacterBalanceClassMultipliers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalanceClassMultipliers to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalanceClassMultipliers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterBalanceClassMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalanceClassMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CharacterBalanceStatWeights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CharacterBalanceStatWeights) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes CharacterBalanceStatWeights from json.
func (s *CharacterBalanceStatWeights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterBalanceStatWeights to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterBalanceStatWeights")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterBalanceStatWeights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterBalanceStatWeights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("strength")
		e.Int(s.Strength)
	}
	{
		e.FieldStart("agility")
		e.Int(s.Agility)
	}
	{
		e.FieldStart("intelligence")
		e.Int(s.Intelligence)
	}
	{
		e.FieldStart("armor")
		e.Int(s.Armor)
	}
	{
		if s.CriticalChance.Set {
			e.FieldStart("critical_chance")
			s.CriticalChance.Encode(e)
		}
	}
}

var jsonFieldsNameOfCharacterStats = [6]string{
	0: "level",
	1: "strength",
	2: "agility",
	3: "intelligence",
	4: "armor",
	5: "critical_chance",
}

// Decode decodes CharacterStats from json.
func (s *CharacterStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "strength":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Strength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strength\"")
			}
		case "agility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Agility = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agility\"")
			}
		case "intelligence":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Intelligence = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intelligence\"")
			}
		case "armor":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Armor = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor\"")
			}
		case "critical_chance":
			if err := func() error {
				s.CriticalChance.Reset()
				if err := s.CriticalChance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_chance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterStats) {
					name = jsonFieldsNameOfCharacterStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClassBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClassBalance) encodeFields(e *jx.Encoder) {
	{
		if s.DpsBalance.Set {
			e.FieldStart("dps_balance")
			s.DpsBalance.Encode(e)
		}
	}
	{
		if s.TankBalance.Set {
			e.FieldStart("tank_balance")
			s.TankBalance.Encode(e)
		}
	}
	{
		if s.HealerBalance.Set {
			e.FieldStart("healer_balance")
			s.HealerBalance.Encode(e)
		}
	}
	{
		if s.SupportBalance.Set {
			e.FieldStart("support_balance")
			s.SupportBalance.Encode(e)
		}
	}
}

var jsonFieldsNameOfClassBalance = [4]string{
	0: "dps_balance",
	1: "tank_balance",
	2: "healer_balance",
	3: "support_balance",
}

// Decode decodes ClassBalance from json.
func (s *ClassBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClassBalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dps_balance":
			if err := func() error {
				s.DpsBalance.Reset()
				if err := s.DpsBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dps_balance\"")
			}
		case "tank_balance":
			if err := func() error {
				s.TankBalance.Reset()
				if err := s.TankBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tank_balance\"")
			}
		case "healer_balance":
			if err := func() error {
				s.HealerBalance.Reset()
				if err := s.HealerBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healer_balance\"")
			}
		case "support_balance":
			if err := func() error {
				s.SupportBalance.Reset()
				if err := s.SupportBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"support_balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClassBalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClassBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClassBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatBalanceConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatBalanceConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		e.FieldStart("global_multipliers")
		s.GlobalMultipliers.Encode(e)
	}
	{
		e.FieldStart("character_balance")
		s.CharacterBalance.Encode(e)
	}
	{
		e.FieldStart("environmental_balance")
		s.EnvironmentalBalance.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCombatBalanceConfig = [7]string{
	0: "id",
	1: "version",
	2: "global_multipliers",
	3: "character_balance",
	4: "environmental_balance",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes CombatBalanceConfig from json.
func (s *CombatBalanceConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatBalanceConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "global_multipliers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.GlobalMultipliers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"global_multipliers\"")
			}
		case "character_balance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CharacterBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_balance\"")
			}
		case "environmental_balance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EnvironmentalBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_balance\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatBalanceConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatBalanceConfig) {
					name = jsonFieldsNameOfCombatBalanceConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatBalanceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatBalanceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatMechanics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatMechanics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("turn_based_enabled")
		e.Bool(s.TurnBasedEnabled)
	}
	{
		e.FieldStart("action_points_system")
		s.ActionPointsSystem.Encode(e)
	}
	{
		e.FieldStart("interruption_rules")
		s.InterruptionRules.Encode(e)
	}
}

var jsonFieldsNameOfCombatMechanics = [3]string{
	0: "turn_based_enabled",
	1: "action_points_system",
	2: "interruption_rules",
}

// Decode decodes CombatMechanics from json.
func (s *CombatMechanics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatMechanics to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "turn_based_enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.TurnBasedEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turn_based_enabled\"")
			}
		case "action_points_system":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ActionPointsSystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_points_system\"")
			}
		case "interruption_rules":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.InterruptionRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interruption_rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatMechanics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatMechanics) {
					name = jsonFieldsNameOfCombatMechanics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatMechanics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatMechanics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombatSystemRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombatSystemRules) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
	{
		e.FieldStart("damage_rules")
		s.DamageRules.Encode(e)
	}
	{
		e.FieldStart("combat_mechanics")
		s.CombatMechanics.Encode(e)
	}
	{
		e.FieldStart("balance_parameters")
		s.BalanceParameters.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCombatSystemRules = [8]string{
	0: "id",
	1: "version",
	2: "damage_rules",
	3: "combat_mechanics",
	4: "balance_parameters",
	5: "created_at",
	6: "updated_at",
	7: "created_by",
}

// Decode decodes CombatSystemRules from json.
func (s *CombatSystemRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "damage_rules":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DamageRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_rules\"")
			}
		case "combat_mechanics":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CombatMechanics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_mechanics\"")
			}
		case "balance_parameters":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BalanceParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_parameters\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombatSystemRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombatSystemRules) {
					name = jsonFieldsNameOfCombatSystemRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckOK as json.
func (s *CombatSystemServiceHealthCheckOK) Encode(e *jx.Encoder) {
	unwrapped := (*HealthResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CombatSystemServiceHealthCheckOK from json.
func (s *CombatSystemServiceHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckOK to nil")
	}
	var unwrapped HealthResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CombatSystemServiceHealthCheckOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatSystemServiceHealthCheckServiceUnavailable as json.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*HealthResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CombatSystemServiceHealthCheckServiceUnavailable from json.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombatSystemServiceHealthCheckServiceUnavailable to nil")
	}
	var unwrapped HealthResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CombatSystemServiceHealthCheckServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombatSystemServiceHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_id")
		json.EncodeUUID(e, s.AttackerID)
	}
	{
		e.FieldStart("defender_id")
		json.EncodeUUID(e, s.DefenderID)
	}
	{
		e.FieldStart("ability_id")
		json.EncodeUUID(e, s.AbilityID)
	}
	{
		e.FieldStart("base_damage")
		e.Int(s.BaseDamage)
	}
	{
		e.FieldStart("damage_type")
		e.Str(s.DamageType)
	}
	{
		e.FieldStart("attacker_stats")
		s.AttackerStats.Encode(e)
	}
	{
		e.FieldStart("defender_stats")
		s.DefenderStats.Encode(e)
	}
	{
		if s.EnvironmentalFactors.Set {
			e.FieldStart("environmental_factors")
			s.EnvironmentalFactors.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageCalculationRequest = [8]string{
	0: "attacker_id",
	1: "defender_id",
	2: "ability_id",
	3: "base_damage",
	4: "damage_type",
	5: "attacker_stats",
	6: "defender_stats",
	7: "environmental_factors",
}

// Decode decodes DamageCalculationRequest from json.
func (s *DamageCalculationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_id\"")
			}
		case "defender_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DefenderID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_id\"")
			}
		case "ability_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AbilityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability_id\"")
			}
		case "base_damage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.BaseDamage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DamageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "attacker_stats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.AttackerStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_stats\"")
			}
		case "defender_stats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.DefenderStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_stats\"")
			}
		case "environmental_factors":
			if err := func() error {
				s.EnvironmentalFactors.Reset()
				if err := s.EnvironmentalFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_factors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationRequest) {
					name = jsonFieldsNameOfDamageCalculationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageCalculationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageCalculationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("final_damage")
		e.Int(s.FinalDamage)
	}
	{
		e.FieldStart("critical_hit")
		e.Bool(s.CriticalHit)
	}
	{
		e.FieldStart("damage_type")
		e.Str(s.DamageType)
	}
	{
		if s.Modifiers != nil {
			e.FieldStart("modifiers")
			e.ArrStart()
			for _, elem := range s.Modifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CalculationLog != nil {
			e.FieldStart("calculation_log")
			e.ArrStart()
			for _, elem := range s.CalculationLog {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDamageCalculationResponse = [5]string{
	0: "final_damage",
	1: "critical_hit",
	2: "damage_type",
	3: "modifiers",
	4: "calculation_log",
}

// Decode decodes DamageCalculationResponse from json.
func (s *DamageCalculationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageCalculationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "final_damage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FinalDamage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_damage\"")
			}
		case "critical_hit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CriticalHit = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_hit\"")
			}
		case "damage_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DamageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_type\"")
			}
		case "modifiers":
			if err := func() error {
				s.Modifiers = make([]DamageModifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DamageModifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Modifiers = append(s.Modifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiers\"")
			}
		case "calculation_log":
			if err := func() error {
				s.CalculationLog = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CalculationLog = append(s.CalculationLog, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calculation_log\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageCalculationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageCalculationResponse) {
					name = jsonFieldsNameOfDamageCalculationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageCalculationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageCalculationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageModifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageModifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("value")
		e.Float32(s.Value)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDamageModifier = [3]string{
	0: "type",
	1: "value",
	2: "description",
}

// Decode decodes DamageModifier from json.
func (s *DamageModifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageModifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Value = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageModifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageModifier) {
					name = jsonFieldsNameOfDamageModifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageModifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageModifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DamageRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DamageRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("base_damage_multiplier")
		e.Float32(s.BaseDamageMultiplier)
	}
	{
		e.FieldStart("critical_hit_multiplier")
		e.Float32(s.CriticalHitMultiplier)
	}
	{
		e.FieldStart("armor_reduction_factor")
		e.Float32(s.ArmorReductionFactor)
	}
}

var jsonFieldsNameOfDamageRules = [3]string{
	0: "base_damage_multiplier",
	1: "critical_hit_multiplier",
	2: "armor_reduction_factor",
}

// Decode decodes DamageRules from json.
func (s *DamageRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DamageRules to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_damage_multiplier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.BaseDamageMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_damage_multiplier\"")
			}
		case "critical_hit_multiplier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CriticalHitMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_hit_multiplier\"")
			}
		case "armor_reduction_factor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.ArmorReductionFactor = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor_reduction_factor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DamageRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDamageRules) {
					name = jsonFieldsNameOfDamageRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DamageRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DamageRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyScaling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyScaling) encodeFields(e *jx.Encoder) {
	{
		if s.EasyMultiplier.Set {
			e.FieldStart("easy_multiplier")
			s.EasyMultiplier.Encode(e)
		}
	}
	{
		if s.NormalMultiplier.Set {
			e.FieldStart("normal_multiplier")
			s.NormalMultiplier.Encode(e)
		}
	}
	{
		if s.HardMultiplier.Set {
			e.FieldStart("hard_multiplier")
			s.HardMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfDifficultyScaling = [3]string{
	0: "easy_multiplier",
	1: "normal_multiplier",
	2: "hard_multiplier",
}

// Decode decodes DifficultyScaling from json.
func (s *DifficultyScaling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyScaling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "easy_multiplier":
			if err := func() error {
				s.EasyMultiplier.Reset()
				if err := s.EasyMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"easy_multiplier\"")
			}
		case "normal_multiplier":
			if err := func() error {
				s.NormalMultiplier.Reset()
				if err := s.NormalMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normal_multiplier\"")
			}
		case "hard_multiplier":
			if err := func() error {
				s.HardMultiplier.Reset()
				if err := s.HardMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyScaling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentalBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentalBalance) encodeFields(e *jx.Encoder) {
	{
		if s.WeatherEffects.Set {
			e.FieldStart("weather_effects")
			s.WeatherEffects.Encode(e)
		}
	}
	{
		if s.TerrainModifiers.Set {
			e.FieldStart("terrain_modifiers")
			s.TerrainModifiers.Encode(e)
		}
	}
	{
		if s.TimeOfDayEffects.Set {
			e.FieldStart("time_of_day_effects")
			s.TimeOfDayEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentalBalance = [3]string{
	0: "weather_effects",
	1: "terrain_modifiers",
	2: "time_of_day_effects",
}

// Decode decodes EnvironmentalBalance from json.
func (s *EnvironmentalBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalBalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather_effects":
			if err := func() error {
				s.WeatherEffects.Reset()
				if err := s.WeatherEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather_effects\"")
			}
		case "terrain_modifiers":
			if err := func() error {
				s.TerrainModifiers.Reset()
				if err := s.TerrainModifiers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_modifiers\"")
			}
		case "time_of_day_effects":
			if err := func() error {
				s.TimeOfDayEffects.Reset()
				if err := s.TimeOfDayEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalBalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentalBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EnvironmentalBalanceTerrainModifiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EnvironmentalBalanceTerrainModifiers) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes EnvironmentalBalanceTerrainModifiers from json.
func (s *EnvironmentalBalanceTerrainModifiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalBalanceTerrainModifiers to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalBalanceTerrainModifiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalBalanceTerrainModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalBalanceTerrainModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EnvironmentalBalanceTimeOfDayEffects) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EnvironmentalBalanceTimeOfDayEffects) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes EnvironmentalBalanceTimeOfDayEffects from json.
func (s *EnvironmentalBalanceTimeOfDayEffects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalBalanceTimeOfDayEffects to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalBalanceTimeOfDayEffects")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalBalanceTimeOfDayEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalBalanceTimeOfDayEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EnvironmentalBalanceWeatherEffects) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EnvironmentalBalanceWeatherEffects) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes EnvironmentalBalanceWeatherEffects from json.
func (s *EnvironmentalBalanceWeatherEffects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalBalanceWeatherEffects to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalBalanceWeatherEffects")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentalBalanceWeatherEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalBalanceWeatherEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentalFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentalFactors) encodeFields(e *jx.Encoder) {
	{
		if s.Weather.Set {
			e.FieldStart("weather")
			s.Weather.Encode(e)
		}
	}
	{
		if s.TimeOfDay.Set {
			e.FieldStart("time_of_day")
			s.TimeOfDay.Encode(e)
		}
	}
	{
		if s.TerrainType.Set {
			e.FieldStart("terrain_type")
			s.TerrainType.Encode(e)
		}
	}
	{
		if s.Modifier.Set {
			e.FieldStart("modifier")
			s.Modifier.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnvironmentalFactors = [4]string{
	0: "weather",
	1: "time_of_day",
	2: "terrain_type",
	3: "modifier",
}

// Decode decodes EnvironmentalFactors from json.
func (s *EnvironmentalFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentalFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weather":
			if err := func() error {
				s.Weather.Reset()
				if err := s.Weather.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weather\"")
			}
		case "time_of_day":
			if err := func() error {
				s.TimeOfDay.Reset()
				if err := s.TimeOfDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day\"")
			}
		case "terrain_type":
			if err := func() error {
				s.TerrainType.Reset()
				if err := s.TerrainType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terrain_type\"")
			}
		case "modifier":
			if err := func() error {
				s.Modifier.Reset()
				if err := s.Modifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentalFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GlobalMultipliers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GlobalMultipliers) encodeFields(e *jx.Encoder) {
	{
		if s.DamageMultiplier.Set {
			e.FieldStart("damage_multiplier")
			s.DamageMultiplier.Encode(e)
		}
	}
	{
		if s.HealingMultiplier.Set {
			e.FieldStart("healing_multiplier")
			s.HealingMultiplier.Encode(e)
		}
	}
	{
		if s.CooldownMultiplier.Set {
			e.FieldStart("cooldown_multiplier")
			s.CooldownMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfGlobalMultipliers = [3]string{
	0: "damage_multiplier",
	1: "healing_multiplier",
	2: "cooldown_multiplier",
}

// Decode decodes GlobalMultipliers from json.
func (s *GlobalMultipliers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GlobalMultipliers to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_multiplier":
			if err := func() error {
				s.DamageMultiplier.Reset()
				if err := s.DamageMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_multiplier\"")
			}
		case "healing_multiplier":
			if err := func() error {
				s.HealingMultiplier.Reset()
				if err := s.HealingMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healing_multiplier\"")
			}
		case "cooldown_multiplier":
			if err := func() error {
				s.CooldownMultiplier.Reset()
				if err := s.CooldownMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GlobalMultipliers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GlobalMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GlobalMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthDetails) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCombatCalculations.Set {
			e.FieldStart("totalCombatCalculations")
			s.TotalCombatCalculations.Encode(e)
		}
	}
	{
		if s.ActiveCombatSessions.Set {
			e.FieldStart("activeCombatSessions")
			s.ActiveCombatSessions.Encode(e)
		}
	}
	{
		if s.TotalAbilities.Set {
			e.FieldStart("totalAbilities")
			s.TotalAbilities.Encode(e)
		}
	}
	{
		if s.ActiveBalanceConfigs.Set {
			e.FieldStart("activeBalanceConfigs")
			s.ActiveBalanceConfigs.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthDetails = [4]string{
	0: "totalCombatCalculations",
	1: "activeCombatSessions",
	2: "totalAbilities",
	3: "activeBalanceConfigs",
}

// Decode decodes HealthDetails from json.
func (s *HealthDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalCombatCalculations":
			if err := func() error {
				s.TotalCombatCalculations.Reset()
				if err := s.TotalCombatCalculations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCombatCalculations\"")
			}
		case "activeCombatSessions":
			if err := func() error {
				s.ActiveCombatSessions.Reset()
				if err := s.ActiveCombatSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeCombatSessions\"")
			}
		case "totalAbilities":
			if err := func() error {
				s.TotalAbilities.Reset()
				if err := s.TotalAbilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAbilities\"")
			}
		case "activeBalanceConfigs":
			if err := func() error {
				s.ActiveBalanceConfigs.Reset()
				if err := s.ActiveBalanceConfigs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalanceConfigs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [4]string{
	0: "status",
	1: "message",
	2: "timestamp",
	3: "details",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	case HealthResponseStatusUnhealthy:
		*s = HealthResponseStatusUnhealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InterruptionRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InterruptionRules) encodeFields(e *jx.Encoder) {
	{
		if s.InterruptionEnabled.Set {
			e.FieldStart("interruption_enabled")
			s.InterruptionEnabled.Encode(e)
		}
	}
	{
		if s.InterruptionChance.Set {
			e.FieldStart("interruption_chance")
			s.InterruptionChance.Encode(e)
		}
	}
}

var jsonFieldsNameOfInterruptionRules = [2]string{
	0: "interruption_enabled",
	1: "interruption_chance",
}

// Decode decodes InterruptionRules from json.
func (s *InterruptionRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InterruptionRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "interruption_enabled":
			if err := func() error {
				s.InterruptionEnabled.Reset()
				if err := s.InterruptionEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interruption_enabled\"")
			}
		case "interruption_chance":
			if err := func() error {
				s.InterruptionChance.Reset()
				if err := s.InterruptionChance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interruption_chance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InterruptionRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InterruptionRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InterruptionRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LevelScaling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LevelScaling) encodeFields(e *jx.Encoder) {
	{
		if s.MinLevel.Set {
			e.FieldStart("min_level")
			s.MinLevel.Encode(e)
		}
	}
	{
		if s.MaxLevel.Set {
			e.FieldStart("max_level")
			s.MaxLevel.Encode(e)
		}
	}
	{
		if s.ScalingFactor.Set {
			e.FieldStart("scaling_factor")
			s.ScalingFactor.Encode(e)
		}
	}
}

var jsonFieldsNameOfLevelScaling = [3]string{
	0: "min_level",
	1: "max_level",
	2: "scaling_factor",
}

// Decode decodes LevelScaling from json.
func (s *LevelScaling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LevelScaling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "min_level":
			if err := func() error {
				s.MinLevel.Reset()
				if err := s.MinLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_level\"")
			}
		case "max_level":
			if err := func() error {
				s.MaxLevel.Reset()
				if err := s.MaxLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_level\"")
			}
		case "scaling_factor":
			if err := func() error {
				s.ScalingFactor.Reset()
				if err := s.ScalingFactor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaling_factor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LevelScaling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LevelScaling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LevelScaling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AbilityConfigurationStatRequirements as json.
func (o OptAbilityConfigurationStatRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AbilityConfigurationStatRequirements from json.
func (o *OptAbilityConfigurationStatRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAbilityConfigurationStatRequirements to nil")
	}
	o.Set = true
	o.Value = make(AbilityConfigurationStatRequirements)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAbilityConfigurationStatRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAbilityConfigurationStatRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BalanceParameters as json.
func (o OptBalanceParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BalanceParameters from json.
func (o *OptBalanceParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBalanceParameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBalanceParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBalanceParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalance as json.
func (o OptCharacterBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterBalance from json.
func (o *OptCharacterBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalanceClassMultipliers as json.
func (o OptCharacterBalanceClassMultipliers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterBalanceClassMultipliers from json.
func (o *OptCharacterBalanceClassMultipliers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalanceClassMultipliers to nil")
	}
	o.Set = true
	o.Value = make(CharacterBalanceClassMultipliers)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalanceClassMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalanceClassMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterBalanceStatWeights as json.
func (o OptCharacterBalanceStatWeights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterBalanceStatWeights from json.
func (o *OptCharacterBalanceStatWeights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterBalanceStatWeights to nil")
	}
	o.Set = true
	o.Value = make(CharacterBalanceStatWeights)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterBalanceStatWeights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterBalanceStatWeights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CombatMechanics as json.
func (o OptCombatMechanics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CombatMechanics from json.
func (o *OptCombatMechanics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCombatMechanics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCombatMechanics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCombatMechanics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DamageRules as json.
func (o OptDamageRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DamageRules from json.
func (o *OptDamageRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDamageRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDamageRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDamageRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EnvironmentalBalance as json.
func (o OptEnvironmentalBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalBalance from json.
func (o *OptEnvironmentalBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalBalanceTerrainModifiers as json.
func (o OptEnvironmentalBalanceTerrainModifiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalBalanceTerrainModifiers from json.
func (o *OptEnvironmentalBalanceTerrainModifiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalBalanceTerrainModifiers to nil")
	}
	o.Set = true
	o.Value = make(EnvironmentalBalanceTerrainModifiers)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalBalanceTerrainModifiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalBalanceTerrainModifiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalBalanceTimeOfDayEffects as json.
func (o OptEnvironmentalBalanceTimeOfDayEffects) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalBalanceTimeOfDayEffects from json.
func (o *OptEnvironmentalBalanceTimeOfDayEffects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalBalanceTimeOfDayEffects to nil")
	}
	o.Set = true
	o.Value = make(EnvironmentalBalanceTimeOfDayEffects)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalBalanceTimeOfDayEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalBalanceTimeOfDayEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalBalanceWeatherEffects as json.
func (o OptEnvironmentalBalanceWeatherEffects) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalBalanceWeatherEffects from json.
func (o *OptEnvironmentalBalanceWeatherEffects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalBalanceWeatherEffects to nil")
	}
	o.Set = true
	o.Value = make(EnvironmentalBalanceWeatherEffects)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalBalanceWeatherEffects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalBalanceWeatherEffects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentalFactors as json.
func (o OptEnvironmentalFactors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentalFactors from json.
func (o *OptEnvironmentalFactors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentalFactors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentalFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentalFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GlobalMultipliers as json.
func (o OptGlobalMultipliers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GlobalMultipliers from json.
func (o *OptGlobalMultipliers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGlobalMultipliers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGlobalMultipliers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGlobalMultipliers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthDetails as json.
func (o OptHealthDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthDetails from json.
func (o *OptHealthDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCombatBalanceConfigRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCombatBalanceConfigRequest) encodeFields(e *jx.Encoder) {
	{
		if s.GlobalMultipliers.Set {
			e.FieldStart("global_multipliers")
			s.GlobalMultipliers.Encode(e)
		}
	}
	{
		if s.CharacterBalance.Set {
			e.FieldStart("character_balance")
			s.CharacterBalance.Encode(e)
		}
	}
	{
		if s.EnvironmentalBalance.Set {
			e.FieldStart("environmental_balance")
			s.EnvironmentalBalance.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCombatBalanceConfigRequest = [3]string{
	0: "global_multipliers",
	1: "character_balance",
	2: "environmental_balance",
}

// Decode decodes UpdateCombatBalanceConfigRequest from json.
func (s *UpdateCombatBalanceConfigRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCombatBalanceConfigRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "global_multipliers":
			if err := func() error {
				s.GlobalMultipliers.Reset()
				if err := s.GlobalMultipliers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"global_multipliers\"")
			}
		case "character_balance":
			if err := func() error {
				s.CharacterBalance.Reset()
				if err := s.CharacterBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_balance\"")
			}
		case "environmental_balance":
			if err := func() error {
				s.EnvironmentalBalance.Reset()
				if err := s.EnvironmentalBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environmental_balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCombatBalanceConfigRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCombatBalanceConfigRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCombatBalanceConfigRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCombatSystemRulesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCombatSystemRulesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.DamageRules.Set {
			e.FieldStart("damage_rules")
			s.DamageRules.Encode(e)
		}
	}
	{
		if s.CombatMechanics.Set {
			e.FieldStart("combat_mechanics")
			s.CombatMechanics.Encode(e)
		}
	}
	{
		if s.BalanceParameters.Set {
			e.FieldStart("balance_parameters")
			s.BalanceParameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCombatSystemRulesRequest = [3]string{
	0: "damage_rules",
	1: "combat_mechanics",
	2: "balance_parameters",
}

// Decode decodes UpdateCombatSystemRulesRequest from json.
func (s *UpdateCombatSystemRulesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCombatSystemRulesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damage_rules":
			if err := func() error {
				s.DamageRules.Reset()
				if err := s.DamageRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_rules\"")
			}
		case "combat_mechanics":
			if err := func() error {
				s.CombatMechanics.Reset()
				if err := s.CombatMechanics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_mechanics\"")
			}
		case "balance_parameters":
			if err := func() error {
				s.BalanceParameters.Reset()
				if err := s.BalanceParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance_parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCombatSystemRulesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCombatSystemRulesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCombatSystemRulesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
