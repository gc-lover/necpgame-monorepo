// Issue: #141886640
package server

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/necpgame/companion-service-go/models"
	"github.com/sirupsen/logrus"
)

type CompanionRepository struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

func NewCompanionRepository(db *pgxpool.Pool) *CompanionRepository {
	return &CompanionRepository{
		db:     db,
		logger: GetLogger(),
	}
}

func (r *CompanionRepository) GetCompanionType(ctx context.Context, companionTypeID string) (*models.CompanionType, error) {
	var companionType models.CompanionType
	var statsJSON, abilitiesJSON []byte

	query := `
		SELECT id, category, name, description, stats, abilities, cost, created_at
		FROM gameplay.companion_types
		WHERE id = $1`

	err := r.db.QueryRow(ctx, query, companionTypeID).Scan(
		&companionType.ID, &companionType.Category, &companionType.Name,
		&companionType.Description, &statsJSON, &abilitiesJSON,
		&companionType.Cost, &companionType.CreatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if len(statsJSON) > 0 {
		if err := json.Unmarshal(statsJSON, &companionType.Stats); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal stats JSON")
			return nil, err
		}
	} else {
		companionType.Stats = make(map[string]interface{})
	}

	if len(abilitiesJSON) > 0 {
		if err := json.Unmarshal(abilitiesJSON, &companionType.Abilities); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal abilities JSON")
			return nil, err
		}
	} else {
		companionType.Abilities = []string{}
	}

	return &companionType, nil
}

func (r *CompanionRepository) ListCompanionTypes(ctx context.Context, category *models.CompanionCategory, limit, offset int) ([]models.CompanionType, error) {
	var query string
	var args []interface{}

	if category != nil {
		query = `
			SELECT id, category, name, description, stats, abilities, cost, created_at
			FROM gameplay.companion_types
			WHERE category = $1
			ORDER BY name
			LIMIT $2 OFFSET $3`
		args = []interface{}{*category, limit, offset}
	} else {
		query = `
			SELECT id, category, name, description, stats, abilities, cost, created_at
			FROM gameplay.companion_types
			ORDER BY name
			LIMIT $1 OFFSET $2`
		args = []interface{}{limit, offset}
	}

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var types []models.CompanionType
	for rows.Next() {
		var companionType models.CompanionType
		var statsJSON, abilitiesJSON []byte

		err := rows.Scan(
			&companionType.ID, &companionType.Category, &companionType.Name,
			&companionType.Description, &statsJSON, &abilitiesJSON,
			&companionType.Cost, &companionType.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		if len(statsJSON) > 0 {
			if err := json.Unmarshal(statsJSON, &companionType.Stats); err != nil {
				r.logger.WithError(err).Error("Failed to unmarshal stats JSON")
				return nil, err
			}
		} else {
			companionType.Stats = make(map[string]interface{})
		}

		if len(abilitiesJSON) > 0 {
			if err := json.Unmarshal(abilitiesJSON, &companionType.Abilities); err != nil {
				r.logger.WithError(err).Error("Failed to unmarshal abilities JSON")
				return nil, err
			}
		} else {
			companionType.Abilities = []string{}
		}

		types = append(types, companionType)
	}

	return types, nil
}

func (r *CompanionRepository) CountCompanionTypes(ctx context.Context, category *models.CompanionCategory) (int, error) {
	var count int
	var query string
	var args []interface{}

	if category != nil {
		query = `SELECT COUNT(*) FROM gameplay.companion_types WHERE category = $1`
		args = []interface{}{*category}
	} else {
		query = `SELECT COUNT(*) FROM gameplay.companion_types`
		args = []interface{}{}
	}

	err := r.db.QueryRow(ctx, query, args...).Scan(&count)
	return count, err
}

func (r *CompanionRepository) CreatePlayerCompanion(ctx context.Context, companion *models.PlayerCompanion) error {
	equipmentJSON, err := json.Marshal(companion.Equipment)
	if err != nil {
		r.logger.WithError(err).Error("Failed to marshal equipment JSON")
		return err
	}
	statsJSON, err := json.Marshal(companion.Stats)
	if err != nil {
		r.logger.WithError(err).Error("Failed to marshal stats JSON")
		return err
	}

	query := `
		INSERT INTO gameplay.player_companions (
			id, character_id, companion_type_id, custom_name, level,
			experience, status, equipment, stats, summoned_at, created_at, updated_at
		) VALUES (
			gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW()
		) RETURNING id, created_at, updated_at`

	err = r.db.QueryRow(ctx, query,
		companion.CharacterID, companion.CompanionTypeID, companion.CustomName,
		companion.Level, companion.Experience, companion.Status,
		equipmentJSON, statsJSON, companion.SummonedAt,
	).Scan(&companion.ID, &companion.CreatedAt, &companion.UpdatedAt)

	return err
}

func (r *CompanionRepository) GetPlayerCompanion(ctx context.Context, companionID uuid.UUID) (*models.PlayerCompanion, error) {
	var companion models.PlayerCompanion
	var equipmentJSON, statsJSON []byte

	query := `
		SELECT id, character_id, companion_type_id, custom_name, level,
		       experience, status, equipment, stats, summoned_at, created_at, updated_at
		FROM gameplay.player_companions
		WHERE id = $1`

	err := r.db.QueryRow(ctx, query, companionID).Scan(
		&companion.ID, &companion.CharacterID, &companion.CompanionTypeID,
		&companion.CustomName, &companion.Level, &companion.Experience,
		&companion.Status, &equipmentJSON, &statsJSON,
		&companion.SummonedAt, &companion.CreatedAt, &companion.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if len(equipmentJSON) > 0 {
		if err := json.Unmarshal(equipmentJSON, &companion.Equipment); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal equipment JSON")
			return nil, err
		}
	} else {
		companion.Equipment = make(map[string]interface{})
	}

	if len(statsJSON) > 0 {
		if err := json.Unmarshal(statsJSON, &companion.Stats); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal stats JSON")
			return nil, err
		}
	} else {
		companion.Stats = make(map[string]interface{})
	}

	return &companion, nil
}

func (r *CompanionRepository) GetActiveCompanion(ctx context.Context, characterID uuid.UUID) (*models.PlayerCompanion, error) {
	var companion models.PlayerCompanion
	var equipmentJSON, statsJSON []byte

	query := `
		SELECT id, character_id, companion_type_id, custom_name, level,
		       experience, status, equipment, stats, summoned_at, created_at, updated_at
		FROM gameplay.player_companions
		WHERE character_id = $1 AND status = 'summoned'
		LIMIT 1`

	err := r.db.QueryRow(ctx, query, characterID).Scan(
		&companion.ID, &companion.CharacterID, &companion.CompanionTypeID,
		&companion.CustomName, &companion.Level, &companion.Experience,
		&companion.Status, &equipmentJSON, &statsJSON,
		&companion.SummonedAt, &companion.CreatedAt, &companion.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if len(equipmentJSON) > 0 {
		if err := json.Unmarshal(equipmentJSON, &companion.Equipment); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal equipment JSON")
			return nil, err
		}
	} else {
		companion.Equipment = make(map[string]interface{})
	}

	if len(statsJSON) > 0 {
		if err := json.Unmarshal(statsJSON, &companion.Stats); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal stats JSON")
			return nil, err
		}
	} else {
		companion.Stats = make(map[string]interface{})
	}

	return &companion, nil
}

func (r *CompanionRepository) UpdatePlayerCompanion(ctx context.Context, companion *models.PlayerCompanion) error {
	equipmentJSON, err := json.Marshal(companion.Equipment)
	if err != nil {
		r.logger.WithError(err).Error("Failed to marshal equipment JSON")
		return err
	}
	statsJSON, err := json.Marshal(companion.Stats)
	if err != nil {
		r.logger.WithError(err).Error("Failed to marshal stats JSON")
		return err
	}

	query := `
		UPDATE gameplay.player_companions
		SET custom_name = $1, level = $2, experience = $3, status = $4,
		    equipment = $5, stats = $6, summoned_at = $7, updated_at = NOW()
		WHERE id = $8`

	_, err = r.db.Exec(ctx, query,
		companion.CustomName, companion.Level, companion.Experience,
		companion.Status, equipmentJSON, statsJSON, companion.SummonedAt,
		companion.ID,
	)

	return err
}

func (r *CompanionRepository) ListPlayerCompanions(ctx context.Context, characterID uuid.UUID, status *models.CompanionStatus, limit, offset int) ([]models.PlayerCompanion, error) {
	var query string
	var args []interface{}

	if status != nil {
		query = `
			SELECT id, character_id, companion_type_id, custom_name, level,
			       experience, status, equipment, stats, summoned_at, created_at, updated_at
			FROM gameplay.player_companions
			WHERE character_id = $1 AND status = $2
			ORDER BY updated_at DESC
			LIMIT $3 OFFSET $4`
		args = []interface{}{characterID, *status, limit, offset}
	} else {
		query = `
			SELECT id, character_id, companion_type_id, custom_name, level,
			       experience, status, equipment, stats, summoned_at, created_at, updated_at
			FROM gameplay.player_companions
			WHERE character_id = $1
			ORDER BY updated_at DESC
			LIMIT $2 OFFSET $3`
		args = []interface{}{characterID, limit, offset}
	}

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var companions []models.PlayerCompanion
	for rows.Next() {
		var companion models.PlayerCompanion
		var equipmentJSON, statsJSON []byte

		err := rows.Scan(
			&companion.ID, &companion.CharacterID, &companion.CompanionTypeID,
			&companion.CustomName, &companion.Level, &companion.Experience,
			&companion.Status, &equipmentJSON, &statsJSON,
			&companion.SummonedAt, &companion.CreatedAt, &companion.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		if len(equipmentJSON) > 0 {
			json.Unmarshal(equipmentJSON, &companion.Equipment)
		} else {
			companion.Equipment = make(map[string]interface{})
		}

		if len(statsJSON) > 0 {
			json.Unmarshal(statsJSON, &companion.Stats)
		} else {
			companion.Stats = make(map[string]interface{})
		}

		companions = append(companions, companion)
	}

	return companions, nil
}

func (r *CompanionRepository) CountPlayerCompanions(ctx context.Context, characterID uuid.UUID, status *models.CompanionStatus) (int, error) {
	var count int
	var query string
	var args []interface{}

	if status != nil {
		query = `SELECT COUNT(*) FROM gameplay.player_companions WHERE character_id = $1 AND status = $2`
		args = []interface{}{characterID, *status}
	} else {
		query = `SELECT COUNT(*) FROM gameplay.player_companions WHERE character_id = $1`
		args = []interface{}{characterID}
	}

	err := r.db.QueryRow(ctx, query, args...).Scan(&count)
	return count, err
}

func (r *CompanionRepository) GetCompanionAbility(ctx context.Context, playerCompanionID uuid.UUID, abilityID string) (*models.CompanionAbility, error) {
	var ability models.CompanionAbility

	query := `
		SELECT id, player_companion_id, ability_id, is_active,
		       cooldown_until, last_used_at, updated_at
		FROM gameplay.companion_abilities
		WHERE player_companion_id = $1 AND ability_id = $2`

	err := r.db.QueryRow(ctx, query, playerCompanionID, abilityID).Scan(
		&ability.ID, &ability.PlayerCompanionID, &ability.AbilityID,
		&ability.IsActive, &ability.CooldownUntil, &ability.LastUsedAt,
		&ability.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &ability, nil
}

func (r *CompanionRepository) CreateCompanionAbility(ctx context.Context, ability *models.CompanionAbility) error {
	query := `
		INSERT INTO gameplay.companion_abilities (
			id, player_companion_id, ability_id, is_active,
			cooldown_until, last_used_at, updated_at
		) VALUES (
			gen_random_uuid(), $1, $2, $3, $4, $5, NOW()
		) RETURNING id, updated_at`

	err := r.db.QueryRow(ctx, query,
		ability.PlayerCompanionID, ability.AbilityID, ability.IsActive,
		ability.CooldownUntil, ability.LastUsedAt,
	).Scan(&ability.ID, &ability.UpdatedAt)

	return err
}

func (r *CompanionRepository) UpdateCompanionAbility(ctx context.Context, ability *models.CompanionAbility) error {
	query := `
		UPDATE gameplay.companion_abilities
		SET is_active = $1, cooldown_until = $2, last_used_at = $3, updated_at = NOW()
		WHERE id = $4`

	_, err := r.db.Exec(ctx, query,
		ability.IsActive, ability.CooldownUntil, ability.LastUsedAt,
		ability.ID,
	)

	return err
}

func (r *CompanionRepository) ListCompanionAbilities(ctx context.Context, playerCompanionID uuid.UUID) ([]models.CompanionAbility, error) {
	query := `
		SELECT id, player_companion_id, ability_id, is_active,
		       cooldown_until, last_used_at, updated_at
		FROM gameplay.companion_abilities
		WHERE player_companion_id = $1
		ORDER BY ability_id`

	rows, err := r.db.Query(ctx, query, playerCompanionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var abilities []models.CompanionAbility
	for rows.Next() {
		var ability models.CompanionAbility
		err := rows.Scan(
			&ability.ID, &ability.PlayerCompanionID, &ability.AbilityID,
			&ability.IsActive, &ability.CooldownUntil, &ability.LastUsedAt,
			&ability.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		abilities = append(abilities, ability)
	}

	return abilities, nil
}

