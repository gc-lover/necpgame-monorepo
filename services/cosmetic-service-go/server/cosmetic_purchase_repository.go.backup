package server

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/necpgame/cosmetic-service-go/models"
	"github.com/sirupsen/logrus"
)

type CosmeticPurchaseRepository struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

func NewCosmeticPurchaseRepository(db *pgxpool.Pool) *CosmeticPurchaseRepository {
	return &CosmeticPurchaseRepository{
		db:     db,
		logger: GetLogger(),
	}
}

func (r *CosmeticPurchaseRepository) CreatePlayerCosmetic(ctx context.Context, playerID, cosmeticID uuid.UUID, source string) (*models.PlayerCosmetic, error) {
	query := `
		INSERT INTO monetization.player_cosmetics (
			id, player_id, cosmetic_item_id, source, obtained_at, times_used, created_at
		) VALUES (
			gen_random_uuid(), $1, $2, $3, NOW(), 0, NOW()
		) RETURNING id, obtained_at, created_at`

	var playerCosmetic models.PlayerCosmetic
	err := r.db.QueryRow(ctx, query, playerID, cosmeticID, source).Scan(
		&playerCosmetic.ID, &playerCosmetic.ObtainedAt, &playerCosmetic.CreatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create player cosmetic: %w", err)
	}

	playerCosmetic.PlayerID = playerID
	playerCosmetic.CosmeticItemID = cosmeticID
	playerCosmetic.Source = source
	playerCosmetic.TimesUsed = 0

	cosmeticItem, err := r.getCosmeticItem(ctx, cosmeticID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cosmetic item: %w", err)
	}
	playerCosmetic.CosmeticItem = cosmeticItem

	return &playerCosmetic, nil
}

func (r *CosmeticPurchaseRepository) GetPurchaseHistory(ctx context.Context, playerID uuid.UUID, limit, offset int) ([]models.PurchaseRecord, int, error) {
	var total int
	countQuery := `
		SELECT COUNT(*)
		FROM monetization.cosmetic_purchases
		WHERE player_id = $1`
	err := r.db.QueryRow(ctx, countQuery, playerID).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count purchases: %w", err)
	}

	query := `
		SELECT cp.id, cp.player_id, cp.cosmetic_item_id, cp.cost, cp.currency_type, cp.purchased_at
		FROM monetization.cosmetic_purchases cp
		WHERE cp.player_id = $1
		ORDER BY cp.purchased_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := r.db.Query(ctx, query, playerID, limit, offset)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get purchase history: %w", err)
	}
	defer rows.Close()

	var purchases []models.PurchaseRecord
	for rows.Next() {
		var purchase models.PurchaseRecord

		err := rows.Scan(
			&purchase.ID, &purchase.PlayerID, &purchase.CosmeticItemID,
			&purchase.Cost, &purchase.CurrencyType, &purchase.PurchasedAt,
		)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to scan purchase: %w", err)
		}

		cosmeticItem, err := r.getCosmeticItem(ctx, purchase.CosmeticItemID)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to get cosmetic item: %w", err)
		}
		purchase.CosmeticItem = cosmeticItem

		purchases = append(purchases, purchase)
	}

	return purchases, total, nil
}

func (r *CosmeticPurchaseRepository) CreatePurchaseRecord(ctx context.Context, playerID, cosmeticID uuid.UUID, cost int64, currencyType string) error {
	query := `
		INSERT INTO monetization.cosmetic_purchases (
			id, player_id, cosmetic_item_id, cost, currency_type, purchased_at
		) VALUES (
			gen_random_uuid(), $1, $2, $3, $4, NOW()
		)`

	_, err := r.db.Exec(ctx, query, playerID, cosmeticID, cost, currencyType)
	if err != nil {
		return fmt.Errorf("failed to create purchase record: %w", err)
	}

	return nil
}

func (r *CosmeticPurchaseRepository) getCosmeticItem(ctx context.Context, cosmeticID uuid.UUID) (*models.CosmeticItem, error) {
	var item models.CosmeticItem
	var visualEffectsJSON []byte
	var assetsJSON []byte

	query := `
		SELECT id, code, name, category, cosmetic_type, rarity, description,
			cost, currency_type, is_exclusive, source, visual_effects, assets,
			is_active, created_at, updated_at
		FROM monetization.cosmetic_items
		WHERE id = $1`

	err := r.db.QueryRow(ctx, query, cosmeticID).Scan(
		&item.ID, &item.Code, &item.Name, &item.Category, &item.CosmeticType,
		&item.Rarity, &item.Description, &item.Cost, &item.CurrencyType,
		&item.IsExclusive, &item.Source, &visualEffectsJSON, &assetsJSON,
		&item.IsActive, &item.CreatedAt, &item.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, fmt.Errorf("cosmetic item not found: %s", cosmeticID)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get cosmetic item: %w", err)
	}

	if len(visualEffectsJSON) > 0 {
		if err := json.Unmarshal(visualEffectsJSON, &item.VisualEffects); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal visual_effects JSON")
			return nil, fmt.Errorf("failed to unmarshal visual_effects JSON: %w", err)
		}
	}

	if len(assetsJSON) > 0 {
		if err := json.Unmarshal(assetsJSON, &item.Assets); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal assets JSON")
			return nil, fmt.Errorf("failed to unmarshal assets JSON: %w", err)
		}
	}

	return &item, nil
}

