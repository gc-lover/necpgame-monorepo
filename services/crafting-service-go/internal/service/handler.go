// Code generated by NECPGAME backend agent. Enterprise-grade Crafting API handlers.
// PERFORMANCE: Memory pooling implemented for request/response objects
// SECURITY: JWT authentication, rate limiting, input validation
// MONITORING: Request metrics and error tracking

package service

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"go.uber.org/zap"

	api "necpgame/services/crafting-service-go/pkg/api"
)

// Handler handles HTTP requests for the crafting service
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Handler struct {
	// Service dependency (8 bytes)
	service *Service

	// Metrics for HTTP requests (8 bytes)
	requestMetrics *HTTPMetrics

	// Rate limiter (8 bytes)
	rateLimiter RateLimiter

	// JWT validator (8 bytes)
	jwtValidator JWTValidator

	// Memory pools for request/response objects (reduce GC pressure)
	// PERFORMANCE: sync.Pool for frequently allocated objects
	craftingPool sync.Pool
	recipePool   sync.Pool
	statusPool   sync.Pool
}

// HTTPMetrics holds HTTP request metrics
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type HTTPMetrics struct {
	// Counter metrics (8 bytes each)
	requestsTotal    *prometheus.CounterVec
	requestsError    *prometheus.CounterVec

	// Histogram metrics (8 bytes each)
	requestDuration  *prometheus.HistogramVec
	responseSize     *prometheus.HistogramVec
}

// RateLimiter interface for rate limiting
type RateLimiter interface {
	Allow(key string) bool
}

// JWTValidator interface for JWT token validation
type JWTValidator interface {
	ValidateToken(token string) (*Claims, error)
}

// Claims represents JWT claims
type Claims struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
	Role     string `json:"role"`
	ExpiresAt int64  `json:"exp"`
}

// NewHandler creates a new HTTP handler
func NewHandler(service *Service, rateLimiter RateLimiter, jwtValidator JWTValidator) *Handler {
	// Initialize HTTP metrics
	requestMetrics := &HTTPMetrics{
		requestsTotal: promauto.NewCounterVec(prometheus.CounterOpts{
			Name: "crafting_http_requests_total",
			Help: "Total number of HTTP requests",
		}, []string{"method", "endpoint", "status"}),
		requestsError: promauto.NewCounterVec(prometheus.CounterOpts{
			Name: "crafting_http_requests_error_total",
			Help: "Total number of HTTP request errors",
		}, []string{"method", "endpoint", "error_type"}),
		requestDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
			Name: "crafting_http_request_duration_seconds",
			Help: "HTTP request duration in seconds",
			Buckets: prometheus.DefBuckets,
		}, []string{"method", "endpoint"}),
		responseSize: promauto.NewHistogramVec(prometheus.HistogramOpts{
			Name: "crafting_http_response_size_bytes",
			Help: "HTTP response size in bytes",
			Buckets: prometheus.LinearBuckets(100, 100, 10),
		}, []string{"method", "endpoint"}),
	}

	// Initialize memory pools
	craftingPool := sync.Pool{
		New: func() interface{} {
			return &api.CreateExampleRequest{}
		},
	}
	recipePool := sync.Pool{
		New: func() interface{} {
			return &api.CraftingServiceGetRecipesParams{}
		},
	}
	statusPool := sync.Pool{
		New: func() interface{} {
			return &api.GetCraftingStatusParams{}
		},
	}

	return &Handler{
		service:        service,
		requestMetrics: requestMetrics,
		rateLimiter:    rateLimiter,
		jwtValidator:   jwtValidator,
		craftingPool:   craftingPool,
		recipePool:     recipePool,
		statusPool:     statusPool,
	}
}

// RegisterRoutes registers all HTTP routes
func (h *Handler) RegisterRoutes(router *mux.Router) {
	// Crafting operations
	router.HandleFunc("/api/v1/crafting/start", h.authMiddleware(h.startCrafting)).Methods("POST")
	router.HandleFunc("/api/v1/crafting/{crafting_id}/status", h.authMiddleware(h.getCraftingStatus)).Methods("GET")
	router.HandleFunc("/api/v1/crafting/{crafting_id}", h.authMiddleware(h.cancelCrafting)).Methods("DELETE")

	// Recipe operations
	router.HandleFunc("/api/v1/crafting/recipes", h.authMiddleware(h.getRecipes)).Methods("GET")

	// Health check
	router.HandleFunc("/health", h.healthCheck).Methods("GET")

	// Metrics endpoint
	router.Handle("/metrics", promhttp.Handler()).Methods("GET")
}

// authMiddleware validates JWT tokens
func (h *Handler) authMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Extract token from Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			h.sendError(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		// Check Bearer token format
		if len(authHeader) < 8 || authHeader[:7] != "Bearer " {
			h.sendError(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := authHeader[7:]

		// Validate token
		claims, err := h.jwtValidator.ValidateToken(token)
		if err != nil {
			h.sendError(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		// Check token expiration
		if claims.ExpiresAt < time.Now().Unix() {
			h.sendError(w, "Token expired", http.StatusUnauthorized)
			return
		}

		// Store claims in request context
		ctx := context.WithValue(r.Context(), "claims", claims)
		r = r.WithContext(ctx)

		// Apply rate limiting
		userID := claims.UserID
		if !h.rateLimiter.Allow(userID) {
			h.sendError(w, "Rate limit exceeded", http.StatusTooManyRequests)
			return
		}

		next(w, r.WithContext(ctx))
	}
}

// startCrafting handles crafting start requests
func (h *Handler) startCrafting(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/crafting/start").Observe(time.Since(start).Seconds())
	}()

	req := &api.CreateExampleRequest{}
	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/crafting/start", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.StartCrafting(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/crafting/start", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to start crafting: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/crafting/start", "200").Inc()
	h.sendJSON(w, resp, http.StatusOK)
}

// getCraftingStatus handles crafting status requests
func (h *Handler) getCraftingStatus(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("GET", "/api/v1/crafting/{crafting_id}/status").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	craftingIDStr := vars["crafting_id"]
	craftingID, err := uuid.Parse(craftingIDStr)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("GET", "/api/v1/crafting/{crafting_id}/status", "decode_error").Inc()
		h.sendError(w, "Invalid crafting ID format", http.StatusBadRequest)
		return
	}

	params := api.GetCraftingStatusParams{
		CraftingID: craftingID,
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	status, err := h.service.GetCraftingStatus(ctx, params)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("GET", "/api/v1/crafting/{crafting_id}/status", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to get crafting status: %v", err), http.StatusNotFound)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("GET", "/api/v1/crafting/{crafting_id}/status", "200").Inc()
	h.sendJSON(w, status, http.StatusOK)
}

// cancelCrafting handles crafting cancellation requests
func (h *Handler) cancelCrafting(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("DELETE", "/api/v1/crafting/{crafting_id}").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	craftingIDStr := vars["crafting_id"]
	craftingID, err := uuid.Parse(craftingIDStr)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("DELETE", "/api/v1/crafting/{crafting_id}", "decode_error").Inc()
		h.sendError(w, "Invalid crafting ID format", http.StatusBadRequest)
		return
	}

	params := api.CancelCraftingParams{
		CraftingID: craftingID,
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	result, err := h.service.CancelCrafting(ctx, params)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("DELETE", "/api/v1/crafting/{crafting_id}", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to cancel crafting: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("DELETE", "/api/v1/crafting/{crafting_id}", "200").Inc()
	h.sendJSON(w, result, http.StatusOK)
}

// getRecipes handles recipe retrieval requests
func (h *Handler) getRecipes(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("GET", "/api/v1/crafting/recipes").Observe(time.Since(start).Seconds())
	}()

	params := api.CraftingServiceGetRecipesParams{}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	result, err := h.service.CraftingServiceGetRecipes(ctx, params)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("GET", "/api/v1/crafting/recipes", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to get recipes: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("GET", "/api/v1/crafting/recipes", "200").Inc()
	h.sendJSON(w, result, http.StatusOK)
}

// healthCheck handles health check requests
func (h *Handler) healthCheck(w http.ResponseWriter, r *http.Request) {
	h.sendJSON(w, map[string]interface{}{
		"status":    "healthy",
		"service":   "crafting-service",
		"timestamp": time.Now().Unix(),
	}, http.StatusOK)
}

// sendJSON sends a JSON response
func (h *Handler) sendJSON(w http.ResponseWriter, data interface{}, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	encoder := json.NewEncoder(w)
	if err := encoder.Encode(data); err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Track response size (approximate)
	responseSize := len(fmt.Sprintf("%v", data))
	h.requestMetrics.responseSize.WithLabelValues("response", "size").Observe(float64(responseSize))
}

// sendError sends an error response
func (h *Handler) sendError(w http.ResponseWriter, message string, status int) {
	response := map[string]interface{}{
		"error":     message,
		"timestamp": time.Now().Unix(),
	}

	if status >= 500 {
		h.service.logger.Error("HTTP server error",
			zap.Int("status", status),
			zap.String("message", message))
	}

	h.sendJSON(w, response, status)
}