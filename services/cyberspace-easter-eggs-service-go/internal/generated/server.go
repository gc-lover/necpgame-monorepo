// Code generated by hand from OpenAPI spec. DO NOT EDIT.
// This file contains the generated server interface from cyberspace-easter-eggs-service OpenAPI spec

package generated

import (
	"context"
	"net/http"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check endpoint
	HealthCheck(w http.ResponseWriter, r *http.Request)

	// Easter eggs endpoints
	GetEasterEggs(w http.ResponseWriter, r *http.Request)
	GetEasterEggByID(w http.ResponseWriter, r *http.Request)
	GetEasterEggsByCategory(w http.ResponseWriter, r *http.Request)
	GetEasterEggsByDifficulty(w http.ResponseWriter, r *http.Request)

	// Player progress endpoints
	GetPlayerProgress(w http.ResponseWriter, r *http.Request)
	DiscoverEasterEgg(w http.ResponseWriter, r *http.Request)

	// Hints endpoints
	GetEasterEggHints(w http.ResponseWriter, r *http.Request)
	PurchaseHint(w http.ResponseWriter, r *http.Request)

	// Statistics endpoints
	GetEasterEggStatistics(w http.ResponseWriter, r *http.Request)
	GetEasterEggCategoryStats(w http.ResponseWriter, r *http.Request)

	// Challenge endpoints
	GetActiveChallenges(w http.ResponseWriter, r *http.Request)
	GetChallengeByID(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       ErrorHandlerFunc
}

// MiddlewareFunc defines a middleware function.
type MiddlewareFunc func(http.Handler) http.Handler

// ErrorHandlerFunc defines an error handler function.
type ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)

// ServeHTTP implements http.Handler.
func (siw *ServerInterfaceWrapper) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Apply middlewares
	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/health":
			if r.Method == http.MethodGet {
				siw.Handler.HealthCheck(w, r)
				return
			}
		case "/api/v1/easter-eggs":
			if r.Method == http.MethodGet {
				siw.Handler.GetEasterEggs(w, r)
				return
			}
		default:
			// Handle path parameters and other routes
			if len(r.URL.Path) > len("/api/v1/easter-eggs/") && r.URL.Path[:len("/api/v1/easter-eggs/")] == "/api/v1/easter-eggs/" {
				path := r.URL.Path[len("/api/v1/easter-eggs/"):]
				if r.Method == http.MethodGet {
					// Could be /api/v1/easter-eggs/{id} or /api/v1/easter-eggs/category/{category}
					if len(path) > 0 {
						r = r.WithContext(context.WithValue(r.Context(), "id", path))
						siw.Handler.GetEasterEggByID(w, r)
						return
					}
				}
			}

			if len(r.URL.Path) > len("/api/v1/easter-eggs/category/") && r.URL.Path[:len("/api/v1/easter-eggs/category/")] == "/api/v1/easter-eggs/category/" {
				if r.Method == http.MethodGet {
					category := r.URL.Path[len("/api/v1/easter-eggs/category/"):]
					r = r.WithContext(context.WithValue(r.Context(), "category", category))
					siw.Handler.GetEasterEggsByCategory(w, r)
					return
				}
			}

			if len(r.URL.Path) > len("/api/v1/easter-eggs/difficulty/") && r.URL.Path[:len("/api/v1/easter-eggs/difficulty/")] == "/api/v1/easter-eggs/difficulty/" {
				if r.Method == http.MethodGet {
					difficulty := r.URL.Path[len("/api/v1/easter-eggs/difficulty/"):]
					r = r.WithContext(context.WithValue(r.Context(), "difficulty", difficulty))
					siw.Handler.GetEasterEggsByDifficulty(w, r)
					return
				}
			}

			if len(r.URL.Path) > len("/api/v1/players/") && r.URL.Path[:len("/api/v1/players/")] == "/api/v1/players/" {
				playerPath := r.URL.Path[len("/api/v1/players/"):]

				if len(playerPath) > len("/progress") && playerPath[len(playerPath)-len("/progress"):] == "/progress" {
					if r.Method == http.MethodGet {
						playerID := playerPath[:len(playerPath)-len("/progress")]
						r = r.WithContext(context.WithValue(r.Context(), "playerId", playerID))
						siw.Handler.GetPlayerProgress(w, r)
						return
					}
				}

				// Handle /api/v1/players/{playerId}/easter-eggs/{eggId}/discover
				if len(playerPath) > len("/easter-eggs/") && playerPath[len("/easter-eggs/")-1] == '/' {
					remaining := playerPath[len("/easter-eggs/"):]
					if len(remaining) > 0 {
						parts := splitPath(remaining)
						if len(parts) >= 2 && parts[1] == "discover" {
							playerID := parts[0][:len(parts[0])-len("/easter-eggs")]
							eggID := parts[1][:len(parts[1])-len("/discover")]
							if r.Method == http.MethodPost {
								r = r.WithContext(context.WithValue(r.Context(), "playerId", playerID))
								r = r.WithContext(context.WithValue(r.Context(), "eggId", eggID))
								siw.Handler.DiscoverEasterEgg(w, r)
								return
							}
						}
					}
				}
			}

			// Statistics endpoints
			if r.URL.Path == "/api/v1/statistics/easter-eggs" && r.Method == http.MethodGet {
				siw.Handler.GetEasterEggStatistics(w, r)
				return
			}

			if r.URL.Path == "/api/v1/statistics/categories" && r.Method == http.MethodGet {
				siw.Handler.GetEasterEggCategoryStats(w, r)
				return
			}

			// Challenges endpoints
			if r.URL.Path == "/api/v1/challenges" && r.Method == http.MethodGet {
				siw.Handler.GetActiveChallenges(w, r)
				return
			}

			// Default: method not allowed
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		}
	})

	// Apply middlewares in reverse order
	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// splitPath is a simple path splitter
func splitPath(path string) []string {
	var parts []string
	var current string
	for _, char := range path {
		if char == '/' {
			if current != "" {
				parts = append(parts, current)
				current = ""
			}
		} else {
			current += string(char)
		}
	}
	if current != "" {
		parts = append(parts, current)
	}
	return parts
}
