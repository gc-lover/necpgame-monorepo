// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CalibrateCyberwareInstallation invokes calibrateCyberwareInstallation operation.
	//
	// **Neural calibration procedure**
	// Performs comprehensive neural recalibration, performance optimization, and system synchronization
	// for optimal cyberware functionality.
	// **Time-Intensive Operation:** Requires neural focus.
	//
	// POST /cyberware/installations/{installation_id}/calibrate
	CalibrateCyberwareInstallation(ctx context.Context, request *CalibrateCyberwareRequest, params CalibrateCyberwareInstallationParams) (CalibrateCyberwareInstallationRes, error)
	// CheckCyberwareCompatibility invokes checkCyberwareCompatibility operation.
	//
	// **Compatibility validation engine**
	// Performs comprehensive compatibility analysis between cyberware components, existing installations,
	//  and neural capacity.
	// **Validation Operation:** Prevents system conflicts.
	//
	// POST /cyberware/compatibility
	CheckCyberwareCompatibility(ctx context.Context, request *CyberwareCompatibilityRequest) (CheckCyberwareCompatibilityRes, error)
	// CyberwareDomainBatchHealthCheck invokes cyberwareDomainBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple domain health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	CyberwareDomainBatchHealthCheck(ctx context.Context, request *CyberwareDomainBatchHealthCheckReq) (CyberwareDomainBatchHealthCheckRes, error)
	// CyberwareDomainHealthCheck invokes cyberwareDomainHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the cyberware domain microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	CyberwareDomainHealthCheck(ctx context.Context, params CyberwareDomainHealthCheckParams) (CyberwareDomainHealthCheckRes, error)
	// CyberwareDomainHealthWebSocket invokes cyberwareDomainHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	CyberwareDomainHealthWebSocket(ctx context.Context, params CyberwareDomainHealthWebSocketParams) (CyberwareDomainHealthWebSocketRes, error)
	// GetCyberwareDiagnostics invokes getCyberwareDiagnostics operation.
	//
	// **Comprehensive system diagnostics**
	// Provides detailed health assessment, performance metrics, neural integration status, and
	// maintenance recommendations.
	// **Diagnostic Operation:** Non-invasive analysis.
	//
	// GET /cyberware/installations/{installation_id}/diagnostics
	GetCyberwareDiagnostics(ctx context.Context, params GetCyberwareDiagnosticsParams) (GetCyberwareDiagnosticsRes, error)
	// GetCyberwareInstallation invokes getCyberwareInstallation operation.
	//
	// **Enterprise-grade installation retrieval**
	// Returns comprehensive cyberware installation information including real-time performance metrics,
	// neural integration status, and maintenance requirements.
	// **Performance:** <5ms P95 with Redis caching.
	//
	// GET /cyberware/installations/{installation_id}
	GetCyberwareInstallation(ctx context.Context, params GetCyberwareInstallationParams) (GetCyberwareInstallationRes, error)
	// InstallCyberware invokes installCyberware operation.
	//
	// **Enterprise-grade cyberware installation**
	// Performs complete cyberware installation with neural integration, compatibility validation, and
	// safety protocols.
	// **Critical Operation:** Requires neural synchronization.
	//
	// POST /cyberware/installations
	InstallCyberware(ctx context.Context, request *InstallCyberwareRequest) (InstallCyberwareRes, error)
	// ListCyberwareInstallations invokes listCyberwareInstallations operation.
	//
	// **Enterprise-grade installation listing**
	// Lists all cyberware installations with comprehensive filtering by type, status, performance
	// metrics, and health indicators.
	// **Performance:** <10ms P95, supports complex queries.
	//
	// GET /cyberware/installations
	ListCyberwareInstallations(ctx context.Context, params ListCyberwareInstallationsParams) (ListCyberwareInstallationsRes, error)
	// OptimizeCyberwarePerformance invokes optimizeCyberwarePerformance operation.
	//
	// **Performance optimization engine**
	// Analyzes and optimizes cyberware performance across all installations, balancing power consumption,
	//  neural load, and operational efficiency.
	// **Optimization Operation:** System-wide tuning.
	//
	// POST /cyberware/performance/optimize
	OptimizeCyberwarePerformance(ctx context.Context, request *OptimizePerformanceRequest, params OptimizeCyberwarePerformanceParams) (OptimizeCyberwarePerformanceRes, error)
	// RemoveCyberwareInstallation invokes removeCyberwareInstallation operation.
	//
	// **Surgical cyberware removal**
	// Performs controlled removal with neural disconnection and system stabilization protocols.
	// **High-Risk Operation:** May cause neural trauma.
	//
	// DELETE /cyberware/installations/{installation_id}
	RemoveCyberwareInstallation(ctx context.Context, params RemoveCyberwareInstallationParams) (RemoveCyberwareInstallationRes, error)
	// UpdateCyberwareInstallation invokes updateCyberwareInstallation operation.
	//
	// **Enterprise-grade installation update**
	// Updates installation parameters, recalibrates settings, or applies maintenance fixes with
	// optimistic locking.
	// **Performance:** <25ms P95, includes validation and conflict resolution.
	//
	// PUT /cyberware/installations/{installation_id}
	UpdateCyberwareInstallation(ctx context.Context, request *UpdateCyberwareInstallationRequest, params UpdateCyberwareInstallationParams) (UpdateCyberwareInstallationRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}
type errorHandler interface {
	NewError(ctx context.Context, err error) *ErrRespStatusCode
}

var _ Handler = struct {
	errorHandler
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CalibrateCyberwareInstallation invokes calibrateCyberwareInstallation operation.
//
// **Neural calibration procedure**
// Performs comprehensive neural recalibration, performance optimization, and system synchronization
// for optimal cyberware functionality.
// **Time-Intensive Operation:** Requires neural focus.
//
// POST /cyberware/installations/{installation_id}/calibrate
func (c *Client) CalibrateCyberwareInstallation(ctx context.Context, request *CalibrateCyberwareRequest, params CalibrateCyberwareInstallationParams) (CalibrateCyberwareInstallationRes, error) {
	res, err := c.sendCalibrateCyberwareInstallation(ctx, request, params)
	return res, err
}

func (c *Client) sendCalibrateCyberwareInstallation(ctx context.Context, request *CalibrateCyberwareRequest, params CalibrateCyberwareInstallationParams) (res CalibrateCyberwareInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("calibrateCyberwareInstallation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/cyberware/installations/{installation_id}/calibrate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CalibrateCyberwareInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/cyberware/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calibrate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCalibrateCyberwareInstallationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CalibrateCyberwareInstallationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCalibrateCyberwareInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CheckCyberwareCompatibility invokes checkCyberwareCompatibility operation.
//
// **Compatibility validation engine**
// Performs comprehensive compatibility analysis between cyberware components, existing installations,
//
//	and neural capacity.
//
// **Validation Operation:** Prevents system conflicts.
//
// POST /cyberware/compatibility
func (c *Client) CheckCyberwareCompatibility(ctx context.Context, request *CyberwareCompatibilityRequest) (CheckCyberwareCompatibilityRes, error) {
	res, err := c.sendCheckCyberwareCompatibility(ctx, request)
	return res, err
}

func (c *Client) sendCheckCyberwareCompatibility(ctx context.Context, request *CyberwareCompatibilityRequest) (res CheckCyberwareCompatibilityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checkCyberwareCompatibility"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/cyberware/compatibility"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CheckCyberwareCompatibilityOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/cyberware/compatibility"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCheckCyberwareCompatibilityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CheckCyberwareCompatibilityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCheckCyberwareCompatibilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CyberwareDomainBatchHealthCheck invokes cyberwareDomainBatchHealthCheck operation.
//
// **Performance optimization:** Check multiple domain health in single request
// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
// Eliminates network overhead in health monitoring scenarios.
// **Use case:** Service mesh health checks, Kubernetes readiness probes.
//
// POST /health/batch
func (c *Client) CyberwareDomainBatchHealthCheck(ctx context.Context, request *CyberwareDomainBatchHealthCheckReq) (CyberwareDomainBatchHealthCheckRes, error) {
	res, err := c.sendCyberwareDomainBatchHealthCheck(ctx, request)
	return res, err
}

func (c *Client) sendCyberwareDomainBatchHealthCheck(ctx context.Context, request *CyberwareDomainBatchHealthCheckReq) (res CyberwareDomainBatchHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cyberwareDomainBatchHealthCheck"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/health/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CyberwareDomainBatchHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCyberwareDomainBatchHealthCheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CyberwareDomainBatchHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCyberwareDomainBatchHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CyberwareDomainHealthCheck invokes cyberwareDomainHealthCheck operation.
//
// **Enterprise-grade health check endpoint**
// Provides real-time health status of the cyberware domain microservice.
// Critical for service discovery, load balancing, and monitoring.
// **Performance:** <1ms response time, cached for 30 seconds.
//
// GET /health
func (c *Client) CyberwareDomainHealthCheck(ctx context.Context, params CyberwareDomainHealthCheckParams) (CyberwareDomainHealthCheckRes, error) {
	res, err := c.sendCyberwareDomainHealthCheck(ctx, params)
	return res, err
}

func (c *Client) sendCyberwareDomainHealthCheck(ctx context.Context, params CyberwareDomainHealthCheckParams) (res CyberwareDomainHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cyberwareDomainHealthCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CyberwareDomainHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AcceptEncoding.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CyberwareDomainHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCyberwareDomainHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CyberwareDomainHealthWebSocket invokes cyberwareDomainHealthWebSocket operation.
//
// **Performance optimization:** Real-time health updates without polling
// Eliminates periodic HTTP requests, reduces server load by ~90%.
// Perfect for dashboard monitoring and alerting systems.
// **Protocol:** WebSocket with JSON payloads
// **Heartbeat:** 30 second intervals
// **Reconnection:** Automatic with exponential backoff.
//
// GET /health/ws
func (c *Client) CyberwareDomainHealthWebSocket(ctx context.Context, params CyberwareDomainHealthWebSocketParams) (CyberwareDomainHealthWebSocketRes, error) {
	res, err := c.sendCyberwareDomainHealthWebSocket(ctx, params)
	return res, err
}

func (c *Client) sendCyberwareDomainHealthWebSocket(ctx context.Context, params CyberwareDomainHealthWebSocketParams) (res CyberwareDomainHealthWebSocketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cyberwareDomainHealthWebSocket"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/ws"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CyberwareDomainHealthWebSocketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/ws"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "services" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "services",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Services != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Services {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CyberwareDomainHealthWebSocketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCyberwareDomainHealthWebSocketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCyberwareDiagnostics invokes getCyberwareDiagnostics operation.
//
// **Comprehensive system diagnostics**
// Provides detailed health assessment, performance metrics, neural integration status, and
// maintenance recommendations.
// **Diagnostic Operation:** Non-invasive analysis.
//
// GET /cyberware/installations/{installation_id}/diagnostics
func (c *Client) GetCyberwareDiagnostics(ctx context.Context, params GetCyberwareDiagnosticsParams) (GetCyberwareDiagnosticsRes, error) {
	res, err := c.sendGetCyberwareDiagnostics(ctx, params)
	return res, err
}

func (c *Client) sendGetCyberwareDiagnostics(ctx context.Context, params GetCyberwareDiagnosticsParams) (res GetCyberwareDiagnosticsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCyberwareDiagnostics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/cyberware/installations/{installation_id}/diagnostics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCyberwareDiagnosticsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/cyberware/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/diagnostics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "diagnostic_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "diagnostic_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DiagnosticLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_historical" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_historical",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeHistorical.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetCyberwareDiagnosticsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCyberwareDiagnosticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCyberwareInstallation invokes getCyberwareInstallation operation.
//
// **Enterprise-grade installation retrieval**
// Returns comprehensive cyberware installation information including real-time performance metrics,
// neural integration status, and maintenance requirements.
// **Performance:** <5ms P95 with Redis caching.
//
// GET /cyberware/installations/{installation_id}
func (c *Client) GetCyberwareInstallation(ctx context.Context, params GetCyberwareInstallationParams) (GetCyberwareInstallationRes, error) {
	res, err := c.sendGetCyberwareInstallation(ctx, params)
	return res, err
}

func (c *Client) sendGetCyberwareInstallation(ctx context.Context, params GetCyberwareInstallationParams) (res GetCyberwareInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCyberwareInstallation"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/cyberware/installations/{installation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCyberwareInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/cyberware/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "include_diagnostics" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_diagnostics",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeDiagnostics.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_effects" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_effects",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeEffects.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-None-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfNoneMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetCyberwareInstallationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCyberwareInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstallCyberware invokes installCyberware operation.
//
// **Enterprise-grade cyberware installation**
// Performs complete cyberware installation with neural integration, compatibility validation, and
// safety protocols.
// **Critical Operation:** Requires neural synchronization.
//
// POST /cyberware/installations
func (c *Client) InstallCyberware(ctx context.Context, request *InstallCyberwareRequest) (InstallCyberwareRes, error) {
	res, err := c.sendInstallCyberware(ctx, request)
	return res, err
}

func (c *Client) sendInstallCyberware(ctx context.Context, request *InstallCyberwareRequest) (res InstallCyberwareRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("installCyberware"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/cyberware/installations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InstallCyberwareOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/cyberware/installations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstallCyberwareRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, InstallCyberwareOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstallCyberwareResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCyberwareInstallations invokes listCyberwareInstallations operation.
//
// **Enterprise-grade installation listing**
// Lists all cyberware installations with comprehensive filtering by type, status, performance
// metrics, and health indicators.
// **Performance:** <10ms P95, supports complex queries.
//
// GET /cyberware/installations
func (c *Client) ListCyberwareInstallations(ctx context.Context, params ListCyberwareInstallationsParams) (ListCyberwareInstallationsRes, error) {
	res, err := c.sendListCyberwareInstallations(ctx, params)
	return res, err
}

func (c *Client) sendListCyberwareInstallations(ctx context.Context, params ListCyberwareInstallationsParams) (res ListCyberwareInstallationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCyberwareInstallations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/cyberware/installations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListCyberwareInstallationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/cyberware/installations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "player_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "player_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PlayerID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Category.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "health_min" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "health_min",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HealthMin.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "performance_min" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "performance_min",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerformanceMin.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ListCyberwareInstallationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListCyberwareInstallationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OptimizeCyberwarePerformance invokes optimizeCyberwarePerformance operation.
//
// **Performance optimization engine**
// Analyzes and optimizes cyberware performance across all installations, balancing power consumption,
//
//	neural load, and operational efficiency.
//
// **Optimization Operation:** System-wide tuning.
//
// POST /cyberware/performance/optimize
func (c *Client) OptimizeCyberwarePerformance(ctx context.Context, request *OptimizePerformanceRequest, params OptimizeCyberwarePerformanceParams) (OptimizeCyberwarePerformanceRes, error) {
	res, err := c.sendOptimizeCyberwarePerformance(ctx, request, params)
	return res, err
}

func (c *Client) sendOptimizeCyberwarePerformance(ctx context.Context, request *OptimizePerformanceRequest, params OptimizeCyberwarePerformanceParams) (res OptimizeCyberwarePerformanceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("optimizeCyberwarePerformance"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/cyberware/performance/optimize"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, OptimizeCyberwarePerformanceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/cyberware/performance/optimize"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "player_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "player_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PlayerID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOptimizeCyberwarePerformanceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, OptimizeCyberwarePerformanceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOptimizeCyberwarePerformanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveCyberwareInstallation invokes removeCyberwareInstallation operation.
//
// **Surgical cyberware removal**
// Performs controlled removal with neural disconnection and system stabilization protocols.
// **High-Risk Operation:** May cause neural trauma.
//
// DELETE /cyberware/installations/{installation_id}
func (c *Client) RemoveCyberwareInstallation(ctx context.Context, params RemoveCyberwareInstallationParams) (RemoveCyberwareInstallationRes, error) {
	res, err := c.sendRemoveCyberwareInstallation(ctx, params)
	return res, err
}

func (c *Client) sendRemoveCyberwareInstallation(ctx context.Context, params RemoveCyberwareInstallationParams) (res RemoveCyberwareInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeCyberwareInstallation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/cyberware/installations/{installation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveCyberwareInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/cyberware/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "emergency_removal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "emergency_removal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EmergencyRemoval.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, RemoveCyberwareInstallationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveCyberwareInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCyberwareInstallation invokes updateCyberwareInstallation operation.
//
// **Enterprise-grade installation update**
// Updates installation parameters, recalibrates settings, or applies maintenance fixes with
// optimistic locking.
// **Performance:** <25ms P95, includes validation and conflict resolution.
//
// PUT /cyberware/installations/{installation_id}
func (c *Client) UpdateCyberwareInstallation(ctx context.Context, request *UpdateCyberwareInstallationRequest, params UpdateCyberwareInstallationParams) (UpdateCyberwareInstallationRes, error) {
	res, err := c.sendUpdateCyberwareInstallation(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCyberwareInstallation(ctx context.Context, request *UpdateCyberwareInstallationRequest, params UpdateCyberwareInstallationParams) (res UpdateCyberwareInstallationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateCyberwareInstallation"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/cyberware/installations/{installation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateCyberwareInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/cyberware/installations/"
	{
		// Encode "installation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.InstallationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCyberwareInstallationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, UpdateCyberwareInstallationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateCyberwareInstallationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
