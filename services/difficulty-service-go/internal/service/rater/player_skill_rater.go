// Code generated by NECPGAME backend agent. Player Skill Rater for Difficulty Rating System.
// Issue: #142074659
// PERFORMANCE: Optimized skill rating calculations with caching and batch processing

package rater

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.uber.org/zap"
)

// PlayerSkillRating represents a player's skill rating
type PlayerSkillRating struct {
	PlayerID        uuid.UUID `json:"player_id"`
	SkillRating     float64   `json:"skill_rating"`
	ConfidenceLevel float64   `json:"confidence_level"`
	CompletionRate  float64   `json:"completion_rate"`
	AverageTime     int       `json:"average_time"`
	AverageDeaths   float64   `json:"average_deaths"`
	LastUpdated     time.Time `json:"last_updated"`
}

// PlayerSkillRater handles player skill rating calculations
type PlayerSkillRater struct {
	db    *pgxpool.Pool
	redis *redis.Client
	log   *zap.Logger
}

// NewPlayerSkillRater creates a new player skill rater
func NewPlayerSkillRater(db *pgxpool.Pool, redis *redis.Client, log *zap.Logger) *PlayerSkillRater {
	return &PlayerSkillRater{
		db:    db,
		redis: redis,
		log:   log,
	}
}

// CalculatePlayerRating calculates and returns the player's skill rating
func (r *PlayerSkillRater) CalculatePlayerRating(ctx context.Context, playerID uuid.UUID) (*PlayerSkillRating, error) {
	// Try cache first
	cacheKey := fmt.Sprintf("player_rating:%s", playerID.String())
	if cached, err := r.redis.Get(ctx, cacheKey).Result(); err == nil {
		var rating PlayerSkillRating
		if err := json.Unmarshal([]byte(cached), &rating); err == nil {
			return &rating, nil
		}
	}

	// Calculate rating from player statistics
	rating, err := r.calculateRatingFromStats(ctx, playerID)
	if err != nil {
		return nil, errors.Wrap(err, "calculate rating from stats")
	}

	// Cache the result (30 minutes)
	if data, err := json.Marshal(rating); err == nil {
		r.redis.Set(ctx, cacheKey, data, 30*time.Minute)
	}

	return rating, nil
}

// calculateRatingFromStats calculates rating based on player performance statistics
func (r *PlayerSkillRater) calculateRatingFromStats(ctx context.Context, playerID uuid.UUID) (*PlayerSkillRating, error) {
	// Query player statistics from database
	row := r.db.QueryRow(ctx, `
		SELECT
			COUNT(*) as total_games,
			AVG(completion_rate) as avg_completion_rate,
			AVG(completion_time) as avg_completion_time,
			AVG(deaths) as avg_deaths,
			MAX(level) as max_level,
			COUNT(CASE WHEN victory = true THEN 1 END) * 100.0 / COUNT(*) as win_rate
		FROM player_game_stats
		WHERE player_id = $1 AND completed_at >= NOW() - INTERVAL '30 days'
	`, playerID)

	var totalGames int
	var avgCompletionRate, avgCompletionTime, avgDeaths, winRate sql.NullFloat64
	var maxLevel sql.NullInt32

	err := row.Scan(&totalGames, &avgCompletionRate, &avgCompletionTime, &avgDeaths, &maxLevel, &winRate)
	if err != nil {
		if err == sql.ErrNoRows {
			// New player, return default rating
			return r.getDefaultRating(playerID), nil
		}
		return nil, errors.Wrap(err, "query player stats")
	}

	// Calculate skill rating using weighted algorithm
	skillRating := r.calculateSkillRating(avgCompletionRate, avgCompletionTime, avgDeaths, winRate, maxLevel, totalGames)

	// Determine confidence level based on sample size
	confidenceLevel := r.calculateConfidenceLevel(totalGames)

	rating := &PlayerSkillRating{
		PlayerID:        playerID,
		SkillRating:     skillRating,
		ConfidenceLevel: confidenceLevel,
		CompletionRate:  r.nullFloatToFloat(avgCompletionRate),
		AverageTime:     int(r.nullFloatToFloat(avgCompletionTime)),
		AverageDeaths:   r.nullFloatToFloat(avgDeaths),
		LastUpdated:     time.Now(),
	}

	return rating, nil
}

// calculateSkillRating computes skill rating using weighted factors
func (r *PlayerSkillRater) calculateSkillRating(
	completionRate, completionTime, deaths, winRate sql.NullFloat64,
	maxLevel sql.NullInt32, totalGames int) float64 {

	// Base weights for different factors
	completionWeight := 0.25
	timeWeight := 0.20
	deathWeight := 0.15
	winRateWeight := 0.30
	levelWeight := 0.10

	// Normalize and weight each factor
	completionScore := r.nullFloatToFloat(completionRate) * completionWeight
	timeScore := (1.0 - r.normalizeTime(r.nullFloatToFloat(completionTime))) * timeWeight
	deathScore := (1.0 - r.normalizeDeaths(r.nullFloatToFloat(deaths))) * deathWeight
	winScore := r.nullFloatToFloat(winRate) / 100.0 * winRateWeight
	levelScore := float64(r.nullIntToInt(maxLevel)) / 100.0 * levelWeight

	// Experience bonus for veteran players
	experienceBonus := r.calculateExperienceBonus(totalGames)

	totalScore := completionScore + timeScore + deathScore + winScore + levelScore + experienceBonus

	// Clamp to 0-100 range
	if totalScore < 0 {
		totalScore = 0
	}
	if totalScore > 100 {
		totalScore = 100
	}

	return totalScore
}

// calculateConfidenceLevel determines how confident we are in the rating
func (r *PlayerSkillRater) calculateConfidenceLevel(totalGames int) float64 {
	if totalGames < 5 {
		return 0.3 // Low confidence for new players
	}
	if totalGames < 20 {
		return 0.6 // Medium confidence
	}
	if totalGames < 50 {
		return 0.8 // High confidence
	}
	return 0.95 // Very high confidence for veterans
}

// Helper functions
func (r *PlayerSkillRater) nullFloatToFloat(nf sql.NullFloat64) float64 {
	if nf.Valid {
		return nf.Float64
	}
	return 0.0
}

func (r *PlayerSkillRater) nullIntToInt(ni sql.NullInt32) int {
	if ni.Valid {
		return int(ni.Int32)
	}
	return 0
}

func (r *PlayerSkillRater) normalizeTime(avgTime float64) float64 {
	// Normalize completion time (lower is better)
	// Assume 300 seconds (5 minutes) is baseline
	if avgTime <= 0 {
		return 1.0
	}
	normalized := 300.0 / avgTime
	if normalized > 1.0 {
		return 1.0
	}
	return normalized
}

func (r *PlayerSkillRater) normalizeDeaths(avgDeaths float64) float64 {
	// Normalize deaths (lower is better)
	// Assume 5 deaths per game is baseline
	if avgDeaths <= 0 {
		return 0.0
	}
	normalized := 5.0 / avgDeaths
	if normalized > 1.0 {
		return 1.0
	}
	return normalized
}

func (r *PlayerSkillRater) calculateExperienceBonus(totalGames int) float64 {
	// Bonus for experienced players
	if totalGames > 100 {
		return 5.0
	}
	if totalGames > 50 {
		return 2.5
	}
	if totalGames > 25 {
		return 1.0
	}
	return 0.0
}

func (r *PlayerSkillRater) getDefaultRating(playerID uuid.UUID) *PlayerSkillRating {
	return &PlayerSkillRating{
		PlayerID:        playerID,
		SkillRating:     50.0, // Default middle rating
		ConfidenceLevel: 0.1,  // Very low confidence
		CompletionRate:  0.5,  // 50% default
		AverageTime:     600,  // 10 minutes default
		AverageDeaths:   3.0,  // 3 deaths default
		LastUpdated:     time.Now(),
	}
}
