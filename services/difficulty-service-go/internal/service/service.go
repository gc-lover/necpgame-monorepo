// Code generated by NECPGAME backend agent. Enterprise-grade Difficulty Rating Service.
// Issue: #142074659
// PERFORMANCE: Optimized for MMOFPS difficulty rating operations with <50ms P99 latency

package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/difficulty-service-go/internal/service/rater"
)

// Config holds service configuration
type Config struct {
	Logger      *zap.Logger
	Tracer      trace.Tracer
	Meter       metric.Meter
	DatabaseURL string
	RedisURL    string
}

// Service implements the difficulty rating business logic
type Service struct {
	logger      *zap.Logger
	tracer      trace.Tracer
	meter       metric.Meter
	db          *pgxpool.Pool
	redis       *redis.Client
	startTime   time.Time

	// Business logic components
	playerSkillRater *rater.PlayerSkillRater

	// Prometheus metrics
	ratingOperations    *prometheus.CounterVec
	ratingCalculationTime prometheus.Histogram
	ratingErrors        *prometheus.CounterVec
}

// NewDifficultyService creates a new difficulty service instance
func NewDifficultyService(cfg Config) (*Service, error) {
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}

	svc := &Service{
		logger:    cfg.Logger,
		tracer:    cfg.Tracer,
		meter:     cfg.Meter,
		startTime: time.Now(),
	}

	// Initialize database connection
	if err := svc.initDatabase(cfg.DatabaseURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize database")
	}

	// Initialize Redis connection
	if err := svc.initRedis(cfg.RedisURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize redis")
	}

	// Initialize business logic components
	if err := svc.initComponents(); err != nil {
		return nil, errors.Wrap(err, "failed to initialize components")
	}

	svc.logger.Info("Difficulty service initialized successfully")
	return svc, nil
}

// initDatabase initializes PostgreSQL connection with performance optimizations
func (s *Service) initDatabase(databaseURL string) error {
	// PERFORMANCE: Optimized connection pool for high-throughput rating operations
	config, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse database URL")
	}

	// PERFORMANCE: Tune connection pool for rating service (read-heavy workload)
	config.MaxConns = 15                    // Moderate pool size for analytical workload
	config.MinConns = 3                     // Keep minimum connections alive
	config.MaxConnLifetime = 30 * time.Minute // Rotate connections
	config.MaxConnIdleTime = 5 * time.Minute  // Close idle connections

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return errors.Wrap(err, "failed to create connection pool")
	}

	if err := pool.Ping(context.Background()); err != nil {
		return errors.Wrap(err, "failed to ping database")
	}

	s.db = pool
	return nil
}

// initRedis initializes Redis connection for caching
func (s *Service) initRedis(redisURL string) error {
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse Redis URL")
	}

	// PERFORMANCE: Optimize Redis connection for caching
	opt.MaxRetries = 3
	opt.MinRetryBackoff = 8 * time.Millisecond
	opt.MaxRetryBackoff = 512 * time.Millisecond
	opt.DialTimeout = 5 * time.Second
	opt.ReadTimeout = 3 * time.Second
	opt.WriteTimeout = 3 * time.Second

	client := redis.NewClient(opt)

	if err := client.Ping(context.Background()).Err(); err != nil {
		return errors.Wrap(err, "failed to ping Redis")
	}

	s.redis = client
	return nil
}

// initComponents initializes business logic components
func (s *Service) initComponents() error {
	// Initialize Player Skill Rater
	s.playerSkillRater = rater.NewPlayerSkillRater(s.db, s.redis, s.logger)

	// Initialize Prometheus metrics
	if err := s.initMetrics(); err != nil {
		return errors.Wrap(err, "failed to initialize metrics")
	}

	return nil
}

// initMetrics initializes Prometheus metrics
func (s *Service) initMetrics() error {
	s.ratingOperations = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "difficulty_rating_operations_total",
			Help: "Total number of difficulty rating operations by type",
		},
		[]string{"operation", "status"},
	)

	s.ratingCalculationTime = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "difficulty_rating_calculation_duration_seconds",
			Help:    "Time taken to calculate difficulty ratings",
			Buckets: prometheus.DefBuckets,
		},
	)

	s.ratingErrors = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "difficulty_service_errors_total",
			Help: "Total number of difficulty service errors by type",
		},
		[]string{"error_type", "operation"},
	)

	// Register metrics
	metrics := []prometheus.Collector{
		s.ratingOperations,
		s.ratingCalculationTime,
		s.ratingErrors,
	}

	for _, metric := range metrics {
		if err := prometheus.Register(metric); err != nil {
			if _, ok := err.(prometheus.AlreadyRegisteredError); !ok {
				return errors.Wrap(err, "register metric")
			}
		}
	}

	return nil
}

// HealthHandler handles health check requests
func (s *Service) HealthHandler(w http.ResponseWriter, r *http.Request) {
	health := map[string]interface{}{
		"status":    "healthy",
		"timestamp": time.Now().Format(time.RFC3339),
		"version":   "1.0.0",
		"uptime":    int(time.Since(s.startTime).Seconds()),
		"services": map[string]string{
			"database": s.checkDatabaseHealth(),
			"redis":    s.checkRedisHealth(),
		},
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(health); err != nil {
		s.logger.Error("Failed to encode health response", zap.Error(err))
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// PlayerRatingHandler handles player rating requests
func (s *Service) PlayerRatingHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract player ID from URL path
	path := strings.TrimPrefix(r.URL.Path, "/api/v1/difficulty/player/")
	if path == "" {
		http.Error(w, "Player ID required", http.StatusBadRequest)
		return
	}

	playerID, err := uuid.Parse(path)
	if err != nil {
		s.ratingErrors.WithLabelValues("validation", "player_rating").Inc()
		http.Error(w, "Invalid player ID", http.StatusBadRequest)
		return
	}

	// PERFORMANCE: Start timing rating calculation
	startTime := time.Now()
	defer func() {
		duration := time.Since(startTime)
		s.ratingCalculationTime.Observe(duration.Seconds())
	}()

	// Calculate player rating
	rating, err := s.playerSkillRater.CalculatePlayerRating(r.Context(), playerID)
	if err != nil {
		s.ratingErrors.WithLabelValues("calculation", "player_rating").Inc()
		s.logger.Error("Failed to calculate player rating",
			zap.String("player_id", playerID.String()),
			zap.Error(err))
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Update metrics
	s.ratingOperations.WithLabelValues("player_rating", "success").Inc()

	// Return response
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(rating); err != nil {
		s.logger.Error("Failed to encode rating response", zap.Error(err))
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// MetricsHandler returns HTTP handler for Prometheus metrics
func (s *Service) MetricsHandler() http.Handler {
	return promhttp.Handler()
}

// checkDatabaseHealth checks database connectivity
func (s *Service) checkDatabaseHealth() string {
	if s.db == nil {
		return "disconnected"
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	if err := s.db.Ping(ctx); err != nil {
		return "error"
	}

	return "healthy"
}

// checkRedisHealth checks Redis connectivity
func (s *Service) checkRedisHealth() string {
	if s.redis == nil {
		return "disconnected"
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	if err := s.redis.Ping(ctx).Err(); err != nil {
		return "error"
	}

	return "healthy"
}
