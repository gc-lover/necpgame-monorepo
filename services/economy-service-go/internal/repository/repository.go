// Code generated by NECPGAME backend agent. Economy agent repository.
// PERFORMANCE: Optimized for fast agent retrieval and market simulation

package repository

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"

	"necpgame/services/economy-service-go/internal/simulation/bazaar"
)

// Repository handles database operations for economy service
type Repository struct {
	pool   *pgxpool.Pool
	logger *zap.Logger
}

// NewRepository creates a new repository instance
func NewRepository(pool *pgxpool.Pool, logger *zap.Logger) *Repository {
	return &Repository{
		pool:   pool,
		logger: logger,
	}
}

// EconomyAgent represents an agent stored in database
type EconomyAgent struct {
	ID            string    `db:"id"`
	Name          string    `db:"name"`
	Type          string    `db:"type"`           // "buyer", "seller", "trader"
	Commodity     string    `db:"commodity"`
	Wealth        float64   `db:"wealth"`
	Inventory     int       `db:"inventory"`
	PriceMin      float64   `db:"price_min"`
	PriceMax      float64   `db:"price_max"`
	IsActive      bool      `db:"is_active"`
	CreatedAt     time.Time `db:"created_at"`
	UpdatedAt     time.Time `db:"updated_at"`
	LastActiveAt  time.Time `db:"last_active_at"`
}

// GetActiveAgents retrieves active agents for a specific commodity
func (r *Repository) GetActiveAgents(ctx context.Context, commodity bazaar.Commodity, limit int) ([]*EconomyAgent, error) {
	// PERFORMANCE: Add timeout for database operations (1 second for agent retrieval)
	dbCtx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	if limit <= 0 || limit > 100 {
		limit = 50 // Default limit
	}

	query := `
		SELECT id, name, type, commodity, wealth, inventory, price_min, price_max,
		       is_active, created_at, updated_at, last_active_at
		FROM economy.agents
		WHERE commodity = $1 AND is_active = true
		ORDER BY last_active_at DESC, wealth DESC
		LIMIT $2
	`

	rows, err := r.pool.Query(dbCtx, query, string(commodity), limit)
	if err != nil {
		r.logger.Error("Failed to query active agents",
			zap.String("commodity", string(commodity)),
			zap.Error(err))
		return nil, fmt.Errorf("failed to query agents: %w", err)
	}
	defer rows.Close()

	var agents []*EconomyAgent
	for rows.Next() {
		var agent EconomyAgent
		err := rows.Scan(
			&agent.ID,
			&agent.Name,
			&agent.Type,
			&agent.Commodity,
			&agent.Wealth,
			&agent.Inventory,
			&agent.PriceMin,
			&agent.PriceMax,
			&agent.IsActive,
			&agent.CreatedAt,
			&agent.UpdatedAt,
			&agent.LastActiveAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan agent row", zap.Error(err))
			continue
		}
		agents = append(agents, &agent)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating agent rows", zap.Error(err))
		return nil, fmt.Errorf("error iterating agents: %w", err)
	}

	r.logger.Debug("Retrieved active agents",
		zap.String("commodity", string(commodity)),
		zap.Int("count", len(agents)),
		zap.Int("limit", limit))

	return agents, nil
}

// CreateAgent creates a new economy agent
func (r *Repository) CreateAgent(ctx context.Context, agent *EconomyAgent) (*EconomyAgent, error) {
	dbCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
	defer cancel()

	agentID := uuid.New().String()
	now := time.Now().UTC()

	query := `
		INSERT INTO economy.agents
		(id, name, type, commodity, wealth, inventory, price_min, price_max, is_active, created_at, updated_at, last_active_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
		RETURNING id
	`

	err := r.pool.QueryRow(dbCtx, query,
		agentID,
		agent.Name,
		agent.Type,
		agent.Commodity,
		agent.Wealth,
		agent.Inventory,
		agent.PriceMin,
		agent.PriceMax,
		true,
		now,
		now,
		now,
	).Scan(&agent.ID)

	if err != nil {
		r.logger.Error("Failed to create agent",
			zap.String("name", agent.Name),
			zap.String("type", agent.Type),
			zap.Error(err))
		return nil, fmt.Errorf("failed to create agent: %w", err)
	}

	agent.ID = agentID
	agent.IsActive = true
	agent.CreatedAt = now
	agent.UpdatedAt = now
	agent.LastActiveAt = now

	r.logger.Info("Created economy agent",
		zap.String("id", agent.ID),
		zap.String("name", agent.Name),
		zap.String("commodity", agent.Commodity))

	return agent, nil
}

// UpdateAgentState updates agent state after market activity
func (r *Repository) UpdateAgentState(ctx context.Context, agentID string, wealth float64, inventory int) error {
	dbCtx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	query := `
		UPDATE economy.agents
		SET wealth = $1, inventory = $2, updated_at = $3, last_active_at = $3
		WHERE id = $4 AND is_active = true
	`

	result, err := r.pool.Exec(dbCtx, query, wealth, inventory, time.Now().UTC(), agentID)
	if err != nil {
		r.logger.Error("Failed to update agent state",
			zap.String("agent_id", agentID),
			zap.Error(err))
		return fmt.Errorf("failed to update agent state: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("agent not found or inactive: %s", agentID)
	}

	return nil
}

// CreateDefaultAgents creates a set of default agents for a commodity if none exist
func (r *Repository) CreateDefaultAgents(ctx context.Context, commodity bazaar.Commodity) error {
	// Check if agents already exist for this commodity
	existing, err := r.GetActiveAgents(ctx, commodity, 1)
	if err != nil {
		return fmt.Errorf("failed to check existing agents: %w", err)
	}

	if len(existing) > 0 {
		r.logger.Info("Agents already exist for commodity, skipping default creation",
			zap.String("commodity", string(commodity)))
		return nil
	}

	// Create default buyers
	for i := 0; i < 5; i++ {
		buyer := &EconomyAgent{
			Name:      fmt.Sprintf("buyer-%d", i+1),
			Type:      "buyer",
			Commodity: string(commodity),
			Wealth:    100.0 + float64(i*20),
			Inventory: 0,
			PriceMin:  5.0 + float64(i),
			PriceMax:  15.0 + float64(i),
		}

		if _, err := r.CreateAgent(ctx, buyer); err != nil {
			r.logger.Warn("Failed to create default buyer",
				zap.String("name", buyer.Name),
				zap.Error(err))
		}
	}

	// Create default sellers
	for i := 0; i < 5; i++ {
		seller := &EconomyAgent{
			Name:      fmt.Sprintf("seller-%d", i+1),
			Type:      "seller",
			Commodity: string(commodity),
			Wealth:    100.0 + float64(i*15),
			Inventory: 10 + i*5,
			PriceMin:  8.0 + float64(i),
			PriceMax:  12.0 + float64(i),
		}

		if _, err := r.CreateAgent(ctx, seller); err != nil {
			r.logger.Warn("Failed to create default seller",
				zap.String("name", seller.Name),
				zap.Error(err))
		}
	}

	r.logger.Info("Created default agents for commodity",
		zap.String("commodity", string(commodity)),
		zap.Int("buyers", 5),
		zap.Int("sellers", 5))

	return nil
}

// ConvertToBazaarAgent converts database agent to bazaar simulation agent
func (r *Repository) ConvertToBazaarAgent(dbAgent *EconomyAgent) *bazaar.AgentLogic {
	agent := bazaar.NewAgentLogic(dbAgent.Name, dbAgent.Wealth)

	// Set inventory
	if dbAgent.Inventory > 0 {
		commodity := bazaar.Commodity(dbAgent.Commodity)
		agent.State.Inventory[commodity] = dbAgent.Inventory
	}

	// Set price beliefs
	commodity := bazaar.Commodity(dbAgent.Commodity)
	agent.SetPriceBelief(commodity, dbAgent.PriceMin, dbAgent.PriceMax)

	return agent
}