// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// BuyoutAuctionParams is parameters of buyoutAuction operation.
type BuyoutAuctionParams struct {
	// Auction ID.
	AuctionID uuid.UUID
}

func unpackBuyoutAuctionParams(packed middleware.Parameters) (params BuyoutAuctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "auction_id",
			In:   "path",
		}
		params.AuctionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeBuyoutAuctionParams(args [1]string, argsEscaped bool, r *http.Request) (params BuyoutAuctionParams, _ error) {
	// Decode path: auction_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "auction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.AuctionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "auction_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CancelAuctionParams is parameters of cancelAuction operation.
type CancelAuctionParams struct {
	// Auction ID.
	AuctionID uuid.UUID
}

func unpackCancelAuctionParams(packed middleware.Parameters) (params CancelAuctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "auction_id",
			In:   "path",
		}
		params.AuctionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeCancelAuctionParams(args [1]string, argsEscaped bool, r *http.Request) (params CancelAuctionParams, _ error) {
	// Decode path: auction_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "auction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.AuctionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "auction_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CancelTradeParams is parameters of cancelTrade operation.
type CancelTradeParams struct {
	// Trade unique identifier.
	TradeID uuid.UUID
}

func unpackCancelTradeParams(packed middleware.Parameters) (params CancelTradeParams) {
	{
		key := middleware.ParameterKey{
			Name: "trade_id",
			In:   "path",
		}
		params.TradeID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeCancelTradeParams(args [1]string, argsEscaped bool, r *http.Request) (params CancelTradeParams, _ error) {
	// Decode path: trade_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trade_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.TradeID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trade_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetActiveTradesParams is parameters of getActiveTrades operation.
type GetActiveTradesParams struct {
	// Page number for pagination.
	Page OptInt `json:",omitempty,omitzero"`
	// Number of trades per page.
	Limit OptInt `json:",omitempty,omitzero"`
	// Filter by trade type.
	TradeType OptGetActiveTradesTradeType `json:",omitempty,omitzero"`
	// Filter by item category.
	ItemCategory OptString `json:",omitempty,omitzero"`
	// Minimum price per unit filter.
	MinPrice OptFloat64 `json:",omitempty,omitzero"`
	// Maximum price per unit filter.
	MaxPrice OptFloat64 `json:",omitempty,omitzero"`
	// Filter by specific seller.
	SellerID OptUUID `json:",omitempty,omitzero"`
	// Sort field.
	SortBy OptGetActiveTradesSortBy `json:",omitempty,omitzero"`
	// Sort order.
	SortOrder OptGetActiveTradesSortOrder `json:",omitempty,omitzero"`
}

func unpackGetActiveTradesParams(packed middleware.Parameters) (params GetActiveTradesParams) {
	{
		key := middleware.ParameterKey{
			Name: "page",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Page = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "trade_type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TradeType = v.(OptGetActiveTradesTradeType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "item_category",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ItemCategory = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "min_price",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MinPrice = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "max_price",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxPrice = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "seller_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SellerID = v.(OptUUID)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortBy = v.(OptGetActiveTradesSortBy)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort_order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortOrder = v.(OptGetActiveTradesSortOrder)
		}
	}
	return params
}

func decodeGetActiveTradesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetActiveTradesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Page.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: trade_type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "trade_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTradeTypeVal GetActiveTradesTradeType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTradeTypeVal = GetActiveTradesTradeType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.TradeType.SetTo(paramsDotTradeTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TradeType.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trade_type",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: item_category.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "item_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemCategoryVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotItemCategoryVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemCategory.SetTo(paramsDotItemCategoryVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.ItemCategory.Get(); ok {
					if err := func() error {
						if err := (validate.String{
							MinLength:     0,
							MinLengthSet:  false,
							MaxLength:     50,
							MaxLengthSet:  true,
							Email:         false,
							Hostname:      false,
							Regex:         nil,
							MinNumeric:    0,
							MinNumericSet: false,
							MaxNumeric:    0,
							MaxNumericSet: false,
						}).Validate(string(value)); err != nil {
							return errors.Wrap(err, "string")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "item_category",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: min_price.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "min_price",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMinPriceVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotMinPriceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MinPrice.SetTo(paramsDotMinPriceVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.MinPrice.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
							Pattern:       nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "min_price",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: max_price.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "max_price",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxPriceVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotMaxPriceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxPrice.SetTo(paramsDotMaxPriceVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.MaxPrice.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
							Pattern:       nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "max_price",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: seller_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "seller_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSellerIDVal uuid.UUID
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUUID(val)
					if err != nil {
						return err
					}

					paramsDotSellerIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SellerID.SetTo(paramsDotSellerIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "seller_id",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: sort_by.
	{
		val := GetActiveTradesSortBy("created_at")
		params.SortBy.SetTo(val)
	}
	// Decode query: sort_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortByVal GetActiveTradesSortBy
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortByVal = GetActiveTradesSortBy(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SortBy.SetTo(paramsDotSortByVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.SortBy.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort_by",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: sort_order.
	{
		val := GetActiveTradesSortOrder("desc")
		params.SortOrder.SetTo(val)
	}
	// Decode query: sort_order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort_order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortOrderVal GetActiveTradesSortOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortOrderVal = GetActiveTradesSortOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SortOrder.SetTo(paramsDotSortOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.SortOrder.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort_order",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAuctionDetailsParams is parameters of getAuctionDetails operation.
type GetAuctionDetailsParams struct {
	// Auction ID.
	AuctionID uuid.UUID
}

func unpackGetAuctionDetailsParams(packed middleware.Parameters) (params GetAuctionDetailsParams) {
	{
		key := middleware.ParameterKey{
			Name: "auction_id",
			In:   "path",
		}
		params.AuctionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetAuctionDetailsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAuctionDetailsParams, _ error) {
	// Decode path: auction_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "auction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.AuctionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "auction_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAuctionsParams is parameters of getAuctions operation.
type GetAuctionsParams struct {
	// Filter by auction status.
	Status OptGetAuctionsStatus `json:",omitempty,omitzero"`
	// Filter by item ID.
	ItemID OptUUID `json:",omitempty,omitzero"`
	// Filter by seller ID.
	SellerID OptUUID `json:",omitempty,omitzero"`
	// Sort auctions.
	Sort OptGetAuctionsSort `json:",omitempty,omitzero"`
	// Number of auctions to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetAuctionsParams(packed middleware.Parameters) (params GetAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetAuctionsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "item_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ItemID = v.(OptUUID)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "seller_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SellerID = v.(OptUUID)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptGetAuctionsSort)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetAuctionsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetAuctionsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetAuctionsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: item_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "item_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemIDVal uuid.UUID
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUUID(val)
					if err != nil {
						return err
					}

					paramsDotItemIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemID.SetTo(paramsDotItemIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "item_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: seller_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "seller_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSellerIDVal uuid.UUID
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUUID(val)
					if err != nil {
						return err
					}

					paramsDotSellerIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SellerID.SetTo(paramsDotSellerIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "seller_id",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: sort.
	{
		val := GetAuctionsSort("ending_soon")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal GetAuctionsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = GetAuctionsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Sort.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCharacterInventoryParams is parameters of getCharacterInventory operation.
type GetCharacterInventoryParams struct {
	// Player ID.
	PlayerID uuid.UUID
	// Filter by item category.
	Category OptGetCharacterInventoryCategory `json:",omitempty,omitzero"`
}

func unpackGetCharacterInventoryParams(packed middleware.Parameters) (params GetCharacterInventoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "player_id",
			In:   "path",
		}
		params.PlayerID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "category",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Category = v.(OptGetCharacterInventoryCategory)
		}
	}
	return params
}

func decodeGetCharacterInventoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCharacterInventoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: player_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "player_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.PlayerID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "player_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: category.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCategoryVal GetCharacterInventoryCategory
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCategoryVal = GetCharacterInventoryCategory(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Category.SetTo(paramsDotCategoryVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Category.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "category",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCraftingRecipesParams is parameters of getCraftingRecipes operation.
type GetCraftingRecipesParams struct {
	// Filter by recipe category.
	Category OptGetCraftingRecipesCategory `json:",omitempty,omitzero"`
	// Filter by recipe tier.
	Tier OptInt `json:",omitempty,omitzero"`
	// Filter by minimum quality.
	Quality OptInt `json:",omitempty,omitzero"`
	// Number of recipes to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetCraftingRecipesParams(packed middleware.Parameters) (params GetCraftingRecipesParams) {
	{
		key := middleware.ParameterKey{
			Name: "category",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Category = v.(OptGetCraftingRecipesCategory)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "tier",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tier = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "quality",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Quality = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetCraftingRecipesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCraftingRecipesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: category.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCategoryVal GetCraftingRecipesCategory
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCategoryVal = GetCraftingRecipesCategory(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Category.SetTo(paramsDotCategoryVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Category.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "category",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: tier.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tier",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTierVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTierVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tier.SetTo(paramsDotTierVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Tier.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           5,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tier",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quality.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quality",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQualityVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotQualityVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Quality.SetTo(paramsDotQualityVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Quality.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quality",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetEconomyOverviewParams is parameters of getEconomyOverview operation.
type GetEconomyOverviewParams struct {
	// Optional player ID filter.
	PlayerID OptUUID `json:",omitempty,omitzero"`
}

func unpackGetEconomyOverviewParams(packed middleware.Parameters) (params GetEconomyOverviewParams) {
	{
		key := middleware.ParameterKey{
			Name: "player_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PlayerID = v.(OptUUID)
		}
	}
	return params
}

func decodeGetEconomyOverviewParams(args [0]string, argsEscaped bool, r *http.Request) (params GetEconomyOverviewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: player_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "player_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPlayerIDVal uuid.UUID
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUUID(val)
					if err != nil {
						return err
					}

					paramsDotPlayerIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PlayerID.SetTo(paramsDotPlayerIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "player_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetMyAuctionsParams is parameters of getMyAuctions operation.
type GetMyAuctionsParams struct {
	// Filter by auction status.
	Status OptGetMyAuctionsStatus `json:",omitempty,omitzero"`
	// Number of auctions to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetMyAuctionsParams(packed middleware.Parameters) (params GetMyAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetMyAuctionsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetMyAuctionsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetMyAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetMyAuctionsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetMyAuctionsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetMyBidsParams is parameters of getMyBids operation.
type GetMyBidsParams struct {
	// Number of auctions to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetMyBidsParams(packed middleware.Parameters) (params GetMyBidsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetMyBidsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetMyBidsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPlayerTransactionHistoryParams is parameters of getPlayerTransactionHistory operation.
type GetPlayerTransactionHistoryParams struct {
	// Player unique identifier.
	PlayerID uuid.UUID
	// Number of transactions per page.
	Limit OptInt `json:",omitempty,omitzero"`
	// Number of transactions to skip.
	Offset OptInt `json:",omitempty,omitzero"`
	// Filter by transaction type.
	TransactionType OptGetPlayerTransactionHistoryTransactionType `json:",omitempty,omitzero"`
}

func unpackGetPlayerTransactionHistoryParams(packed middleware.Parameters) (params GetPlayerTransactionHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "player_id",
			In:   "path",
		}
		params.PlayerID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "transaction_type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TransactionType = v.(OptGetPlayerTransactionHistoryTransactionType)
		}
	}
	return params
}

func decodeGetPlayerTransactionHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPlayerTransactionHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: player_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "player_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.PlayerID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "player_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: transaction_type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "transaction_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTransactionTypeVal GetPlayerTransactionHistoryTransactionType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTransactionTypeVal = GetPlayerTransactionHistoryTransactionType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.TransactionType.SetTo(paramsDotTransactionTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TransactionType.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "transaction_type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPlayerWalletParams is parameters of getPlayerWallet operation.
type GetPlayerWalletParams struct {
	// Player ID.
	PlayerID uuid.UUID
}

func unpackGetPlayerWalletParams(packed middleware.Parameters) (params GetPlayerWalletParams) {
	{
		key := middleware.ParameterKey{
			Name: "player_id",
			In:   "path",
		}
		params.PlayerID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetPlayerWalletParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPlayerWalletParams, _ error) {
	// Decode path: player_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "player_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.PlayerID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "player_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTradeDetailsParams is parameters of getTradeDetails operation.
type GetTradeDetailsParams struct {
	// Trade unique identifier.
	TradeID uuid.UUID
}

func unpackGetTradeDetailsParams(packed middleware.Parameters) (params GetTradeDetailsParams) {
	{
		key := middleware.ParameterKey{
			Name: "trade_id",
			In:   "path",
		}
		params.TradeID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetTradeDetailsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTradeDetailsParams, _ error) {
	// Decode path: trade_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trade_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.TradeID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "trade_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PlaceBidParams is parameters of placeBid operation.
type PlaceBidParams struct {
	// Auction ID.
	AuctionID uuid.UUID
}

func unpackPlaceBidParams(packed middleware.Parameters) (params PlaceBidParams) {
	{
		key := middleware.ParameterKey{
			Name: "auction_id",
			In:   "path",
		}
		params.AuctionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodePlaceBidParams(args [1]string, argsEscaped bool, r *http.Request) (params PlaceBidParams, _ error) {
	// Decode path: auction_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "auction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.AuctionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "auction_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdatePlayerWalletParams is parameters of updatePlayerWallet operation.
type UpdatePlayerWalletParams struct {
	// Player ID.
	PlayerID uuid.UUID
}

func unpackUpdatePlayerWalletParams(packed middleware.Parameters) (params UpdatePlayerWalletParams) {
	{
		key := middleware.ParameterKey{
			Name: "player_id",
			In:   "path",
		}
		params.PlayerID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeUpdatePlayerWalletParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdatePlayerWalletParams, _ error) {
	// Decode path: player_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "player_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.PlayerID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "player_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
