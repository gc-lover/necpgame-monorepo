// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
)

// Handler handles operations described by OpenAPI v3 specification.
type Handler interface {
	// CreateEffect implements createEffect operation.
	//
	// **Enterprise-grade creation endpoint for elemental effects**
	// Creates new elemental weapon effect with validation of all parameters. Ensures effect uniqueness
	// and proper damage calculations.
	// **Performance:** <25ms P95, includes validation and business logic.
	//
	// POST /effects
	CreateEffect(ctx context.Context, req *EffectUpsertRequest) (CreateEffectRes, error)
	// CreateInteraction implements createInteraction operation.
	//
	// Create effect interaction rule.
	//
	// POST /effects/interactions
	CreateInteraction(ctx context.Context, req *InteractionUpsertRequest) (CreateInteractionRes, error)
	// DeleteEffect implements deleteEffect operation.
	//
	// Delete elemental effect.
	//
	// DELETE /effects/{effect_id}
	DeleteEffect(ctx context.Context, params DeleteEffectParams) (DeleteEffectRes, error)
	// EffectServiceApplyEffects implements effectServiceApplyEffects operation.
	//
	// **Enterprise-grade effect application endpoint**
	// Applies buffs, debuffs, and status effects to combat participants. Validates effect compatibility,
	// stacking rules, and duration calculations.
	// Essential for combat mechanics, abilities, and environmental effects.
	// **Performance:** <10ms P95, synchronous application required
	// **Validation:** Effect stacking limits, immunity checks, duration caps.
	//
	// POST /effects/apply
	EffectServiceApplyEffects(ctx context.Context, req *ApplyEffectsRequest) (EffectServiceApplyEffectsRes, error)
	// EffectServiceBatchHealthCheck implements effectServiceBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple domain health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	EffectServiceBatchHealthCheck(ctx context.Context, req *EffectServiceBatchHealthCheckReq) (EffectServiceBatchHealthCheckRes, error)
	// EffectServiceExtendEffect implements effectServiceExtendEffect operation.
	//
	// **Enterprise-grade effect extension endpoint**
	// Extends the duration of an existing active effect. Validates extension limits and stacking rules.
	// Used for effect refresh mechanics and duration bonuses.
	// **Performance:** <5ms P95, atomic duration update.
	//
	// PUT /effects/{effectId}/extend
	EffectServiceExtendEffect(ctx context.Context, req *ExtendEffectRequest, params EffectServiceExtendEffectParams) (EffectServiceExtendEffectRes, error)
	// EffectServiceGetActiveEffects implements effectServiceGetActiveEffects operation.
	//
	// **Enterprise-grade active effects retrieval endpoint**
	// Retrieves all currently active effects on a target entity. Includes buffs, debuffs, status effects
	// with remaining duration.
	// Critical for UI display, effect tracking, and gameplay awareness.
	// **Performance:** <15ms P95 with effect caching
	// **Real-time:** Effects updated via WebSocket for active combat.
	//
	// GET /effects/active
	EffectServiceGetActiveEffects(ctx context.Context, params EffectServiceGetActiveEffectsParams) (EffectServiceGetActiveEffectsRes, error)
	// EffectServiceHealthCheck implements effectServiceHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the example domain microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	EffectServiceHealthCheck(ctx context.Context, params EffectServiceHealthCheckParams) (EffectServiceHealthCheckRes, error)
	// EffectServiceHealthWebSocket implements effectServiceHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	EffectServiceHealthWebSocket(ctx context.Context, params EffectServiceHealthWebSocketParams) (EffectServiceHealthWebSocketRes, error)
	// GetEffect implements getEffect operation.
	//
	// Get elemental effect.
	//
	// GET /effects/{effect_id}
	GetEffect(ctx context.Context, params GetEffectParams) (GetEffectRes, error)
	// ListEffects implements listEffects operation.
	//
	// **Enterprise-grade listing endpoint for elemental effects**
	// Returns paginated list of all elemental weapon effects (fire, ice, poison, acid, electric, void).
	// Supports filtering by effect type and advanced search capabilities.
	// **Performance:** <10ms P95, supports 1000+ concurrent requests with caching.
	//
	// GET /effects
	ListEffects(ctx context.Context, params ListEffectsParams) (ListEffectsRes, error)
	// ListInteractions implements listInteractions operation.
	//
	// List effect interaction rules.
	//
	// GET /effects/interactions
	ListInteractions(ctx context.Context) (ListInteractionsRes, error)
	// PreviewInteraction implements previewInteraction operation.
	//
	// Preview effect interaction.
	//
	// POST /effects/interactions/preview
	PreviewInteraction(ctx context.Context, req *InteractionPreviewRequest) (PreviewInteractionRes, error)
	// UpdateEffect implements updateEffect operation.
	//
	// Update elemental effect.
	//
	// PATCH /effects/{effect_id}
	UpdateEffect(ctx context.Context, req *EffectUpsertRequest, params UpdateEffectParams) (UpdateEffectRes, error)
	// NewError creates *ErrRespStatusCode from error returned by handler.
	//
	// Used for common default response.
	NewError(ctx context.Context, err error) *ErrRespStatusCode
}

// Server implements http server based on OpenAPI v3 specification and
// calls Handler to handle requests.
type Server struct {
	h   Handler
	sec SecurityHandler
	baseServer
}

// NewServer creates new Server.
func NewServer(h Handler, sec SecurityHandler, opts ...ServerOption) (*Server, error) {
	s, err := newServerConfig(opts...).baseServer()
	if err != nil {
		return nil, err
	}
	return &Server{
		h:          h,
		sec:        sec,
		baseServer: s,
	}, nil
}
