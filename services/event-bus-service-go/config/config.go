// Code generated by NECPGAME backend agent. Enterprise-grade Event Bus service configuration.
// PERFORMANCE: Optimized configuration loading for event-driven operations

package config

import (
	"os"
	"strconv"
	"strings"
	"time"
)

// Config holds the complete service configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Config struct {
	Server    ServerConfig    `yaml:"server"`
	Database  DatabaseConfig  `yaml:"database"`
	Redis     RedisConfig     `yaml:"redis"`
	Kafka     KafkaConfig     `yaml:"kafka"`
	EventBus  EventBusConfig  `yaml:"event_bus"`
	Security  SecurityConfig  `yaml:"security"`
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
	Port         string        `yaml:"port"`
	ReadTimeout  time.Duration `yaml:"read_timeout"`
	WriteTimeout time.Duration `yaml:"write_timeout"`
	IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

// DatabaseConfig holds PostgreSQL database configuration
type DatabaseConfig struct {
	Host            string `yaml:"host"`
	Port            int    `yaml:"port"`
	User            string `yaml:"user"`
	Password        string `yaml:"password"`
	Database        string `yaml:"database"`
	SSLMode         string `yaml:"ssl_mode"`
	MaxOpenConns    int    `yaml:"max_open_conns"`
	MaxIdleConns    int    `yaml:"max_idle_conns"`
	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `yaml:"conn_max_idle_time"`
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
	Host         string `yaml:"host"`
	Port         int    `yaml:"port"`
	Password     string `yaml:"password"`
	DB           int    `yaml:"db"`
	PoolSize     int    `yaml:"pool_size"`
	MinIdleConns int    `yaml:"min_idle_conns"`
}

// KafkaConfig holds Kafka configuration
type KafkaConfig struct {
	Brokers         []string      `yaml:"brokers"`
	ClientID        string        `yaml:"client_id"`
	GroupID         string        `yaml:"group_id"`
	SessionTimeout  time.Duration `yaml:"session_timeout"`
	HeartbeatInterval time.Duration `yaml:"heartbeat_interval"`
	RebalanceTimeout time.Duration `yaml:"rebalance_timeout"`
	AutoOffsetReset string        `yaml:"auto_offset_reset"`
	EnableAutoCommit bool         `yaml:"enable_auto_commit"`
	FlushFrequency  time.Duration `yaml:"flush_frequency"`
	FlushMessages   int           `yaml:"flush_messages"`
	FlushBytes      int           `yaml:"flush_bytes"`
	MaxMessageBytes int           `yaml:"max_message_bytes"`
	RequiredAcks    int           `yaml:"required_acks"`
	RetryMax        int           `yaml:"retry_max"`
	RetryBackoff    time.Duration `yaml:"retry_backoff"`
	SASL            SASLConfig    `yaml:"sasl"`
	TLS             TLSConfig     `yaml:"tls"`
}

// SASLConfig holds SASL authentication configuration
type SASLConfig struct {
	Enable   bool   `yaml:"enable"`
	User     string `yaml:"user"`
	Password string `yaml:"password"`
}

// TLSConfig holds TLS configuration
type TLSConfig struct {
	Enable bool   `yaml:"enable"`
	Cert   string `yaml:"cert"`
	Key    string `yaml:"key"`
	CA     string `yaml:"ca"`
}

// EventBusConfig holds event bus specific configuration
type EventBusConfig struct {
	DefaultTopicPartitions int           `yaml:"default_topic_partitions"`
	DefaultTopicReplicas   int           `yaml:"default_topic_replicas"`
	EventRetentionPeriod   time.Duration `yaml:"event_retention_period"`
	DeadLetterTopic        string        `yaml:"dead_letter_topic"`
	EventReplayEnabled     bool          `yaml:"event_replay_enabled"`
	MaxRetryAttempts       int           `yaml:"max_retry_attempts"`
	RetryBackoff           time.Duration `yaml:"retry_backoff"`
	BatchSize              int           `yaml:"batch_size"`
	WorkerPoolSize         int           `yaml:"worker_pool_size"`
	EventBufferSize        int           `yaml:"event_buffer_size"`
}

// SecurityConfig holds security specific configuration
type SecurityConfig struct {
	EnableEncryption bool     `yaml:"enable_encryption"`
	EncryptionKey    string   `yaml:"encryption_key"`
	AllowedTopics    []string `yaml:"allowed_topics"`
	RateLimitEvents  int      `yaml:"rate_limit_events"`
	RateLimitWindow  time.Duration `yaml:"rate_limit_window"`
}

// Load loads configuration from environment variables with event-bus defaults
func Load() *Config {
	cfg := &Config{
		Server: ServerConfig{
			Port:         getEnv("EVENT_BUS_PORT", "8083"),
			ReadTimeout:  getDurationEnv("EVENT_BUS_READ_TIMEOUT", 30*time.Second),
			WriteTimeout: getDurationEnv("EVENT_BUS_WRITE_TIMEOUT", 30*time.Second),
			IdleTimeout:  getDurationEnv("EVENT_BUS_IDLE_TIMEOUT", 120*time.Second),
		},
		Database: DatabaseConfig{
			Host:            getEnv("DB_HOST", "localhost"),
			Port:            getIntEnv("DB_PORT", 5432),
			User:            getEnv("DB_USER", "postgres"),
			Password:        getEnv("DB_PASSWORD", "postgres"),
			Database:        getEnv("DB_NAME", "necpgame"),
			SSLMode:         getEnv("DB_SSL_MODE", "disable"),
			MaxOpenConns:    getIntEnv("DB_MAX_OPEN_CONNS", 20),
			MaxIdleConns:    getIntEnv("DB_MAX_IDLE_CONNS", 5),
			ConnMaxLifetime: getDurationEnv("DB_CONN_MAX_LIFETIME", 30*time.Minute),
			ConnMaxIdleTime: getDurationEnv("DB_CONN_MAX_IDLE_TIME", 5*time.Minute),
		},
		Redis: RedisConfig{
			Host:         getEnv("REDIS_HOST", "localhost"),
			Port:         getIntEnv("REDIS_PORT", 6379),
			Password:     getEnv("REDIS_PASSWORD", ""),
			DB:           getIntEnv("REDIS_DB", 0),
			PoolSize:     getIntEnv("REDIS_POOL_SIZE", 20),
			MinIdleConns: getIntEnv("REDIS_MIN_IDLE_CONNS", 5),
		},
		Kafka: KafkaConfig{
			Brokers:           getStringSliceEnv("KAFKA_BROKERS", []string{"localhost:9092"}),
			ClientID:          getEnv("KAFKA_CLIENT_ID", "event-bus-service"),
			GroupID:           getEnv("KAFKA_GROUP_ID", "event-bus-group"),
			SessionTimeout:    getDurationEnv("KAFKA_SESSION_TIMEOUT", 10*time.Second),
			HeartbeatInterval: getDurationEnv("KAFKA_HEARTBEAT_INTERVAL", 3*time.Second),
			RebalanceTimeout:  getDurationEnv("KAFKA_REBALANCE_TIMEOUT", 60*time.Second),
			AutoOffsetReset:   getEnv("KAFKA_AUTO_OFFSET_RESET", "latest"),
			EnableAutoCommit:  getBoolEnv("KAFKA_ENABLE_AUTO_COMMIT", true),
			FlushFrequency:    getDurationEnv("KAFKA_FLUSH_FREQUENCY", 500*time.Millisecond),
			FlushMessages:     getIntEnv("KAFKA_FLUSH_MESSAGES", 100),
			FlushBytes:        getIntEnv("KAFKA_FLUSH_BYTES", 1048576), // 1MB
			MaxMessageBytes:   getIntEnv("KAFKA_MAX_MESSAGE_BYTES", 1048576), // 1MB
			RequiredAcks:      getIntEnv("KAFKA_REQUIRED_ACKS", 1),
			RetryMax:          getIntEnv("KAFKA_RETRY_MAX", 3),
			RetryBackoff:      getDurationEnv("KAFKA_RETRY_BACKOFF", 100*time.Millisecond),
			SASL: SASLConfig{
				Enable:   getBoolEnv("KAFKA_SASL_ENABLE", false),
				User:     getEnv("KAFKA_SASL_USER", ""),
				Password: getEnv("KAFKA_SASL_PASSWORD", ""),
			},
			TLS: TLSConfig{
				Enable: getBoolEnv("KAFKA_TLS_ENABLE", false),
				Cert:   getEnv("KAFKA_TLS_CERT", ""),
				Key:    getEnv("KAFKA_TLS_KEY", ""),
				CA:     getEnv("KAFKA_TLS_CA", ""),
			},
		},
		EventBus: EventBusConfig{
			DefaultTopicPartitions: getIntEnv("EVENT_BUS_DEFAULT_PARTITIONS", 3),
			DefaultTopicReplicas:   getIntEnv("EVENT_BUS_DEFAULT_REPLICAS", 2),
			EventRetentionPeriod:   getDurationEnv("EVENT_BUS_RETENTION_PERIOD", 7*24*time.Hour),
			DeadLetterTopic:        getEnv("EVENT_BUS_DEAD_LETTER_TOPIC", "dead-letter-events"),
			EventReplayEnabled:     getBoolEnv("EVENT_BUS_REPLAY_ENABLED", true),
			MaxRetryAttempts:       getIntEnv("EVENT_BUS_MAX_RETRY_ATTEMPTS", 3),
			RetryBackoff:           getDurationEnv("EVENT_BUS_RETRY_BACKOFF", 1*time.Second),
			BatchSize:              getIntEnv("EVENT_BUS_BATCH_SIZE", 100),
			WorkerPoolSize:         getIntEnv("EVENT_BUS_WORKER_POOL_SIZE", 10),
			EventBufferSize:        getIntEnv("EVENT_BUS_BUFFER_SIZE", 1000),
		},
		Security: SecurityConfig{
			EnableEncryption: getBoolEnv("EVENT_BUS_ENCRYPTION_ENABLED", false),
			EncryptionKey:    getEnv("EVENT_BUS_ENCRYPTION_KEY", ""),
			AllowedTopics:    getStringSliceEnv("EVENT_BUS_ALLOWED_TOPICS", []string{}),
			RateLimitEvents:  getIntEnv("EVENT_BUS_RATE_LIMIT_EVENTS", 1000),
			RateLimitWindow:  getDurationEnv("EVENT_BUS_RATE_LIMIT_WINDOW", time.Minute),
		},
	}

	return cfg
}

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getIntEnv(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getBoolEnv(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}

func getStringSliceEnv(key string, defaultValue []string) []string {
	if value := os.Getenv(key); value != "" {
		return strings.Split(value, ",")
	}
	return defaultValue
}

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string {
	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		c.Host, c.Port, c.User, c.Password, c.Database, c.SSLMode)
}