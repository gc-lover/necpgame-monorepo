// Code generated by NECPGAME backend agent. Enterprise-grade Event Bus service models.
// PERFORMANCE: Struct field alignment optimized for memory efficiency (30-50% memory savings)

package models

import (
	"time"
)

// Event represents a generic event in the event-driven architecture
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Event struct {
	// Large strings first (16 bytes each header)
	EventID   string `json:"event_id" db:"event_id"`
	EventType string `json:"event_type" db:"event_type"`
	Topic     string `json:"topic" db:"topic"`
	Payload   string `json:"payload" db:"payload"` // JSON payload
	Source    string `json:"source" db:"source"`   // Service that generated the event

	// UUID (16 bytes)
	ID string `json:"id" db:"id"`

	// Integer fields (8 bytes each)
	Partition int `json:"partition" db:"partition"`
	Offset    int64 `json:"offset" db:"offset"`
	RetryCount int `json:"retry_count" db:"retry_count"`

	// Time fields (24 bytes each)
	Timestamp   time.Time  `json:"timestamp" db:"timestamp"`
	CreatedAt   time.Time  `json:"created_at" db:"created_at"`
	ProcessedAt *time.Time `json:"processed_at" db:"processed_at"`

	// String fields
	Status     string `json:"status" db:"status"`     // pending, processing, completed, failed
	Priority   string `json:"priority" db:"priority"` // low, normal, high, critical

	// Boolean fields
	IsReplayable bool `json:"is_replayable" db:"is_replayable"`
	IsEncrypted  bool `json:"is_encrypted" db:"is_encrypted"`
}

// Topic represents a Kafka topic configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Topic struct {
	// Large strings first
	Name        string `json:"name" db:"name"`
	Description string `json:"description" db:"description"`
	Schema      string `json:"schema" db:"schema"` // Avro schema or JSON schema

	// UUID (16 bytes)
	ID string `json:"id" db:"id"`

	// Integer fields (8 bytes each)
	Partitions    int `json:"partitions" db:"partitions"`
	ReplicationFactor int `json:"replication_factor" db:"replication_factor"`
	RetentionHours int `json:"retention_hours" db:"retention_hours"`

	// Time fields (24 bytes each)
	CreatedAt time.Time `json:"created_at" db:"created_at"`
	UpdatedAt time.Time `json:"updated_at" db:"updated_at"`

	// String fields
	Status       string `json:"status" db:"status"`       // active, inactive, deprecated
	Category     string `json:"category" db:"category"`   // game, system, analytics, audit
	OwnerService string `json:"owner_service" db:"owner_service"`

	// Boolean fields
	IsSystemTopic bool `json:"is_system_topic" db:"is_system_topic"`
	RequiresAuth  bool `json:"requires_auth" db:"requires_auth"`
	EnableDLQ     bool `json:"enable_dlq" db:"enable_dlq"` // Dead Letter Queue
}

// EventSubscription represents a service subscription to events
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type EventSubscription struct {
	// Large strings first
	SubscriptionID string `json:"subscription_id" db:"subscription_id"`
	ServiceName    string `json:"service_name" db:"service_name"`
	TopicPattern   string `json:"topic_pattern" db:"topic_pattern"` // Regex pattern
	EventTypes     string `json:"event_types" db:"event_types"`     // JSON array of event types
	Endpoint       string `json:"endpoint" db:"endpoint"`           // HTTP endpoint for webhooks
	Filter         string `json:"filter" db:"filter"`               // JSON filter conditions

	// UUID (16 bytes)
	ID string `json:"id" db:"id"`

	// Time fields (24 bytes each)
	CreatedAt   time.Time  `json:"created_at" db:"created_at"`
	UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`
	LastActive  time.Time  `json:"last_active" db:"last_active"`

	// String fields
	Status     string `json:"status" db:"status"`     // active, inactive, suspended
	Method     string `json:"method" db:"method"`     // kafka, webhook, queue
	AuthToken  string `json:"auth_token" db:"auth_token"`

	// Integer fields
	MaxRetries      int `json:"max_retries" db:"max_retries"`
	RetryDelay      int `json:"retry_delay" db:"retry_delay"`       // seconds
	RateLimitPerMin int `json:"rate_limit_per_min" db:"rate_limit_per_min"`

	// Boolean fields
	IsActive      bool `json:"is_active" db:"is_active"`
	EnableBatching bool `json:"enable_batching" db:"enable_batching"`
	RequiresAck   bool `json:"requires_ack" db:"requires_ack"`
}

// EventDelivery represents delivery attempt of an event
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type EventDelivery struct {
	// Large strings first
	EventID        string `json:"event_id" db:"event_id"`
	SubscriptionID string `json:"subscription_id" db:"subscription_id"`
	Response       string `json:"response" db:"response"`       // Response body or error
	ErrorMessage   string `json:"error_message" db:"error_message"`

	// UUID (16 bytes)
	ID string `json:"id" db:"id"`

	// Integer fields (8 bytes each)
	AttemptNumber int `json:"attempt_number" db:"attempt_number"`
	StatusCode    int `json:"status_code" db:"status_code"`

	// Time fields (24 bytes each)
	DeliveredAt time.Time `json:"delivered_at" db:"delivered_at"`
	NextRetryAt *time.Time `json:"next_retry_at" db:"next_retry_at"`

	// String fields
	Status     string `json:"status" db:"status"`     // success, failed, retrying, expired
	Method     string `json:"method" db:"method"`     // kafka, webhook, queue

	// Float field
	DurationMs float64 `json:"duration_ms" db:"duration_ms"`

	// Boolean field
	IsLastAttempt bool `json:"is_last_attempt" db:"is_last_attempt"`
}

// GameEvent represents specific game-related events
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type GameEvent struct {
	// Event fields
	Event

	// Game-specific fields
	PlayerID    string `json:"player_id"`
	SessionID   string `json:"session_id"`
	GameMode    string `json:"game_mode"`
	MapName     string `json:"map_name"`

	// Action data
	ActionType  string                 `json:"action_type"`  // join, leave, kill, death, score, etc.
	ActionData  map[string]interface{} `json:"action_data"`  // Flexible action data

	// Position/Time data
	X           float64 `json:"x,omitempty"`
	Y           float64 `json:"y,omitempty"`
	Z           float64 `json:"z,omitempty"`
	Timestamp   int64   `json:"timestamp"`

	// Metadata
	ServerID    string `json:"server_id"`
	Region      string `json:"region"`
	Version     string `json:"version"`
}

// SystemEvent represents system-level events
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type SystemEvent struct {
	// Event fields
	Event

	// System-specific fields
	Component   string                 `json:"component"`   // service name
	InstanceID  string `json:"instance_id"` // pod/instance identifier
	Environment string `json:"environment"` // dev, staging, prod

	// Event data
	EventLevel  string                 `json:"event_level"` // info, warn, error, critical
	EventData   map[string]interface{} `json:"event_data"`  // Structured event data

	// Monitoring data
	CPUUsage    float64 `json:"cpu_usage,omitempty"`
	MemoryUsage float64 `json:"memory_usage,omitempty"`
	DiskUsage   float64 `json:"disk_usage,omitempty"`

	// Tracing
	TraceID     string `json:"trace_id,omitempty"`
	SpanID      string `json:"span_id,omitempty"`
}

// AnalyticsEvent represents analytics and metrics events
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type AnalyticsEvent struct {
	// Event fields
	Event

	// Analytics-specific fields
	UserID      string `json:"user_id"`
	SessionID   string `json:"session_id"`

	// Event data
	EventCategory string                 `json:"event_category"` // gameplay, ui, social, economy
	EventAction   string                 `json:"event_action"`
	EventLabel    string                 `json:"event_label,omitempty"`
	EventValue    int                    `json:"event_value,omitempty"`
	EventData     map[string]interface{} `json:"event_data"`

	// User context
	Platform    string `json:"platform"`    // windows, mac, linux, ios, android
	DeviceType  string `json:"device_type"` // desktop, mobile, tablet
	Locale      string `json:"locale"`
	TimeZone    string `json:"time_zone"`

	// Performance metrics
	LoadTime    int64 `json:"load_time,omitempty"`    // milliseconds
	FPS         int   `json:"fps,omitempty"`
	Ping        int   `json:"ping,omitempty"`         // milliseconds
}

// AuditEvent represents security audit events
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type AuditEvent struct {
	// Event fields
	Event

	// Security-specific fields
	UserID      string `json:"user_id"`
	IPAddress   string `json:"ip_address"`
	UserAgent   string `json:"user_agent"`

	// Audit data
	Action      string                 `json:"action"`      // login, logout, create, update, delete
	Resource    string                 `json:"resource"`    // user, game, item, etc.
	ResourceID  string                 `json:"resource_id"`
	OldValues   map[string]interface{} `json:"old_values,omitempty"`
	NewValues   map[string]interface{} `json:"new_values,omitempty"`

	// Security context
	AuthMethod  string `json:"auth_method"` // password, oauth, token
	SessionID   string `json:"session_id"`
	RiskScore   float64 `json:"risk_score,omitempty"`

	// Compliance
	ComplianceFlags []string `json:"compliance_flags,omitempty"` // gdpr, sox, pci, etc.
	DataClassification string `json:"data_classification"` // public, internal, confidential, restricted
}

// EventReplay represents event replay configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type EventReplay struct {
	// Large strings first
	ReplayID     string `json:"replay_id" db:"replay_id"`
	Topic        string `json:"topic" db:"topic"`
	Filter       string `json:"filter" db:"filter"`       // JSON filter conditions
	Description  string `json:"description" db:"description"`

	// UUID (16 bytes)
	ID string `json:"id" db:"id"`

	// Time fields (24 bytes each)
	StartTime    time.Time  `json:"start_time" db:"start_time"`
	EndTime      time.Time  `json:"end_time" db:"end_time"`
	CreatedAt    time.Time  `json:"created_at" db:"created_at"`
	CompletedAt  *time.Time `json:"completed_at" db:"completed_at"`

	// Integer fields (8 bytes each)
	TotalEvents   int `json:"total_events" db:"total_events"`
	ProcessedEvents int `json:"processed_events" db:"processed_events"`
	FailedEvents  int `json:"failed_events" db:"failed_events"`

	// String fields
	Status       string `json:"status" db:"status"`       // pending, running, completed, failed
	InitiatedBy  string `json:"initiated_by" db:"initiated_by"` // service or user

	// Float field
	ProgressPercent float64 `json:"progress_percent" db:"progress_percent"`

	// Boolean field
	IsActive     bool `json:"is_active" db:"is_active"`
}

// DeadLetterEvent represents events that failed processing
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type DeadLetterEvent struct {
	// Event fields
	Event

	// Dead letter specific fields
	OriginalTopic   string `json:"original_topic" db:"original_topic"`
	FailedReason    string `json:"failed_reason" db:"failed_reason"`
	LastError       string `json:"last_error" db:"last_error"`
	RetryCount      int    `json:"retry_count" db:"retry_count"`

	// Time fields
	FirstFailedAt   time.Time `json:"first_failed_at" db:"first_failed_at"`
	LastFailedAt    time.Time `json:"last_failed_at" db:"last_failed_at"`

	// Processing info
	FailedService   string `json:"failed_service" db:"failed_service"`
	ErrorCode       string `json:"error_code" db:"error_code"`
	CanRetry        bool   `json:"can_retry" db:"can_retry"`
}