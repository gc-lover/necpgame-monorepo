// Code generated by NECPGAME backend agent. Comprehensive event bus service tests.
// PERFORMANCE: Tests validate enterprise-grade event-driven implementation

package service

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestEventBusService_EventPublishing(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupEventBusTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("publish generic event", func(t *testing.T) {
		event := getEvent()
		defer putEvent(event)

		event.EventID = uuid.New().String()
		event.EventType = "test.event"
		event.Topic = "test.events"
		event.Source = "test-service"
		event.Payload = "{\"message\":\"test event\"}"

		err := svc.PublishEvent(ctx, event)
		require.NoError(t, err)

		assert.NotEmpty(t, event.EventID)
		assert.Equal(t, "test.events", event.Topic)
		assert.NotZero(t, event.Partition)
		assert.NotZero(t, event.Offset)
	})

	t.Run("publish game event", func(t *testing.T) {
		gameEvent := getGameEvent()
		defer putGameEvent(gameEvent)

		gameEvent.EventID = uuid.New().String()
		gameEvent.EventType = "game.player.join"
		gameEvent.Topic = "game.events"
		gameEvent.PlayerID = "test_player"
		gameEvent.SessionID = "test_session"
		gameEvent.GameMode = "battle_royale"
		gameEvent.ActionType = "join"
		gameEvent.ServerID = "test-server"
		gameEvent.Region = "us-east-1"

		err := svc.PublishGameEvent(ctx, gameEvent)
		require.NoError(t, err)

		assert.NotEmpty(t, gameEvent.EventID)
		assert.Equal(t, "game.events", gameEvent.Topic)
	})
}

func TestEventBusService_TopicManagement(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupEventBusTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("create topic", func(t *testing.T) {
		topic := &models.Topic{
			Name:             "test.topic." + uuid.New().String()[:8],
			Description:      "Test topic for unit tests",
			Partitions:       2,
			ReplicationFactor: 1, // Single broker for testing
			RetentionHours:   24,
			Category:         "test",
			OwnerService:     "test-service",
		}

		err := svc.CreateTopic(ctx, topic)
		require.NoError(t, err)

		assert.NotEmpty(t, topic.ID)
		assert.Equal(t, "active", topic.Status)
		assert.NotZero(t, topic.CreatedAt)
	})

	t.Run("topic validation", func(t *testing.T) {
		invalidTopic := &models.Topic{
			Name: "", // Invalid: empty name
		}

		err := svc.CreateTopic(ctx, invalidTopic)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "topic name is required")
	})
}

func TestEventBusService_SubscriptionManagement(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupEventBusTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("create subscription", func(t *testing.T) {
		subscription := &models.EventSubscription{
			ServiceName:     "test-service",
			TopicPattern:    "test.*",
			EventTypes:      "[\"test.event\"]",
			Method:          "kafka",
			MaxRetries:      3,
			RetryDelay:      60,
			RateLimitPerMin: 100,
			IsActive:        true,
		}

		err := svc.SubscribeToEvents(ctx, subscription)
		require.NoError(t, err)

		assert.NotEmpty(t, subscription.ID)
		assert.NotEmpty(t, subscription.SubscriptionID)
		assert.Equal(t, "test-service", subscription.ServiceName)
		assert.True(t, subscription.IsActive)
	})

	t.Run("subscription validation", func(t *testing.T) {
		invalidSubscription := &models.EventSubscription{
			ServiceName: "", // Invalid: empty service name
		}

		err := svc.SubscribeToEvents(ctx, invalidSubscription)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "service name is required")
	})
}

func TestEventBusService_EventConsumption(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupEventBusTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("consume events", func(t *testing.T) {
		topics := []string{"test.events"}

		// Start consumer in background
		go func() {
			err := svc.ConsumeEvents(ctx, topics)
			if err != nil && err != context.Canceled {
				t.Errorf("Consumer error: %v", err)
			}
		}()

		// Give consumer time to start
		time.Sleep(2 * time.Second)

		// Publish test event
		event := getEvent()
		defer putEvent(event)

		event.EventID = uuid.New().String()
		event.EventType = "test.consumption"
		event.Topic = "test.events"
		event.Source = "test-publisher"

		err := svc.PublishEvent(ctx, event)
		require.NoError(t, err)

		// Wait for consumption
		time.Sleep(3 * time.Second)

		// Verify event was processed (would check metrics in real implementation)
		// For this test, we just verify no errors occurred
		assert.NotEmpty(t, event.EventID)
	})
}

func TestEventBusService_EventRouting(t *testing.T) {
	svc := &EventBusService{}

	t.Run("event matches subscription", func(t *testing.T) {
		event := &models.Event{
			EventType:   "game.player.join",
			Topic:       "game.events",
		}

		subscription := &models.EventSubscription{
			TopicPattern: "game.*",
			EventTypes:   "[\"game.player.join\"]",
		}

		matches := svc.eventMatchesSubscription(event, subscription)
		assert.True(t, matches)
	})

	t.Run("event does not match subscription", func(t *testing.T) {
		event := &models.Event{
			EventType:   "system.error",
			Topic:       "system.events",
		}

		subscription := &models.EventSubscription{
			TopicPattern: "game.*",
			EventTypes:   "[\"game.player.join\"]",
		}

		matches := svc.eventMatchesSubscription(event, subscription)
		assert.False(t, matches)
	})
}

func TestEventBusService_Performance(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping performance test in short mode")
	}

	svc := setupEventBusTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("high-volume event publishing", func(t *testing.T) {
		eventCount := 100
		events := make([]*models.Event, eventCount)

		// Prepare events
		for i := 0; i < eventCount; i++ {
			event := getEvent()
			event.EventID = uuid.New().String()
			event.EventType = "performance.test"
			event.Topic = "perf.events"
			event.Source = "performance-test"
			event.Payload = "{\"index\":" + string(rune(i)) + "}"
			events[i] = event
		}

		// Measure publishing time
		start := time.Now()
		for _, event := range events {
			err := svc.PublishEvent(ctx, event)
			require.NoError(t, err)
		}
		duration := time.Since(start)

		// Verify performance
		avgTime := duration / time.Duration(eventCount)
		t.Logf("Published %d events in %v (avg: %v per event)", eventCount, duration, avgTime)

		// Should be under 50ms per event
		assert.True(t, avgTime < 50*time.Millisecond,
			"Average publish time %v exceeds 50ms limit", avgTime)
	})
}

func BenchmarkEventBusService_PublishEvent(b *testing.B) {
	svc := setupEventBusTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			event := getEvent()
			event.EventID = uuid.New().String()
			event.EventType = "benchmark.event"
			event.Topic = "benchmark.events"
			event.Source = "benchmark-test"

			err := svc.PublishEvent(ctx, event)
			if err != nil {
				b.Fatal(err)
			}

			putEvent(event)
		}
	})
}

func BenchmarkEventBusService_EventRouting(b *testing.B) {
	svc := &EventBusService{}

	event := &models.Event{
		EventType: "game.player.action",
		Topic:     "game.events",
	}

	subscription := &models.EventSubscription{
		TopicPattern: "game.*",
		EventTypes:   "[\"game.player.action\"]",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		matches := svc.eventMatchesSubscription(event, subscription)
		if !matches {
			b.Fatal("Event should match subscription")
		}
	}
}

// Test utilities

func setupEventBusTestService(t *testing.T) *EventBusService {
	// Use test database configuration
	config := Config{
		Logger:      zap.NewNop(),
		Tracer:      nil,
		Meter:       nil,
		DatabaseURL: "postgres://postgres:postgres@localhost:5432/necpgame_test?sslmode=disable",
		RedisURL:    "redis://localhost:6379/3", // Use DB 3 for tests
		KafkaBrokers: "localhost:9092", // Single broker for testing
	}

	svc, err := NewEventBusService(config)
	require.NoError(t, err)

	// Setup test database schema
	setupEventBusTestDatabase(t, svc)

	return svc
}

func setupEventBusTestDatabase(t *testing.T, svc *EventBusService) {
	// Create test tables if they don't exist
	_, err := svc.db.Exec(context.Background(), `
		CREATE TABLE IF NOT EXISTS events (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			event_id VARCHAR(100) UNIQUE,
			event_type VARCHAR(100),
			topic VARCHAR(255),
			source VARCHAR(100),
			payload TEXT,
			partition INTEGER,
			"offset" BIGINT,
			status VARCHAR(20) DEFAULT 'pending',
			retry_count INTEGER DEFAULT 0,
			priority VARCHAR(10) DEFAULT 'normal',
			timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			processed_at TIMESTAMP WITH TIME ZONE,
			is_replayable BOOLEAN DEFAULT true,
			is_encrypted BOOLEAN DEFAULT false
		);

		CREATE TABLE IF NOT EXISTS topics (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			name VARCHAR(255) UNIQUE,
			description TEXT,
			schema TEXT,
			partitions INTEGER DEFAULT 3,
			replication_factor INTEGER DEFAULT 2,
			retention_hours INTEGER DEFAULT 168,
			status VARCHAR(20) DEFAULT 'active',
			category VARCHAR(20) DEFAULT 'game',
			owner_service VARCHAR(100),
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			is_system_topic BOOLEAN DEFAULT false,
			requires_auth BOOLEAN DEFAULT false,
			enable_dlq BOOLEAN DEFAULT true
		);

		CREATE TABLE IF NOT EXISTS event_subscriptions (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			subscription_id VARCHAR(100) UNIQUE,
			service_name VARCHAR(100),
			topic_pattern VARCHAR(255) DEFAULT '*',
			event_types TEXT,
			endpoint VARCHAR(500),
			filter TEXT,
			status VARCHAR(20) DEFAULT 'active',
			method VARCHAR(20) DEFAULT 'kafka',
			auth_token VARCHAR(255),
			max_retries INTEGER DEFAULT 3,
			retry_delay INTEGER DEFAULT 60,
			rate_limit_per_min INTEGER DEFAULT 1000,
			is_active BOOLEAN DEFAULT true,
			enable_batching BOOLEAN DEFAULT false,
			requires_ack BOOLEAN DEFAULT true,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			last_active TIMESTAMP WITH TIME ZONE DEFAULT NOW()
		);

		-- Create indexes for performance
		CREATE INDEX IF NOT EXISTS idx_events_event_id ON events(event_id);
		CREATE INDEX IF NOT EXISTS idx_events_topic ON events(topic);
		CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);
		CREATE INDEX IF NOT EXISTS idx_topics_name ON topics(name);
		CREATE INDEX IF NOT EXISTS idx_subscriptions_service ON event_subscriptions(service_name);
	`)
	require.NoError(t, err)

	// Clean up test data
	_, err = svc.db.Exec(context.Background(), `
		DELETE FROM event_subscriptions WHERE service_name LIKE 'test-%';
		DELETE FROM events WHERE source LIKE 'test-%' OR source LIKE 'performance-%' OR source LIKE 'benchmark-%';
		DELETE FROM topics WHERE name LIKE 'test.%' OR name LIKE 'perf.%' OR name LIKE 'benchmark.%';
	`)
	require.NoError(t, err)
}