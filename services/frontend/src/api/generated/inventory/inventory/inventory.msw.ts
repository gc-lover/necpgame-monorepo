/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Inventory API
 * REST API –¥–ª—è core-–∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞: –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–¥–º–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ,
—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∞–∫–æ–≤, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏. –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞
`.BRAIN/05-technical/backend/inventory-system/` (v1.0.2, Part1/Part2).

 * OpenAPI spec version: 1.1.0
 */
import { faker } from '@faker-js/faker'

import { HttpResponse, delay, http } from 'msw'
import type { RequestHandlerOptions } from 'msw'

import { EncumbranceLevel, ItemBindType } from '.././models'
import type {
  InventoryItem,
  InventorySnapshot,
  InventorySplitResponse,
  ItemUseResponse,
} from '.././models'

export const getGetCharacterInventoryResponseMock = (
  overrideResponse: Partial<InventorySnapshot> = {}
): InventorySnapshot => ({
  character_id: faker.string.uuid(),
  items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    item_instance_id: faker.string.uuid(),
    item_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    quantity: faker.number.int({ min: 1, max: undefined }),
    slot_index: faker.number.int({ min: 0, max: 49 }),
    durability: faker.number.float({ min: 0, max: 100, fractionDigits: 2 }),
    bound_type: faker.helpers.arrayElement(Object.values(ItemBindType)),
    acquired_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      undefined,
    ]),
    expires_at: faker.helpers.arrayElement([
      faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]),
      undefined,
    ]),
    metadata: faker.helpers.arrayElement([{}, undefined]),
  })),
  capacity: {
    max_slots: faker.number.int({ min: undefined, max: undefined }),
    used_slots: faker.number.int({ min: undefined, max: undefined }),
    current_weight: faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    max_weight: faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    encumbrance_level: faker.helpers.arrayElement(Object.values(EncumbranceLevel)),
  },
  ...overrideResponse,
})

export const getAddItemToInventoryResponseMock = (
  overrideResponse: Partial<InventoryItem> = {}
): InventoryItem => ({
  item_instance_id: faker.string.uuid(),
  item_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  quantity: faker.number.int({ min: 1, max: undefined }),
  slot_index: faker.number.int({ min: 0, max: 49 }),
  durability: faker.number.float({ min: 0, max: 100, fractionDigits: 2 }),
  bound_type: faker.helpers.arrayElement(Object.values(ItemBindType)),
  acquired_at: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split('.')[0]}Z`,
    undefined,
  ]),
  expires_at: faker.helpers.arrayElement([
    faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]),
    undefined,
  ]),
  metadata: faker.helpers.arrayElement([{}, undefined]),
  ...overrideResponse,
})

export const getSplitInventoryStackResponseMock = (
  overrideResponse: Partial<InventorySplitResponse> = {}
): InventorySplitResponse => ({
  original_stack: {
    item_instance_id: faker.string.uuid(),
    item_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    quantity: faker.number.int({ min: 1, max: undefined }),
    slot_index: faker.number.int({ min: 0, max: 49 }),
    durability: faker.number.float({ min: 0, max: 100, fractionDigits: 2 }),
    bound_type: faker.helpers.arrayElement(Object.values(ItemBindType)),
    acquired_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      undefined,
    ]),
    expires_at: faker.helpers.arrayElement([
      faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]),
      undefined,
    ]),
    metadata: faker.helpers.arrayElement([{}, undefined]),
  },
  new_stack: {
    item_instance_id: faker.string.uuid(),
    item_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    quantity: faker.number.int({ min: 1, max: undefined }),
    slot_index: faker.number.int({ min: 0, max: 49 }),
    durability: faker.number.float({ min: 0, max: 100, fractionDigits: 2 }),
    bound_type: faker.helpers.arrayElement(Object.values(ItemBindType)),
    acquired_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      undefined,
    ]),
    expires_at: faker.helpers.arrayElement([
      faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]),
      undefined,
    ]),
    metadata: faker.helpers.arrayElement([{}, undefined]),
  },
  ...overrideResponse,
})

export const getUseInventoryItemResponseMock = (
  overrideResponse: Partial<ItemUseResponse> = {}
): ItemUseResponse => ({
  consumed: faker.datatype.boolean(),
  remaining_quantity: faker.number.int({ min: undefined, max: undefined }),
  applied_effects: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    effect_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    description: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
    duration_seconds: faker.number.int({ min: undefined, max: undefined }),
  })),
  ...overrideResponse,
})

export const getGetCharacterInventoryMockHandler = (
  overrideResponse?:
    | InventorySnapshot
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<InventorySnapshot> | InventorySnapshot),
  options?: RequestHandlerOptions
) => {
  return http.get(
    '*/inventory/characters/:characterId',
    async info => {
      await delay(1000)

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === 'function'
              ? await overrideResponse(info)
              : overrideResponse
            : getGetCharacterInventoryResponseMock()
        ),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      )
    },
    options
  )
}

export const getAddItemToInventoryMockHandler = (
  overrideResponse?:
    | InventoryItem
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<InventoryItem> | InventoryItem),
  options?: RequestHandlerOptions
) => {
  return http.post(
    '*/inventory/characters/:characterId/items',
    async info => {
      await delay(1000)

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === 'function'
              ? await overrideResponse(info)
              : overrideResponse
            : getAddItemToInventoryResponseMock()
        ),
        { status: 201, headers: { 'Content-Type': 'application/json' } }
      )
    },
    options
  )
}

export const getDeleteInventoryItemMockHandler = (
  overrideResponse?:
    | void
    | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    '*/inventory/characters/:characterId/items/:itemInstanceId',
    async info => {
      await delay(1000)
      if (typeof overrideResponse === 'function') {
        await overrideResponse(info)
      }
      return new HttpResponse(null, { status: 204 })
    },
    options
  )
}

export const getSplitInventoryStackMockHandler = (
  overrideResponse?:
    | InventorySplitResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<InventorySplitResponse> | InventorySplitResponse),
  options?: RequestHandlerOptions
) => {
  return http.post(
    '*/inventory/characters/:characterId/items/:itemInstanceId/split',
    async info => {
      await delay(1000)

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === 'function'
              ? await overrideResponse(info)
              : overrideResponse
            : getSplitInventoryStackResponseMock()
        ),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      )
    },
    options
  )
}

export const getUseInventoryItemMockHandler = (
  overrideResponse?:
    | ItemUseResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<ItemUseResponse> | ItemUseResponse),
  options?: RequestHandlerOptions
) => {
  return http.post(
    '*/inventory/characters/:characterId/items/:itemInstanceId/use',
    async info => {
      await delay(1000)

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === 'function'
              ? await overrideResponse(info)
              : overrideResponse
            : getUseInventoryItemResponseMock()
        ),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      )
    },
    options
  )
}
export const getInventoryMock = () => [
  getGetCharacterInventoryMockHandler(),
  getAddItemToInventoryMockHandler(),
  getDeleteInventoryItemMockHandler(),
  getSplitInventoryStackMockHandler(),
  getUseInventoryItemMockHandler(),
]
