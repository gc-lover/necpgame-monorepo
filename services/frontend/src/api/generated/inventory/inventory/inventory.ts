/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Inventory API
 * REST API –¥–ª—è core-–∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞: –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–¥–º–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ,
—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∞–∫–æ–≤, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏. –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞
`.BRAIN/05-technical/backend/inventory-system/` (v1.0.2, Part1/Part2).

 * OpenAPI spec version: 1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  GetCharacterInventoryParams,
  InventoryItem,
  InventorySnapshot,
  InventorySplitResponse,
  ItemAddRequest,
  ItemSplitRequest,
  ItemUseRequest,
  ItemUseResponse,
} from '.././models'
import type {
  BadRequestResponse,
  ConflictResponse,
  NotFoundResponse,
  UnauthorizedResponse,
} from '.././models/shared-common-responses'

import { customInstance } from '../../../custom-instance'
import type { ErrorType, BodyType } from '../../../custom-instance'

/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏ –∞–≥—Ä–µ–≥–∞—Ç—ã –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
 */
export const getCharacterInventory = (
  characterId: string,
  params?: GetCharacterInventoryParams,
  signal?: AbortSignal
) => {
  return customInstance<InventorySnapshot>({
    url: `/inventory/characters/${characterId}`,
    method: 'GET',
    params,
    signal,
  })
}

export const getGetCharacterInventoryQueryKey = (
  characterId?: string,
  params?: GetCharacterInventoryParams
) => {
  return [`/inventory/characters/${characterId}`, ...(params ? [params] : [])] as const
}

export const getGetCharacterInventoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getCharacterInventory>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  characterId: string,
  params?: GetCharacterInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCharacterInventory>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCharacterInventoryQueryKey(characterId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCharacterInventory>>> = ({ signal }) =>
    getCharacterInventory(characterId, params, signal)

  return { queryKey, queryFn, enabled: !!characterId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCharacterInventory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCharacterInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCharacterInventory>>
>
export type GetCharacterInventoryQueryError = ErrorType<UnauthorizedResponse | NotFoundResponse>

export function useGetCharacterInventory<
  TData = Awaited<ReturnType<typeof getCharacterInventory>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  characterId: string,
  params: undefined | GetCharacterInventoryParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCharacterInventory>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCharacterInventory>>,
          TError,
          Awaited<ReturnType<typeof getCharacterInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCharacterInventory<
  TData = Awaited<ReturnType<typeof getCharacterInventory>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  characterId: string,
  params?: GetCharacterInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCharacterInventory>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCharacterInventory>>,
          TError,
          Awaited<ReturnType<typeof getCharacterInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCharacterInventory<
  TData = Awaited<ReturnType<typeof getCharacterInventory>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  characterId: string,
  params?: GetCharacterInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCharacterInventory>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
 */

export function useGetCharacterInventory<
  TData = Awaited<ReturnType<typeof getCharacterInventory>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  characterId: string,
  params?: GetCharacterInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCharacterInventory>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCharacterInventoryQueryOptions(characterId, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * –î–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ–¥–º–µ—Ç, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±—ä–µ–¥–∏–Ω—è—è —Å—Ç–∞–∫—É–µ–º—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã.
 * @summary –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
 */
export const addItemToInventory = (
  characterId: string,
  itemAddRequest: BodyType<ItemAddRequest>,
  signal?: AbortSignal
) => {
  return customInstance<InventoryItem>({
    url: `/inventory/characters/${characterId}/items`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: itemAddRequest,
    signal,
  })
}

export const getAddItemToInventoryMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addItemToInventory>>,
    TError,
    { characterId: string; data: BodyType<ItemAddRequest> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof addItemToInventory>>,
  TError,
  { characterId: string; data: BodyType<ItemAddRequest> },
  TContext
> => {
  const mutationKey = ['addItemToInventory']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItemToInventory>>,
    { characterId: string; data: BodyType<ItemAddRequest> }
  > = props => {
    const { characterId, data } = props ?? {}

    return addItemToInventory(characterId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddItemToInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof addItemToInventory>>
>
export type AddItemToInventoryMutationBody = BodyType<ItemAddRequest>
export type AddItemToInventoryMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | ConflictResponse
>

/**
 * @summary –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
 */
export const useAddItemToInventory = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addItemToInventory>>,
      TError,
      { characterId: string; data: BodyType<ItemAddRequest> },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addItemToInventory>>,
  TError,
  { characterId: string; data: BodyType<ItemAddRequest> },
  TContext
> => {
  const mutationOptions = getAddItemToInventoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * –£–¥–∞–ª—è–µ—Ç –ø—Ä–µ–¥–º–µ—Ç –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è (drop/delete).
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–ª–∏ –≤—ã–±—Ä–æ—Å–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç
 */
export const deleteInventoryItem = (characterId: string, itemInstanceId: string) => {
  return customInstance<void>({
    url: `/inventory/characters/${characterId}/items/${itemInstanceId}`,
    method: 'DELETE',
  })
}

export const getDeleteInventoryItemMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInventoryItem>>,
    TError,
    { characterId: string; itemInstanceId: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInventoryItem>>,
  TError,
  { characterId: string; itemInstanceId: string },
  TContext
> => {
  const mutationKey = ['deleteInventoryItem']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInventoryItem>>,
    { characterId: string; itemInstanceId: string }
  > = props => {
    const { characterId, itemInstanceId } = props ?? {}

    return deleteInventoryItem(characterId, itemInstanceId)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInventoryItem>>
>

export type DeleteInventoryItemMutationError = ErrorType<UnauthorizedResponse | NotFoundResponse>

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–ª–∏ –≤—ã–±—Ä–æ—Å–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç
 */
export const useDeleteInventoryItem = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInventoryItem>>,
      TError,
      { characterId: string; itemInstanceId: string },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteInventoryItem>>,
  TError,
  { characterId: string; itemInstanceId: string },
  TContext
> => {
  const mutationOptions = getDeleteInventoryItemMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * –î–µ–ª–∏—Ç —Å—Ç–∞–∫—É–µ–º—ã–π –ø—Ä–µ–¥–º–µ—Ç –Ω–∞ –¥–≤–µ —á–∞—Å—Ç–∏.
 * @summary –†–∞–∑–¥–µ–ª–∏—Ç—å —Å—Ç–∞–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
 */
export const splitInventoryStack = (
  characterId: string,
  itemInstanceId: string,
  itemSplitRequest: BodyType<ItemSplitRequest>,
  signal?: AbortSignal
) => {
  return customInstance<InventorySplitResponse>({
    url: `/inventory/characters/${characterId}/items/${itemInstanceId}/split`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: itemSplitRequest,
    signal,
  })
}

export const getSplitInventoryStackMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof splitInventoryStack>>,
    TError,
    { characterId: string; itemInstanceId: string; data: BodyType<ItemSplitRequest> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof splitInventoryStack>>,
  TError,
  { characterId: string; itemInstanceId: string; data: BodyType<ItemSplitRequest> },
  TContext
> => {
  const mutationKey = ['splitInventoryStack']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof splitInventoryStack>>,
    { characterId: string; itemInstanceId: string; data: BodyType<ItemSplitRequest> }
  > = props => {
    const { characterId, itemInstanceId, data } = props ?? {}

    return splitInventoryStack(characterId, itemInstanceId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type SplitInventoryStackMutationResult = NonNullable<
  Awaited<ReturnType<typeof splitInventoryStack>>
>
export type SplitInventoryStackMutationBody = BodyType<ItemSplitRequest>
export type SplitInventoryStackMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>

/**
 * @summary –†–∞–∑–¥–µ–ª–∏—Ç—å —Å—Ç–∞–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
 */
export const useSplitInventoryStack = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof splitInventoryStack>>,
      TError,
      { characterId: string; itemInstanceId: string; data: BodyType<ItemSplitRequest> },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof splitInventoryStack>>,
  TError,
  { characterId: string; itemInstanceId: string; data: BodyType<ItemSplitRequest> },
  TContext
> => {
  const mutationOptions = getSplitInventoryStackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * –ü—Ä–∏–º–µ–Ω—è–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–µ–¥–º–µ—Ç–∞ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å.
 * @summary –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç
 */
export const useInventoryItem = (
  characterId: string,
  itemInstanceId: string,
  itemUseRequest: BodyType<ItemUseRequest>,
  signal?: AbortSignal
) => {
  return customInstance<ItemUseResponse>({
    url: `/inventory/characters/${characterId}/items/${itemInstanceId}/use`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: itemUseRequest,
    signal,
  })
}

export const getUseInventoryItemMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof useInventoryItem>>,
    TError,
    { characterId: string; itemInstanceId: string; data: BodyType<ItemUseRequest> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof useInventoryItem>>,
  TError,
  { characterId: string; itemInstanceId: string; data: BodyType<ItemUseRequest> },
  TContext
> => {
  const mutationKey = ['useInventoryItem']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof useInventoryItem>>,
    { characterId: string; itemInstanceId: string; data: BodyType<ItemUseRequest> }
  > = props => {
    const { characterId, itemInstanceId, data } = props ?? {}

    return useInventoryItem(characterId, itemInstanceId, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UseInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof useInventoryItem>>
>
export type UseInventoryItemMutationBody = BodyType<ItemUseRequest>
export type UseInventoryItemMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>

/**
 * @summary –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç
 */
export const useUseInventoryItem = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof useInventoryItem>>,
      TError,
      { characterId: string; itemInstanceId: string; data: BodyType<ItemUseRequest> },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof useInventoryItem>>,
  TError,
  { characterId: string; itemInstanceId: string; data: BodyType<ItemUseRequest> },
  TContext
> => {
  const mutationOptions = getUseInventoryItemMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
