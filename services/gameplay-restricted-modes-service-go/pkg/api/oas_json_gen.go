// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Achievement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Achievement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("achievement_id")
		e.Str(s.AchievementID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		if s.Rarity.Set {
			e.FieldStart("rarity")
			s.Rarity.Encode(e)
		}
	}
}

var jsonFieldsNameOfAchievement = [5]string{
	0: "achievement_id",
	1: "name",
	2: "description",
	3: "icon_url",
	4: "rarity",
}

// Decode decodes Achievement from json.
func (s *Achievement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Achievement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "achievement_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AchievementID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievement_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "rarity":
			if err := func() error {
				s.Rarity.Reset()
				if err := s.Rarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Achievement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievement) {
					name = jsonFieldsNameOfAchievement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Achievement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Achievement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRarity as json.
func (s AchievementRarity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementRarity from json.
func (s *AchievementRarity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementRarity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementRarity(v) {
	case AchievementRarityCommon:
		*s = AchievementRarityCommon
	case AchievementRarityRare:
		*s = AchievementRarityRare
	case AchievementRarityEpic:
		*s = AchievementRarityEpic
	case AchievementRarityLegendary:
		*s = AchievementRarityLegendary
	default:
		*s = AchievementRarity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveRestrictedMode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveRestrictedMode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("mode_type")
		s.ModeType.Encode(e)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.Progress != nil {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		e.FieldStart("restrictions")
		e.ArrStart()
		for _, elem := range s.Restrictions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.TimeElapsed.Set {
			e.FieldStart("time_elapsed")
			s.TimeElapsed.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveRestrictedMode = [7]string{
	0: "session_id",
	1: "character_id",
	2: "mode_type",
	3: "started_at",
	4: "progress",
	5: "restrictions",
	6: "time_elapsed",
}

// Decode decodes ActiveRestrictedMode from json.
func (s *ActiveRestrictedMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveRestrictedMode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "mode_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "progress":
			if err := func() error {
				s.Progress = nil
				var elem ActiveRestrictedModeProgress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Progress = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "restrictions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Restrictions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Restrictions = append(s.Restrictions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "time_elapsed":
			if err := func() error {
				s.TimeElapsed.Reset()
				if err := s.TimeElapsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_elapsed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveRestrictedMode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveRestrictedMode) {
					name = jsonFieldsNameOfActiveRestrictedMode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveRestrictedMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveRestrictedMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveRestrictedModeModeType as json.
func (s ActiveRestrictedModeModeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveRestrictedModeModeType from json.
func (s *ActiveRestrictedModeModeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveRestrictedModeModeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveRestrictedModeModeType(v) {
	case ActiveRestrictedModeModeTypeIronman:
		*s = ActiveRestrictedModeModeTypeIronman
	case ActiveRestrictedModeModeTypeHardcore:
		*s = ActiveRestrictedModeModeTypeHardcore
	case ActiveRestrictedModeModeTypeSolo:
		*s = ActiveRestrictedModeModeTypeSolo
	case ActiveRestrictedModeModeTypeNodeath:
		*s = ActiveRestrictedModeModeTypeNodeath
	default:
		*s = ActiveRestrictedModeModeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveRestrictedModeModeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveRestrictedModeModeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveRestrictedModeProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveRestrictedModeProgress) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActiveRestrictedModeProgress = [0]string{}

// Decode decodes ActiveRestrictedModeProgress from json.
func (s *ActiveRestrictedModeProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveRestrictedModeProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActiveRestrictedModeProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveRestrictedModeProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveRestrictedModeProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [3]string{
	0: "error",
	1: "message",
	2: "details",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBadRequest) {
					name = jsonFieldsNameOfBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBadRequestDetails = [0]string{}

// Decode decodes BadRequestDetails from json.
func (s *BadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteRestrictedModeSessionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteRestrictedModeSessionOK) encodeFields(e *jx.Encoder) {
	{
		if s.Session.Set {
			e.FieldStart("session")
			s.Session.Encode(e)
		}
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
	{
		if s.AchievementsUnlocked != nil {
			e.FieldStart("achievements_unlocked")
			e.ArrStart()
			for _, elem := range s.AchievementsUnlocked {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCompleteRestrictedModeSessionOK = [3]string{
	0: "session",
	1: "rewards",
	2: "achievements_unlocked",
}

// Decode decodes CompleteRestrictedModeSessionOK from json.
func (s *CompleteRestrictedModeSessionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteRestrictedModeSessionOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			if err := func() error {
				s.Session.Reset()
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "achievements_unlocked":
			if err := func() error {
				s.AchievementsUnlocked = make([]Achievement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Achievement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AchievementsUnlocked = append(s.AchievementsUnlocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_unlocked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteRestrictedModeSessionOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteRestrictedModeSessionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteRestrictedModeSessionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteRestrictedModeSessionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteRestrictedModeSessionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteRestrictedModeSessionReq = [4]string{
	0: "success",
	1: "completion_time",
	2: "score",
	3: "notes",
}

// Decode decodes CompleteRestrictedModeSessionReq from json.
func (s *CompleteRestrictedModeSessionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteRestrictedModeSessionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteRestrictedModeSessionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteRestrictedModeSessionReq) {
					name = jsonFieldsNameOfCompleteRestrictedModeSessionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteRestrictedModeSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteRestrictedModeSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompletedRestrictedModeSession) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompletedRestrictedModeSession) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("mode_type")
		s.ModeType.Encode(e)
	}
	{
		e.FieldStart("completed_at")
		json.EncodeDateTime(e, s.CompletedAt)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.FinalScore.Set {
			e.FieldStart("final_score")
			s.FinalScore.Encode(e)
		}
	}
	{
		if s.RankAchieved.Set {
			e.FieldStart("rank_achieved")
			s.RankAchieved.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompletedRestrictedModeSession = [7]string{
	0: "session_id",
	1: "mode_type",
	2: "completed_at",
	3: "success",
	4: "completion_time",
	5: "final_score",
	6: "rank_achieved",
}

// Decode decodes CompletedRestrictedModeSession from json.
func (s *CompletedRestrictedModeSession) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompletedRestrictedModeSession to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "mode_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "completed_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CompletedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "final_score":
			if err := func() error {
				s.FinalScore.Reset()
				if err := s.FinalScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_score\"")
			}
		case "rank_achieved":
			if err := func() error {
				s.RankAchieved.Reset()
				if err := s.RankAchieved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_achieved\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompletedRestrictedModeSession")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompletedRestrictedModeSession) {
					name = jsonFieldsNameOfCompletedRestrictedModeSession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompletedRestrictedModeSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompletedRestrictedModeSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompletedRestrictedModeSessionModeType as json.
func (s CompletedRestrictedModeSessionModeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CompletedRestrictedModeSessionModeType from json.
func (s *CompletedRestrictedModeSessionModeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompletedRestrictedModeSessionModeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CompletedRestrictedModeSessionModeType(v) {
	case CompletedRestrictedModeSessionModeTypeIronman:
		*s = CompletedRestrictedModeSessionModeTypeIronman
	case CompletedRestrictedModeSessionModeTypeHardcore:
		*s = CompletedRestrictedModeSessionModeTypeHardcore
	case CompletedRestrictedModeSessionModeTypeSolo:
		*s = CompletedRestrictedModeSessionModeTypeSolo
	case CompletedRestrictedModeSessionModeTypeNodeath:
		*s = CompletedRestrictedModeSessionModeTypeNodeath
	default:
		*s = CompletedRestrictedModeSessionModeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CompletedRestrictedModeSessionModeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompletedRestrictedModeSessionModeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FailRestrictedModeSessionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FailRestrictedModeSessionOK) encodeFields(e *jx.Encoder) {
	{
		if s.Session.Set {
			e.FieldStart("session")
			s.Session.Encode(e)
		}
	}
	{
		if s.PenaltiesApplied != nil {
			e.FieldStart("penalties_applied")
			e.ArrStart()
			for _, elem := range s.PenaltiesApplied {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFailRestrictedModeSessionOK = [2]string{
	0: "session",
	1: "penalties_applied",
}

// Decode decodes FailRestrictedModeSessionOK from json.
func (s *FailRestrictedModeSessionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailRestrictedModeSessionOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			if err := func() error {
				s.Session.Reset()
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "penalties_applied":
			if err := func() error {
				s.PenaltiesApplied = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PenaltiesApplied = append(s.PenaltiesApplied, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"penalties_applied\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FailRestrictedModeSessionOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FailRestrictedModeSessionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailRestrictedModeSessionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FailRestrictedModeSessionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FailRestrictedModeSessionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("failure_reason")
		s.FailureReason.Encode(e)
	}
	{
		if s.FailureDetails != nil {
			e.FieldStart("failure_details")
			s.FailureDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfFailRestrictedModeSessionReq = [2]string{
	0: "failure_reason",
	1: "failure_details",
}

// Decode decodes FailRestrictedModeSessionReq from json.
func (s *FailRestrictedModeSessionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailRestrictedModeSessionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failure_reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_reason\"")
			}
		case "failure_details":
			if err := func() error {
				s.FailureDetails = nil
				var elem FailRestrictedModeSessionReqFailureDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FailureDetails = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FailRestrictedModeSessionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFailRestrictedModeSessionReq) {
					name = jsonFieldsNameOfFailRestrictedModeSessionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FailRestrictedModeSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailRestrictedModeSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FailRestrictedModeSessionReqFailureDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FailRestrictedModeSessionReqFailureDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfFailRestrictedModeSessionReqFailureDetails = [0]string{}

// Decode decodes FailRestrictedModeSessionReqFailureDetails from json.
func (s *FailRestrictedModeSessionReqFailureDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailRestrictedModeSessionReqFailureDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode FailRestrictedModeSessionReqFailureDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FailRestrictedModeSessionReqFailureDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailRestrictedModeSessionReqFailureDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FailRestrictedModeSessionReqFailureReason as json.
func (s FailRestrictedModeSessionReqFailureReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FailRestrictedModeSessionReqFailureReason from json.
func (s *FailRestrictedModeSessionReqFailureReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailRestrictedModeSessionReqFailureReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FailRestrictedModeSessionReqFailureReason(v) {
	case FailRestrictedModeSessionReqFailureReasonDeath:
		*s = FailRestrictedModeSessionReqFailureReasonDeath
	case FailRestrictedModeSessionReqFailureReasonTimeout:
		*s = FailRestrictedModeSessionReqFailureReasonTimeout
	case FailRestrictedModeSessionReqFailureReasonQuit:
		*s = FailRestrictedModeSessionReqFailureReasonQuit
	case FailRestrictedModeSessionReqFailureReasonViolation:
		*s = FailRestrictedModeSessionReqFailureReasonViolation
	default:
		*s = FailRestrictedModeSessionReqFailureReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FailRestrictedModeSessionReqFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailRestrictedModeSessionReqFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FailedRestrictedModeSession) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FailedRestrictedModeSession) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("mode_type")
		s.ModeType.Encode(e)
	}
	{
		e.FieldStart("failed_at")
		json.EncodeDateTime(e, s.FailedAt)
	}
	{
		e.FieldStart("failure_reason")
		s.FailureReason.Encode(e)
	}
	{
		if s.PenaltiesApplied != nil {
			e.FieldStart("penalties_applied")
			e.ArrStart()
			for _, elem := range s.PenaltiesApplied {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFailedRestrictedModeSession = [5]string{
	0: "session_id",
	1: "mode_type",
	2: "failed_at",
	3: "failure_reason",
	4: "penalties_applied",
}

// Decode decodes FailedRestrictedModeSession from json.
func (s *FailedRestrictedModeSession) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailedRestrictedModeSession to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "mode_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "failed_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.FailedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "failure_reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_reason\"")
			}
		case "penalties_applied":
			if err := func() error {
				s.PenaltiesApplied = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PenaltiesApplied = append(s.PenaltiesApplied, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"penalties_applied\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FailedRestrictedModeSession")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFailedRestrictedModeSession) {
					name = jsonFieldsNameOfFailedRestrictedModeSession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FailedRestrictedModeSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailedRestrictedModeSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FailedRestrictedModeSessionFailureReason as json.
func (s FailedRestrictedModeSessionFailureReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FailedRestrictedModeSessionFailureReason from json.
func (s *FailedRestrictedModeSessionFailureReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailedRestrictedModeSessionFailureReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FailedRestrictedModeSessionFailureReason(v) {
	case FailedRestrictedModeSessionFailureReasonDeath:
		*s = FailedRestrictedModeSessionFailureReasonDeath
	case FailedRestrictedModeSessionFailureReasonTimeout:
		*s = FailedRestrictedModeSessionFailureReasonTimeout
	case FailedRestrictedModeSessionFailureReasonQuit:
		*s = FailedRestrictedModeSessionFailureReasonQuit
	case FailedRestrictedModeSessionFailureReasonViolation:
		*s = FailedRestrictedModeSessionFailureReasonViolation
	default:
		*s = FailedRestrictedModeSessionFailureReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FailedRestrictedModeSessionFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailedRestrictedModeSessionFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FailedRestrictedModeSessionModeType as json.
func (s FailedRestrictedModeSessionModeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FailedRestrictedModeSessionModeType from json.
func (s *FailedRestrictedModeSessionModeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailedRestrictedModeSessionModeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FailedRestrictedModeSessionModeType(v) {
	case FailedRestrictedModeSessionModeTypeIronman:
		*s = FailedRestrictedModeSessionModeTypeIronman
	case FailedRestrictedModeSessionModeTypeHardcore:
		*s = FailedRestrictedModeSessionModeTypeHardcore
	case FailedRestrictedModeSessionModeTypeSolo:
		*s = FailedRestrictedModeSessionModeTypeSolo
	case FailedRestrictedModeSessionModeTypeNodeath:
		*s = FailedRestrictedModeSessionModeTypeNodeath
	default:
		*s = FailedRestrictedModeSessionModeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FailedRestrictedModeSessionModeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailedRestrictedModeSessionModeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAvailableRestrictedModesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAvailableRestrictedModesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Modes != nil {
			e.FieldStart("modes")
			e.ArrStart()
			for _, elem := range s.Modes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PlayerEligibility.Set {
			e.FieldStart("player_eligibility")
			s.PlayerEligibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAvailableRestrictedModesOK = [2]string{
	0: "modes",
	1: "player_eligibility",
}

// Decode decodes GetAvailableRestrictedModesOK from json.
func (s *GetAvailableRestrictedModesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvailableRestrictedModesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modes":
			if err := func() error {
				s.Modes = make([]RestrictedMode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RestrictedMode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Modes = append(s.Modes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modes\"")
			}
		case "player_eligibility":
			if err := func() error {
				s.PlayerEligibility.Reset()
				if err := s.PlayerEligibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_eligibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAvailableRestrictedModesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAvailableRestrictedModesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvailableRestrictedModesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAvailableRestrictedModesOKPlayerEligibility) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAvailableRestrictedModesOKPlayerEligibility) encodeFields(e *jx.Encoder) {
	{
		if s.IronmanAvailable.Set {
			e.FieldStart("ironman_available")
			s.IronmanAvailable.Encode(e)
		}
	}
	{
		if s.HardcoreAvailable.Set {
			e.FieldStart("hardcore_available")
			s.HardcoreAvailable.Encode(e)
		}
	}
	{
		if s.SoloAvailable.Set {
			e.FieldStart("solo_available")
			s.SoloAvailable.Encode(e)
		}
	}
	{
		if s.NodeathAvailable.Set {
			e.FieldStart("nodeath_available")
			s.NodeathAvailable.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAvailableRestrictedModesOKPlayerEligibility = [4]string{
	0: "ironman_available",
	1: "hardcore_available",
	2: "solo_available",
	3: "nodeath_available",
}

// Decode decodes GetAvailableRestrictedModesOKPlayerEligibility from json.
func (s *GetAvailableRestrictedModesOKPlayerEligibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvailableRestrictedModesOKPlayerEligibility to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ironman_available":
			if err := func() error {
				s.IronmanAvailable.Reset()
				if err := s.IronmanAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ironman_available\"")
			}
		case "hardcore_available":
			if err := func() error {
				s.HardcoreAvailable.Reset()
				if err := s.HardcoreAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardcore_available\"")
			}
		case "solo_available":
			if err := func() error {
				s.SoloAvailable.Reset()
				if err := s.SoloAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"solo_available\"")
			}
		case "nodeath_available":
			if err := func() error {
				s.NodeathAvailable.Reset()
				if err := s.NodeathAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeath_available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAvailableRestrictedModesOKPlayerEligibility")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAvailableRestrictedModesOKPlayerEligibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvailableRestrictedModesOKPlayerEligibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerRestrictedModesStatusOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerRestrictedModesStatusOK) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveModes != nil {
			e.FieldStart("active_modes")
			e.ArrStart()
			for _, elem := range s.ActiveModes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerRestrictedModesStatusOK = [2]string{
	0: "active_modes",
	1: "statistics",
}

// Decode decodes GetPlayerRestrictedModesStatusOK from json.
func (s *GetPlayerRestrictedModesStatusOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerRestrictedModesStatusOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active_modes":
			if err := func() error {
				s.ActiveModes = make([]ActiveRestrictedMode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveRestrictedMode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveModes = append(s.ActiveModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_modes\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerRestrictedModesStatusOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerRestrictedModesStatusOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerRestrictedModesStatusOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRestrictedModesLeaderboardOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRestrictedModesLeaderboardOK) encodeFields(e *jx.Encoder) {
	{
		if s.Leaderboard != nil {
			e.FieldStart("leaderboard")
			e.ArrStart()
			for _, elem := range s.Leaderboard {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeType.Set {
			e.FieldStart("mode_type")
			s.ModeType.Encode(e)
		}
	}
	{
		if s.Timeframe.Set {
			e.FieldStart("timeframe")
			s.Timeframe.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRestrictedModesLeaderboardOK = [3]string{
	0: "leaderboard",
	1: "mode_type",
	2: "timeframe",
}

// Decode decodes GetRestrictedModesLeaderboardOK from json.
func (s *GetRestrictedModesLeaderboardOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRestrictedModesLeaderboardOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leaderboard":
			if err := func() error {
				s.Leaderboard = make([]LeaderboardEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeaderboardEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Leaderboard = append(s.Leaderboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard\"")
			}
		case "mode_type":
			if err := func() error {
				s.ModeType.Reset()
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "timeframe":
			if err := func() error {
				s.Timeframe.Reset()
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRestrictedModesLeaderboardOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRestrictedModesLeaderboardOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRestrictedModesLeaderboardOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalServerError = [2]string{
	0: "error",
	1: "message",
}

// Decode decodes InternalServerError from json.
func (s *InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInternalServerError) {
					name = jsonFieldsNameOfInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Item) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Item) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item_id")
		e.Str(s.ItemID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Rarity.Set {
			e.FieldStart("rarity")
			s.Rarity.Encode(e)
		}
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfItem = [4]string{
	0: "item_id",
	1: "name",
	2: "rarity",
	3: "quantity",
}

// Decode decodes Item from json.
func (s *Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Item to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ItemID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rarity":
			if err := func() error {
				s.Rarity.Reset()
				if err := s.Rarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Item")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItem) {
					name = jsonFieldsNameOfItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("player_name")
		e.Str(s.PlayerName)
	}
	{
		if s.CharacterName.Set {
			e.FieldStart("character_name")
			s.CharacterName.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
	{
		e.FieldStart("rank")
		e.Int(s.Rank)
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardEntry = [7]string{
	0: "player_id",
	1: "player_name",
	2: "character_name",
	3: "completed_at",
	4: "score",
	5: "rank",
	6: "completion_time",
}

// Decode decodes LeaderboardEntry from json.
func (s *LeaderboardEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "player_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlayerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_name\"")
			}
		case "character_name":
			if err := func() error {
				s.CharacterName.Reset()
				if err := s.CharacterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_name\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Rank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardEntry) {
					name = jsonFieldsNameOfLeaderboardEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModeCompletionRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModeCompletionRewards) encodeFields(e *jx.Encoder) {
	{
		if s.ItemsGranted != nil {
			e.FieldStart("items_granted")
			e.ArrStart()
			for _, elem := range s.ItemsGranted {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TitlesUnlocked != nil {
			e.FieldStart("titles_unlocked")
			e.ArrStart()
			for _, elem := range s.TitlesUnlocked {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AchievementsUnlocked != nil {
			e.FieldStart("achievements_unlocked")
			e.ArrStart()
			for _, elem := range s.AchievementsUnlocked {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExperienceGained.Set {
			e.FieldStart("experience_gained")
			s.ExperienceGained.Encode(e)
		}
	}
}

var jsonFieldsNameOfModeCompletionRewards = [4]string{
	0: "items_granted",
	1: "titles_unlocked",
	2: "achievements_unlocked",
	3: "experience_gained",
}

// Decode decodes ModeCompletionRewards from json.
func (s *ModeCompletionRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModeCompletionRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items_granted":
			if err := func() error {
				s.ItemsGranted = make([]Item, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Item
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ItemsGranted = append(s.ItemsGranted, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_granted\"")
			}
		case "titles_unlocked":
			if err := func() error {
				s.TitlesUnlocked = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TitlesUnlocked = append(s.TitlesUnlocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titles_unlocked\"")
			}
		case "achievements_unlocked":
			if err := func() error {
				s.AchievementsUnlocked = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AchievementsUnlocked = append(s.AchievementsUnlocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_unlocked\"")
			}
		case "experience_gained":
			if err := func() error {
				s.ExperienceGained.Reset()
				if err := s.ExperienceGained.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience_gained\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModeCompletionRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModeCompletionRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModeCompletionRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModeRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModeRequirements) encodeFields(e *jx.Encoder) {
	{
		if s.RequiredAchievements != nil {
			e.FieldStart("required_achievements")
			e.ArrStart()
			for _, elem := range s.RequiredAchievements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinCharacterLevel.Set {
			e.FieldStart("min_character_level")
			s.MinCharacterLevel.Encode(e)
		}
	}
	{
		if s.CooldownPeriod.Set {
			e.FieldStart("cooldown_period")
			s.CooldownPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfModeRequirements = [3]string{
	0: "required_achievements",
	1: "min_character_level",
	2: "cooldown_period",
}

// Decode decodes ModeRequirements from json.
func (s *ModeRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModeRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required_achievements":
			if err := func() error {
				s.RequiredAchievements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredAchievements = append(s.RequiredAchievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_achievements\"")
			}
		case "min_character_level":
			if err := func() error {
				s.MinCharacterLevel.Reset()
				if err := s.MinCharacterLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_character_level\"")
			}
		case "cooldown_period":
			if err := func() error {
				s.CooldownPeriod.Reset()
				if err := s.CooldownPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_period\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModeRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModeRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModeRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModeRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModeRewards) encodeFields(e *jx.Encoder) {
	{
		if s.UniqueTitles != nil {
			e.FieldStart("unique_titles")
			e.ArrStart()
			for _, elem := range s.UniqueTitles {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExclusiveItems != nil {
			e.FieldStart("exclusive_items")
			e.ArrStart()
			for _, elem := range s.ExclusiveItems {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BaseXpMultiplier.Set {
			e.FieldStart("base_xp_multiplier")
			s.BaseXpMultiplier.Encode(e)
		}
	}
	{
		if s.ItemDropsMultiplier.Set {
			e.FieldStart("item_drops_multiplier")
			s.ItemDropsMultiplier.Encode(e)
		}
	}
	{
		if s.LeaderboardBonuses.Set {
			e.FieldStart("leaderboard_bonuses")
			s.LeaderboardBonuses.Encode(e)
		}
	}
}

var jsonFieldsNameOfModeRewards = [5]string{
	0: "unique_titles",
	1: "exclusive_items",
	2: "base_xp_multiplier",
	3: "item_drops_multiplier",
	4: "leaderboard_bonuses",
}

// Decode decodes ModeRewards from json.
func (s *ModeRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModeRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unique_titles":
			if err := func() error {
				s.UniqueTitles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UniqueTitles = append(s.UniqueTitles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_titles\"")
			}
		case "exclusive_items":
			if err := func() error {
				s.ExclusiveItems = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExclusiveItems = append(s.ExclusiveItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusive_items\"")
			}
		case "base_xp_multiplier":
			if err := func() error {
				s.BaseXpMultiplier.Reset()
				if err := s.BaseXpMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_xp_multiplier\"")
			}
		case "item_drops_multiplier":
			if err := func() error {
				s.ItemDropsMultiplier.Reset()
				if err := s.ItemDropsMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_drops_multiplier\"")
			}
		case "leaderboard_bonuses":
			if err := func() error {
				s.LeaderboardBonuses.Reset()
				if err := s.LeaderboardBonuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard_bonuses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModeRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModeRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModeRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModeStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModeStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.TotalPlayersAttempted.Set {
			e.FieldStart("total_players_attempted")
			s.TotalPlayersAttempted.Encode(e)
		}
	}
	{
		if s.TotalPlayersCompleted.Set {
			e.FieldStart("total_players_completed")
			s.TotalPlayersCompleted.Encode(e)
		}
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("average_completion_time")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.HighestScore.Set {
			e.FieldStart("highest_score")
			s.HighestScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfModeStatistics = [4]string{
	0: "total_players_attempted",
	1: "total_players_completed",
	2: "average_completion_time",
	3: "highest_score",
}

// Decode decodes ModeStatistics from json.
func (s *ModeStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModeStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_players_attempted":
			if err := func() error {
				s.TotalPlayersAttempted.Reset()
				if err := s.TotalPlayersAttempted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_players_attempted\"")
			}
		case "total_players_completed":
			if err := func() error {
				s.TotalPlayersCompleted.Reset()
				if err := s.TotalPlayersCompleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_players_completed\"")
			}
		case "average_completion_time":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_completion_time\"")
			}
		case "highest_score":
			if err := func() error {
				s.HighestScore.Reset()
				if err := s.HighestScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highest_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModeStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModeStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModeStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementRarity as json.
func (o OptAchievementRarity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AchievementRarity from json.
func (o *OptAchievementRarity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAchievementRarity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAchievementRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAchievementRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveRestrictedMode as json.
func (o OptActiveRestrictedMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActiveRestrictedMode from json.
func (o *OptActiveRestrictedMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActiveRestrictedMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActiveRestrictedMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActiveRestrictedMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompletedRestrictedModeSession as json.
func (o OptCompletedRestrictedModeSession) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CompletedRestrictedModeSession from json.
func (o *OptCompletedRestrictedModeSession) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompletedRestrictedModeSession to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompletedRestrictedModeSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompletedRestrictedModeSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FailedRestrictedModeSession as json.
func (o OptFailedRestrictedModeSession) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FailedRestrictedModeSession from json.
func (o *OptFailedRestrictedModeSession) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFailedRestrictedModeSession to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFailedRestrictedModeSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFailedRestrictedModeSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAvailableRestrictedModesOKPlayerEligibility as json.
func (o OptGetAvailableRestrictedModesOKPlayerEligibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetAvailableRestrictedModesOKPlayerEligibility from json.
func (o *OptGetAvailableRestrictedModesOKPlayerEligibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAvailableRestrictedModesOKPlayerEligibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAvailableRestrictedModesOKPlayerEligibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAvailableRestrictedModesOKPlayerEligibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModeCompletionRewards as json.
func (o OptModeCompletionRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModeCompletionRewards from json.
func (o *OptModeCompletionRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModeCompletionRewards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModeCompletionRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModeCompletionRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModeStatistics as json.
func (o OptModeStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModeStatistics from json.
func (o *OptModeStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModeStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModeStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModeStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerModeStatistics as json.
func (o OptPlayerModeStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PlayerModeStatistics from json.
func (o *OptPlayerModeStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerModeStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerModeStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerModeStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerModeStatisticsBestScores as json.
func (o OptPlayerModeStatisticsBestScores) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PlayerModeStatisticsBestScores from json.
func (o *OptPlayerModeStatisticsBestScores) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayerModeStatisticsBestScores to nil")
	}
	o.Set = true
	o.Value = make(PlayerModeStatisticsBestScores)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayerModeStatisticsBestScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayerModeStatisticsBestScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectRestrictedModeReqContentType as json.
func (o OptSelectRestrictedModeReqContentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SelectRestrictedModeReqContentType from json.
func (o *OptSelectRestrictedModeReqContentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectRestrictedModeReqContentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSelectRestrictedModeReqContentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSelectRestrictedModeReqContentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectRestrictedModeReqDifficulty as json.
func (o OptSelectRestrictedModeReqDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SelectRestrictedModeReqDifficulty from json.
func (o *OptSelectRestrictedModeReqDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectRestrictedModeReqDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSelectRestrictedModeReqDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSelectRestrictedModeReqDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerModeStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerModeStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.BestScores.Set {
			e.FieldStart("best_scores")
			s.BestScores.Encode(e)
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalSessions.Set {
			e.FieldStart("total_sessions")
			s.TotalSessions.Encode(e)
		}
	}
	{
		if s.SuccessfulSessions.Set {
			e.FieldStart("successful_sessions")
			s.SuccessfulSessions.Encode(e)
		}
	}
	{
		if s.FailedSessions.Set {
			e.FieldStart("failed_sessions")
			s.FailedSessions.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayerModeStatistics = [5]string{
	0: "best_scores",
	1: "achievements",
	2: "total_sessions",
	3: "successful_sessions",
	4: "failed_sessions",
}

// Decode decodes PlayerModeStatistics from json.
func (s *PlayerModeStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerModeStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "best_scores":
			if err := func() error {
				s.BestScores.Reset()
				if err := s.BestScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_scores\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		case "total_sessions":
			if err := func() error {
				s.TotalSessions.Reset()
				if err := s.TotalSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_sessions\"")
			}
		case "successful_sessions":
			if err := func() error {
				s.SuccessfulSessions.Reset()
				if err := s.SuccessfulSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_sessions\"")
			}
		case "failed_sessions":
			if err := func() error {
				s.FailedSessions.Reset()
				if err := s.FailedSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_sessions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerModeStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerModeStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerModeStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PlayerModeStatisticsBestScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PlayerModeStatisticsBestScores) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes PlayerModeStatisticsBestScores from json.
func (s *PlayerModeStatisticsBestScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerModeStatisticsBestScores to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerModeStatisticsBestScores")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerModeStatisticsBestScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerModeStatisticsBestScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestrictedMode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestrictedMode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mode_type")
		s.ModeType.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("requirements")
		s.Requirements.Encode(e)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
}

var jsonFieldsNameOfRestrictedMode = [6]string{
	0: "mode_type",
	1: "name",
	2: "description",
	3: "requirements",
	4: "rewards",
	5: "statistics",
}

// Decode decodes RestrictedMode from json.
func (s *RestrictedMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestrictedMode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "requirements":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Requirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestrictedMode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestrictedMode) {
					name = jsonFieldsNameOfRestrictedMode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestrictedMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestrictedMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RestrictedModeModeType as json.
func (s RestrictedModeModeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RestrictedModeModeType from json.
func (s *RestrictedModeModeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestrictedModeModeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RestrictedModeModeType(v) {
	case RestrictedModeModeTypeIronman:
		*s = RestrictedModeModeTypeIronman
	case RestrictedModeModeTypeHardcore:
		*s = RestrictedModeModeTypeHardcore
	case RestrictedModeModeTypeSolo:
		*s = RestrictedModeModeTypeSolo
	case RestrictedModeModeTypeNodeath:
		*s = RestrictedModeModeTypeNodeath
	default:
		*s = RestrictedModeModeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RestrictedModeModeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestrictedModeModeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectRestrictedModeConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectRestrictedModeConflict) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.CurrentMode.Set {
			e.FieldStart("current_mode")
			s.CurrentMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSelectRestrictedModeConflict = [2]string{
	0: "error",
	1: "current_mode",
}

// Decode decodes SelectRestrictedModeConflict from json.
func (s *SelectRestrictedModeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeConflict to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "current_mode":
			if err := func() error {
				s.CurrentMode.Reset()
				if err := s.CurrentMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectRestrictedModeConflict")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectRestrictedModeConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectRestrictedModeCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectRestrictedModeCreated) encodeFields(e *jx.Encoder) {
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.RestrictionsApplied != nil {
			e.FieldStart("restrictions_applied")
			e.ArrStart()
			for _, elem := range s.RestrictionsApplied {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSelectRestrictedModeCreated = [3]string{
	0: "session_id",
	1: "mode",
	2: "restrictions_applied",
}

// Decode decodes SelectRestrictedModeCreated from json.
func (s *SelectRestrictedModeCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "restrictions_applied":
			if err := func() error {
				s.RestrictionsApplied = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RestrictionsApplied = append(s.RestrictionsApplied, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions_applied\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectRestrictedModeCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectRestrictedModeCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectRestrictedModeForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectRestrictedModeForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfSelectRestrictedModeForbidden = [2]string{
	0: "error",
	1: "reason",
}

// Decode decodes SelectRestrictedModeForbidden from json.
func (s *SelectRestrictedModeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectRestrictedModeForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectRestrictedModeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectRestrictedModeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectRestrictedModeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mode_type")
		s.ModeType.Encode(e)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfSelectRestrictedModeReq = [4]string{
	0: "mode_type",
	1: "character_id",
	2: "content_type",
	3: "difficulty",
}

// Decode decodes SelectRestrictedModeReq from json.
func (s *SelectRestrictedModeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ModeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode_type\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectRestrictedModeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSelectRestrictedModeReq) {
					name = jsonFieldsNameOfSelectRestrictedModeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectRestrictedModeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectRestrictedModeReqContentType as json.
func (s SelectRestrictedModeReqContentType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SelectRestrictedModeReqContentType from json.
func (s *SelectRestrictedModeReqContentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeReqContentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SelectRestrictedModeReqContentType(v) {
	case SelectRestrictedModeReqContentTypeQuest:
		*s = SelectRestrictedModeReqContentTypeQuest
	case SelectRestrictedModeReqContentTypeDungeon:
		*s = SelectRestrictedModeReqContentTypeDungeon
	case SelectRestrictedModeReqContentTypeRaid:
		*s = SelectRestrictedModeReqContentTypeRaid
	case SelectRestrictedModeReqContentTypePvp:
		*s = SelectRestrictedModeReqContentTypePvp
	default:
		*s = SelectRestrictedModeReqContentType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SelectRestrictedModeReqContentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeReqContentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectRestrictedModeReqDifficulty as json.
func (s SelectRestrictedModeReqDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SelectRestrictedModeReqDifficulty from json.
func (s *SelectRestrictedModeReqDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeReqDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SelectRestrictedModeReqDifficulty(v) {
	case SelectRestrictedModeReqDifficultyNormal:
		*s = SelectRestrictedModeReqDifficultyNormal
	case SelectRestrictedModeReqDifficultyHard:
		*s = SelectRestrictedModeReqDifficultyHard
	case SelectRestrictedModeReqDifficultyMythic:
		*s = SelectRestrictedModeReqDifficultyMythic
	default:
		*s = SelectRestrictedModeReqDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SelectRestrictedModeReqDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeReqDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectRestrictedModeReqModeType as json.
func (s SelectRestrictedModeReqModeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SelectRestrictedModeReqModeType from json.
func (s *SelectRestrictedModeReqModeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectRestrictedModeReqModeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SelectRestrictedModeReqModeType(v) {
	case SelectRestrictedModeReqModeTypeIronman:
		*s = SelectRestrictedModeReqModeTypeIronman
	case SelectRestrictedModeReqModeTypeHardcore:
		*s = SelectRestrictedModeReqModeTypeHardcore
	case SelectRestrictedModeReqModeTypeSolo:
		*s = SelectRestrictedModeReqModeTypeSolo
	case SelectRestrictedModeReqModeTypeNodeath:
		*s = SelectRestrictedModeReqModeTypeNodeath
	default:
		*s = SelectRestrictedModeReqModeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SelectRestrictedModeReqModeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectRestrictedModeReqModeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorized = [2]string{
	0: "error",
	1: "message",
}

// Decode decodes Unauthorized from json.
func (s *Unauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorized) {
					name = jsonFieldsNameOfUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
