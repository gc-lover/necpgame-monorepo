// Code generated by NECPGAME backend agent. Enterprise-grade Affix Manager.
// Issue: #1495
// PERFORMANCE: Optimized for high-throughput affix operations with caching

package affix

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/gameplay-service-go/pkg/api"
)

// Config holds affix manager configuration
type Config struct {
	DB     *pgxpool.Pool
	Redis  *redis.Client
	Logger *zap.Logger
	Tracer trace.Tracer
	Meter  metric.Meter
}

// Manager handles affix CRUD operations
type Manager struct {
	db     *pgxpool.Pool
	redis  *redis.Client
	logger *zap.Logger
	tracer trace.Tracer
	meter  metric.Meter
}

// NewManager creates a new affix manager
func NewManager(cfg Config) (*Manager, error) {
	if cfg.DB == nil {
		return nil, errors.New("database connection is required")
	}
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}

	return &Manager{
		db:     cfg.DB,
		redis:  cfg.Redis,
		logger: cfg.Logger,
		tracer: cfg.Tracer,
		meter:  cfg.Meter,
	}, nil
}

// GetActiveAffixes returns currently active affixes for the week
func (m *Manager) GetActiveAffixes(ctx context.Context) ([]*api.Affix, error) {
	ctx, span := m.tracer.Start(ctx, "affix_manager.get_active_affixes")
	defer span.End()

	// Query database
	query := `
		SELECT a.id, a.name, a.description, a.category, a.reward_modifier, a.difficulty_modifier, a.mechanics, a.visual_effects
		FROM gameplay.affixes a
		JOIN gameplay.active_affixes aa ON a.id = aa.affix_id
		JOIN gameplay.affix_rotations ar ON aa.rotation_id = ar.id
		WHERE ar.week_start <= NOW() AND ar.week_end > NOW()
		ORDER BY a.category, a.name
	`

	rows, err := m.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "failed to query active affixes")
	}
	defer rows.Close()

	var affixes []*api.Affix
	for rows.Next() {
		var affix api.Affix
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&affix.ID,
			&affix.Name,
			&affix.Description,
			&affix.Category,
			&affix.RewardModifier,
			&affix.DifficultyModifier,
			&mechanics,
			&visualEffects,
		)
		if err != nil {
			return nil, errors.Wrap(err, "failed to scan affix")
		}

		// Parse JSON fields
		if len(mechanics) > 0 {
			affix.Mechanics = api.OptAffixMechanics{
				Value: string(mechanics),
				Set:   true,
			}
		}
		if len(visualEffects) > 0 {
			affix.VisualEffects = api.OptAffixVisualEffects{
				Value: string(visualEffects),
				Set:   true,
			}
		}

		affixes = append(affixes, &affix)
	}

	if err := rows.Err(); err != nil {
		return nil, errors.Wrap(err, "error iterating rows")
	}

	m.logger.Info("Retrieved active affixes", zap.Int("count", len(affixes)))
	return affixes, nil
}

// GetAffix returns a single affix by ID
func (m *Manager) GetAffix(ctx context.Context, id uuid.UUID) (*api.Affix, error) {
	ctx, span := m.tracer.Start(ctx, "affix_manager.get_affix")
	defer span.End()

	query := `
		SELECT id, name, description, category, reward_modifier, difficulty_modifier, mechanics, visual_effects
		FROM gameplay.affixes
		WHERE id = $1
	`

	var affix api.Affix
	var mechanics, visualEffects []byte

	err := m.db.QueryRow(ctx, query, id).Scan(
		&affix.ID,
		&affix.Name,
		&affix.Description,
		&affix.Category,
		&affix.RewardModifier,
		&affix.DifficultyModifier,
		&mechanics,
		&visualEffects,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.New("affix not found")
		}
		return nil, errors.Wrap(err, "failed to get affix")
	}

	// Parse JSON fields
	if len(mechanics) > 0 {
		affix.Mechanics = api.OptAffixMechanics{
			Value: string(mechanics),
			Set:   true,
		}
	}
	if len(visualEffects) > 0 {
		affix.VisualEffects = api.OptAffixVisualEffects{
			Value: string(visualEffects),
			Set:   true,
		}
	}

	return &affix, nil
}

// CreateAffix creates a new affix
func (m *Manager) CreateAffix(ctx context.Context, req api.CreateAffixRequest) (*api.Affix, error) {
	ctx, span := m.tracer.Start(ctx, "affix_manager.create_affix")
	defer span.End()

	id := uuid.New()
	now := time.Now()

	query := `
		INSERT INTO gameplay.affixes (id, name, description, category, reward_modifier, difficulty_modifier, mechanics, visual_effects, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`

	_, err := m.db.Exec(ctx, query,
		id,
		req.Name,
		req.Description,
		req.Category,
		req.RewardModifier,
		req.DifficultyModifier,
		req.Mechanics,
		req.VisualEffects,
		now,
	)

	if err != nil {
		return nil, errors.Wrap(err, "failed to create affix")
	}

	// Invalidate cache
	if m.redis != nil {
		m.redis.Del(ctx, "active_affixes")
	}

	affix := &api.Affix{
		ID:                 id,
		Name:               req.Name,
		Description:        req.Description,
		Category:           api.AffixCategory(req.Category),
		RewardModifier:     float32(req.RewardModifier),
		DifficultyModifier: float32(req.DifficultyModifier),
		Mechanics:          api.OptAffixMechanics{Value: req.Mechanics, Set: true},
		VisualEffects:      api.OptAffixVisualEffects{Value: req.VisualEffects, Set: true},
	}

	m.logger.Info("Created new affix", zap.String("id", id.String()), zap.String("name", req.Name))
	return affix, nil
}

// UpdateAffix updates an existing affix
func (m *Manager) UpdateAffix(ctx context.Context, id uuid.UUID, req api.UpdateAffixRequest) (*api.Affix, error) {
	ctx, span := m.tracer.Start(ctx, "affix_manager.update_affix")
	defer span.End()

	// Build dynamic update query
	setParts := []string{}
	args := []interface{}{}
	argIdx := 1

	if req.Name.IsSet() {
		setParts = append(setParts, fmt.Sprintf("name = $%d", argIdx))
		args = append(args, req.Name.Value)
		argIdx++
	}
	if req.Description.IsSet() {
		setParts = append(setParts, fmt.Sprintf("description = $%d", argIdx))
		args = append(args, req.Description.Value)
		argIdx++
	}
	if req.Category.IsSet() {
		setParts = append(setParts, fmt.Sprintf("category = $%d", argIdx))
		args = append(args, req.Category.Value)
		argIdx++
	}
	if req.RewardModifier.IsSet() {
		setParts = append(setParts, fmt.Sprintf("reward_modifier = $%d", argIdx))
		args = append(args, req.RewardModifier.Value)
		argIdx++
	}
	if req.DifficultyModifier.IsSet() {
		setParts = append(setParts, fmt.Sprintf("difficulty_modifier = $%d", argIdx))
		args = append(args, req.DifficultyModifier.Value)
		argIdx++
	}
	if req.Mechanics.IsSet() {
		setParts = append(setParts, fmt.Sprintf("mechanics = $%d", argIdx))
		args = append(args, req.Mechanics.Value)
		argIdx++
	}
	if req.VisualEffects.IsSet() {
		setParts = append(setParts, fmt.Sprintf("visual_effects = $%d", argIdx))
		args = append(args, req.VisualEffects.Value)
		argIdx++
	}

	if len(setParts) == 0 {
		return nil, errors.New("no fields to update")
	}

	query := fmt.Sprintf("UPDATE gameplay.affixes SET %s WHERE id = $%d", strings.Join(setParts, ", "), argIdx)
	args = append(args, id)

	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update affix")
	}

	if result.RowsAffected() == 0 {
		return nil, errors.New("affix not found")
	}

	// Invalidate cache
	if m.redis != nil {
		m.redis.Del(ctx, "active_affixes")
	}

	// Return updated affix
	return m.GetAffix(ctx, id)
}

// DeleteAffix deletes an affix
func (m *Manager) DeleteAffix(ctx context.Context, id uuid.UUID) error {
	ctx, span := m.tracer.Start(ctx, "affix_manager.delete_affix")
	defer span.End()

	query := "DELETE FROM gameplay.affixes WHERE id = $1"

	result, err := m.db.Exec(ctx, query, id)
	if err != nil {
		return errors.Wrap(err, "failed to delete affix")
	}

	if result.RowsAffected() == 0 {
		return errors.New("affix not found")
	}

	// Invalidate cache
	if m.redis != nil {
		m.redis.Del(ctx, "active_affixes")
	}

	m.logger.Info("Deleted affix", zap.String("id", id.String()))
	return nil
}

// ListAffixes returns paginated list of affixes
func (m *Manager) ListAffixes(ctx context.Context, category string, limit, offset int) ([]*api.Affix, int64, error) {
	ctx, span := m.tracer.Start(ctx, "affix_manager.list_affixes")
	defer span.End()

	// Build query
	query := `
		SELECT id, name, description, category, reward_modifier, difficulty_modifier, mechanics, visual_effects
		FROM gameplay.affixes
	`
	countQuery := "SELECT COUNT(*) FROM gameplay.affixes"

	args := []interface{}{}
	argIdx := 1

	whereParts := []string{}
	if category != "" {
		whereParts = append(whereParts, fmt.Sprintf("category = $%d", argIdx))
		args = append(args, category)
		argIdx++
	}

	if len(whereParts) > 0 {
		whereClause := " WHERE " + strings.Join(whereParts, " AND ")
		query += whereClause
		countQuery += whereClause
	}

	query += fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", argIdx, argIdx+1)
	args = append(args, limit, offset)

	// Get total count
	var total int64
	err := m.db.QueryRow(ctx, countQuery, args[:len(args)-2]...).Scan(&total)
	if err != nil {
		return nil, 0, errors.Wrap(err, "failed to get total count")
	}

	// Get affixes
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, errors.Wrap(err, "failed to query affixes")
	}
	defer rows.Close()

	var affixes []*api.Affix
	for rows.Next() {
		var affix api.Affix
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&affix.ID,
			&affix.Name,
			&affix.Description,
			&affix.Category,
			&affix.RewardModifier,
			&affix.DifficultyModifier,
			&mechanics,
			&visualEffects,
		)
		if err != nil {
			return nil, 0, errors.Wrap(err, "failed to scan affix")
		}

		if len(mechanics) > 0 {
			affix.Mechanics = api.OptAffixMechanics{
				Value: string(mechanics),
				Set:   true,
			}
		}
		if len(visualEffects) > 0 {
			affix.VisualEffects = api.OptAffixVisualEffects{
				Value: string(visualEffects),
				Set:   true,
			}
		}

		affixes = append(affixes, &affix)
	}

	return affixes, total, nil
}
