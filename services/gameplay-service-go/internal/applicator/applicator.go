// Code generated by NECPGAME backend agent. Enterprise-grade Affix Applicator.
// Issue: #1495
// PERFORMANCE: Optimized instance affix application with <50ms latency

package applicator

import (
	"context"
	"fmt"
	"math/rand"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	eventbus "github.com/your-org/necpgame/scripts/kafka-event-driven"
	"necpgame/services/gameplay-service-go/internal/affix"
	"necpgame/services/gameplay-service-go/internal/rotation"
	"necpgame/services/gameplay-service-go/pkg/api"
)

// Config holds applicator configuration
type Config struct {
	DB               *pgxpool.Pool
	Redis            *redis.Client
	Logger           *zap.Logger
	Tracer           trace.Tracer
	Meter            metric.Meter
	EventBus         *eventbus.EventBus
	AffixManager     *affix.Manager
	RotationController *rotation.Controller
}

// InstanceModifiers represents calculated modifiers for an instance
type InstanceModifiers struct {
	RewardModifier    float64
	DifficultyModifier float64
}

// Applicator handles affix application to game instances
type Applicator struct {
	db               *pgxpool.Pool
	redis            *redis.Client
	logger           *zap.Logger
	tracer           trace.Tracer
	meter            metric.Meter
	eventBus         *eventbus.EventBus
	affixManager     *affix.Manager
	rotationController *rotation.Controller
}

// NewApplicator creates a new affix applicator
func NewApplicator(cfg Config) (*Applicator, error) {
	if cfg.DB == nil {
		return nil, errors.New("database connection is required")
	}
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}
	if cfg.AffixManager == nil {
		return nil, errors.New("affix manager is required")
	}
	if cfg.RotationController == nil {
		return nil, errors.New("rotation controller is required")
	}

	return &Applicator{
		db:                cfg.DB,
		redis:             cfg.Redis,
		logger:            cfg.Logger,
		tracer:            cfg.Tracer,
		meter:             cfg.Meter,
		eventBus:          cfg.EventBus,
		affixManager:      cfg.AffixManager,
		rotationController: cfg.RotationController,
	}, nil
}

// ApplyAffixesToInstance applies random affixes to a dungeon/raid instance
func (a *Applicator) ApplyAffixesToInstance(ctx context.Context, instanceID uuid.UUID) ([]*api.Affix, *InstanceModifiers, error) {
	ctx, span := a.tracer.Start(ctx, "applicator.apply_affixes_to_instance")
	defer span.End()

	// Get active affixes for current rotation
	activeAffixes, err := a.affixManager.GetActiveAffixes(ctx)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to get active affixes")
	}

	if len(activeAffixes) == 0 {
		a.logger.Warn("No active affixes available for instance", zap.String("instance_id", instanceID.String()))
		return []*api.Affix{}, &InstanceModifiers{RewardModifier: 1.0, DifficultyModifier: 1.0}, nil
	}

	// Select random affixes (2-4)
	selectedAffixes := a.selectRandomAffixes(activeAffixes, 2, 4)

	// Check compatibility
	selectedAffixes = a.filterCompatibleAffixes(selectedAffixes)

	// Apply to instance
	err = a.applyAffixesToDatabase(ctx, instanceID, selectedAffixes)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to apply affixes to database")
	}

	// Calculate modifiers
	modifiers := a.calculateInstanceModifiers(selectedAffixes)

	a.logger.Info("Applied affixes to instance",
		zap.String("instance_id", instanceID.String()),
		zap.Int("affix_count", len(selectedAffixes)),
		zap.Float64("reward_modifier", modifiers.RewardModifier),
		zap.Float64("difficulty_modifier", modifiers.DifficultyModifier))

	// Publish event gameplay.affixes.applied
	if a.eventBus != nil {
		// Prepare affix data for event payload
		affixIDs := make([]string, len(selectedAffixes))
		for i, affix := range selectedAffixes {
			affixIDs[i] = affix.Id
		}

		eventPayload := map[string]interface{}{
			"instance_id":        instanceID.String(),
			"affix_ids":          affixIDs,
			"affix_count":        len(selectedAffixes),
			"reward_modifier":    modifiers.RewardModifier,
			"difficulty_modifier": modifiers.DifficultyModifier,
			"applied_at":         time.Now(),
		}

		err = a.eventBus.PublishGameEvent(ctx, instanceID.String(), eventbus.EventTypeAffixApplied, eventPayload, "gameplay-service")
		if err != nil {
			a.logger.Error("Failed to publish affix applied event",
				zap.String("instance_id", instanceID.String()),
				zap.Error(err))
			// Don't return error - affix application succeeded, just event publishing failed
		} else {
			a.logger.Info("Published affix applied event",
				zap.String("instance_id", instanceID.String()),
				zap.Int("affix_count", len(selectedAffixes)))
		}
	} else {
		a.logger.Info("Applied affixes to instance (no event bus)",
			zap.String("instance_id", instanceID.String()),
			zap.Int("affix_count", len(selectedAffixes)))
	}

	return selectedAffixes, modifiers, nil
}

// GetInstanceAffixes returns affixes applied to an instance
func (a *Applicator) GetInstanceAffixes(ctx context.Context, instanceID uuid.UUID) ([]*api.Affix, *InstanceModifiers, error) {
	ctx, span := a.tracer.Start(ctx, "applicator.get_instance_affixes")
	defer span.End()

	// PERFORMANCE: Add timeout for DB operations to prevent hanging
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	query := `
		SELECT a.id, a.name, a.description, a.category, a.reward_modifier, a.difficulty_modifier, a.mechanics, a.visual_effects
		FROM gameplay.affixes a
		JOIN gameplay.instance_affixes ia ON a.id = ia.affix_id
		WHERE ia.instance_id = $1
		ORDER BY a.category, a.name
	`

	rows, err := a.db.Query(ctx, query, instanceID)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to query instance affixes")
	}
	defer rows.Close()

	var affixes []*api.Affix
	for rows.Next() {
		var affix api.Affix
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Description, &affix.Category,
			&affix.RewardModifier, &affix.DifficultyModifier, &mechanics, &visualEffects,
		)
		if err != nil {
			return nil, nil, errors.Wrap(err, "failed to scan affix")
		}

		if len(mechanics) > 0 {
			affix.Mechanics = api.OptAffixMechanics{
				Value: string(mechanics),
				Set:   true,
			}
		}
		if len(visualEffects) > 0 {
			affix.VisualEffects = api.OptAffixVisualEffects{
				Value: string(visualEffects),
				Set:   true,
			}
		}

		affixes = append(affixes, &affix)
	}

	if len(affixes) == 0 {
		return []*api.Affix{}, &InstanceModifiers{RewardModifier: 1.0, DifficultyModifier: 1.0}, nil
	}

	modifiers := a.calculateInstanceModifiers(affixes)
	return affixes, modifiers, nil
}

// selectRandomAffixes selects random affixes from the active pool
func (a *Applicator) selectRandomAffixes(availableAffixes []*api.Affix, minCount, maxCount int) []*api.Affix {
	if len(availableAffixes) <= maxCount {
		return availableAffixes
	}

	// Shuffle the array
	shuffled := make([]*api.Affix, len(availableAffixes))
	copy(shuffled, availableAffixes)

	rand.Shuffle(len(shuffled), func(i, j int) {
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	})

	// Select random count between min and max
	count := minCount
	if len(shuffled) > maxCount {
		count = minCount + rand.Intn(maxCount-minCount+1)
	}

	return shuffled[:count]
}

// filterCompatibleAffixes ensures selected affixes are compatible
func (a *Applicator) filterCompatibleAffixes(affixes []*api.Affix) []*api.Affix {
	// Define incompatible combinations
	incompatiblePairs := map[string]map[string]bool{
		"Raging":  {"Fortified": true},
		"Volatile": {"Incorporeal": true},
		"Bursting": {"Sanguine": true},
	}

	// Simple filtering - remove incompatible pairs
	var filtered []*api.Affix
	nameMap := make(map[string]*api.Affix)

	for _, affix := range affixes {
		nameMap[affix.Name] = affix
	}

	for _, affix := range affixes {
		compatible := true

		if incompatibles, exists := incompatiblePairs[affix.Name]; exists {
			for _, existing := range filtered {
				if incompatibles[existing.Name] {
					compatible = false
					a.logger.Debug("Filtered incompatible affix",
						zap.String("affix", affix.Name),
						zap.String("incompatible_with", existing.Name))
					break
				}
			}
		}

		if compatible {
			filtered = append(filtered, affix)
		}
	}

	// Ensure we have at least 2 affixes
	if len(filtered) < 2 {
		// Add random affixes to meet minimum
		for _, affix := range affixes {
			found := false
			for _, existing := range filtered {
				if existing.ID == affix.ID {
					found = true
					break
				}
			}
			if !found && len(filtered) < 2 {
				filtered = append(filtered, affix)
			}
		}
	}

	return filtered
}

// applyAffixesToDatabase saves affixes to the database for an instance
func (a *Applicator) applyAffixesToDatabase(ctx context.Context, instanceID uuid.UUID, affixes []*api.Affix) error {
	// PERFORMANCE: Add timeout for DB operations to prevent hanging
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Insert instance affixes
	for _, affix := range affixes {
		affixID, err := uuid.Parse(affix.ID)
		if err != nil {
			return errors.Wrap(err, "invalid affix ID")
		}

		_, err = a.db.Exec(ctx,
			"INSERT INTO gameplay.instance_affixes (instance_id, affix_id) VALUES ($1, $2)",
			instanceID, affixID)
		if err != nil {
			return errors.Wrap(err, "failed to insert instance affix")
		}
	}

	return nil
}

// calculateInstanceModifiers calculates combined modifiers for affixes
func (a *Applicator) calculateInstanceModifiers(affixes []*api.Affix) *InstanceModifiers {
	if len(affixes) == 0 {
		return &InstanceModifiers{
			RewardModifier:    1.0,
			DifficultyModifier: 1.0,
		}
	}

	rewardMod := 1.0
	difficultyMod := 1.0

	for _, affix := range affixes {
		rewardMod *= affix.RewardModifier
		difficultyMod *= affix.DifficultyModifier
	}

	return &InstanceModifiers{
		RewardModifier:    rewardMod,
		DifficultyModifier: difficultyMod,
	}
}

// RemoveInstanceAffixes removes affixes from an instance (for cleanup)
func (a *Applicator) RemoveInstanceAffixes(ctx context.Context, instanceID uuid.UUID) error {
	ctx, span := a.tracer.Start(ctx, "applicator.remove_instance_affixes")
	defer span.End()

	// PERFORMANCE: Add timeout for DB operations to prevent hanging
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	_, err := a.db.Exec(ctx, "DELETE FROM gameplay.instance_affixes WHERE instance_id = $1", instanceID)
	if err != nil {
		return errors.Wrap(err, "failed to remove instance affixes")
	}

	a.logger.Info("Removed affixes from instance", zap.String("instance_id", instanceID.String()))
	return nil
}
