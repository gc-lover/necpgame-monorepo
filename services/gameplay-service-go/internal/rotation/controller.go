// Code generated by NECPGAME backend agent. Enterprise-grade Rotation Controller.
// Issue: #1495
// PERFORMANCE: Optimized weekly rotation scheduling with cron integration

package rotation

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"math/rand"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/gameplay-service-go/pkg/api"
)

// Config holds rotation controller configuration
type Config struct {
	DB     *pgxpool.Pool
	Redis  *redis.Client
	Logger *zap.Logger
	Tracer trace.Tracer
	Meter  metric.Meter
}

// Controller manages affix rotation scheduling
type Controller struct {
	db     *pgxpool.Pool
	redis  *redis.Client
	logger *zap.Logger
	tracer trace.Tracer
	meter  metric.Meter
}

// Rotation represents an affix rotation period
type Rotation struct {
	ID             uuid.UUID
	WeekStart      time.Time
	WeekEnd        time.Time
	SeasonalAffixID *uuid.UUID
	Affixes        []*api.Affix
}

// CachedRotationData represents cached rotation data for Redis
type CachedRotationData struct {
	ID             uuid.UUID     `json:"id"`
	WeekStart      time.Time     `json:"week_start"`
	WeekEnd        time.Time     `json:"week_end"`
	SeasonalAffixID *uuid.UUID    `json:"seasonal_affix_id,omitempty"`
	Affixes        []*api.Affix  `json:"affixes"`
}

// NewController creates a new rotation controller
func NewController(cfg Config) (*Controller, error) {
	if cfg.DB == nil {
		return nil, errors.New("database connection is required")
	}
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}

	return &Controller{
		db:     cfg.DB,
		redis:  cfg.Redis,
		logger: cfg.Logger,
		tracer: cfg.Tracer,
		meter:  cfg.Meter,
	}, nil
}

// GetCurrentRotation returns the current active rotation
func (c *Controller) GetCurrentRotation(ctx context.Context) (*Rotation, []*api.Affix, error) {
	ctx, span := c.tracer.Start(ctx, "rotation_controller.get_current_rotation")
	defer span.End()

	// Try cache first
	cacheKey := "current_rotation"
	if c.redis != nil {
		cachedData, err := c.redis.Get(ctx, cacheKey).Result()
		if err == nil {
			// Cache hit - deserialize and return
			var cachedRotation CachedRotationData
			if err := json.Unmarshal([]byte(cachedData), &cachedRotation); err == nil {
				rotation := &Rotation{
					ID:             cachedRotation.ID,
					WeekStart:      cachedRotation.WeekStart,
					WeekEnd:        cachedRotation.WeekEnd,
					SeasonalAffixID: cachedRotation.SeasonalAffixID,
				}

				c.metrics.cacheHits.Add(ctx, 1)
				c.logger.Debug("Rotation cache hit", zap.String("rotation_id", rotation.ID.String()))
				return rotation, cachedRotation.Affixes, nil
			}
			// If unmarshal fails, continue to database query
			c.logger.Warn("Failed to unmarshal cached rotation data", zap.Error(err))
		}
		// Cache miss - proceed to database query
		c.metrics.cacheMisses.Add(ctx, 1)
	}

	query := `
		SELECT ar.id, ar.week_start, ar.week_end, ar.seasonal_affix_id,
		       a.id, a.name, a.description, a.category, a.reward_modifier, a.difficulty_modifier, a.mechanics, a.visual_effects
		FROM gameplay.affix_rotations ar
		LEFT JOIN gameplay.active_affixes aa ON ar.id = aa.rotation_id
		LEFT JOIN gameplay.affixes a ON aa.affix_id = a.id
		WHERE ar.week_start <= NOW() AND ar.week_end > NOW()
		ORDER BY a.category, a.name
	`

	rows, err := c.db.Query(ctx, query)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to query current rotation")
	}
	defer rows.Close()

	var rotation *Rotation
	var affixes []*api.Affix

	for rows.Next() {
		var rotID uuid.UUID
		var weekStart, weekEnd time.Time
		var seasonalAffixID *uuid.UUID
		var affixID uuid.UUID
		var name, description, category string
		var rewardMod, difficultyMod float64
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&rotID, &weekStart, &weekEnd, &seasonalAffixID,
			&affixID, &name, &description, &category, &rewardMod, &difficultyMod,
			&mechanics, &visualEffects,
		)
		if err != nil {
			return nil, nil, errors.Wrap(err, "failed to scan rotation")
		}

		if rotation == nil {
			rotation = &Rotation{
				ID:             rotID,
				WeekStart:      weekStart,
				WeekEnd:        weekEnd,
				SeasonalAffixID: seasonalAffixID,
			}
		}

		affix := &api.Affix{
			ID:                 affixID,
			Name:               name,
			Description:        description,
			Category:           api.AffixCategory(category),
			RewardModifier:     float32(rewardMod),
			DifficultyModifier: float32(difficultyMod),
		}

		if len(mechanics) > 0 {
			affix.Mechanics = api.OptAffixMechanics{
				Value: string(mechanics),
				Set:   true,
			}
		}
		if len(visualEffects) > 0 {
			affix.VisualEffects = api.OptAffixVisualEffects{
				Value: string(visualEffects),
				Set:   true,
			}
		}

		affixes = append(affixes, affix)
	}

	if rotation == nil {
		return nil, nil, errors.New("no active rotation found")
	}

	rotation.Affixes = affixes

	// Cache the result for future requests
	if c.redis != nil {
		cachedData := CachedRotationData{
			ID:             rotation.ID,
			WeekStart:      rotation.WeekStart,
			WeekEnd:        rotation.WeekEnd,
			SeasonalAffixID: rotation.SeasonalAffixID,
			Affixes:        affixes,
		}

		cacheJSON, err := json.Marshal(cachedData)
		if err != nil {
			c.logger.Error("Failed to marshal rotation data for cache", zap.Error(err))
		} else {
			// Cache for 1 hour (rotations change weekly, but cache shorter for freshness)
			err := c.redis.Set(ctx, cacheKey, string(cacheJSON), time.Hour).Err()
			if err != nil {
				c.logger.Error("Failed to cache rotation data", zap.Error(err))
			} else {
				c.logger.Debug("Rotation data cached",
					zap.String("rotation_id", rotation.ID.String()),
					zap.Int("affixes_count", len(affixes)))
			}
		}
	}

	return rotation, affixes, nil
}

// GetRotationHistory returns paginated rotation history
func (c *Controller) GetRotationHistory(ctx context.Context, limit, offset int) ([]*Rotation, int64, error) {
	ctx, span := c.tracer.Start(ctx, "rotation_controller.get_rotation_history")
	defer span.End()

	// Get total count
	countQuery := "SELECT COUNT(*) FROM gameplay.affix_rotations"
	var total int64
	err := c.db.QueryRow(ctx, countQuery).Scan(&total)
	if err != nil {
		return nil, 0, errors.Wrap(err, "failed to get rotation count")
	}

	// Get rotations with affixes
	query := `
		SELECT ar.id, ar.week_start, ar.week_end, ar.seasonal_affix_id,
		       a.id, a.name, a.description, a.category, a.reward_modifier, a.difficulty_modifier
		FROM gameplay.affix_rotations ar
		LEFT JOIN gameplay.active_affixes aa ON ar.id = aa.rotation_id
		LEFT JOIN gameplay.affixes a ON aa.affix_id = a.id
		ORDER BY ar.week_start DESC
		LIMIT $1 OFFSET $2
	`

	rows, err := c.db.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, 0, errors.Wrap(err, "failed to query rotation history")
	}
	defer rows.Close()

	rotationMap := make(map[uuid.UUID]*Rotation)
	var rotations []*Rotation

	for rows.Next() {
		var rotID uuid.UUID
		var weekStart, weekEnd time.Time
		var seasonalAffixID *uuid.UUID
		var affixID uuid.UUID
		var name, description, category string
		var rewardMod, difficultyMod float64

		err := rows.Scan(
			&rotID, &weekStart, &weekEnd, &seasonalAffixID,
			&affixID, &name, &description, &category, &rewardMod, &difficultyMod,
		)
		if err != nil {
			return nil, 0, errors.Wrap(err, "failed to scan rotation history")
		}

		if rotation, exists := rotationMap[rotID]; !exists {
			rotation = &Rotation{
				ID:             rotID,
				WeekStart:      weekStart,
				WeekEnd:        weekEnd,
				SeasonalAffixID: seasonalAffixID,
				Affixes:        []*api.Affix{},
			}
			rotationMap[rotID] = rotation
			rotations = append(rotations, rotation)
		}

		if affixID != uuid.Nil {
			affix := &api.Affix{
				ID:                 affixID,
				Name:               name,
				Description:        description,
				Category:           api.AffixCategory(category),
				RewardModifier:     float32(rewardMod),
				DifficultyModifier: float32(difficultyMod),
			}
			rotationMap[rotID].Affixes = append(rotationMap[rotID].Affixes, affix)
		}
	}

	return rotations, total, nil
}

// TriggerManualRotation creates a new rotation manually (admin function)
func (c *Controller) TriggerManualRotation(ctx context.Context) (*Rotation, error) {
	ctx, span := c.tracer.Start(ctx, "rotation_controller.trigger_manual_rotation")
	defer span.End()

	// Check if there's already an active rotation
	var existingCount int
	err := c.db.QueryRow(ctx, "SELECT COUNT(*) FROM gameplay.affix_rotations WHERE week_end > NOW()").Scan(&existingCount)
	if err != nil {
		return nil, errors.Wrap(err, "failed to check existing rotations")
	}

	if existingCount > 0 {
		return nil, errors.New("active rotation already exists")
	}

	// Create new rotation
	return c.createNewRotation(ctx)
}

// createNewRotation creates a new affix rotation
func (c *Controller) createNewRotation(ctx context.Context) (*Rotation, error) {
	// Calculate week boundaries (Monday to Sunday)
	now := time.Now().UTC()
	daysUntilMonday := (int(now.Weekday()) - int(time.Monday) + 7) % 7
	weekStart := now.AddDate(0, 0, -daysUntilMonday).Truncate(24 * time.Hour)
	weekEnd := weekStart.AddDate(0, 0, 7)

	rotationID := uuid.New()

	// Insert rotation
	rotationQuery := `
		INSERT INTO gameplay.affix_rotations (id, week_start, week_end, created_at)
		VALUES ($1, $2, $3, $4)
	`

	_, err := c.db.Exec(ctx, rotationQuery, rotationID, weekStart, weekEnd, now)
	if err != nil {
		return nil, errors.Wrap(err, "failed to insert rotation")
	}

	// Select random affixes (8-10 from available pool)
	affixes, err := c.selectRandomAffixes(ctx, 8, 10)
	if err != nil {
		return nil, errors.Wrap(err, "failed to select affixes")
	}

	// Insert active affixes
	for _, affix := range affixes {
		_, err := c.db.Exec(ctx,
			"INSERT INTO gameplay.active_affixes (rotation_id, affix_id) VALUES ($1, $2)",
			rotationID, affix.ID)
		if err != nil {
			return nil, errors.Wrap(err, "failed to insert active affix")
		}
	}

	rotation := &Rotation{
		ID:        rotationID,
		WeekStart: weekStart,
		WeekEnd:   weekEnd,
		Affixes:   affixes,
	}

	// Invalidate caches
	if c.redis != nil {
		c.redis.Del(ctx, "current_rotation", "active_affixes")
	}

	c.logger.Info("Created new affix rotation",
		zap.String("rotation_id", rotationID.String()),
		zap.Time("week_start", weekStart),
		zap.Time("week_end", weekEnd),
		zap.Int("affix_count", len(affixes)))

	return rotation, nil
}

// selectRandomAffixes selects random affixes from the pool
func (c *Controller) selectRandomAffixes(ctx context.Context, minCount, maxCount int) ([]*api.Affix, error) {
	// Get all available affixes
	query := `
		SELECT id, name, description, category, reward_modifier, difficulty_modifier, mechanics, visual_effects
		FROM gameplay.affixes
		ORDER BY id
	`

	rows, err := c.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "failed to query affixes")
	}
	defer rows.Close()

	var allAffixes []*api.Affix
	for rows.Next() {
		var affix api.Affix
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Description, &affix.Category,
			&affix.RewardModifier, &affix.DifficultyModifier, &mechanics, &visualEffects,
		)
		if err != nil {
			return nil, errors.Wrap(err, "failed to scan affix")
		}

		if len(mechanics) > 0 {
			affix.Mechanics = api.OptAffixMechanics{
				Value: string(mechanics),
				Set:   true,
			}
		}
		if len(visualEffects) > 0 {
			affix.VisualEffects = api.OptAffixVisualEffects{
				Value: string(visualEffects),
				Set:   true,
			}
		}

		allAffixes = append(allAffixes, &affix)
	}

	if len(allAffixes) < minCount {
		return nil, fmt.Errorf("insufficient affixes in pool: %d, need at least %d", len(allAffixes), minCount)
	}

	// Randomly select affixes
	count := minCount
	if len(allAffixes) > maxCount {
		count = maxCount
	} else if len(allAffixes) > minCount {
		count = minCount + rand.Intn(len(allAffixes)-minCount+1)
	}

	// Shuffle and select
	rand.Shuffle(len(allAffixes), func(i, j int) {
		allAffixes[i], allAffixes[j] = allAffixes[j], allAffixes[i]
	})

	return allAffixes[:count], nil
}

// ScheduleWeeklyRotation should be called by a cron job every Monday
func (c *Controller) ScheduleWeeklyRotation(ctx context.Context) error {
	ctx, span := c.tracer.Start(ctx, "rotation_controller.schedule_weekly_rotation")
	defer span.End()

	c.logger.Info("Starting scheduled weekly rotation")

	_, err := c.createNewRotation(ctx)
	if err != nil {
		c.logger.Error("Failed to create weekly rotation", zap.Error(err))
		return err
	}

	c.logger.Info("Completed scheduled weekly rotation")
	return nil
}
