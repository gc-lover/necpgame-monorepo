// Code generated by NECPGAME backend agent. Component implementations for Gameplay Affixes Service.
// Issue: #1495
// Implements core business logic with performance optimizations

package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/trace"

	"necpgame/services/gameplay-service-go/pkg/api"
)

// GetActiveAffixes returns currently active affixes for the weekly rotation
func (am *AffixManager) GetActiveAffixes(ctx context.Context) ([]api.Affix, *api.AffixRotation, error) {
	_, span := am.tracer.Start(ctx, "AffixManager.GetActiveAffixes")
	defer span.End()

	// Try cache first
	cacheKey := "gameplay:affixes:active"
	cached, err := am.redis.Get(ctx, cacheKey).Result()
	if err == nil {
		var result struct {
			Affixes  []api.Affix        `json:"affixes"`
			Rotation *api.AffixRotation `json:"rotation"`
		}
		if err := json.Unmarshal([]byte(cached), &result); err == nil {
			return result.Affixes, result.Rotation, nil
		}
	}

	// Get current rotation
	rotation, err := am.getCurrentRotation(ctx)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to get current rotation")
	}

	// Get affixes for current rotation
	affixes, err := am.getAffixesByIDs(ctx, rotation.ActiveAffixes)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to get affixes")
	}

	// Cache result for 1 hour
	result := struct {
		Affixes  []api.Affix        `json:"affixes"`
		Rotation *api.AffixRotation `json:"rotation"`
	}{
		Affixes:  affixes,
		Rotation: rotation,
	}

	data, _ := json.Marshal(result)
	am.redis.Set(ctx, cacheKey, data, time.Hour)

	return affixes, rotation, nil
}

// GetAffixByID returns detailed information about a specific affix
func (am *AffixManager) GetAffixByID(ctx context.Context, id uuid.UUID) (*api.Affix, error) {
	_, span := am.tracer.Start(ctx, "AffixManager.GetAffixByID",
		trace.WithAttributes(trace.StringAttribute("affix_id", id.String())))
	defer span.End()

	// Try cache first
	cacheKey := fmt.Sprintf("gameplay:affix:%s", id.String())
	cached, err := am.redis.Get(ctx, cacheKey).Result()
	if err == nil {
		var affix api.Affix
		if err := json.Unmarshal([]byte(cached), &affix); err == nil {
			return &affix, nil
		}
	}

	// Query database
	query := `
		SELECT id, name, category, description, mechanics, visual_effects,
		       reward_modifier, difficulty_modifier, created_at, updated_at
		FROM affixes WHERE id = $1
	`

	var affix api.Affix
	var mechanics, visualEffects []byte
	err = am.db.QueryRowContext(ctx, query, id).Scan(
		&affix.ID, &affix.Name, &affix.Category, &affix.Description,
		&mechanics, &visualEffects, &affix.RewardModifier,
		&affix.DifficultyModifier, &affix.CreatedAt, &affix.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Parse JSON fields
	json.Unmarshal(mechanics, &affix.Mechanics)
	json.Unmarshal(visualEffects, &affix.VisualEffects)

	// Cache result
	data, _ := json.Marshal(affix)
	am.redis.Set(ctx, cacheKey, data, time.Hour)

	return &affix, nil
}

// getCurrentRotation retrieves the current affix rotation
func (am *AffixManager) getCurrentRotation(ctx context.Context) (*api.AffixRotation, error) {
	query := `
		SELECT id, week_start, week_end, active_affixes, seasonal_affix_id, created_at
		FROM affix_rotations
		WHERE week_start <= NOW() AND week_end > NOW()
		ORDER BY week_start DESC
		LIMIT 1
	`

	var rotation api.AffixRotation
	var activeAffixes []byte
	var seasonalAffixID sql.NullString

	err := am.db.QueryRowContext(ctx, query).Scan(
		&rotation.ID, &rotation.WeekStart, &rotation.WeekEnd,
		&activeAffixes, &seasonalAffixID, &rotation.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Parse active affixes array
	json.Unmarshal(activeAffixes, &rotation.ActiveAffixes)

	// Parse seasonal affix if present
	if seasonalAffixID.Valid {
		if id, err := uuid.Parse(seasonalAffixID.String); err == nil {
			rotation.SeasonalAffixID = &id
		}
	}

	return &rotation, nil
}

// getAffixesByIDs retrieves multiple affixes by their IDs
func (am *AffixManager) getAffixesByIDs(ctx context.Context, ids []uuid.UUID) ([]api.Affix, error) {
	if len(ids) == 0 {
		return []api.Affix{}, nil
	}

	// Build query with IN clause
	query := `
		SELECT id, name, category, description, mechanics, visual_effects,
		       reward_modifier, difficulty_modifier, created_at, updated_at
		FROM affixes WHERE id = ANY($1)
	`

	// Convert UUIDs to strings for PostgreSQL
	uuidStrings := make([]string, len(ids))
	for i, id := range ids {
		uuidStrings[i] = id.String()
	}

	rows, err := am.db.QueryContext(ctx, query, uuidStrings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var affixes []api.Affix
	for rows.Next() {
		var affix api.Affix
		var mechanics, visualEffects []byte

		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Category, &affix.Description,
			&mechanics, &visualEffects, &affix.RewardModifier,
			&affix.DifficultyModifier, &affix.CreatedAt, &affix.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		// Parse JSON fields
		json.Unmarshal(mechanics, &affix.Mechanics)
		json.Unmarshal(visualEffects, &affix.VisualEffects)

		affixes = append(affixes, affix)
	}

	return affixes, rows.Err()
}

// GetInstanceAffixes returns affixes applied to a specific instance
func (aa *AffixApplicator) GetInstanceAffixes(ctx context.Context, instanceID uuid.UUID) ([]api.AppliedAffix, time.Time, error) {
	_, span := aa.tracer.Start(ctx, "AffixApplicator.GetInstanceAffixes",
		trace.WithAttributes(trace.StringAttribute("instance_id", instanceID.String())))
	defer span.End()

	query := `
		SELECT ia.affix_id, ia.applied_at, a.name, a.mechanics
		FROM instance_affixes ia
		JOIN affixes a ON ia.affix_id = a.id
		WHERE ia.instance_id = $1
		ORDER BY ia.applied_at
	`

	rows, err := aa.db.QueryContext(ctx, query, instanceID)
	if err != nil {
		return nil, time.Time{}, err
	}
	defer rows.Close()

	var affixes []api.AppliedAffix
	var appliedAt time.Time

	for rows.Next() {
		var affix api.AppliedAffix
		var mechanics []byte
		var affixName string

		err := rows.Scan(&affix.AffixID, &appliedAt, &affixName, &mechanics)
		if err != nil {
			return nil, time.Time{}, err
		}

		// Parse mechanics and create scaled version
		var baseMechanics map[string]interface{}
		json.Unmarshal(mechanics, &baseMechanics)
		affix.ScaledMechanics = baseMechanics

		affixes = append(affixes, affix)
	}

	if len(affixes) == 0 {
		appliedAt = time.Now() // fallback
	}

	return affixes, appliedAt, rows.Err()
}

// GetCurrentRotation returns the current affix rotation
func (rc *RotationController) GetCurrentRotation(ctx context.Context) (*api.AffixRotation, error) {
	_, span := rc.tracer.Start(ctx, "RotationController.GetCurrentRotation")
	defer span.End()

	return rc.getCurrentRotation(ctx)
}

// getCurrentRotation is shared with AffixManager
func (rc *RotationController) getCurrentRotation(ctx context.Context) (*api.AffixRotation, error) {
	query := `
		SELECT id, week_start, week_end, active_affixes, seasonal_affix_id, created_at
		FROM affix_rotations
		WHERE week_start <= NOW() AND week_end > NOW()
		ORDER BY week_start DESC
		LIMIT 1
	`

	var rotation api.AffixRotation
	var activeAffixes []byte
	var seasonalAffixID sql.NullString

	err := rc.db.QueryRowContext(ctx, query).Scan(
		&rotation.ID, &rotation.WeekStart, &rotation.WeekEnd,
		&activeAffixes, &seasonalAffixID, &rotation.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Parse active affixes array
	json.Unmarshal(activeAffixes, &rotation.ActiveAffixes)

	// Parse seasonal affix if present
	if seasonalAffixID.Valid {
		if id, err := uuid.Parse(seasonalAffixID.String); err == nil {
			rotation.SeasonalAffixID = &id
		}
	}

	return &rotation, nil
}

// GetRotationHistory returns paginated rotation history
func (rc *RotationController) GetRotationHistory(ctx context.Context, limit, offset int) ([]api.AffixRotation, int, error) {
	_, span := rc.tracer.Start(ctx, "RotationController.GetRotationHistory")
	defer span.End()

	// Get total count
	var total int
	countQuery := `SELECT COUNT(*) FROM affix_rotations`
	if err := rc.db.QueryRowContext(ctx, countQuery).Scan(&total); err != nil {
		return nil, 0, err
	}

	// Get paginated results
	query := `
		SELECT id, week_start, week_end, active_affixes, seasonal_affix_id, created_at
		FROM affix_rotations
		ORDER BY week_start DESC
		LIMIT $1 OFFSET $2
	`

	rows, err := rc.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var rotations []api.AffixRotation
	for rows.Next() {
		var rotation api.AffixRotation
		var activeAffixes []byte
		var seasonalAffixID sql.NullString

		err := rows.Scan(
			&rotation.ID, &rotation.WeekStart, &rotation.WeekEnd,
			&activeAffixes, &seasonalAffixID, &rotation.CreatedAt,
		)
		if err != nil {
			return nil, 0, err
		}

		// Parse active affixes array
		json.Unmarshal(activeAffixes, &rotation.ActiveAffixes)

		// Parse seasonal affix if present
		if seasonalAffixID.Valid {
			if id, err := uuid.Parse(seasonalAffixID.String); err == nil {
				rotation.SeasonalAffixID = &id
			}
		}

		rotations = append(rotations, rotation)
	}

	return rotations, total, rows.Err()
}
