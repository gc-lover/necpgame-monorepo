// Code generated by NECPGAME backend agent. Enterprise-grade Gameplay Affixes Service.
// Issue: #1495
// PERFORMANCE: Optimized handler implementation with memory pooling

package service

import (
	"context"
	"net/http"
	"strconv"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/gameplay-service-go/pkg/api"
)

// Handler implements the API handler interface
type Handler struct {
	service *Service
}

// NewHandler creates a new API handler
func NewHandler(svc *Service) *Handler {
	return &Handler{
		service: svc,
	}
}

// HealthGet implements health check endpoint
func (h *Handler) HealthGet(ctx context.Context) (api.HealthGetRes, error) {
	// Calculate actual uptime since service start
	uptimeSeconds := int(time.Since(h.service.startTime).Seconds())

	return &api.HealthResponse{
		Status:   "healthy",
		Version:  "1.0.0",
		Uptime:   uptimeSeconds,
	}, nil
}

// APIV1GameplayAffixesActiveGet implements GET /api/v1/gameplay/affixes/active
func (h *Handler) APIV1GameplayAffixesActiveGet(ctx context.Context) (api.APIV1GameplayAffixesActiveGetRes, error) {
	affixes, err := h.service.affixManager.GetActiveAffixes(ctx)
	if err != nil {
		h.service.logger.Error("Failed to get active affixes", zap.Error(err))
		return &api.APIV1GameplayAffixesActiveGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to retrieve active affixes",
				},
			},
		}, nil
	}

	// Record successful operation
	h.service.gameplayOperations.WithLabelValues("get_active_affixes", "success").Inc()

	return &api.ActiveAffixesResponse{
		Affixes: affixes,
		Rotation: &api.ActiveAffixesResponseRotation{
			WeekStart: h.getCurrentWeekStart(),
			WeekEnd:   h.getCurrentWeekEnd(),
		},
	}, nil
}

// APIV1GameplayAffixesIDGet implements GET /api/v1/gameplay/affixes/{id}
func (h *Handler) APIV1GameplayAffixesIDGet(ctx context.Context, params api.APIV1GameplayAffixesIDGetParams) (api.APIV1GameplayAffixesIDGetRes, error) {
	affixID, err := uuid.Parse(params.ID)
	if err != nil {
		return &api.APIV1GameplayAffixesIDGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INVALID_ID",
					Message: "Invalid affix ID format",
				},
			},
		}, nil
	}

	affix, err := h.service.affixManager.GetAffix(ctx, affixID)
	if err != nil {
		h.service.logger.Error("Failed to get affix", zap.Error(err), zap.String("affix_id", params.ID))
		return &api.APIV1GameplayAffixesIDGetResDefault{
			StatusCode: http.StatusNotFound,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "AFFIX_NOT_FOUND",
					Message: "Affix not found",
				},
			},
		}, nil
	}

	return &api.AffixDetailsResponse{
		Affix: affix,
	}, nil
}

// APIV1GameplayInstancesInstanceIdAffixesGet implements GET /api/v1/gameplay/instances/{instanceId}/affixes
func (h *Handler) APIV1GameplayInstancesInstanceIdAffixesGet(ctx context.Context, params api.APIV1GameplayInstancesInstanceIdAffixesGetParams) (api.APIV1GameplayInstancesInstanceIdAffixesGetRes, error) {
	instanceID, err := uuid.Parse(params.InstanceID)
	if err != nil {
		return &api.APIV1GameplayInstancesInstanceIdAffixesGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INVALID_INSTANCE_ID",
					Message: "Invalid instance ID format",
				},
			},
		}, nil
	}

	affixes, modifiers, err := h.service.applicator.GetInstanceAffixes(ctx, instanceID)
	if err != nil {
		h.service.logger.Error("Failed to get instance affixes", zap.Error(err), zap.String("instance_id", params.InstanceID))
		return &api.APIV1GameplayInstancesInstanceIdAffixesGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to retrieve instance affixes",
				},
			},
		}, nil
	}

	// Record successful operation
	h.service.gameplayOperations.WithLabelValues("get_instance_affixes", "success").Inc()

	return &api.InstanceAffixesResponse{
		InstanceID: params.InstanceID,
		Affixes:    affixes,
		Modifiers: &api.InstanceAffixesResponseModifiers{
			RewardModifier:    modifiers.RewardModifier,
			DifficultyModifier: modifiers.DifficultyModifier,
		},
	}, nil
}

// APIV1GameplayAffixesRotationCurrentGet implements GET /api/v1/gameplay/affixes/rotation/current
func (h *Handler) APIV1GameplayAffixesRotationCurrentGet(ctx context.Context) (api.APIV1GameplayAffixesRotationCurrentGetRes, error) {
	rotation, affixes, err := h.service.rotationController.GetCurrentRotation(ctx)
	if err != nil {
		h.service.logger.Error("Failed to get current rotation", zap.Error(err))
		return &api.APIV1GameplayAffixesRotationCurrentGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to retrieve current rotation",
				},
			},
		}, nil
	}

	return &api.CurrentRotationResponse{
		Rotation: &api.CurrentRotationResponseRotation{
			ID:        rotation.ID.String(),
			WeekStart: &rotation.WeekStart,
			WeekEnd:   &rotation.WeekEnd,
		},
		Affixes: affixes,
	}, nil
}

// APIV1GameplayAffixesRotationHistoryGet implements GET /api/v1/gameplay/affixes/rotation/history
func (h *Handler) APIV1GameplayAffixesRotationHistoryGet(ctx context.Context, params api.APIV1GameplayAffixesRotationHistoryGetParams) (api.APIV1GameplayAffixesRotationHistoryGetRes, error) {
	limit := 10  // default
	offset := 0  // default

	if params.Limit != nil && *params.Limit > 0 && *params.Limit <= 50 {
		limit = int(*params.Limit)
	}
	if params.Offset != nil && *params.Offset >= 0 {
		offset = int(*params.Offset)
	}

	history, total, err := h.service.rotationController.GetRotationHistory(ctx, limit, offset)
	if err != nil {
		h.service.logger.Error("Failed to get rotation history", zap.Error(err))
		return &api.APIV1GameplayAffixesRotationHistoryGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to retrieve rotation history",
				},
			},
		}, nil
	}

	// Convert to API format
	rotations := make([]*api.RotationHistoryResponseRotationsItem, len(history))
	for i, rot := range history {
		affixes := make([]*api.Affix, len(rot.Affixes))
		for j, affix := range rot.Affixes {
			affixes[j] = &affix // Assuming Affix type compatibility
		}

		rotations[i] = &api.RotationHistoryResponseRotationsItem{
			ID:         rot.ID.String(),
			WeekStart:  &rot.WeekStart,
			WeekEnd:    &rot.WeekEnd,
			SeasonalAffix: h.getSeasonalAffixForWeek(rot.WeekStart),
			Affixes:    affixes,
		}
	}

	return &api.RotationHistoryResponse{
		Rotations: rotations,
		Pagination: &api.RotationHistoryResponsePagination{
			Total:  int(total),
			Limit:  limit,
			Offset: offset,
		},
	}, nil
}

// APIV1GameplayAffixesPost implements POST /api/v1/gameplay/affixes (admin)
func (h *Handler) APIV1GameplayAffixesPost(ctx context.Context, req *api.CreateAffixRequest) (api.APIV1GameplayAffixesPostRes, error) {
	// TODO: Implement admin authentication/authorization

	affix, err := h.service.affixManager.CreateAffix(ctx, *req)
	if err != nil {
		h.service.logger.Error("Failed to create affix", zap.Error(err))
		return &api.APIV1GameplayAffixesPostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to create affix",
				},
			},
		}, nil
	}

	// Record successful operation
	h.service.gameplayOperations.WithLabelValues("create_affix", "success").Inc()

	return &api.AffixResponse{
		Affix: affix,
	}, nil
}

// APIV1GameplayAffixesGet implements GET /api/v1/gameplay/affixes (admin)
func (h *Handler) APIV1GameplayAffixesGet(ctx context.Context, params api.APIV1GameplayAffixesGetParams) (api.APIV1GameplayAffixesGetRes, error) {
	// TODO: Implement admin authentication/authorization

	category := ""
	limit := 20  // default
	offset := 0  // default

	if params.Category != nil {
		category = *params.Category
	}
	if params.Limit != nil && *params.Limit > 0 && *params.Limit <= 100 {
		limit = int(*params.Limit)
	}
	if params.Offset != nil && *params.Offset >= 0 {
		offset = int(*params.Offset)
	}

	affixes, total, err := h.service.affixManager.ListAffixes(ctx, category, limit, offset)
	if err != nil {
		h.service.logger.Error("Failed to list affixes", zap.Error(err))
		return &api.APIV1GameplayAffixesGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to retrieve affixes",
				},
			},
		}, nil
	}

	return &api.ListAffixesResponse{
		Affixes: affixes,
		Pagination: &api.ListAffixesResponsePagination{
			Total:  int(total),
			Limit:  limit,
			Offset: offset,
		},
	}, nil
}

// APIV1GameplayAffixesIDPut implements PUT /api/v1/gameplay/affixes/{id} (admin)
func (h *Handler) APIV1GameplayAffixesIDPut(ctx context.Context, req *api.UpdateAffixRequest, params api.APIV1GameplayAffixesIDPutParams) (api.APIV1GameplayAffixesIDPutRes, error) {
	// TODO: Implement admin authentication/authorization

	affixID, err := uuid.Parse(params.ID)
	if err != nil {
		return &api.APIV1GameplayAffixesIDPutResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INVALID_ID",
					Message: "Invalid affix ID format",
				},
			},
		}, nil
	}

	affix, err := h.service.affixManager.UpdateAffix(ctx, affixID, *req)
	if err != nil {
		h.service.logger.Error("Failed to update affix", zap.Error(err), zap.String("affix_id", params.ID))
		return &api.APIV1GameplayAffixesIDPutResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to update affix",
				},
			},
		}, nil
	}

	return &api.AffixResponse{
		Affix: affix,
	}, nil
}

// APIV1AdminGameplayAffixesIDDelete implements DELETE /api/v1/admin/gameplay/affixes/{id} (admin)
func (h *Handler) APIV1AdminGameplayAffixesIDDelete(ctx context.Context, params api.APIV1AdminGameplayAffixesIDDeleteParams) (api.APIV1AdminGameplayAffixesIDDeleteRes, error) {
	// TODO: Implement admin authentication/authorization

	affixID, err := uuid.Parse(params.ID)
	if err != nil {
		return &api.APIV1AdminGameplayAffixesIDDeleteResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INVALID_ID",
					Message: "Invalid affix ID format",
				},
			},
		}, nil
	}

	if err := h.service.affixManager.DeleteAffix(ctx, affixID); err != nil {
		h.service.logger.Error("Failed to delete affix", zap.Error(err), zap.String("affix_id", params.ID))
		return &api.APIV1AdminGameplayAffixesIDDeleteResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to delete affix",
				},
			},
		}, nil
	}

	return &api.APIV1AdminGameplayAffixesIDDeleteResNoContent{}, nil
}

// APIV1GameplayAffixesRotationTriggerPost implements POST /api/v1/gameplay/affixes/rotation/trigger (admin)
func (h *Handler) APIV1GameplayAffixesRotationTriggerPost(ctx context.Context) (api.APIV1GameplayAffixesRotationTriggerPostRes, error) {
	// TODO: Implement admin authentication/authorization

	rotation, err := h.service.rotationController.TriggerManualRotation(ctx)
	if err != nil {
		h.service.logger.Error("Failed to trigger manual rotation", zap.Error(err))
		return &api.APIV1GameplayAffixesRotationTriggerPostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to trigger rotation",
				},
			},
		}, nil
	}

	// Record successful operation
	h.service.gameplayOperations.WithLabelValues("trigger_rotation", "success").Inc()

	return &api.RotationTriggerResponse{
		Success: true,
		NewRotation: &api.RotationTriggerResponseNewRotation{
			ID:        rotation.ID.String(),
			WeekStart: &rotation.WeekStart,
			WeekEnd:   &rotation.WeekEnd,
		},
	}, nil
}

// Analytics endpoints - telemetry integration for gameplay insights
func (h *Handler) APIV1AnalyticsAffixesPopularityGet(ctx context.Context, params api.APIV1AnalyticsAffixesPopularityGetParams) (api.APIV1AnalyticsAffixesPopularityGetRes, error) {
	// Get popularity analytics from telemetry collector
	popularityData, err := h.service.telemetryCollector.GetAffixPopularityForAPI(ctx, params)
	if err != nil {
		h.service.logger.Error("Failed to get affix popularity analytics", zap.Error(err))
		return &api.APIV1AnalyticsAffixesPopularityGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "ANALYTICS_ERROR",
					Message: "Failed to retrieve popularity analytics",
				},
			},
		}, nil
	}

	// Record successful analytics operation
	h.service.gameplayOperations.WithLabelValues("analytics_popularity", "success").Inc()

	return &api.PopularityMetricsResponse{
		Period:  popularityData.Period,
		Metrics: popularityData.Metrics,
	}, nil
}

func (h *Handler) APIV1AnalyticsAffixesDifficultyGet(ctx context.Context, params api.APIV1AnalyticsAffixesDifficultyGetParams) (api.APIV1AnalyticsAffixesDifficultyGetRes, error) {
	// Get difficulty analytics from telemetry collector
	difficultyData, err := h.service.telemetryCollector.GetAffixDifficulty(ctx, params)
	if err != nil {
		h.service.logger.Error("Failed to get affix difficulty analytics", zap.Error(err))
		return &api.APIV1AnalyticsAffixesDifficultyGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "ANALYTICS_ERROR",
					Message: "Failed to retrieve difficulty analytics",
				},
			},
		}, nil
	}

	// Record successful analytics operation
	h.service.gameplayOperations.WithLabelValues("analytics_difficulty", "success").Inc()

	return &api.DifficultyMetricsResponse{
		Period:  difficultyData.Period,
		Metrics: difficultyData.Metrics,
	}, nil
}

func (h *Handler) APIV1AnalyticsAffixesCombinationsGet(ctx context.Context, params api.APIV1AnalyticsAffixesCombinationsGetParams) (api.APIV1AnalyticsAffixesCombinationsGetRes, error) {
	// Get combination analytics from telemetry collector
	combinationData, err := h.service.telemetryCollector.GetAffixCombinations(ctx, params)
	if err != nil {
		h.service.logger.Error("Failed to get affix combination analytics", zap.Error(err))
		return &api.APIV1AnalyticsAffixesCombinationsGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.ErrorResponse{
				Error: api.ErrorResponseError{
					Code:    "ANALYTICS_ERROR",
					Message: "Failed to retrieve combination analytics",
				},
			},
		}, nil
	}

	// Record successful analytics operation
	h.service.gameplayOperations.WithLabelValues("analytics_combinations", "success").Inc()

	return &api.CombinationAnalysisResponse{
		Combinations: combinationData.Combinations,
	}, nil
}

// getCurrentWeekStart returns the start of the current week (Monday)
func (h *Handler) getCurrentWeekStart() *time.Time {
	now := time.Now()
	// Find Monday of current week
	daysSinceMonday := int(now.Weekday() - time.Monday)
	if daysSinceMonday < 0 {
		daysSinceMonday += 7
	}
	weekStart := now.AddDate(0, 0, -daysSinceMonday).Truncate(24 * time.Hour)
	return &weekStart
}

// getCurrentWeekEnd returns the end of the current week (Sunday)
func (h *Handler) getCurrentWeekEnd() *time.Time {
	weekStart := h.getCurrentWeekStart()
	weekEnd := weekStart.AddDate(0, 0, 6).Add(23*time.Hour + 59*time.Minute + 59*time.Second)
	return &weekEnd
}

// getSeasonalAffixForWeek returns the seasonal affix for the given week
func (h *Handler) getSeasonalAffixForWeek(weekStart time.Time) *api.Affix {
	// Define seasonal affixes based on season
	// This is a simplified implementation - in production this would be configurable

	// Calculate season (1-4 quarters per year)
	month := weekStart.Month()
	var seasonAffix *api.Affix

	switch {
	case month >= 12 || month <= 2: // Winter (Dec-Feb)
		seasonAffix = &api.Affix{
			ID:          "winter-frost",
			Name:        "Winter Frost",
			Description: "Enemies take increased damage from ice attacks but reduced damage from fire attacks",
			Type:        "seasonal",
			Tier:        1,
			Effects: []*api.AffixEffect{
				{
					Type:     "damage_modifier",
					Target:   "enemy",
					Element:  "ice",
					Value:    1.25, // 25% bonus
					Duration: -1,   // Permanent for season
				},
				{
					Type:     "damage_modifier",
					Target:   "enemy",
					Element:  "fire",
					Value:    0.75, // 25% penalty
					Duration: -1,
				},
			},
		}
	case month >= 3 && month <= 5: // Spring (Mar-May)
		seasonAffix = &api.Affix{
			ID:          "spring-bloom",
			Name:        "Spring Bloom",
			Description: "Increased healing and regeneration effects, poison damage reduced",
			Type:        "seasonal",
			Tier:        1,
			Effects: []*api.AffixEffect{
				{
					Type:     "healing_modifier",
					Target:   "player",
					Value:    1.3, // 30% bonus healing
					Duration: -1,
				},
				{
					Type:     "damage_modifier",
					Target:   "enemy",
					Element:  "poison",
					Value:    0.8, // 20% reduced poison damage
					Duration: -1,
				},
			},
		}
	case month >= 6 && month <= 8: // Summer (Jun-Aug)
		seasonAffix = &api.Affix{
			ID:          "summer-heat",
			Name:        "Summer Heat",
			Description: "Fire damage increased, ice damage decreased, stamina drain accelerated",
			Type:        "seasonal",
			Tier:        1,
			Effects: []*api.AffixEffect{
				{
					Type:     "damage_modifier",
					Target:   "player",
					Element:  "fire",
					Value:    1.2, // 20% bonus fire damage
					Duration: -1,
				},
				{
					Type:     "damage_modifier",
					Target:   "player",
					Element:  "ice",
					Value:    0.85, // 15% reduced ice damage
					Duration: -1,
				},
			},
		}
	case month >= 9 && month <= 11: // Fall (Sep-Nov)
		seasonAffix = &api.Affix{
			ID:          "fall-harvest",
			Name:        "Fall Harvest",
			Description: "Increased item drops and gold rewards, but reduced experience gains",
			Type:        "seasonal",
			Tier:        1,
			Effects: []*api.AffixEffect{
				{
					Type:   "item_drop_rate",
					Target: "player",
					Value:  1.5, // 50% more item drops
					Duration: -1,
				},
				{
					Type:   "gold_modifier",
					Target: "player",
					Value:  1.25, // 25% more gold
					Duration: -1,
				},
				{
					Type:   "experience_modifier",
					Target: "player",
					Value:  0.9, // 10% less experience
					Duration: -1,
				},
			},
		}
	}

	return seasonAffix
}