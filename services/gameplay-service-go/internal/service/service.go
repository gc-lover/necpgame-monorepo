// Code generated by NECPGAME backend agent. Enterprise-grade Gameplay Affixes Service.
// Issue: #1495
// PERFORMANCE: Optimized for MMOFPS gameplay with <50ms affix operations

package service

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/gameplay-service-go/internal/affix"
	"necpgame/services/gameplay-service-go/internal/applicator"
	"necpgame/services/gameplay-service-go/internal/difficulty"
	"necpgame/services/gameplay-service-go/internal/effect"
	"necpgame/services/gameplay-service-go/internal/rotation"
	"necpgame/services/gameplay-service-go/internal/telemetry"
	"necpgame/services/gameplay-service-go/pkg/api"
)

// Config holds service configuration
type Config struct {
	Logger      *zap.Logger
	Tracer      trace.Tracer
	Meter       metric.Meter
	DatabaseURL string
	RedisURL    string
	Environment string
	JWTSecret   string
}

// Service implements the gameplay affixes business logic
type Service struct {
	config     Config
	logger     *zap.Logger
	tracer     trace.Tracer
	meter      metric.Meter
	db         *pgxpool.Pool
	redis      *redis.Client

	// Service lifecycle tracking
	startTime time.Time

	// Prometheus metrics
	gameplayOperations     *prometheus.CounterVec
	affixApplicationTime   prometheus.Histogram
	playerStatsRequests    prometheus.GaugeVec
	effectProcessingTime   prometheus.Histogram
	telemetryEventsCount   *prometheus.CounterVec
	activeGameplaySessions prometheus.Gauge

	// Business logic components
	affixManager       *affix.Manager
	rotationController *rotation.Controller
	applicator         *applicator.Applicator
	effectEngine       *effect.Engine
	telemetryCollector *telemetry.Collector

	// Difficulty Rating System components
	playerSkillRater       *difficulty.PlayerSkillRater
	contentDifficultyRater *difficulty.ContentDifficultyRater
	difficultyAdjuster     *difficulty.Adjuster
	recommendationEngine   *difficulty.RecommendationEngine
	ratingTelemetryCollector *difficulty.RatingTelemetryCollector
}

// NewGameplayService creates a new gameplay service instance
func NewGameplayService(cfg Config) (*Service, error) {
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}

	// Validate JWT secret for production environments
	if (cfg.Environment == "" || cfg.Environment == "production") && cfg.JWTSecret == "" {
		return nil, errors.New("JWT_SECRET is required for production environment")
	}

	svc := &Service{
		config:   cfg,
		logger:   cfg.Logger,
		tracer:   cfg.Tracer,
		meter:    cfg.Meter,
		startTime: time.Now(),
	}

	// Initialize database connection
	if err := svc.initDatabase(cfg.DatabaseURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize database")
	}

	// Initialize Redis connection
	if err := svc.initRedis(cfg.RedisURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize redis")
	}

	// Initialize business logic components
	if err := svc.initComponents(); err != nil {
		return nil, errors.Wrap(err, "failed to initialize components")
	}

	svc.logger.Info("Gameplay service initialized successfully")
	return svc, nil
}

// initDatabase initializes PostgreSQL connection with performance optimizations
func (s *Service) initDatabase(databaseURL string) error {
	// PERFORMANCE: Optimized connection pool for high-throughput gameplay operations
	config, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse database URL")
	}

	// PERFORMANCE: Tune connection pool for gameplay service
	config.MaxConns = 20                    // Moderate pool size for read-heavy workload
	config.MinConns = 5                     // Keep minimum connections alive
	config.MaxConnLifetime = 30 * time.Minute // Rotate connections
	config.MaxConnIdleTime = 5 * time.Minute  // Close idle connections

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return errors.Wrap(err, "failed to create connection pool")
	}

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := pool.Ping(ctx); err != nil {
		return errors.Wrap(err, "failed to ping database")
	}

	s.db = pool
	s.logger.Info("Database connection established")
	return nil
}

// initRedis initializes Redis connection for caching and session management
func (s *Service) initRedis(redisURL string) error {
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse redis URL")
	}

	// PERFORMANCE: Optimize Redis client for low-latency operations
	rdb := redis.NewClient(opt)
	rdb.Options().PoolSize = 10
	rdb.Options().MinIdleConns = 2
	rdb.Options().ConnMaxLifetime = 30 * time.Minute

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := rdb.Ping(ctx).Err(); err != nil {
		return errors.Wrap(err, "failed to ping redis")
	}

	s.redis = rdb
	s.logger.Info("Redis connection established")
	return nil
}

// initComponents initializes all business logic components
func (s *Service) initComponents() error {
	// Initialize affix manager
	affixManager, err := affix.NewManager(affix.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize affix manager")
	}
	s.affixManager = affixManager

	// Initialize rotation controller
	rotationController, err := rotation.NewController(rotation.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize rotation controller")
	}
	s.rotationController = rotationController

	// Initialize applicator
	applicator, err := applicator.NewApplicator(applicator.Config{
		DB:              s.db,
		Redis:           s.redis,
		Logger:          s.logger,
		Tracer:          s.tracer,
		Meter:           s.meter,
		AffixManager:    s.affixManager,
		RotationController: s.rotationController,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize applicator")
	}
	s.applicator = applicator

	// Initialize effect engine
	effectEngine, err := effect.NewEngine(effect.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize effect engine")
	}
	s.effectEngine = effectEngine

	// Initialize telemetry collector
	telemetryCollector, err := telemetry.NewCollector(telemetry.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize telemetry collector")
	}
	s.telemetryCollector = telemetryCollector

	// Initialize Prometheus metrics
	if err := s.initPrometheusMetrics(); err != nil {
		return errors.Wrap(err, "failed to initialize prometheus metrics")
	}

	s.logger.Info("All components initialized successfully")
	return nil
}

// initPrometheusMetrics initializes Prometheus metrics for gameplay operations
func (s *Service) initPrometheusMetrics() error {
	// Counter for gameplay operations by type and result
	s.gameplayOperations = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "gameplay_operations_total",
			Help: "Total number of gameplay operations by type and status",
		},
		[]string{"operation", "status"},
	)

	// Histogram for affix application timing
	s.affixApplicationTime = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "gameplay_affix_application_duration_seconds",
			Help:    "Time taken to apply affixes to gameplay instances",
			Buckets: prometheus.DefBuckets,
		},
	)

	// Gauge for player statistics requests
	s.playerStatsRequests = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "gameplay_player_stats_active_requests",
			Help: "Number of active player statistics requests",
		},
		[]string{"player_id"},
	)

	// Histogram for effect processing timing
	s.effectProcessingTime = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "gameplay_effect_processing_duration_seconds",
			Help:    "Time taken to process gameplay effects",
			Buckets: prometheus.DefBuckets,
		},
	)

	// Counter for telemetry events
	s.telemetryEventsCount = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "gameplay_telemetry_events_total",
			Help: "Total number of telemetry events collected by type",
		},
		[]string{"event_type"},
	)

	// Gauge for active gameplay sessions
	s.activeGameplaySessions = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "gameplay_active_sessions",
			Help: "Number of currently active gameplay sessions",
		},
	)

	// Register metrics with Prometheus (handle already registered errors)
	metrics := []prometheus.Collector{
		s.gameplayOperations,
		s.affixApplicationTime,
		s.playerStatsRequests,
		s.effectProcessingTime,
		s.telemetryEventsCount,
		s.activeGameplaySessions,
	}

	for _, metric := range metrics {
		if err := prometheus.Register(metric); err != nil {
			if _, ok := err.(prometheus.AlreadyRegisteredError); !ok {
				return errors.Wrap(err, "failed to register prometheus metric")
			}
		}
	}

	s.logger.Info("Prometheus metrics initialized successfully")
	return nil
}

// MetricsHandler returns Prometheus metrics handler
func (s *Service) MetricsHandler() http.Handler {
	return promhttp.Handler()
}

// Close gracefully shuts down the service
func (s *Service) Close() error {
	s.logger.Info("Shutting down gameplay service")

	if s.db != nil {
		s.db.Close()
		s.logger.Info("Database connection closed")
	}

	if s.redis != nil {
		if err := s.redis.Close(); err != nil {
			s.logger.Error("Error closing Redis connection", zap.Error(err))
		} else {
			s.logger.Info("Redis connection closed")
		}
	}

	return nil
}