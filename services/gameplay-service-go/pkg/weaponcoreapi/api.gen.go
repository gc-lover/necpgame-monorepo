// Package weaponcoreapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package weaponcoreapi

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ApplySpecialMechanicsRequestMechanicType.
const (
	ApplySpecialMechanicsRequestMechanicTypeChainDamage            ApplySpecialMechanicsRequestMechanicType = "chain_damage"
	ApplySpecialMechanicsRequestMechanicTypeControl                ApplySpecialMechanicsRequestMechanicType = "control"
	ApplySpecialMechanicsRequestMechanicTypeDeployable             ApplySpecialMechanicsRequestMechanicType = "deployable"
	ApplySpecialMechanicsRequestMechanicTypeElemental              ApplySpecialMechanicsRequestMechanicType = "elemental"
	ApplySpecialMechanicsRequestMechanicTypeEnvironmentDestruction ApplySpecialMechanicsRequestMechanicType = "environment_destruction"
	ApplySpecialMechanicsRequestMechanicTypeLaser                  ApplySpecialMechanicsRequestMechanicType = "laser"
	ApplySpecialMechanicsRequestMechanicTypeMelee                  ApplySpecialMechanicsRequestMechanicType = "melee"
	ApplySpecialMechanicsRequestMechanicTypePersistentEffect       ApplySpecialMechanicsRequestMechanicType = "persistent_effect"
	ApplySpecialMechanicsRequestMechanicTypeProjectileForm         ApplySpecialMechanicsRequestMechanicType = "projectile_form"
	ApplySpecialMechanicsRequestMechanicTypeSummon                 ApplySpecialMechanicsRequestMechanicType = "summon"
	ApplySpecialMechanicsRequestMechanicTypeTemporal               ApplySpecialMechanicsRequestMechanicType = "temporal"
)

// Defines values for CalculateChainDamageRequestDamageType.
const (
	Emp       CalculateChainDamageRequestDamageType = "emp"
	Lightning CalculateChainDamageRequestDamageType = "lightning"
)

// Defines values for CreatePersistentEffectRequestProjectileType.
const (
	Arrow    CreatePersistentEffectRequestProjectileType = "arrow"
	Bolt     CreatePersistentEffectRequestProjectileType = "bolt"
	Shuriken CreatePersistentEffectRequestProjectileType = "shuriken"
)

// Defines values for DestroyedObjectDestructionType.
const (
	Barrier  DestroyedObjectDestructionType = "barrier"
	BodyPart DestroyedObjectDestructionType = "body_part"
	Debris   DestroyedObjectDestructionType = "debris"
	Wall     DestroyedObjectDestructionType = "wall"
)

// AffectedTarget defines model for AffectedTarget.
type AffectedTarget struct {
	BodyPartsDestroyed *[]string           `json:"body_parts_destroyed,omitempty"`
	Damage             *float32            `json:"damage,omitempty"`
	TargetId           *openapi_types.UUID `json:"target_id,omitempty"`
}

// ApplySpecialMechanicsRequest defines model for ApplySpecialMechanicsRequest.
type ApplySpecialMechanicsRequest struct {
	CharacterId openapi_types.UUID `json:"character_id"`

	// MechanicData Данные механики (зависит от типа)
	MechanicData *map[string]interface{} `json:"mechanic_data,omitempty"`

	// MechanicType Тип специальной механики
	MechanicType ApplySpecialMechanicsRequestMechanicType `json:"mechanic_type"`
	TargetId     openapi_types.UUID                       `json:"target_id"`
	WeaponId     openapi_types.UUID                       `json:"weapon_id"`
}

// ApplySpecialMechanicsRequestMechanicType Тип специальной механики
type ApplySpecialMechanicsRequestMechanicType string

// ApplySpecialMechanicsResponse defines model for ApplySpecialMechanicsResponse.
type ApplySpecialMechanicsResponse struct {
	// AppliedAt Время применения
	AppliedAt *time.Time `json:"applied_at,omitempty"`

	// EffectId ID созданного эффекта
	EffectId *openapi_types.UUID `json:"effect_id,omitempty"`

	// MechanicType Тип примененной механики
	MechanicType *string `json:"mechanic_type,omitempty"`
}

// CalculateChainDamageRequest defines model for CalculateChainDamageRequest.
type CalculateChainDamageRequest struct {
	// BaseDamage Базовый урон
	BaseDamage float32 `json:"base_damage"`

	// DamageType Тип цепного урона
	DamageType CalculateChainDamageRequestDamageType `json:"damage_type"`

	// JumpDamageReduction Снижение урона при каждом прыжке
	JumpDamageReduction *float32 `json:"jump_damage_reduction,omitempty"`

	// MaxJumps Максимальное количество прыжков
	MaxJumps       *int               `json:"max_jumps,omitempty"`
	SourceTargetId openapi_types.UUID `json:"source_target_id"`
	WeaponId       openapi_types.UUID `json:"weapon_id"`
}

// CalculateChainDamageRequestDamageType Тип цепного урона
type CalculateChainDamageRequestDamageType string

// ChainDamageJump defines model for ChainDamageJump.
type ChainDamageJump struct {
	Damage *float32 `json:"damage,omitempty"`

	// JumpNumber Номер прыжка
	JumpNumber *int                `json:"jump_number,omitempty"`
	TargetId   *openapi_types.UUID `json:"target_id,omitempty"`
}

// ChainDamageResponse defines model for ChainDamageResponse.
type ChainDamageResponse struct {
	Jumps          *[]ChainDamageJump  `json:"jumps,omitempty"`
	SourceTargetId *openapi_types.UUID `json:"source_target_id,omitempty"`

	// TotalDamage Общий урон по всем целям
	TotalDamage *float32 `json:"total_damage,omitempty"`
}

// CreatePersistentEffectRequest defines model for CreatePersistentEffectRequest.
type CreatePersistentEffectRequest struct {
	// DamagePerTick Урон за тик
	DamagePerTick float32    `json:"damage_per_tick"`
	Position      Position3D `json:"position"`

	// ProjectileType Тип снаряда
	ProjectileType CreatePersistentEffectRequestProjectileType `json:"projectile_type"`

	// RemainingTicks Количество оставшихся тиков
	RemainingTicks *int               `json:"remaining_ticks,omitempty"`
	TargetId       openapi_types.UUID `json:"target_id"`

	// TickInterval Интервал между тиками (секунды)
	TickInterval float32 `json:"tick_interval"`
}

// CreatePersistentEffectRequestProjectileType Тип снаряда
type CreatePersistentEffectRequestProjectileType string

// DestroyEnvironmentRequest defines model for DestroyEnvironmentRequest.
type DestroyEnvironmentRequest struct {
	// Damage Урон взрыва
	Damage            float32    `json:"damage"`
	ExplosionPosition Position3D `json:"explosion_position"`

	// ExplosionRadius Радиус взрыва
	ExplosionRadius float32 `json:"explosion_radius"`

	// WeaponId ID оружия
	WeaponId openapi_types.UUID `json:"weapon_id"`
}

// DestroyedObject defines model for DestroyedObject.
type DestroyedObject struct {
	DestructionType *DestroyedObjectDestructionType `json:"destruction_type,omitempty"`
	ObjectId        *openapi_types.UUID             `json:"object_id,omitempty"`
	Position        *Position3D                     `json:"position,omitempty"`
}

// DestroyedObjectDestructionType defines model for DestroyedObject.DestructionType.
type DestroyedObjectDestructionType string

// EnvironmentDestructionResponse defines model for EnvironmentDestructionResponse.
type EnvironmentDestructionResponse struct {
	AffectedTargets  *[]AffectedTarget  `json:"affected_targets,omitempty"`
	DestroyedObjects *[]DestroyedObject `json:"destroyed_objects,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// PersistentEffect defines model for PersistentEffect.
type PersistentEffect struct {
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	DamagePerTick  *float32            `json:"damage_per_tick,omitempty"`
	ExpiresAt      *time.Time          `json:"expires_at,omitempty"`
	Id             *openapi_types.UUID `json:"id,omitempty"`
	Position       *Position3D         `json:"position,omitempty"`
	ProjectileType *string             `json:"projectile_type,omitempty"`
	RemainingTicks *int                `json:"remaining_ticks,omitempty"`
	TargetId       *openapi_types.UUID `json:"target_id,omitempty"`
	TickInterval   *float32            `json:"tick_interval,omitempty"`
}

// PersistentEffectsResponse defines model for PersistentEffectsResponse.
type PersistentEffectsResponse struct {
	Effects  *[]PersistentEffect `json:"effects,omitempty"`
	TargetId *openapi_types.UUID `json:"target_id,omitempty"`
}

// Position3D defines model for Position3D.
type Position3D struct {
	// X Координата X
	X float32 `json:"x"`

	// Y Координата Y
	Y float32 `json:"y"`

	// Z Координата Z
	Z float32 `json:"z"`
}

// WeaponMechanic defines model for WeaponMechanic.
type WeaponMechanic struct {
	CreatedAt    *time.Time              `json:"created_at,omitempty"`
	Id           *openapi_types.UUID     `json:"id,omitempty"`
	MechanicData *map[string]interface{} `json:"mechanic_data,omitempty"`
	MechanicType *string                 `json:"mechanic_type,omitempty"`
}

// WeaponSpecialMechanicsResponse defines model for WeaponSpecialMechanicsResponse.
type WeaponSpecialMechanicsResponse struct {
	Mechanics *[]WeaponMechanic   `json:"mechanics,omitempty"`
	WeaponId  *openapi_types.UUID `json:"weapon_id,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// CalculateChainDamageJSONRequestBody defines body for CalculateChainDamage for application/json ContentType.
type CalculateChainDamageJSONRequestBody = CalculateChainDamageRequest

// DestroyEnvironmentJSONRequestBody defines body for DestroyEnvironment for application/json ContentType.
type DestroyEnvironmentJSONRequestBody = DestroyEnvironmentRequest

// CreatePersistentEffectJSONRequestBody defines body for CreatePersistentEffect for application/json ContentType.
type CreatePersistentEffectJSONRequestBody = CreatePersistentEffectRequest

// ApplySpecialMechanicsJSONRequestBody defines body for ApplySpecialMechanics for application/json ContentType.
type ApplySpecialMechanicsJSONRequestBody = ApplySpecialMechanicsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Рассчитать цепной урон
	// (POST /gameplay/combat/weapons/chain-damage/calculate)
	CalculateChainDamage(w http.ResponseWriter, r *http.Request)
	// Разрушить окружение
	// (POST /gameplay/combat/weapons/environment/destroy)
	DestroyEnvironment(w http.ResponseWriter, r *http.Request)
	// Создать персистентный эффект
	// (POST /gameplay/combat/weapons/persistent-effects/create)
	CreatePersistentEffect(w http.ResponseWriter, r *http.Request)
	// Получить персистентные эффекты цели
	// (GET /gameplay/combat/weapons/persistent-effects/{targetId})
	GetPersistentEffects(w http.ResponseWriter, r *http.Request, targetId openapi_types.UUID)
	// Применить специальную механику оружия
	// (POST /gameplay/combat/weapons/special-mechanics/apply)
	ApplySpecialMechanics(w http.ResponseWriter, r *http.Request)
	// Получить механики оружия
	// (GET /gameplay/combat/weapons/special-mechanics/{weaponId})
	GetWeaponSpecialMechanics(w http.ResponseWriter, r *http.Request, weaponId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CalculateChainDamage operation middleware
func (siw *ServerInterfaceWrapper) CalculateChainDamage(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CalculateChainDamage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DestroyEnvironment operation middleware
func (siw *ServerInterfaceWrapper) DestroyEnvironment(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DestroyEnvironment(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePersistentEffect operation middleware
func (siw *ServerInterfaceWrapper) CreatePersistentEffect(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePersistentEffect(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPersistentEffects operation middleware
func (siw *ServerInterfaceWrapper) GetPersistentEffects(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "targetId" -------------
	var targetId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "targetId", mux.Vars(r)["targetId"], &targetId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPersistentEffects(w, r, targetId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ApplySpecialMechanics operation middleware
func (siw *ServerInterfaceWrapper) ApplySpecialMechanics(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ApplySpecialMechanics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWeaponSpecialMechanics operation middleware
func (siw *ServerInterfaceWrapper) GetWeaponSpecialMechanics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "weaponId" -------------
	var weaponId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "weaponId", mux.Vars(r)["weaponId"], &weaponId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "weaponId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWeaponSpecialMechanics(w, r, weaponId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/chain-damage/calculate", wrapper.CalculateChainDamage).Methods("POST")

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/environment/destroy", wrapper.DestroyEnvironment).Methods("POST")

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/persistent-effects/create", wrapper.CreatePersistentEffect).Methods("POST")

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/persistent-effects/{targetId}", wrapper.GetPersistentEffects).Methods("GET")

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/special-mechanics/apply", wrapper.ApplySpecialMechanics).Methods("POST")

	r.HandleFunc(options.BaseURL+"/gameplay/combat/weapons/special-mechanics/{weaponId}", wrapper.GetWeaponSpecialMechanics).Methods("GET")

	return r
}
