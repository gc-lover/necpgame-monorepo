package server

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/necpgame/gameplay-service-go/models"
	"github.com/sirupsen/logrus"
)

type AffixRepositoryInterface interface {
	GetAffix(ctx context.Context, affixID uuid.UUID) (*models.Affix, error)
	GetAllAffixes(ctx context.Context) ([]models.Affix, error)
	GetActiveRotation(ctx context.Context) (*models.AffixRotation, error)
	GetRotationByWeek(ctx context.Context, weekStart time.Time) (*models.AffixRotation, error)
	CreateRotation(ctx context.Context, rotation *models.AffixRotation, affixIDs []uuid.UUID) error
	GetRotationHistory(ctx context.Context, weeksBack, limit, offset int) ([]models.AffixRotation, int, error)
	GetInstanceAffixes(ctx context.Context, instanceID uuid.UUID) ([]models.AffixSummary, error)
	AssignAffixesToInstance(ctx context.Context, instanceID uuid.UUID, affixIDs []uuid.UUID) error
}

type AffixRepository struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

func NewAffixRepository(db *pgxpool.Pool) *AffixRepository {
	return &AffixRepository{
		db:     db,
		logger: GetLogger(),
	}
}

func (r *AffixRepository) GetAffix(ctx context.Context, affixID uuid.UUID) (*models.Affix, error) {
	var affix models.Affix
	var mechanicsJSON, visualEffectsJSON sql.NullString

	err := r.db.QueryRow(ctx,
		`SELECT id, name, category, description, mechanics, visual_effects, 
		 reward_modifier, difficulty_modifier, created_at
		 FROM gameplay.affixes WHERE id = $1`,
		affixID,
	).Scan(
		&affix.ID, &affix.Name, &affix.Category, &affix.Description,
		&mechanicsJSON, &visualEffectsJSON,
		&affix.RewardModifier, &affix.DifficultyModifier, &affix.CreatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errors.New("affix not found")
	}
	if err != nil {
		r.logger.WithError(err).Error("Failed to get affix")
		return nil, err
	}

	if mechanicsJSON.Valid {
		json.Unmarshal([]byte(mechanicsJSON.String), &affix.Mechanics)
	}
	if visualEffectsJSON.Valid {
		json.Unmarshal([]byte(visualEffectsJSON.String), &affix.VisualEffects)
	}

	return &affix, nil
}

func (r *AffixRepository) GetAllAffixes(ctx context.Context) ([]models.Affix, error) {
	rows, err := r.db.Query(ctx,
		`SELECT id, name, category, description, mechanics, visual_effects,
		 reward_modifier, difficulty_modifier, created_at
		 FROM gameplay.affixes ORDER BY name`,
	)
	if err != nil {
		r.logger.WithError(err).Error("Failed to get all affixes")
		return nil, err
	}
	defer rows.Close()

	var affixes []models.Affix
	for rows.Next() {
		var affix models.Affix
		var mechanicsJSON, visualEffectsJSON sql.NullString

		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Category, &affix.Description,
			&mechanicsJSON, &visualEffectsJSON,
			&affix.RewardModifier, &affix.DifficultyModifier, &affix.CreatedAt,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to scan affix")
			continue
		}

		if mechanicsJSON.Valid {
			json.Unmarshal([]byte(mechanicsJSON.String), &affix.Mechanics)
		}
		if visualEffectsJSON.Valid {
			json.Unmarshal([]byte(visualEffectsJSON.String), &affix.VisualEffects)
		}

		affixes = append(affixes, affix)
	}

	return affixes, nil
}

func (r *AffixRepository) GetActiveRotation(ctx context.Context) (*models.AffixRotation, error) {
	now := time.Now()
	return r.GetRotationByWeek(ctx, GetWeekStart(now))
}

func GetWeekStart(t time.Time) time.Time {
	weekday := int(t.Weekday())
	if weekday == 0 {
		weekday = 7
	}
	daysFromMonday := weekday - 1
	weekStart := t.AddDate(0, 0, -daysFromMonday)
	weekStart = time.Date(weekStart.Year(), weekStart.Month(), weekStart.Day(), 0, 0, 0, 0, time.UTC)
	return weekStart
}

func (r *AffixRepository) GetRotationByWeek(ctx context.Context, weekStart time.Time) (*models.AffixRotation, error) {
	var rotation models.AffixRotation
	var seasonalAffixID sql.NullString

	err := r.db.QueryRow(ctx,
		`SELECT id, week_start, week_end, seasonal_affix_id, created_at
		 FROM gameplay.affix_rotations WHERE week_start = $1`,
		weekStart,
	).Scan(
		&rotation.ID, &rotation.WeekStart, &rotation.WeekEnd,
		&seasonalAffixID, &rotation.CreatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errors.New("rotation not found")
	}
	if err != nil {
		r.logger.WithError(err).Error("Failed to get rotation")
		return nil, err
	}

	rows, err := r.db.Query(ctx,
		`SELECT a.id, a.name, a.category, a.description, a.reward_modifier, a.difficulty_modifier
		 FROM gameplay.affixes a
		 INNER JOIN gameplay.affix_rotation_affixes ara ON a.id = ara.affix_id
		 WHERE ara.rotation_id = $1`,
		rotation.ID,
	)
	if err != nil {
		r.logger.WithError(err).Error("Failed to get rotation affixes")
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var affix models.AffixSummary
		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Category, &affix.Description,
			&affix.RewardModifier, &affix.DifficultyModifier,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to scan affix")
			continue
		}
		rotation.ActiveAffixes = append(rotation.ActiveAffixes, affix)
	}

	if seasonalAffixID.Valid {
		seasonalID, _ := uuid.Parse(seasonalAffixID.String)
		seasonalAffix, err := r.GetAffix(ctx, seasonalID)
		if err == nil {
			rotation.SeasonalAffix = &models.AffixSummary{
				ID:                seasonalAffix.ID,
				Name:              seasonalAffix.Name,
				Category:          seasonalAffix.Category,
				Description:       seasonalAffix.Description,
				RewardModifier:    seasonalAffix.RewardModifier,
				DifficultyModifier: seasonalAffix.DifficultyModifier,
			}
		}
	}

	return &rotation, nil
}

func (r *AffixRepository) CreateRotation(ctx context.Context, rotation *models.AffixRotation, affixIDs []uuid.UUID) error {
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	err = tx.QueryRow(ctx,
		`INSERT INTO gameplay.affix_rotations (week_start, week_end, seasonal_affix_id)
		 VALUES ($1, $2, $3) RETURNING id, created_at`,
		rotation.WeekStart, rotation.WeekEnd, rotation.SeasonalAffix.ID,
	).Scan(&rotation.ID, &rotation.CreatedAt)

	if err != nil {
		r.logger.WithError(err).Error("Failed to create rotation")
		return err
	}

	for _, affixID := range affixIDs {
		_, err = tx.Exec(ctx,
			`INSERT INTO gameplay.affix_rotation_affixes (rotation_id, affix_id)
			 VALUES ($1, $2)`,
			rotation.ID, affixID,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to add affix to rotation")
			return err
		}
	}

	return tx.Commit(ctx)
}

func (r *AffixRepository) GetRotationHistory(ctx context.Context, weeksBack, limit, offset int) ([]models.AffixRotation, int, error) {
	cutoffDate := time.Now().AddDate(0, 0, -weeksBack*7)

	var total int
	err := r.db.QueryRow(ctx,
		`SELECT COUNT(*) FROM gameplay.affix_rotations WHERE week_start >= $1`,
		cutoffDate,
	).Scan(&total)
	if err != nil {
		r.logger.WithError(err).Error("Failed to count rotations")
		return nil, 0, err
	}

	rows, err := r.db.Query(ctx,
		`SELECT id, week_start, week_end, seasonal_affix_id, created_at
		 FROM gameplay.affix_rotations
		 WHERE week_start >= $1
		 ORDER BY week_start DESC
		 LIMIT $2 OFFSET $3`,
		cutoffDate, limit, offset,
	)
	if err != nil {
		r.logger.WithError(err).Error("Failed to get rotation history")
		return nil, 0, err
	}
	defer rows.Close()

	var rotations []models.AffixRotation
	for rows.Next() {
		var rotation models.AffixRotation
		var seasonalAffixID sql.NullString

		err := rows.Scan(
			&rotation.ID, &rotation.WeekStart, &rotation.WeekEnd,
			&seasonalAffixID, &rotation.CreatedAt,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to scan rotation")
			continue
		}

		affixRows, err := r.db.Query(ctx,
			`SELECT a.id, a.name, a.category, a.description, a.reward_modifier, a.difficulty_modifier
			 FROM gameplay.affixes a
			 INNER JOIN gameplay.affix_rotation_affixes ara ON a.id = ara.affix_id
			 WHERE ara.rotation_id = $1`,
			rotation.ID,
		)
		if err == nil {
			defer affixRows.Close()
			for affixRows.Next() {
				var affix models.AffixSummary
				err := affixRows.Scan(
					&affix.ID, &affix.Name, &affix.Category, &affix.Description,
					&affix.RewardModifier, &affix.DifficultyModifier,
				)
				if err == nil {
					rotation.ActiveAffixes = append(rotation.ActiveAffixes, affix)
				}
			}
		}

		if seasonalAffixID.Valid {
			seasonalID, _ := uuid.Parse(seasonalAffixID.String)
			seasonalAffix, err := r.GetAffix(ctx, seasonalID)
			if err == nil {
				rotation.SeasonalAffix = &models.AffixSummary{
					ID:                seasonalAffix.ID,
					Name:              seasonalAffix.Name,
					Category:          seasonalAffix.Category,
					Description:       seasonalAffix.Description,
					RewardModifier:    seasonalAffix.RewardModifier,
					DifficultyModifier: seasonalAffix.DifficultyModifier,
				}
			}
		}

		rotations = append(rotations, rotation)
	}

	return rotations, total, nil
}

func (r *AffixRepository) GetInstanceAffixes(ctx context.Context, instanceID uuid.UUID) ([]models.AffixSummary, error) {
	rows, err := r.db.Query(ctx,
		`SELECT a.id, a.name, a.category, a.description, a.reward_modifier, a.difficulty_modifier
		 FROM gameplay.affixes a
		 INNER JOIN gameplay.instance_affixes ia ON a.id = ia.affix_id
		 WHERE ia.instance_id = $1`,
		instanceID,
	)
	if err != nil {
		r.logger.WithError(err).Error("Failed to get instance affixes")
		return nil, err
	}
	defer rows.Close()

	var affixes []models.AffixSummary
	for rows.Next() {
		var affix models.AffixSummary
		err := rows.Scan(
			&affix.ID, &affix.Name, &affix.Category, &affix.Description,
			&affix.RewardModifier, &affix.DifficultyModifier,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to scan instance affix")
			continue
		}
		affixes = append(affixes, affix)
	}

	return affixes, nil
}

func (r *AffixRepository) AssignAffixesToInstance(ctx context.Context, instanceID uuid.UUID, affixIDs []uuid.UUID) error {
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	_, err = tx.Exec(ctx,
		`DELETE FROM gameplay.instance_affixes WHERE instance_id = $1`,
		instanceID,
	)
	if err != nil {
		r.logger.WithError(err).Error("Failed to delete existing instance affixes")
		return err
	}

	for _, affixID := range affixIDs {
		_, err = tx.Exec(ctx,
			`INSERT INTO gameplay.instance_affixes (instance_id, affix_id)
			 VALUES ($1, $2)`,
			instanceID, affixID,
		)
		if err != nil {
			r.logger.WithError(err).Error("Failed to assign affix to instance")
			return err
		}
	}

	return tx.Commit(ctx)
}

