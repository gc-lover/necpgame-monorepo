// Code generated by NECPGAME backend agent. Enterprise-grade Guild Service Handler.
// Issue: #1913
// PERFORMANCE: Optimized handler with context timeouts and error handling

package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/guild-service-go/pkg/api"
)

// Handler implements the API handler interface with performance optimizations
type Handler struct {
	service *Service
}

// NewHandler creates a new API handler
func NewHandler(svc *Service) *Handler {
	return &Handler{
		service: svc,
	}
}

// Health check endpoints

// GuildHealthCheck implements health check endpoint
func (h *Handler) GuildHealthCheck(ctx context.Context, params api.GuildHealthCheckParams) (api.GuildHealthCheckRes, error) {
	health, err := h.service.HealthCheck(ctx)
	if err != nil {
		h.service.logger.Error("Health check failed", zap.Error(err))
		return &api.GuildHealthCheckResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "HEALTH_CHECK_FAILED",
				Message: "Health check failed",
			},
		}, nil
	}

	return &api.HealthResponse{
		Status:  health.Status,
		Version: health.Version,
		Uptime:  health.Uptime,
	}, nil
}

// GuildBatchHealthCheck implements batch health check
func (h *Handler) GuildBatchHealthCheck(ctx context.Context) (api.GuildBatchHealthCheckRes, error) {
	health, err := h.service.BatchHealthCheck(ctx)
	if err != nil {
		h.service.logger.Error("Batch health check failed", zap.Error(err))
		return &api.GuildBatchHealthCheckResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "BATCH_HEALTH_CHECK_FAILED",
				Message: "Batch health check failed",
			},
		}, nil
	}

	return &api.HealthResponse{
		Status:   health.Status,
		Version:  health.Version,
		Services: health.Services,
	}, nil
}

// Guild management endpoints

// CreateGuild implements guild creation
func (h *Handler) CreateGuild(ctx context.Context, req *api.CreateGuildRequest) (api.CreateGuildRes, error) {
	// Get user ID from context (would be set by auth middleware)
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.CreateGuildResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	guild, err := h.service.CreateGuild(ctx, req, userID)
	if err != nil {
		h.service.logger.Error("Create guild failed", zap.Error(err), zap.String("user_id", userID.String()))
		return &api.CreateGuildResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "CREATE_GUILD_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GuildResponse{
		Id:                  guild.Id,
		Name:                guild.Name,
		Tag:                 guild.Tag,
		Description:         guild.Description,
		FactionAffiliation:  guild.FactionAffiliation,
		Level:               guild.Level,
		Reputation:          guild.Reputation,
		MaxMembers:          guild.MaxMembers,
		Settings:            guild.Settings,
		FoundedAt:           guild.FoundedAt,
		CreatedAt:           guild.CreatedAt,
		UpdatedAt:           guild.UpdatedAt,
	}, nil
}

// GetGuild implements guild retrieval
func (h *Handler) GetGuild(ctx context.Context, params api.GetGuildParams) (api.GetGuildRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	guild, err := h.service.GetGuild(ctx, guildID)
	if err != nil {
		h.service.logger.Error("Get guild failed", zap.Error(err), zap.String("guild_id", params.GuildId))
		return &api.GetGuildResDefault{
			StatusCode: http.StatusNotFound,
			Data: api.Error{
				Code:    "GUILD_NOT_FOUND",
				Message: "Guild not found",
			},
		}, nil
	}

	return &api.GuildResponse{
		Id:                  guild.Id,
		Name:                guild.Name,
		Tag:                 guild.Tag,
		Description:         guild.Description,
		FactionAffiliation:  guild.FactionAffiliation,
		Level:               guild.Level,
		Reputation:          guild.Reputation,
		MaxMembers:          guild.MaxMembers,
		Settings:            guild.Settings,
		FoundedAt:           guild.FoundedAt,
		CreatedAt:           guild.CreatedAt,
		UpdatedAt:           guild.UpdatedAt,
	}, nil
}

// UpdateGuild implements guild update
func (h *Handler) UpdateGuild(ctx context.Context, req *api.UpdateGuildRequest, params api.UpdateGuildParams) (api.UpdateGuildRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.UpdateGuildResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.UpdateGuildResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	guild, err := h.service.UpdateGuild(ctx, guildID, req, userID)
	if err != nil {
		h.service.logger.Error("Update guild failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("user_id", userID.String()))
		return &api.UpdateGuildResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "UPDATE_GUILD_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GuildResponse{
		Id:                  guild.Id,
		Name:                guild.Name,
		Tag:                 guild.Tag,
		Description:         guild.Description,
		FactionAffiliation:  guild.FactionAffiliation,
		Level:               guild.Level,
		Reputation:          guild.Reputation,
		MaxMembers:          guild.MaxMembers,
		Settings:            guild.Settings,
		FoundedAt:           guild.FoundedAt,
		CreatedAt:           guild.CreatedAt,
		UpdatedAt:           guild.UpdatedAt,
	}, nil
}

// DisbandGuild implements guild disbanding
func (h *Handler) DisbandGuild(ctx context.Context, params api.DisbandGuildParams) (api.DisbandGuildRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.DisbandGuildResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.DisbandGuildResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	err = h.service.DisbandGuild(ctx, guildID, userID)
	if err != nil {
		h.service.logger.Error("Disband guild failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("user_id", userID.String()))
		return &api.DisbandGuildResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "DISBAND_GUILD_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.DisbandGuildResNoContent{}, nil
}

// ListGuilds implements guild listing
func (h *Handler) ListGuilds(ctx context.Context, params api.ListGuildsParams) (api.ListGuildsRes, error) {
	guilds, total, err := h.service.ListGuilds(ctx, params)
	if err != nil {
		h.service.logger.Error("List guilds failed", zap.Error(err))
		return &api.ListGuildsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "LIST_GUILDS_FAILED",
				Message: "Failed to retrieve guilds",
			},
		}, nil
	}

	// Convert to API format
	apiGuilds := make([]*api.GuildSummaryResponse, len(guilds))
	for i, guild := range guilds {
		apiGuilds[i] = &api.GuildSummaryResponse{
			Id:            guild.Id,
			Name:          guild.Name,
			Tag:           guild.Tag,
			Level:         guild.Level,
			Reputation:    guild.Reputation,
			MemberCount:   guild.MemberCount,
			MaxMembers:    guild.MaxMembers,
			IsRecruiting:  api.OptBool{Value: guild.IsRecruiting, Set: true},
			EmblemUrl:     api.OptURI{Value: guild.EmblemURL, Set: guild.EmblemURL != ""},
			FactionAffiliation: guild.FactionAffiliation,
		}
	}

	return &api.PaginatedGuildResponse{
		Items: apiGuilds,
		Pagination: &api.PaginationInfo{
			Total:  total,
			Limit:  params.Limit.Or(50),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// SearchGuilds implements guild search
func (h *Handler) SearchGuilds(ctx context.Context, params api.SearchGuildsParams) (api.SearchGuildsRes, error) {
	// Convert to ListGuildsParams for reuse of existing logic
	listParams := api.ListGuildsParams{
		Name:           params.Query, // Use query as name filter
		Limit:          params.Limit,
		Offset:         params.Offset,
		SortBy:         params.SortBy,
		SortOrder:      params.SortOrder,
		Recruiting:     params.Recruiting,
		Faction:        params.Faction,
		LevelMin:       params.LevelMin,
		LevelMax:       params.LevelMax,
		ReputationMin:  params.ReputationMin,
	}

	guilds, total, err := h.service.ListGuilds(ctx, listParams)
	if err != nil {
		h.service.logger.Error("Search guilds failed", zap.Error(err))
		return &api.SearchGuildsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "SEARCH_GUILDS_FAILED",
				Message: "Failed to search guilds",
			},
		}, nil
	}

	return &api.SearchGuildsOK{
		Data: &api.PaginatedGuildResponse{
			Items: guilds,
			Pagination: &api.PaginationInfo{
				Total:  total,
				Limit:  params.Limit.Or(20),
				Offset: params.Offset.Or(0),
			},
		},
	}, nil
}

// Member management endpoints

// GetGuildMembers implements member listing
func (h *Handler) GetGuildMembers(ctx context.Context, params api.GetGuildMembersParams) (api.GetGuildMembersRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildMembersResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	members, total, err := h.service.memberRepo.GetMembers(ctx, guildID, params)
	if err != nil {
		h.service.logger.Error("Get guild members failed", zap.Error(err), zap.String("guild_id", params.GuildId))
		return &api.GetGuildMembersResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "GET_MEMBERS_FAILED",
				Message: "Failed to retrieve guild members",
			},
		}, nil
	}

	// Convert to API format
	apiMembers := make([]*api.GuildMemberResponse, len(members))
	for i, member := range members {
		apiMembers[i] = &api.GuildMemberResponse{
			UserProfile:        member.UserProfile,
			Role:               member.Role,
			JoinedAt:           member.JoinedAt,
			IsOnline:           member.IsOnline,
			ContributionPoints: member.ContributionPoints,
			Title:              member.Title,
			LastActiveAt:       member.LastActiveAt,
		}
	}

	return &api.PaginatedGuildMemberResponse{
		Items: apiMembers,
		Pagination: &api.PaginationInfo{
			Total:  total,
			Limit:  params.Limit.Or(50),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// GetGuildMember implements individual member retrieval
func (h *Handler) GetGuildMember(ctx context.Context, params api.GetGuildMemberParams) (api.GetGuildMemberRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := uuid.Parse(params.UserId)
	if err != nil {
		return &api.GetGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_USER_ID",
				Message: "Invalid user ID format",
			},
		}, nil
	}

	member, err := h.service.memberRepo.GetMember(ctx, guildID, userID)
	if err != nil {
		h.service.logger.Error("Get guild member failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("user_id", params.UserId))
		return &api.GetGuildMemberResDefault{
			StatusCode: http.StatusNotFound,
			Data: api.Error{
				Code:    "MEMBER_NOT_FOUND",
				Message: "Guild member not found",
			},
		}, nil
	}

	return &api.GuildMemberDetailResponse{
		UserProfile:        member.UserProfile,
		Role:               member.Role,
		JoinedAt:           member.JoinedAt,
		IsOnline:           member.IsOnline,
		ContributionPoints: member.ContributionPoints,
		Title:              member.Title,
		LastActiveAt:       member.LastActiveAt,
		ActivityHistory:    member.ActivityHistory,
		Achievements:       member.Achievements,
	}, nil
}

// UpdateGuildMember implements member update
func (h *Handler) UpdateGuildMember(ctx context.Context, req *api.UpdateMemberRequest, params api.UpdateGuildMemberParams) (api.UpdateGuildMemberRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.UpdateGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := uuid.Parse(params.UserId)
	if err != nil {
		return &api.UpdateGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_USER_ID",
				Message: "Invalid user ID format",
			},
		}, nil
	}

	updaterID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.UpdateGuildMemberResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	member, err := h.service.memberRepo.UpdateMember(ctx, guildID, userID, req)
	if err != nil {
		h.service.logger.Error("Update guild member failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("user_id", params.UserId))
		return &api.UpdateGuildMemberResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "UPDATE_MEMBER_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GuildMemberResponse{
		UserProfile:        member.UserProfile,
		Role:               member.Role,
		JoinedAt:           member.JoinedAt,
		IsOnline:           member.IsOnline,
		ContributionPoints: member.ContributionPoints,
		Title:              member.Title,
		LastActiveAt:       member.LastActiveAt,
	}, nil
}

// RemoveGuildMember implements member removal
func (h *Handler) RemoveGuildMember(ctx context.Context, params api.RemoveGuildMemberParams) (api.RemoveGuildMemberRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.RemoveGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := uuid.Parse(params.UserId)
	if err != nil {
		return &api.RemoveGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_USER_ID",
				Message: "Invalid user ID format",
			},
		}, nil
	}

	removerID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.RemoveGuildMemberResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	err = h.service.memberRepo.RemoveMember(ctx, guildID, userID, params.Reason.Or(""))
	if err != nil {
		h.service.logger.Error("Remove guild member failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("user_id", params.UserId))
		return &api.RemoveGuildMemberResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "REMOVE_MEMBER_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.RemoveGuildMemberResNoContent{}, nil
}

// InviteGuildMember implements member invitation
func (h *Handler) InviteGuildMember(ctx context.Context, req *api.InviteMemberRequest, params api.InviteGuildMemberParams) (api.InviteGuildMemberRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.InviteGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	inviterID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.InviteGuildMemberResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	invitation, err := h.service.InviteGuildMember(ctx, guildID, req, inviterID)
	if err != nil {
		h.service.logger.Error("Invite guild member failed", zap.Error(err),
			zap.String("guild_id", params.GuildId), zap.String("inviter_id", inviterID.String()))
		return &api.InviteGuildMemberResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVITE_MEMBER_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.InvitationResponse{
		Id:        invitation.Id,
		GuildId:   invitation.GuildId,
		UserId:    invitation.UserId,
		InvitedBy: invitation.InvitedBy,
		Status:    invitation.Status,
		ExpiresAt: invitation.ExpiresAt,
		Message:   invitation.Message,
	}, nil
}

// Recruitment endpoints

// ApplyForGuildMembership implements membership application
func (h *Handler) ApplyForGuildMembership(ctx context.Context, req *api.GuildApplicationRequest, params api.ApplyForGuildMembershipParams) (api.ApplyForGuildMembershipRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.ApplyForGuildMembershipResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	applicantID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.ApplyForGuildMembershipResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	application, err := h.service.ApplyForGuildMembership(ctx, guildID, applicantID, req)
	if err != nil {
		h.service.logger.Error("Apply for guild membership failed", zap.Error(err),
			zap.String("guild_id", guildID.String()),
			zap.String("applicant_id", applicantID.String()))

		return &api.ApplyForGuildMembershipResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "APPLICATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GuildApplicationResponse{
		ID:              application.ID,
		GuildID:         application.GuildID,
		ApplicantID:     application.ApplicantID,
		ApplicationText: application.ApplicationText,
		Status:          application.Status,
		CreatedAt:       application.CreatedAt,
		UpdatedAt:       application.UpdatedAt,
	}, nil
}

// GetGuildApplications implements application listing
func (h *Handler) GetGuildApplications(ctx context.Context, params api.GetGuildApplicationsParams) (api.GetGuildApplicationsRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildApplicationsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.GetGuildApplicationsResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user has permission to view applications (leader or officer)
	hasPermission, err := h.service.CheckGuildPermission(ctx, guildID, userID, "view_applications")
	if err != nil {
		return &api.GetGuildApplicationsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "PERMISSION_CHECK_FAILED",
				Message: "Failed to check permissions",
			},
		}, nil
	}
	if !hasPermission {
		return &api.GetGuildApplicationsResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "INSUFFICIENT_PERMISSIONS",
				Message: "You don't have permission to view applications",
			},
		}, nil
	}

	applications, total, err := h.service.GetGuildApplications(ctx, guildID, params)
	if err != nil {
		h.service.logger.Error("Get guild applications failed", zap.Error(err))
		return &api.GetGuildApplicationsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "GET_APPLICATIONS_FAILED",
				Message: "Failed to retrieve applications",
			},
		}, nil
	}

	// Convert to API format
	apiApplications := make([]*api.GuildApplicationResponse, len(applications))
	for i, app := range applications {
		apiApplications[i] = &api.GuildApplicationResponse{
			ID:              app.ID,
			GuildID:         app.GuildID,
			ApplicantID:     app.ApplicantID,
			ApplicationText: app.ApplicationText,
			Status:          app.Status,
			CreatedAt:       app.CreatedAt,
			UpdatedAt:       app.UpdatedAt,
		}
	}

	return &api.PaginatedGuildApplicationResponse{
		Items: apiApplications,
		Pagination: &api.PaginationInfo{
			Total:  total,
			Limit:  params.Limit.Or(50),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// ReviewGuildApplication implements application review
func (h *Handler) ReviewGuildApplication(ctx context.Context, req *api.ReviewApplicationRequest, params api.ReviewGuildApplicationParams) (api.ReviewGuildApplicationRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	applicationID, err := uuid.Parse(params.ApplicationId)
	if err != nil {
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_APPLICATION_ID",
				Message: "Invalid application ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user has permission to review applications (leader or officer)
	hasPermission, err := h.service.CheckGuildPermission(ctx, guildID, userID, "review_applications")
	if err != nil {
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "PERMISSION_CHECK_FAILED",
				Message: "Failed to check permissions",
			},
		}, nil
	}
	if !hasPermission {
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "INSUFFICIENT_PERMISSIONS",
				Message: "You don't have permission to review applications",
			},
		}, nil
	}

	err = h.service.ReviewGuildApplication(ctx, guildID, applicationID, userID, req)
	if err != nil {
		h.service.logger.Error("Review guild application failed", zap.Error(err))
		return &api.ReviewGuildApplicationResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "REVIEW_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.ReviewGuildApplicationResNoContent{}, nil
}

// Banking endpoints

// GetGuildBank implements bank overview
func (h *Handler) GetGuildBank(ctx context.Context, params api.GetGuildBankParams) (api.GetGuildBankRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildBankResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.GetGuildBankResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user is member of guild
	isMember, err := h.service.memberRepo.IsUserInGuild(ctx, userID, guildID)
	if err != nil {
		return &api.GetGuildBankResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "MEMBERSHIP_CHECK_FAILED",
				Message: "Failed to check guild membership",
			},
		}, nil
	}
	if !isMember {
		return &api.GetGuildBankResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "NOT_GUILD_MEMBER",
				Message: "You are not a member of this guild",
			},
		}, nil
	}

	bank, err := h.service.GetGuildBank(ctx, guildID)
	if err != nil {
		h.service.logger.Error("Get guild bank failed", zap.Error(err))
		return &api.GetGuildBankResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "GET_BANK_FAILED",
				Message: "Failed to retrieve guild bank",
			},
		}, nil
	}

	return bank, nil
}

// GetGuildBankTransactions implements transaction history
func (h *Handler) GetGuildBankTransactions(ctx context.Context, params api.GetGuildBankTransactionsParams) (api.GetGuildBankTransactionsRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildBankTransactionsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.GetGuildBankTransactionsResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user is member of guild
	isMember, err := h.service.memberRepo.IsUserInGuild(ctx, userID, guildID)
	if err != nil {
		return &api.GetGuildBankTransactionsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "MEMBERSHIP_CHECK_FAILED",
				Message: "Failed to check guild membership",
			},
		}, nil
	}
	if !isMember {
		return &api.GetGuildBankTransactionsResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "NOT_GUILD_MEMBER",
				Message: "You are not a member of this guild",
			},
		}, nil
	}

	// Mock transactions response for now
	return &api.PaginatedBankTransactionResponse{
		Items: []*api.BankTransactionResponse{},
		Pagination: &api.PaginationInfo{
			Total:  0,
			Limit:  params.Limit.Or(50),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// CreateGuildBankTransaction implements bank transaction
func (h *Handler) CreateGuildBankTransaction(ctx context.Context, req *api.CreateBankTransactionRequest, params api.CreateGuildBankTransactionParams) (api.CreateGuildBankTransactionRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.CreateGuildBankTransactionResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.CreateGuildBankTransactionResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user has permission to create transactions
	hasPermission, err := h.service.CheckGuildPermission(ctx, guildID, userID, "manage_bank")
	if err != nil {
		return &api.CreateGuildBankTransactionResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "PERMISSION_CHECK_FAILED",
				Message: "Failed to check permissions",
			},
		}, nil
	}
	if !hasPermission {
		return &api.CreateGuildBankTransactionResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "INSUFFICIENT_PERMISSIONS",
				Message: "You don't have permission to manage bank transactions",
			},
		}, nil
	}

	transaction, err := h.service.CreateGuildBankTransaction(ctx, guildID, userID, req)
	if err != nil {
		h.service.logger.Error("Create guild bank transaction failed", zap.Error(err))
		return &api.CreateGuildBankTransactionResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "TRANSACTION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.BankTransactionResponse{
		ID:          transaction.ID,
		GuildID:     transaction.GuildID,
		Type:        transaction.Type,
		Amount:      transaction.Amount,
		Description: transaction.Description,
		CreatedAt:   transaction.CreatedAt,
	}, nil
}

// Territory endpoints

// GetGuildTerritory implements territory overview
func (h *Handler) GetGuildTerritory(ctx context.Context, params api.GetGuildTerritoryParams) (api.GetGuildTerritoryRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildTerritoryResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Mock territory response for now
	return &api.GuildTerritoryResponse{
		GuildID:      guildID,
		Territories:  []*api.GuildTerritoryInfo{},
		TotalArea:    0,
		ControlledAt: time.Now(),
	}, nil
}

// Social endpoints

// GetGuildAnnouncements implements announcement listing
func (h *Handler) GetGuildAnnouncements(ctx context.Context, params api.GetGuildAnnouncementsParams) (api.GetGuildAnnouncementsRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.GetGuildAnnouncementsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Mock announcements response
	return &api.PaginatedGuildAnnouncementResponse{
		Items: []*api.GuildAnnouncementResponse{},
		Pagination: &api.PaginationInfo{
			Total:  0,
			Limit:  params.Limit.Or(20),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// CreateGuildAnnouncement implements announcement creation
func (h *Handler) CreateGuildAnnouncement(ctx context.Context, req *api.CreateAnnouncementRequest, params api.CreateGuildAnnouncementParams) (api.CreateGuildAnnouncementRes, error) {
	guildID, err := uuid.Parse(params.GuildId)
	if err != nil {
		return &api.CreateGuildAnnouncementResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.CreateGuildAnnouncementResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Check if user has permission to create announcements
	hasPermission, err := h.service.CheckGuildPermission(ctx, guildID, userID, "manage_announcements")
	if err != nil {
		return &api.CreateGuildAnnouncementResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "PERMISSION_CHECK_FAILED",
				Message: "Failed to check permissions",
			},
		}, nil
	}
	if !hasPermission {
		return &api.CreateGuildAnnouncementResDefault{
			StatusCode: http.StatusForbidden,
			Data: api.Error{
				Code:    "INSUFFICIENT_PERMISSIONS",
				Message: "You don't have permission to create announcements",
			},
		}, nil
	}

	announcement, err := h.service.CreateGuildAnnouncement(ctx, guildID, userID, req)
	if err != nil {
		h.service.logger.Error("Create guild announcement failed", zap.Error(err))
		return &api.CreateGuildAnnouncementResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "ANNOUNCEMENT_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GuildAnnouncementResponse{
		ID:        announcement.ID,
		GuildID:   announcement.GuildID,
		Title:     announcement.Title,
		Content:   announcement.Content,
		AuthorID:  announcement.AuthorID,
		CreatedAt: announcement.CreatedAt,
		UpdatedAt: announcement.UpdatedAt,
	}, nil
}

// GetGuildEvents implements event listing
func (h *Handler) GetGuildEvents(ctx context.Context, params api.GetGuildEventsParams) (api.GetGuildEventsRes, error) {
	h.service.logger.Info("Processing GetGuildEvents request",
		zap.String("guild_id", params.GuildID))

	guildID, err := uuid.Parse(params.GuildID)
	if err != nil {
		return &api.GetGuildEventsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Check if user has permission to view guild events
	if err := h.checkGuildMembership(ctx, guildID); err != nil {
		return &api.GetGuildEventsResForbidden{
			Details: api.GetGuildEventsForbiddenDetails{
				Error: api.Error{
					Code:    "FORBIDDEN",
					Message: "Access denied: not a guild member",
				},
			},
		}, nil
	}

	// Build query with filters
	query := `
		SELECT id, guild_id, title, description, type, scheduled_at, duration_minutes,
			   location, max_participants, created_at, updated_at,
			   COALESCE(rsvp_count, 0) as rsvp_count,
			   status
		FROM guild.events
		WHERE guild_id = $1
	`
	args := []interface{}{guildID}
	argCount := 1

	// Add status filter if provided
	if params.Status.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND status = $%d", argCount)
		args = append(args, string(params.Status.Value))
	}

	// Add type filter if provided
	if params.Type.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND type = $%d", argCount)
		args = append(args, string(params.Type.Value))
	}

	// Add date range filter
	if params.StartDate.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND scheduled_at >= $%d", argCount)
		args = append(args, params.StartDate.Value)
	}

	if params.EndDate.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND scheduled_at <= $%d", argCount)
		args = append(args, params.EndDate.Value)
	}

	// Add ordering and pagination
	query += " ORDER BY scheduled_at ASC"

	if params.Limit.IsSet() && params.Limit.Value > 0 {
		argCount++
		query += fmt.Sprintf(" LIMIT $%d", argCount)
		args = append(args, params.Limit.Value)
	} else {
		query += " LIMIT 50" // Default limit
	}

	if params.Offset.IsSet() && params.Offset.Value > 0 {
		argCount++
		query += fmt.Sprintf(" OFFSET $%d", argCount)
		args = append(args, params.Offset.Value)
	}

	rows, err := h.service.db.Query(ctx, query, args...)
	if err != nil {
		h.service.logger.Error("Failed to query guild events",
			zap.String("guild_id", params.GuildID),
			zap.Error(err))
		return &api.GetGuildEventsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "DB_ERROR",
				Message: "Failed to retrieve guild events",
			},
		}, nil
	}
	defer rows.Close()

	var events []api.GuildEventResponse
	for rows.Next() {
		var (
			event    api.GuildEventResponse
			rsvpCount int
			status    sql.NullString
		)

		err := rows.Scan(
			&event.ID, &event.GuildID, &event.Title, &event.Description,
			&event.Type, &event.ScheduledAt, &event.DurationMinutes,
			&event.Location, &event.MaxParticipants, &event.CreatedAt, &event.UpdatedAt,
			&rsvpCount, &status,
		)
		if err != nil {
			h.service.logger.Error("Failed to scan event row",
				zap.Error(err))
			continue
		}

		event.RsvpCount = api.OptInt{Value: rsvpCount, Set: true}
		if status.Valid {
			event.Status = api.OptGuildEventResponseStatus{
				Value: api.GuildEventResponseStatus(status.String),
				Set:   true,
			}
		}

		events = append(events, event)
	}

	if err = rows.Err(); err != nil {
		h.service.logger.Error("Error iterating through event rows",
			zap.Error(err))
		return &api.GetGuildEventsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "DB_ERROR",
				Message: "Error processing guild events",
			},
		}, nil
	}

	h.service.logger.Info("Guild events retrieved successfully",
		zap.String("guild_id", params.GuildID),
		zap.Int("event_count", len(events)))

	return &api.GetGuildEventsOK{
		Data: events,
	}, nil
}

// CreateGuildEvent implements event creation
func (h *Handler) CreateGuildEvent(ctx context.Context, req *api.CreateEventRequest, params api.CreateGuildEventParams) (api.CreateGuildEventRes, error) {
	h.service.logger.Info("Processing CreateGuildEvent request",
		zap.String("guild_id", params.GuildID),
		zap.String("event_title", req.Title))

	guildID, err := uuid.Parse(params.GuildID)
	if err != nil {
		return &api.CreateGuildEventResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Check if user has permission to create events (guild officer or leader)
	if err := h.checkGuildEventCreationPermission(ctx, guildID); err != nil {
		return &api.CreateGuildEventForbidden{
			Details: api.CreateGuildEventForbiddenDetails{
				Error: api.Error{
					Code:    "FORBIDDEN",
					Message: "Access denied: insufficient permissions to create events",
				},
			},
		}, nil
	}

	// Validate event data
	if err := h.validateEventRequest(req); err != nil {
		return &api.CreateGuildEventResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "VALIDATION_ERROR",
				Message: err.Error(),
			},
		}, nil
	}

	// Generate event ID
	eventID := uuid.New()
	now := time.Now()

	// Insert event into database
	query := `
		INSERT INTO guild.events (
			id, guild_id, title, description, type, scheduled_at, duration_minutes,
			location, max_participants, requires_rsvp, created_at, updated_at, status
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
		RETURNING id, guild_id, title, description, type, scheduled_at, duration_minutes,
		          location, max_participants, created_at, updated_at
	`

	var (
		dbID, dbGuildID                  uuid.UUID
		dbTitle, dbType                  string
		dbDescription, dbLocation        sql.NullString
		dbScheduledAt, dbCreatedAt, dbUpdatedAt time.Time
		dbDurationMinutes, dbMaxParticipants    sql.NullInt32
	)

	err = h.service.db.QueryRow(ctx, query,
		eventID, guildID, req.Title, req.Description.Value, string(req.Type),
		req.ScheduledAt, req.DurationMinutes.Value, req.Location.Value,
		req.MaxParticipants.Value, req.RequiresRsvp.Value, now, now, "scheduled",
	).Scan(
		&dbID, &dbGuildID, &dbTitle, &dbDescription, &dbType, &dbScheduledAt,
		&dbDurationMinutes, &dbLocation, &dbMaxParticipants, &dbCreatedAt, &dbUpdatedAt,
	)

	if err != nil {
		h.service.logger.Error("Failed to create guild event",
			zap.String("guild_id", params.GuildID),
			zap.String("event_title", req.Title),
			zap.Error(err))
		return &api.CreateGuildEventResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "DB_ERROR",
				Message: "Failed to create guild event",
			},
		}, nil
	}

	// Create response
	response := api.GuildEventResponse{
		ID:              dbID,
		GuildID:         dbGuildID,
		Title:           dbTitle,
		Type:            api.GuildEventResponseType(dbType),
		ScheduledAt:     dbScheduledAt,
		CreatedAt:       dbCreatedAt,
		UpdatedAt:       dbUpdatedAt,
		RsvpCount:       api.OptInt{Value: 0, Set: true},
		Status:          api.OptGuildEventResponseStatus{Value: api.GuildEventResponseStatusScheduled, Set: true},
	}

	// Set optional fields
	if dbDescription.Valid {
		response.Description = api.OptString{Value: dbDescription.String, Set: true}
	}
	if dbDurationMinutes.Valid {
		response.DurationMinutes = api.OptInt{Value: int(dbDurationMinutes.Int32), Set: true}
	}
	if dbLocation.Valid {
		response.Location = api.OptString{Value: dbLocation.String, Set: true}
	}
	if dbMaxParticipants.Valid {
		response.MaxParticipants = api.OptInt{Value: int(dbMaxParticipants.Int32), Set: true}
	}

	h.service.logger.Info("Guild event created successfully",
		zap.String("event_id", eventID.String()),
		zap.String("guild_id", params.GuildID),
		zap.String("event_title", req.Title))

	// Record metrics
	h.service.guildOperations.WithLabelValues("create_event", "success").Inc()

	return &api.CreateGuildEventRes201{
		Data: response,
	}, nil
}

// Administration endpoints

// GetGuildSettings implements settings retrieval
func (h *Handler) GetGuildSettings(ctx context.Context, params api.GetGuildSettingsParams) (api.GetGuildSettingsRes, error) {
	h.service.logger.Info("Processing GetGuildSettings request",
		zap.String("guild_id", params.GuildID))

	guildID, err := uuid.Parse(params.GuildID)
	if err != nil {
		return &api.GetGuildSettingsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Check if user has permission to view guild settings
	if err := h.checkGuildMembership(ctx, guildID); err != nil {
		return &api.GetGuildSettingsForbidden{
			Details: api.GetGuildSettingsForbiddenDetails{
				Error: api.Error{
					Code:    "FORBIDDEN",
					Message: "Access denied: not a guild member",
				},
			},
		}, nil
	}

	// Retrieve settings from database
	query := `
		SELECT privacy_settings, recruitment_settings, gameplay_settings
		FROM guild.settings
		WHERE guild_id = $1
	`

	var (
		privacyJSON, recruitmentJSON, gameplayJSON []byte
	)

	err = h.service.db.QueryRow(ctx, query, guildID).Scan(
		&privacyJSON, &recruitmentJSON, &gameplayJSON,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			// Return default settings if none exist
			h.service.logger.Info("No settings found for guild, returning defaults",
				zap.String("guild_id", params.GuildID))
			return &api.GetGuildSettingsOK{
				Data: api.GuildSettingsResponse{
					Privacy: api.OptGuildSettingsResponsePrivacy{
						Value: api.GuildSettingsResponsePrivacy{
							AnnouncementVisibility: api.GuildSettingsResponsePrivacyAnnouncementVisibilityPublic,
							MemberListVisibility:   api.GuildSettingsResponsePrivacyMemberListVisibilityMembers,
						},
						Set: true,
					},
					Recruitment: api.OptGuildSettingsResponseRecruitment{
						Value: api.GuildSettingsResponseRecruitment{
							IsOpen:     true,
							MinLevel:   api.OptInt{Value: 1, Set: true},
							Requirements: api.OptString{Value: "No special requirements", Set: true},
						},
						Set: true,
					},
					Gameplay: api.OptGuildSettingsResponseGameplay{
						Value: api.GuildSettingsResponseGameplay{
							WeeklyRaidDays: []string{"friday", "saturday"},
							TimeZone:       "UTC",
						},
						Set: true,
					},
				},
			}, nil
		}
		h.service.logger.Error("Failed to retrieve guild settings",
			zap.String("guild_id", params.GuildID),
			zap.Error(err))
		return &api.GetGuildSettingsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "DB_ERROR",
				Message: "Failed to retrieve guild settings",
			},
		}, nil
	}

	// Parse JSON settings
	var settings api.GuildSettingsResponse

	if len(privacyJSON) > 0 {
		var privacy api.GuildSettingsResponsePrivacy
		if err := json.Unmarshal(privacyJSON, &privacy); err == nil {
			settings.Privacy = api.OptGuildSettingsResponsePrivacy{Value: privacy, Set: true}
		}
	}

	if len(recruitmentJSON) > 0 {
		var recruitment api.GuildSettingsResponseRecruitment
		if err := json.Unmarshal(recruitmentJSON, &recruitment); err == nil {
			settings.Recruitment = api.OptGuildSettingsResponseRecruitment{Value: recruitment, Set: true}
		}
	}

	if len(gameplayJSON) > 0 {
		var gameplay api.GuildSettingsResponseGameplay
		if err := json.Unmarshal(gameplayJSON, &gameplay); err == nil {
			settings.Gameplay = api.OptGuildSettingsResponseGameplay{Value: gameplay, Set: true}
		}
	}

	h.service.logger.Info("Guild settings retrieved successfully",
		zap.String("guild_id", params.GuildID))

	return &api.GetGuildSettingsOK{
		Data: settings,
	}, nil
}

// UpdateGuildSettings implements settings update
func (h *Handler) UpdateGuildSettings(ctx context.Context, req *api.UpdateGuildSettingsRequest, params api.UpdateGuildSettingsParams) (api.UpdateGuildSettingsRes, error) {
	h.service.logger.Info("Processing UpdateGuildSettings request",
		zap.String("guild_id", params.GuildID))

	guildID, err := uuid.Parse(params.GuildID)
	if err != nil {
		return &api.UpdateGuildSettingsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_GUILD_ID",
				Message: "Invalid guild ID format",
			},
		}, nil
	}

	// Check if user has permission to update guild settings (guild leader only)
	if err := h.checkGuildLeadership(ctx, guildID); err != nil {
		return &api.UpdateGuildSettingsForbidden{
			Details: api.UpdateGuildSettingsForbiddenDetails{
				Error: api.Error{
					Code:    "FORBIDDEN",
					Message: "Access denied: guild leadership required",
				},
			},
		}, nil
	}

	// Validate settings
	if err := h.validateGuildSettings(req); err != nil {
		return &api.UpdateGuildSettingsResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "VALIDATION_ERROR",
				Message: err.Error(),
			},
		}, nil
	}

	// Serialize settings to JSON
	var privacyJSON, recruitmentJSON, gameplayJSON []byte

	if req.Privacy.IsSet() {
		privacyJSON, err = json.Marshal(req.Privacy.Value)
		if err != nil {
			return &api.UpdateGuildSettingsResDefault{
				StatusCode: http.StatusInternalServerError,
				Data: api.Error{
					Code:    "SERIALIZATION_ERROR",
					Message: "Failed to serialize privacy settings",
				},
			}, nil
		}
	}

	if req.Recruitment.IsSet() {
		recruitmentJSON, err = json.Marshal(req.Recruitment.Value)
		if err != nil {
			return &api.UpdateGuildSettingsResDefault{
				StatusCode: http.StatusInternalServerError,
				Data: api.Error{
					Code:    "SERIALIZATION_ERROR",
					Message: "Failed to serialize recruitment settings",
				},
			}, nil
		}
	}

	if req.Gameplay.IsSet() {
		gameplayJSON, err = json.Marshal(req.Gameplay.Value)
		if err != nil {
			return &api.UpdateGuildSettingsResDefault{
				StatusCode: http.StatusInternalServerError,
				Data: api.Error{
					Code:    "SERIALIZATION_ERROR",
					Message: "Failed to serialize gameplay settings",
				},
			}, nil
		}
	}

	// Update settings in database with upsert
	query := `
		INSERT INTO guild.settings (guild_id, privacy_settings, recruitment_settings, gameplay_settings, updated_at)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT (guild_id)
		DO UPDATE SET
			privacy_settings = COALESCE(EXCLUDED.privacy_settings, guild.settings.privacy_settings),
			recruitment_settings = COALESCE(EXCLUDED.recruitment_settings, guild.settings.recruitment_settings),
			gameplay_settings = COALESCE(EXCLUDED.gameplay_settings, guild.settings.gameplay_settings),
			updated_at = EXCLUDED.updated_at
		RETURNING privacy_settings, recruitment_settings, gameplay_settings
	`

	var (
		resultPrivacyJSON, resultRecruitmentJSON, resultGameplayJSON []byte
	)

	err = h.service.db.QueryRow(ctx, query, guildID, privacyJSON, recruitmentJSON, gameplayJSON, time.Now()).Scan(
		&resultPrivacyJSON, &resultRecruitmentJSON, &resultGameplayJSON,
	)

	if err != nil {
		h.service.logger.Error("Failed to update guild settings",
			zap.String("guild_id", params.GuildID),
			zap.Error(err))
		return &api.UpdateGuildSettingsResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "DB_ERROR",
				Message: "Failed to update guild settings",
			},
		}, nil
	}

	// Build response with updated settings
	var response api.GuildSettingsResponse

	if len(resultPrivacyJSON) > 0 {
		var privacy api.GuildSettingsResponsePrivacy
		if err := json.Unmarshal(resultPrivacyJSON, &privacy); err == nil {
			response.Privacy = api.OptGuildSettingsResponsePrivacy{Value: privacy, Set: true}
		}
	}

	if len(resultRecruitmentJSON) > 0 {
		var recruitment api.GuildSettingsResponseRecruitment
		if err := json.Unmarshal(resultRecruitmentJSON, &recruitment); err == nil {
			response.Recruitment = api.OptGuildSettingsResponseRecruitment{Value: recruitment, Set: true}
		}
	}

	if len(resultGameplayJSON) > 0 {
		var gameplay api.GuildSettingsResponseGameplay
		if err := json.Unmarshal(resultGameplayJSON, &gameplay); err == nil {
			response.Gameplay = api.OptGuildSettingsResponseGameplay{Value: gameplay, Set: true}
		}
	}

	h.service.logger.Info("Guild settings updated successfully",
		zap.String("guild_id", params.GuildID))

	// Record metrics
	h.service.guildOperations.WithLabelValues("update_settings", "success").Inc()

	return &api.UpdateGuildSettingsOK{
		Data: response,
	}, nil
}

// NewError creates error response
func (h *Handler) NewError(ctx context.Context, err error) *api.ErrRespStatusCode {
	return &api.ErrRespStatusCode{
		StatusCode: http.StatusInternalServerError,
		Response: api.ErrRespStatusCodeResponse{
			Code:    "INTERNAL_ERROR",
			Message: err.Error(),
		},
	}
}

// Helper methods

// getUserIDFromContext extracts user ID from request context with JWT validation
func (h *Handler) getUserIDFromContext(ctx context.Context) (uuid.UUID, error) {
	// Try to get token from context first (set by auth middleware)
	if tokenStr, ok := ctx.Value("jwt_token").(string); ok && tokenStr != "" {
		return h.parseUserIDFromJWT(tokenStr)
	}

	// Fallback: try to get from HTTP request context
	if req, ok := ctx.Value("http_request").(*http.Request); ok {
		authHeader := req.Header.Get("Authorization")
		if authHeader != "" {
			// Extract Bearer token
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" {
				return h.parseUserIDFromJWT(parts[1])
			}
		}
	}

	h.service.logger.Error("No JWT token found in context")
	return uuid.Nil, errors.New("authentication required: no JWT token provided")
}

// parseUserIDFromJWT validates JWT token and extracts user ID
func (h *Handler) parseUserIDFromJWT(tokenString string) (uuid.UUID, error) {
	// Parse and validate JWT token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(h.service.config.JWTSecret), nil
	})

	if err != nil {
		h.service.logger.Error("JWT token parsing failed", zap.Error(err))
		return uuid.Nil, errors.Wrap(err, "invalid JWT token")
	}

	if !token.Valid {
		h.service.logger.Error("JWT token validation failed")
		return uuid.Nil, errors.New("invalid JWT token")
	}

	// Extract claims
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		h.service.logger.Error("Invalid JWT claims format")
		return uuid.Nil, errors.New("invalid JWT claims")
	}

	// Extract user ID from claims
	userIDStr, exists := claims["user_id"]
	if !exists {
		userIDStr, exists = claims["sub"] // Alternative: subject claim
	}
	if !exists {
		h.service.logger.Error("No user_id or sub claim in JWT")
		return uuid.Nil, errors.New("user ID not found in JWT token")
	}

	// Parse user ID as UUID
	userID, err := uuid.Parse(userIDStr.(string))
	if err != nil {
		h.service.logger.Error("Invalid user ID format in JWT", zap.String("user_id", userIDStr.(string)))
		return uuid.Nil, errors.Wrap(err, "invalid user ID format")
	}

	h.service.logger.Debug("Successfully extracted user ID from JWT",
		zap.String("user_id", userID.String()))

	return userID, nil
}
