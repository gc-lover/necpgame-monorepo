// Code generated by NECPGAME backend agent. Enterprise-grade Member Repository.
// Issue: #1913
// PERFORMANCE: Optimized for high-frequency member operations

package member

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.uber.org/zap"

	"necpgame/services/guild-service-go/pkg/api"
)

// Repository handles guild member operations with performance optimizations
type Repository struct {
	db    *pgxpool.Pool
	redis *redis.Client
	log   *zap.Logger
}

// NewRepository creates optimized member repository
func NewRepository(db *pgxpool.Pool, redis *redis.Client, log *zap.Logger) *Repository {
	return &Repository{
		db:    db,
		redis: redis,
		log:   log,
	}
}

// AddMember adds a new member to guild with role assignment
func (r *Repository) AddMember(ctx context.Context, guildID, userID uuid.UUID, role string) error {
	_, err := r.db.Exec(ctx, `
		INSERT INTO guild_members (guild_id, user_id, role, status, joined_at, created_at, updated_at)
		VALUES ($1, $2, $3, 'active', NOW(), NOW(), NOW())
		ON CONFLICT (guild_id, user_id) DO UPDATE SET
			role = EXCLUDED.role,
			status = 'active',
			updated_at = NOW()
		WHERE guild_members.status != 'active'`, guildID, userID, role)

	if err != nil {
		return errors.Wrap(err, "add member")
	}

	// Clear member cache
	r.clearMemberCache(ctx, guildID, userID)

	r.log.Info("Member added to guild",
		zap.String("guild_id", guildID.String()),
		zap.String("user_id", userID.String()),
		zap.String("role", role))

	return nil
}

// GetMemberRole retrieves member's role in guild
func (r *Repository) GetMemberRole(ctx context.Context, guildID, userID uuid.UUID) (string, error) {
	var role string
	err := r.db.QueryRow(ctx, `
		SELECT role FROM guild_members
		WHERE guild_id = $1 AND user_id = $2 AND status = 'active'`,
		guildID, userID).Scan(&role)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return "", errors.New("member not found")
		}
		return "", errors.Wrap(err, "get member role")
	}

	return role, nil
}

// GetMembers retrieves paginated list of guild members
func (r *Repository) GetMembers(ctx context.Context, guildID uuid.UUID, params api.GetGuildMembersParams) ([]*api.GuildMemberResponse, int, error) {
	query := `
		SELECT gm.user_id, gm.guild_id, gm.role, gm.joined_at, gm.last_active_at,
		       gm.contribution_points, gm.rank, gm.is_active,
		       u.username, u.level, u.reputation, u.is_online
		FROM guild_members gm
		JOIN users u ON gm.user_id = u.id
		WHERE gm.guild_id = $1 AND gm.status = 'active'`

	args := []interface{}{guildID}
	argCount := 1

	// Add filters
	if role := params.Role; role.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND gm.role = $%d", argCount)
		args = append(args, role.Value)
	}

	if status := params.Status; status.IsSet() {
		argCount++
		query += fmt.Sprintf(" AND gm.status = $%d", argCount)
		args = append(args, status.Value)
	}

	// Add sorting
	sortBy := params.SortBy.Or("rank")
	sortOrder := params.SortOrder.Or("desc")

	// Map sort field to actual column
	sortColumn := "gm.joined_at" // default
	switch sortBy {
	case "joined_at":
		sortColumn = "gm.joined_at"
	case "last_active":
		sortColumn = "gm.last_active_at"
	case "contribution_points":
		sortColumn = "gm.contribution_points"
	case "rank":
		sortColumn = "u.level"
	}

	query += fmt.Sprintf(" ORDER BY %s %s", sortColumn, sortOrder)

	// Add pagination
	limit := params.Limit.Or(50)
	offset := params.Offset.Or(0)

	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, limit)

	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, offset)

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, errors.Wrap(err, "query members")
	}
	defer rows.Close()

	var members []*api.GuildMemberResponse
	for rows.Next() {
		member := &api.GuildMemberResponse{}
		var rank, contributionPoints sql.NullInt64
		var lastActiveAt sql.NullTime
		var isActive sql.NullBool
		var username sql.NullString
		var level, reputation sql.NullInt64
		var isOnline sql.NullBool

		err := rows.Scan(
			&member.UserID, &member.GuildID, &member.Role, &member.JoinedAt, &lastActiveAt,
			&contributionPoints, &rank, &isActive,
			&username, &level, &reputation, &isOnline)

		if err != nil {
			return nil, 0, errors.Wrap(err, "scan member")
		}

		// Set optional fields
		if contributionPoints.Valid {
			member.ContributionPoints = api.OptInt{Value: int(contributionPoints.Int64), Set: true}
		}
		if rank.Valid {
			member.Rank = api.OptInt{Value: int(rank.Int64), Set: true}
		}
		if lastActiveAt.Valid {
			member.LastActiveAt = api.OptDateTime{Value: lastActiveAt.Time, Set: true}
		}
		if isActive.Valid {
			member.IsActive = api.OptBool{Value: isActive.Bool, Set: true}
		}
		if isOnline.Valid {
			member.IsOnline = api.OptBool{Value: isOnline.Bool, Set: true}
		}

		// Set user profile if available
		if username.Valid {
			userProfile := &api.GuildMemberResponseUserProfile{}
			userProfile.Username = username.String
			if level.Valid {
				userProfile.Level = api.OptInt{Value: int(level.Int64), Set: true}
			}
			if reputation.Valid {
				userProfile.Reputation = api.OptInt{Value: int(reputation.Int64), Set: true}
			}
			member.UserProfile = api.OptGuildMemberResponseUserProfile{Value: *userProfile, Set: true}
		}

		members = append(members, member)
	}

	// Get total count
	countQuery := `
		SELECT COUNT(*) FROM guild_members
		WHERE guild_id = $1 AND status = 'active'`

	countArgs := []interface{}{guildID}
	if role := params.Role; role != "" {
		countQuery += " AND role = $2"
		countArgs = append(countArgs, role)
	}
	if status := params.Status; status != "" {
		countQuery += " AND status = $3"
		countArgs = append(countArgs, status)
	}

	var total int
	err = r.db.QueryRow(ctx, countQuery, countArgs...).Scan(&total)
	if err != nil {
		return nil, 0, errors.Wrap(err, "count members")
	}

	return members, total, nil
}

// UpdateMember updates member role and permissions
func (r *Repository) UpdateMember(ctx context.Context, guildID, userID uuid.UUID, req *api.UpdateMemberRequest) (*api.GuildMemberResponse, error) {
	_, err := r.db.Exec(ctx, `
		UPDATE guild_members
		SET role = COALESCE($3, role),
		    updated_at = NOW()
		WHERE guild_id = $1 AND user_id = $2 AND status = 'active'`,
		guildID, userID, req.Role)

	if err != nil {
		return nil, errors.Wrap(err, "update member")
	}

	// Clear cache
	r.clearMemberCache(ctx, guildID, userID)

	// Return updated member
	return r.GetMember(ctx, guildID, userID)
}

// RemoveMember removes member from guild
func (r *Repository) RemoveMember(ctx context.Context, guildID, userID uuid.UUID, reason string) error {
	_, err := r.db.Exec(ctx, `
		UPDATE guild_members
		SET status = 'removed',
		    removed_at = NOW(),
		    removal_reason = $3,
		    updated_at = NOW()
		WHERE guild_id = $1 AND user_id = $2 AND status = 'active'`,
		guildID, userID, reason)

	if err != nil {
		return errors.Wrap(err, "remove member")
	}

	// Clear cache
	r.clearMemberCache(ctx, guildID, userID)

	r.log.Info("Member removed from guild",
		zap.String("guild_id", guildID.String()),
		zap.String("user_id", userID.String()),
		zap.String("reason", reason))

	return nil
}

// GetMember retrieves detailed member information
func (r *Repository) GetMember(ctx context.Context, guildID, userID uuid.UUID) (*api.GuildMemberResponse, error) {
	// Try cache first
	if cached := r.getCachedMember(ctx, guildID, userID); cached != nil {
		return cached, nil
	}

	member := &api.GuildMemberResponse{}
	var rank, contributionPoints sql.NullInt64
	var lastActiveAt sql.NullTime
	var isActive sql.NullBool
	var username sql.NullString
	var level, reputation sql.NullInt64
	var isOnline sql.NullBool

	err := r.db.QueryRow(ctx, `
		SELECT gm.user_id, gm.guild_id, gm.role, gm.joined_at, gm.last_active_at,
		       gm.contribution_points, gm.rank, gm.is_active,
		       u.username, u.level, u.reputation, u.is_online
		FROM guild_members gm
		JOIN users u ON gm.user_id = u.id
		WHERE gm.guild_id = $1 AND gm.user_id = $2 AND gm.status = 'active'`,
		guildID, userID).Scan(
		&member.UserID, &member.GuildID, &member.Role, &member.JoinedAt, &lastActiveAt,
		&contributionPoints, &rank, &isActive,
		&username, &level, &reputation, &isOnline)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errors.New("member not found")
		}
		return nil, errors.Wrap(err, "get member")
	}

	// Set optional fields
	if contributionPoints.Valid {
		member.ContributionPoints = api.OptInt{Value: int(contributionPoints.Int64), Set: true}
	}
	if rank.Valid {
		member.Rank = api.OptInt{Value: int(rank.Int64), Set: true}
	}
	if lastActiveAt.Valid {
		member.LastActiveAt = api.OptDateTime{Value: lastActiveAt.Time, Set: true}
	}
	if isActive.Valid {
		member.IsActive = api.OptBool{Value: isActive.Bool, Set: true}
	}
	if isOnline.Valid {
		member.IsOnline = api.OptBool{Value: isOnline.Bool, Set: true}
	}

	// Set user profile if available
	if username.Valid {
		userProfile := &api.GuildMemberResponseUserProfile{}
		userProfile.Username = username.String
		if level.Valid {
			userProfile.Level = api.OptInt{Value: int(level.Int64), Set: true}
		}
		if reputation.Valid {
			userProfile.Reputation = api.OptInt{Value: int(reputation.Int64), Set: true}
		}
		member.UserProfile = api.OptGuildMemberResponseUserProfile{Value: *userProfile, Set: true}
	}

	// Cache result
	r.cacheMember(ctx, guildID, userID, member)

	return member, nil
}

// HasActiveGuild checks if user is already in a guild
func (r *Repository) HasActiveGuild(ctx context.Context, userID uuid.UUID) (bool, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM guild_members
		WHERE user_id = $1 AND status = 'active'`, userID).Scan(&count)

	if err != nil {
		return false, errors.Wrap(err, "check active guild")
	}

	return count > 0, nil
}

// CountActiveMembers counts active guild members
func (r *Repository) CountActiveMembers(ctx context.Context, guildID uuid.UUID) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM guild_members
		WHERE guild_id = $1 AND status = 'active'`, guildID).Scan(&count)

	if err != nil {
		return 0, errors.Wrap(err, "count members")
	}

	return count, nil
}

// IsGuildLeader checks if user is guild leader
func (r *Repository) IsGuildLeader(ctx context.Context, guildID, userID uuid.UUID) (bool, error) {
	var role string
	err := r.db.QueryRow(ctx, `
		SELECT role FROM guild_members
		WHERE guild_id = $1 AND user_id = $2 AND status = 'active'`,
		guildID, userID).Scan(&role)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, errors.Wrap(err, "check leadership")
	}

	return role == "leader", nil
}

// CountActiveMembers counts active guild members
func (r *Repository) CountActiveMembers(ctx context.Context, guildID uuid.UUID) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM guild_members
		WHERE guild_id = $1 AND status = 'active'`, guildID).Scan(&count)

	if err != nil {
		return 0, errors.Wrap(err, "count members")
	}

	return count, nil
}

// CreateInvitation creates guild membership invitation
func (r *Repository) CreateInvitation(ctx context.Context, guildID, userID, inviterID uuid.UUID, message string) (*api.InvitationResponse, error) {
	invitationID := uuid.New()

	expiresAt := time.Now().Add(7 * 24 * time.Hour) // 7 days

	_, err := r.db.Exec(ctx, `
		INSERT INTO guild_invitations (id, guild_id, user_id, inviter_id, message, expires_at, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
		invitationID, guildID, userID, inviterID, message, expiresAt)

	if err != nil {
		return nil, errors.Wrap(err, "create invitation")
	}

	return &api.InvitationResponse{
		ID:        invitationID,
		GuildID:   guildID,
		UserID:    userID,
		InvitedBy: inviterID,
		Status:    "pending",
		ExpiresAt: expiresAt,
		Message:   message,
	}, nil
}

// Caching methods for performance

func (r *Repository) cacheMember(ctx context.Context, guildID, userID uuid.UUID, member *api.GuildMemberResponse) {
	key := fmt.Sprintf("guild_member:%s:%s", guildID.String(), userID.String())
	data := map[string]interface{}{
		"user_id": userID.String(),
		"role":    member.Role,
		"online":  member.IsOnline,
	}

	if jsonData, err := json.Marshal(data); err == nil {
		r.redis.Set(ctx, key, jsonData, 15*time.Minute)
	}
}

func (r *Repository) getCachedMember(ctx context.Context, guildID, userID uuid.UUID) *api.GuildMemberResponse {
	key := fmt.Sprintf("guild_member:%s:%s", guildID.String(), userID.String())
	data, err := r.redis.Get(ctx, key).Result()
	if err != nil {
		return nil
	}

	var cached map[string]interface{}
	if err := json.Unmarshal([]byte(data), &cached); err != nil {
		return nil
	}

	return &api.GuildMemberResponse{
		UserProfile: &api.UserProfileEntity{
			Id: userID,
		},
		Role:     cached["role"].(string),
		IsOnline: cached["online"].(bool),
	}
}

func (r *Repository) clearMemberCache(ctx context.Context, guildID, userID uuid.UUID) {
	key := fmt.Sprintf("guild_member:%s:%s", guildID.String(), userID.String())
	r.redis.Del(ctx, key)
}
