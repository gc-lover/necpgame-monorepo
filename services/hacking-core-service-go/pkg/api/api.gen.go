// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ExecuteHackRequestAction.
const (
	Complete ExecuteHackRequestAction = "complete"
	Step     ExecuteHackRequestAction = "step"
)

// Defines values for HackProcessStatusStatus.
const (
	HackProcessStatusStatusCancelled  HackProcessStatusStatus = "cancelled"
	HackProcessStatusStatusCompleted  HackProcessStatusStatus = "completed"
	HackProcessStatusStatusFailed     HackProcessStatusStatus = "failed"
	HackProcessStatusStatusInProgress HackProcessStatusStatus = "in_progress"
	HackProcessStatusStatusInitiated  HackProcessStatusStatus = "initiated"
)

// Defines values for HackResultResultType.
const (
	HackResultResultTypeAccess   HackResultResultType = "access"
	HackResultResultTypeBackdoor HackResultResultType = "backdoor"
	HackResultResultTypeControl  HackResultResultType = "control"
	HackResultResultTypeData     HackResultResultType = "data"
)

// Defines values for HackSessionStatus.
const (
	HackSessionStatusCancelled  HackSessionStatus = "cancelled"
	HackSessionStatusCompleted  HackSessionStatus = "completed"
	HackSessionStatusFailed     HackSessionStatus = "failed"
	HackSessionStatusInProgress HackSessionStatus = "in_progress"
	HackSessionStatusInitiated  HackSessionStatus = "initiated"
)

// Defines values for HackSessionTargetType.
const (
	HackSessionTargetTypeCyberspace HackSessionTargetType = "cyberspace"
	HackSessionTargetTypeDevice     HackSessionTargetType = "device"
	HackSessionTargetTypeNetwork    HackSessionTargetType = "network"
)

// Defines values for HackStepRequestStepType.
const (
	HackStepRequestStepTypeBackdoor HackStepRequestStepType = "backdoor"
	HackStepRequestStepTypeBreach   HackStepRequestStepType = "breach"
	HackStepRequestStepTypeExploit  HackStepRequestStepType = "exploit"
	HackStepRequestStepTypeScan     HackStepRequestStepType = "scan"
)

// Defines values for InitiateHackRequestTargetType.
const (
	InitiateHackRequestTargetTypeCyberspace InitiateHackRequestTargetType = "cyberspace"
	InitiateHackRequestTargetTypeDevice     InitiateHackRequestTargetType = "device"
	InitiateHackRequestTargetTypeNetwork    InitiateHackRequestTargetType = "network"
)

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// ExecuteHackRequest defines model for ExecuteHackRequest.
type ExecuteHackRequest struct {
	// Action Действие:
	// - `step` - выполнить шаг взлома
	// - `complete` - завершить взлом
	Action ExecuteHackRequestAction `json:"action"`

	// StepData Данные шага взлома (опционально)
	StepData *map[string]interface{} `json:"step_data,omitempty"`
}

// ExecuteHackRequestAction Действие:
// - `step` - выполнить шаг взлома
// - `complete` - завершить взлом
type ExecuteHackRequestAction string

// HackProcessStatus defines model for HackProcessStatus.
type HackProcessStatus struct {
	// CurrentStep Текущий шаг взлома
	CurrentStep *string `json:"current_step,omitempty"`

	// HackId ID сессии взлома
	HackId *openapi_types.UUID `json:"hack_id,omitempty"`

	// Progress Прогресс взлома (0-100)
	Progress *int `json:"progress,omitempty"`

	// Status Статус процесса взлома
	Status *HackProcessStatusStatus `json:"status,omitempty"`

	// StepsCompleted Количество выполненных шагов
	StepsCompleted *int `json:"steps_completed,omitempty"`

	// TotalSteps Общее количество шагов
	TotalSteps *int `json:"total_steps,omitempty"`
}

// HackProcessStatusStatus Статус процесса взлома
type HackProcessStatusStatus string

// HackResult defines model for HackResult.
type HackResult struct {
	// Data Данные, полученные в результате взлома
	Data *map[string]interface{} `json:"data,omitempty"`

	// Effects Эффекты взлома
	Effects *[]struct {
		// Type Тип эффекта
		Type *string `json:"type,omitempty"`

		// Value Значение эффекта
		Value *string `json:"value,omitempty"`
	} `json:"effects,omitempty"`

	// HackId ID сессии взлома
	HackId *openapi_types.UUID `json:"hack_id,omitempty"`

	// ResultType Тип результата:
	// - `access` - получен доступ
	// - `data` - извлечены данные
	// - `control` - получен контроль
	// - `backdoor` - установлен бекдор
	ResultType *HackResultResultType `json:"result_type,omitempty"`

	// Success Успешность взлома
	Success *bool `json:"success,omitempty"`
}

// HackResultResultType Тип результата:
// - `access` - получен доступ
// - `data` - извлечены данные
// - `control` - получен контроль
// - `backdoor` - установлен бекдор
type HackResultResultType string

// HackSession defines model for HackSession.
type HackSession struct {
	// CharacterId ID персонажа
	CharacterId *openapi_types.UUID `json:"character_id,omitempty"`

	// CreatedAt Время создания сессии
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Difficulty Сложность взлома
	Difficulty *int `json:"difficulty,omitempty"`

	// Id ID сессии взлома
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Progress Прогресс взлома (0-100)
	Progress *int `json:"progress,omitempty"`

	// Status Статус сессии взлома
	Status *HackSessionStatus `json:"status,omitempty"`

	// TargetId ID цели взлома
	TargetId *openapi_types.UUID `json:"target_id,omitempty"`

	// TargetType Тип цели взлома
	TargetType *HackSessionTargetType `json:"target_type,omitempty"`

	// UpdatedAt Время последнего обновления
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// HackSessionStatus Статус сессии взлома
type HackSessionStatus string

// HackSessionTargetType Тип цели взлома
type HackSessionTargetType string

// HackStepRequest defines model for HackStepRequest.
type HackStepRequest struct {
	// StepData Данные шага
	StepData *map[string]interface{} `json:"step_data,omitempty"`

	// StepType Тип шага:
	// - `scan` - сканирование
	// - `breach` - взлом барьера
	// - `exploit` - использование уязвимости
	// - `backdoor` - установка бекдора
	StepType HackStepRequestStepType `json:"step_type"`
}

// HackStepRequestStepType Тип шага:
// - `scan` - сканирование
// - `breach` - взлом барьера
// - `exploit` - использование уязвимости
// - `backdoor` - установка бекдора
type HackStepRequestStepType string

// HackStepResult defines model for HackStepResult.
type HackStepResult struct {
	// Message Сообщение о результате шага
	Message *string `json:"message,omitempty"`

	// Progress Прогресс взлома после шага (0-100)
	Progress *int `json:"progress,omitempty"`

	// StepType Тип выполненного шага
	StepType *string `json:"step_type,omitempty"`

	// Success Успешность шага
	Success *bool `json:"success,omitempty"`
}

// InitiateHackRequest defines model for InitiateHackRequest.
type InitiateHackRequest struct {
	// CharacterId ID персонажа, выполняющего взлом
	CharacterId openapi_types.UUID `json:"character_id"`

	// Difficulty Сложность взлома (1-10)
	Difficulty *int `json:"difficulty,omitempty"`

	// TargetId ID цели взлома
	TargetId openapi_types.UUID `json:"target_id"`

	// TargetType Тип цели взлома:
	// - `device` - устройство
	// - `network` - сеть
	// - `cyberspace` - киберпространство
	TargetType InitiateHackRequestTargetType `json:"target_type"`
}

// InitiateHackRequestTargetType Тип цели взлома:
// - `device` - устройство
// - `network` - сеть
// - `cyberspace` - киберпространство
type InitiateHackRequestTargetType string

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Status Статус операции
	Status *string `json:"status,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// InitiateHackJSONRequestBody defines body for InitiateHack for application/json ContentType.
type InitiateHackJSONRequestBody = InitiateHackRequest

// ExecuteHackJSONRequestBody defines body for ExecuteHack for application/json ContentType.
type ExecuteHackJSONRequestBody = ExecuteHackRequest

// ExecuteHackStepJSONRequestBody defines body for ExecuteHackStep for application/json ContentType.
type ExecuteHackStepJSONRequestBody = HackStepRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Инициализация взлома
	// (POST /gameplay/hacking/initiate)
	InitiateHack(w http.ResponseWriter, r *http.Request)
	// Отмена взлома
	// (POST /gameplay/hacking/{hackId}/cancel)
	CancelHack(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Выполнение взлома
	// (POST /gameplay/hacking/{hackId}/execute)
	ExecuteHack(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Повторная попытка взлома
	// (POST /gameplay/hacking/{hackId}/process/retry)
	RetryHackStep(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Статус процесса взлома
	// (GET /gameplay/hacking/{hackId}/process/status)
	GetHackProcessStatus(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Выполнение шага взлома
	// (POST /gameplay/hacking/{hackId}/process/step)
	ExecuteHackStep(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Результат взлома
	// (GET /gameplay/hacking/{hackId}/result)
	GetHackResult(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Применение результата взлома
	// (POST /gameplay/hacking/{hackId}/result/apply)
	ApplyHackResult(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
	// Статус взлома
	// (GET /gameplay/hacking/{hackId}/status)
	GetHackStatus(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Инициализация взлома
// (POST /gameplay/hacking/initiate)
func (_ Unimplemented) InitiateHack(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Отмена взлома
// (POST /gameplay/hacking/{hackId}/cancel)
func (_ Unimplemented) CancelHack(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Выполнение взлома
// (POST /gameplay/hacking/{hackId}/execute)
func (_ Unimplemented) ExecuteHack(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Повторная попытка взлома
// (POST /gameplay/hacking/{hackId}/process/retry)
func (_ Unimplemented) RetryHackStep(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Статус процесса взлома
// (GET /gameplay/hacking/{hackId}/process/status)
func (_ Unimplemented) GetHackProcessStatus(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Выполнение шага взлома
// (POST /gameplay/hacking/{hackId}/process/step)
func (_ Unimplemented) ExecuteHackStep(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Результат взлома
// (GET /gameplay/hacking/{hackId}/result)
func (_ Unimplemented) GetHackResult(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Применение результата взлома
// (POST /gameplay/hacking/{hackId}/result/apply)
func (_ Unimplemented) ApplyHackResult(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Статус взлома
// (GET /gameplay/hacking/{hackId}/status)
func (_ Unimplemented) GetHackStatus(w http.ResponseWriter, r *http.Request, hackId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// InitiateHack operation middleware
func (siw *ServerInterfaceWrapper) InitiateHack(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitiateHack(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelHack operation middleware
func (siw *ServerInterfaceWrapper) CancelHack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelHack(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExecuteHack operation middleware
func (siw *ServerInterfaceWrapper) ExecuteHack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteHack(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RetryHackStep operation middleware
func (siw *ServerInterfaceWrapper) RetryHackStep(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetryHackStep(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHackProcessStatus operation middleware
func (siw *ServerInterfaceWrapper) GetHackProcessStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHackProcessStatus(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExecuteHackStep operation middleware
func (siw *ServerInterfaceWrapper) ExecuteHackStep(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteHackStep(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHackResult operation middleware
func (siw *ServerInterfaceWrapper) GetHackResult(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHackResult(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ApplyHackResult operation middleware
func (siw *ServerInterfaceWrapper) ApplyHackResult(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ApplyHackResult(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHackStatus operation middleware
func (siw *ServerInterfaceWrapper) GetHackStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "hackId" -------------
	var hackId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "hackId", chi.URLParam(r, "hackId"), &hackId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hackId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHackStatus(w, r, hackId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/initiate", wrapper.InitiateHack)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/{hackId}/cancel", wrapper.CancelHack)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/{hackId}/execute", wrapper.ExecuteHack)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/{hackId}/process/retry", wrapper.RetryHackStep)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/hacking/{hackId}/process/status", wrapper.GetHackProcessStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/{hackId}/process/step", wrapper.ExecuteHackStep)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/hacking/{hackId}/result", wrapper.GetHackResult)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/gameplay/hacking/{hackId}/result/apply", wrapper.ApplyHackResult)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gameplay/hacking/{hackId}/status", wrapper.GetHackStatus)
	})

	return r
}
