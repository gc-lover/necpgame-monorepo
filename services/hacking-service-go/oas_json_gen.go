// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AbortHackingSessionConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbortHackingSessionConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbortHackingSessionConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes AbortHackingSessionConflict from json.
func (s *AbortHackingSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbortHackingSessionConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem AbortHackingSessionConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbortHackingSessionConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbortHackingSessionConflict) {
					name = jsonFieldsNameOfAbortHackingSessionConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbortHackingSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbortHackingSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbortHackingSessionConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbortHackingSessionConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAbortHackingSessionConflictDetails = [0]string{}

// Decode decodes AbortHackingSessionConflictDetails from json.
func (s *AbortHackingSessionConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbortHackingSessionConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AbortHackingSessionConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbortHackingSessionConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbortHackingSessionConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbortHackingSessionNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbortHackingSessionNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbortHackingSessionNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes AbortHackingSessionNotFound from json.
func (s *AbortHackingSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbortHackingSessionNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem AbortHackingSessionNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AbortHackingSessionNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAbortHackingSessionNotFound) {
					name = jsonFieldsNameOfAbortHackingSessionNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbortHackingSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbortHackingSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AbortHackingSessionNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AbortHackingSessionNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAbortHackingSessionNotFoundDetails = [0]string{}

// Decode decodes AbortHackingSessionNotFoundDetails from json.
func (s *AbortHackingSessionNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AbortHackingSessionNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AbortHackingSessionNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AbortHackingSessionNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AbortHackingSessionNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteHackingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteHackingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ExtractAllData.Set {
			e.FieldStart("extract_all_data")
			s.ExtractAllData.Encode(e)
		}
	}
	{
		if s.CleanupTraces.Set {
			e.FieldStart("cleanup_traces")
			s.CleanupTraces.Encode(e)
		}
	}
	{
		if s.GenerateReport.Set {
			e.FieldStart("generate_report")
			s.GenerateReport.Encode(e)
		}
	}
	{
		if s.DisconnectSafely.Set {
			e.FieldStart("disconnect_safely")
			s.DisconnectSafely.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteHackingRequest = [4]string{
	0: "extract_all_data",
	1: "cleanup_traces",
	2: "generate_report",
	3: "disconnect_safely",
}

// Decode decodes CompleteHackingRequest from json.
func (s *CompleteHackingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteHackingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "extract_all_data":
			if err := func() error {
				s.ExtractAllData.Reset()
				if err := s.ExtractAllData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extract_all_data\"")
			}
		case "cleanup_traces":
			if err := func() error {
				s.CleanupTraces.Reset()
				if err := s.CleanupTraces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cleanup_traces\"")
			}
		case "generate_report":
			if err := func() error {
				s.GenerateReport.Reset()
				if err := s.GenerateReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generate_report\"")
			}
		case "disconnect_safely":
			if err := func() error {
				s.DisconnectSafely.Reset()
				if err := s.DisconnectSafely.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disconnect_safely\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteHackingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteHackingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteHackingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteHackingSessionBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteHackingSessionBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteHackingSessionBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CompleteHackingSessionBadRequest from json.
func (s *CompleteHackingSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteHackingSessionBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CompleteHackingSessionBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteHackingSessionBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteHackingSessionBadRequest) {
					name = jsonFieldsNameOfCompleteHackingSessionBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteHackingSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteHackingSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteHackingSessionBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteHackingSessionBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCompleteHackingSessionBadRequestDetails = [0]string{}

// Decode decodes CompleteHackingSessionBadRequestDetails from json.
func (s *CompleteHackingSessionBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteHackingSessionBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CompleteHackingSessionBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteHackingSessionBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteHackingSessionBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteHackingSessionConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteHackingSessionConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteHackingSessionConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CompleteHackingSessionConflict from json.
func (s *CompleteHackingSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteHackingSessionConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CompleteHackingSessionConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteHackingSessionConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteHackingSessionConflict) {
					name = jsonFieldsNameOfCompleteHackingSessionConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteHackingSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteHackingSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteHackingSessionConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteHackingSessionConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCompleteHackingSessionConflictDetails = [0]string{}

// Decode decodes CompleteHackingSessionConflictDetails from json.
func (s *CompleteHackingSessionConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteHackingSessionConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CompleteHackingSessionConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteHackingSessionConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteHackingSessionConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployICECountermeasureBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployICECountermeasureBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeployICECountermeasureBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes DeployICECountermeasureBadRequest from json.
func (s *DeployICECountermeasureBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem DeployICECountermeasureBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployICECountermeasureBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployICECountermeasureBadRequest) {
					name = jsonFieldsNameOfDeployICECountermeasureBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployICECountermeasureBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployICECountermeasureBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployICECountermeasureBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDeployICECountermeasureBadRequestDetails = [0]string{}

// Decode decodes DeployICECountermeasureBadRequestDetails from json.
func (s *DeployICECountermeasureBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DeployICECountermeasureBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployICECountermeasureBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployICECountermeasureConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployICECountermeasureConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeployICECountermeasureConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes DeployICECountermeasureConflict from json.
func (s *DeployICECountermeasureConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem DeployICECountermeasureConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployICECountermeasureConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployICECountermeasureConflict) {
					name = jsonFieldsNameOfDeployICECountermeasureConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployICECountermeasureConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployICECountermeasureConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployICECountermeasureConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDeployICECountermeasureConflictDetails = [0]string{}

// Decode decodes DeployICECountermeasureConflictDetails from json.
func (s *DeployICECountermeasureConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DeployICECountermeasureConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployICECountermeasureConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployICECountermeasureRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployICECountermeasureRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("countermeasure_type")
		s.CountermeasureType.Encode(e)
	}
	{
		e.FieldStart("tool_id")
		json.EncodeUUID(e, s.ToolID)
	}
	{
		if s.Intensity.Set {
			e.FieldStart("intensity")
			s.Intensity.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeployICECountermeasureRequest = [4]string{
	0: "countermeasure_type",
	1: "tool_id",
	2: "intensity",
	3: "duration",
}

// Decode decodes DeployICECountermeasureRequest from json.
func (s *DeployICECountermeasureRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "countermeasure_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CountermeasureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countermeasure_type\"")
			}
		case "tool_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ToolID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_id\"")
			}
		case "intensity":
			if err := func() error {
				s.Intensity.Reset()
				if err := s.Intensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployICECountermeasureRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployICECountermeasureRequest) {
					name = jsonFieldsNameOfDeployICECountermeasureRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployICECountermeasureRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployICECountermeasureRequestCountermeasureType as json.
func (s DeployICECountermeasureRequestCountermeasureType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeployICECountermeasureRequestCountermeasureType from json.
func (s *DeployICECountermeasureRequestCountermeasureType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployICECountermeasureRequestCountermeasureType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeployICECountermeasureRequestCountermeasureType(v) {
	case DeployICECountermeasureRequestCountermeasureTypeDECOY:
		*s = DeployICECountermeasureRequestCountermeasureTypeDECOY
	case DeployICECountermeasureRequestCountermeasureTypeOVERLOAD:
		*s = DeployICECountermeasureRequestCountermeasureTypeOVERLOAD
	case DeployICECountermeasureRequestCountermeasureTypeNEURALSHIELD:
		*s = DeployICECountermeasureRequestCountermeasureTypeNEURALSHIELD
	case DeployICECountermeasureRequestCountermeasureTypeDATACORRUPTION:
		*s = DeployICECountermeasureRequestCountermeasureTypeDATACORRUPTION
	case DeployICECountermeasureRequestCountermeasureTypeSYSTEMCRASH:
		*s = DeployICECountermeasureRequestCountermeasureTypeSYSTEMCRASH
	default:
		*s = DeployICECountermeasureRequestCountermeasureType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeployICECountermeasureRequestCountermeasureType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployICECountermeasureRequestCountermeasureType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecuteHackingOperationBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExecuteHackingOperationBadRequest from json.
func (s *ExecuteHackingOperationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExecuteHackingOperationBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecuteHackingOperationBadRequest) {
					name = jsonFieldsNameOfExecuteHackingOperationBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExecuteHackingOperationBadRequestDetails = [0]string{}

// Decode decodes ExecuteHackingOperationBadRequestDetails from json.
func (s *ExecuteHackingOperationBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecuteHackingOperationConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExecuteHackingOperationConflict from json.
func (s *ExecuteHackingOperationConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExecuteHackingOperationConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecuteHackingOperationConflict) {
					name = jsonFieldsNameOfExecuteHackingOperationConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExecuteHackingOperationConflictDetails = [0]string{}

// Decode decodes ExecuteHackingOperationConflictDetails from json.
func (s *ExecuteHackingOperationConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecuteHackingOperationTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ExecuteHackingOperationTooManyRequests from json.
func (s *ExecuteHackingOperationTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ExecuteHackingOperationTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecuteHackingOperationTooManyRequests) {
					name = jsonFieldsNameOfExecuteHackingOperationTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingOperationTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingOperationTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExecuteHackingOperationTooManyRequestsDetails = [0]string{}

// Decode decodes ExecuteHackingOperationTooManyRequestsDetails from json.
func (s *ExecuteHackingOperationTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingOperationTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingOperationTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingOperationTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingOperationTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecuteHackingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecuteHackingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operation_type")
		s.OperationType.Encode(e)
	}
	{
		if s.TargetNode.Set {
			e.FieldStart("target_node")
			s.TargetNode.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.RiskOverride.Set {
			e.FieldStart("risk_override")
			s.RiskOverride.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecuteHackingRequest = [5]string{
	0: "operation_type",
	1: "target_node",
	2: "parameters",
	3: "risk_override",
	4: "priority",
}

// Decode decodes ExecuteHackingRequest from json.
func (s *ExecuteHackingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operation_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OperationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation_type\"")
			}
		case "target_node":
			if err := func() error {
				s.TargetNode.Reset()
				if err := s.TargetNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_node\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "risk_override":
			if err := func() error {
				s.RiskOverride.Reset()
				if err := s.RiskOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_override\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecuteHackingRequest) {
					name = jsonFieldsNameOfExecuteHackingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecuteHackingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExecuteHackingRequestOperationType as json.
func (s ExecuteHackingRequestOperationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExecuteHackingRequestOperationType from json.
func (s *ExecuteHackingRequestOperationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingRequestOperationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExecuteHackingRequestOperationType(v) {
	case ExecuteHackingRequestOperationTypeSCAN:
		*s = ExecuteHackingRequestOperationTypeSCAN
	case ExecuteHackingRequestOperationTypeBREACH:
		*s = ExecuteHackingRequestOperationTypeBREACH
	case ExecuteHackingRequestOperationTypeEXTRACT:
		*s = ExecuteHackingRequestOperationTypeEXTRACT
	case ExecuteHackingRequestOperationTypeCONTROL:
		*s = ExecuteHackingRequestOperationTypeCONTROL
	case ExecuteHackingRequestOperationTypeESCAPE:
		*s = ExecuteHackingRequestOperationTypeESCAPE
	default:
		*s = ExecuteHackingRequestOperationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExecuteHackingRequestOperationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingRequestOperationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExecuteHackingRequestParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExecuteHackingRequestParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExecuteHackingRequestParameters from json.
func (s *ExecuteHackingRequestParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingRequestParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecuteHackingRequestParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExecuteHackingRequestParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingRequestParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExecuteHackingRequestPriority as json.
func (s ExecuteHackingRequestPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExecuteHackingRequestPriority from json.
func (s *ExecuteHackingRequestPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecuteHackingRequestPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExecuteHackingRequestPriority(v) {
	case ExecuteHackingRequestPriorityLOW:
		*s = ExecuteHackingRequestPriorityLOW
	case ExecuteHackingRequestPriorityMEDIUM:
		*s = ExecuteHackingRequestPriorityMEDIUM
	case ExecuteHackingRequestPriorityHIGH:
		*s = ExecuteHackingRequestPriorityHIGH
	case ExecuteHackingRequestPriorityCRITICAL:
		*s = ExecuteHackingRequestPriorityCRITICAL
	default:
		*s = ExecuteHackingRequestPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExecuteHackingRequestPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecuteHackingRequestPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHackingSessionNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHackingSessionNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetHackingSessionNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetHackingSessionNotFound from json.
func (s *GetHackingSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHackingSessionNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetHackingSessionNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHackingSessionNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHackingSessionNotFound) {
					name = jsonFieldsNameOfGetHackingSessionNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHackingSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHackingSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHackingSessionNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHackingSessionNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetHackingSessionNotFoundDetails = [0]string{}

// Decode decodes GetHackingSessionNotFoundDetails from json.
func (s *GetHackingSessionNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHackingSessionNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetHackingSessionNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHackingSessionNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHackingSessionNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHackingSessionTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHackingSessionTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetHackingSessionTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetHackingSessionTooManyRequests from json.
func (s *GetHackingSessionTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHackingSessionTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetHackingSessionTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHackingSessionTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHackingSessionTooManyRequests) {
					name = jsonFieldsNameOfGetHackingSessionTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHackingSessionTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHackingSessionTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHackingSessionTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHackingSessionTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetHackingSessionTooManyRequestsDetails = [0]string{}

// Decode decodes GetHackingSessionTooManyRequestsDetails from json.
func (s *GetHackingSessionTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHackingSessionTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetHackingSessionTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHackingSessionTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHackingSessionTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainBatchHealthCheckBadRequest from json.
func (s *HackingDomainBatchHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainBatchHealthCheckBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainBatchHealthCheckBadRequest) {
					name = jsonFieldsNameOfHackingDomainBatchHealthCheckBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckBadRequestDetails = [0]string{}

// Decode decodes HackingDomainBatchHealthCheckBadRequestDetails from json.
func (s *HackingDomainBatchHealthCheckBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_time_ms")
		e.Int(s.TotalTimeMs)
	}
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckOK = [2]string{
	0: "results",
	1: "total_time_ms",
}

// Decode decodes HackingDomainBatchHealthCheckOK from json.
func (s *HackingDomainBatchHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "total_time_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalTimeMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainBatchHealthCheckOK) {
					name = jsonFieldsNameOfHackingDomainBatchHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("services")
		e.ArrStart()
		for _, elem := range s.Services {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckReq = [1]string{
	0: "services",
}

// Decode decodes HackingDomainBatchHealthCheckReq from json.
func (s *HackingDomainBatchHealthCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "services":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Services = make([]HackingDomainBatchHealthCheckReqServicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HackingDomainBatchHealthCheckReqServicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainBatchHealthCheckReq) {
					name = jsonFieldsNameOfHackingDomainBatchHealthCheckReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingDomainBatchHealthCheckReqServicesItem as json.
func (s HackingDomainBatchHealthCheckReqServicesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingDomainBatchHealthCheckReqServicesItem from json.
func (s *HackingDomainBatchHealthCheckReqServicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckReqServicesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingDomainBatchHealthCheckReqServicesItem(v) {
	case HackingDomainBatchHealthCheckReqServicesItemHacking:
		*s = HackingDomainBatchHealthCheckReqServicesItemHacking
	case HackingDomainBatchHealthCheckReqServicesItemCyberspace:
		*s = HackingDomainBatchHealthCheckReqServicesItemCyberspace
	case HackingDomainBatchHealthCheckReqServicesItemNeuralLink:
		*s = HackingDomainBatchHealthCheckReqServicesItemNeuralLink
	case HackingDomainBatchHealthCheckReqServicesItemImplant:
		*s = HackingDomainBatchHealthCheckReqServicesItemImplant
	case HackingDomainBatchHealthCheckReqServicesItemCyberware:
		*s = HackingDomainBatchHealthCheckReqServicesItemCyberware
	default:
		*s = HackingDomainBatchHealthCheckReqServicesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingDomainBatchHealthCheckReqServicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckReqServicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainBatchHealthCheckTooManyRequests from json.
func (s *HackingDomainBatchHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainBatchHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainBatchHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfHackingDomainBatchHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainBatchHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainBatchHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes HackingDomainBatchHealthCheckTooManyRequestsDetails from json.
func (s *HackingDomainBatchHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainBatchHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainBatchHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainBatchHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthCheckOK = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes HackingDomainHealthCheckOK from json.
func (s *HackingDomainHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthCheckOK) {
					name = jsonFieldsNameOfHackingDomainHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingDomainHealthCheckOKStatus as json.
func (s HackingDomainHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingDomainHealthCheckOKStatus from json.
func (s *HackingDomainHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingDomainHealthCheckOKStatus(v) {
	case HackingDomainHealthCheckOKStatusHealthy:
		*s = HackingDomainHealthCheckOKStatusHealthy
	case HackingDomainHealthCheckOKStatusDegraded:
		*s = HackingDomainHealthCheckOKStatusDegraded
	case HackingDomainHealthCheckOKStatusUnhealthy:
		*s = HackingDomainHealthCheckOKStatusUnhealthy
	default:
		*s = HackingDomainHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingDomainHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthCheckServiceUnavailable = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes HackingDomainHealthCheckServiceUnavailable from json.
func (s *HackingDomainHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckServiceUnavailable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthCheckServiceUnavailable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthCheckServiceUnavailable) {
					name = jsonFieldsNameOfHackingDomainHealthCheckServiceUnavailable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingDomainHealthCheckServiceUnavailableStatus as json.
func (s HackingDomainHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingDomainHealthCheckServiceUnavailableStatus from json.
func (s *HackingDomainHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingDomainHealthCheckServiceUnavailableStatus(v) {
	case HackingDomainHealthCheckServiceUnavailableStatusHealthy:
		*s = HackingDomainHealthCheckServiceUnavailableStatusHealthy
	case HackingDomainHealthCheckServiceUnavailableStatusDegraded:
		*s = HackingDomainHealthCheckServiceUnavailableStatusDegraded
	case HackingDomainHealthCheckServiceUnavailableStatusUnhealthy:
		*s = HackingDomainHealthCheckServiceUnavailableStatusUnhealthy
	default:
		*s = HackingDomainHealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingDomainHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainHealthCheckTooManyRequests from json.
func (s *HackingDomainHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfHackingDomainHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes HackingDomainHealthCheckTooManyRequestsDetails from json.
func (s *HackingDomainHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthWebSocketBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainHealthWebSocketBadRequest from json.
func (s *HackingDomainHealthWebSocketBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainHealthWebSocketBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthWebSocketBadRequest) {
					name = jsonFieldsNameOfHackingDomainHealthWebSocketBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainHealthWebSocketBadRequestDetails = [0]string{}

// Decode decodes HackingDomainHealthWebSocketBadRequestDetails from json.
func (s *HackingDomainHealthWebSocketBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketOK) encodeFields(e *jx.Encoder) {
	{
		if s.WebsocketURL.Set {
			e.FieldStart("websocket_url")
			s.WebsocketURL.Encode(e)
		}
	}
	{
		if s.SupportedProtocols != nil {
			e.FieldStart("supported_protocols")
			e.ArrStart()
			for _, elem := range s.SupportedProtocols {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthWebSocketOK = [2]string{
	0: "websocket_url",
	1: "supported_protocols",
}

// Decode decodes HackingDomainHealthWebSocketOK from json.
func (s *HackingDomainHealthWebSocketOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "websocket_url":
			if err := func() error {
				s.WebsocketURL.Reset()
				if err := s.WebsocketURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"websocket_url\"")
			}
		case "supported_protocols":
			if err := func() error {
				s.SupportedProtocols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SupportedProtocols = append(s.SupportedProtocols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_protocols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthWebSocketTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainHealthWebSocketTooManyRequests from json.
func (s *HackingDomainHealthWebSocketTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainHealthWebSocketTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthWebSocketTooManyRequests) {
					name = jsonFieldsNameOfHackingDomainHealthWebSocketTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainHealthWebSocketTooManyRequestsDetails = [0]string{}

// Decode decodes HackingDomainHealthWebSocketTooManyRequestsDetails from json.
func (s *HackingDomainHealthWebSocketTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingDomainHealthWebSocketUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes HackingDomainHealthWebSocketUnauthorized from json.
func (s *HackingDomainHealthWebSocketUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem HackingDomainHealthWebSocketUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingDomainHealthWebSocketUnauthorized) {
					name = jsonFieldsNameOfHackingDomainHealthWebSocketUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingDomainHealthWebSocketUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingDomainHealthWebSocketUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackingDomainHealthWebSocketUnauthorizedDetails = [0]string{}

// Decode decodes HackingDomainHealthWebSocketUnauthorizedDetails from json.
func (s *HackingDomainHealthWebSocketUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingDomainHealthWebSocketUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackingDomainHealthWebSocketUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingDomainHealthWebSocketUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingDomainHealthWebSocketUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingExecutionResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingExecutionResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operation_id")
		json.EncodeUUID(e, s.OperationID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("execution_time_ms")
		e.Int(s.ExecutionTimeMs)
	}
	{
		if s.DataExtracted.Set {
			e.FieldStart("data_extracted")
			s.DataExtracted.Encode(e)
		}
	}
	{
		if s.IceAlerts != nil {
			e.FieldStart("ice_alerts")
			e.ArrStart()
			for _, elem := range s.IceAlerts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RiskIncrease.Set {
			e.FieldStart("risk_increase")
			s.RiskIncrease.Encode(e)
		}
	}
	{
		if s.NeuralImpact.Set {
			e.FieldStart("neural_impact")
			s.NeuralImpact.Encode(e)
		}
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHackingExecutionResult = [8]string{
	0: "operation_id",
	1: "status",
	2: "execution_time_ms",
	3: "data_extracted",
	4: "ice_alerts",
	5: "risk_increase",
	6: "neural_impact",
	7: "warnings",
}

// Decode decodes HackingExecutionResult from json.
func (s *HackingExecutionResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingExecutionResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.OperationID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "execution_time_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ExecutionTimeMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_time_ms\"")
			}
		case "data_extracted":
			if err := func() error {
				s.DataExtracted.Reset()
				if err := s.DataExtracted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted\"")
			}
		case "ice_alerts":
			if err := func() error {
				s.IceAlerts = make([]ICEEncounter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ICEEncounter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IceAlerts = append(s.IceAlerts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_alerts\"")
			}
		case "risk_increase":
			if err := func() error {
				s.RiskIncrease.Reset()
				if err := s.RiskIncrease.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_increase\"")
			}
		case "neural_impact":
			if err := func() error {
				s.NeuralImpact.Reset()
				if err := s.NeuralImpact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_impact\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingExecutionResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingExecutionResult) {
					name = jsonFieldsNameOfHackingExecutionResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingExecutionResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingExecutionResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingExecutionResultDataExtracted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingExecutionResultDataExtracted) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingExecutionResultDataExtracted from json.
func (s *HackingExecutionResultDataExtracted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingExecutionResultDataExtracted to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingExecutionResultDataExtracted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingExecutionResultDataExtracted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingExecutionResultDataExtracted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingExecutionResultStatus as json.
func (s HackingExecutionResultStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingExecutionResultStatus from json.
func (s *HackingExecutionResultStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingExecutionResultStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingExecutionResultStatus(v) {
	case HackingExecutionResultStatusSUCCESS:
		*s = HackingExecutionResultStatusSUCCESS
	case HackingExecutionResultStatusPARTIALSUCCESS:
		*s = HackingExecutionResultStatusPARTIALSUCCESS
	case HackingExecutionResultStatusFAILED:
		*s = HackingExecutionResultStatusFAILED
	case HackingExecutionResultStatusBLOCKED:
		*s = HackingExecutionResultStatusBLOCKED
	default:
		*s = HackingExecutionResultStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingExecutionResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingExecutionResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionAbortResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionAbortResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("abort_reason")
		s.AbortReason.Encode(e)
	}
	{
		e.FieldStart("data_preserved")
		e.Float32(s.DataPreserved)
	}
	{
		if s.PartialResults.Set {
			e.FieldStart("partial_results")
			s.PartialResults.Encode(e)
		}
	}
	{
		if s.Consequences != nil {
			e.FieldStart("consequences")
			e.ArrStart()
			for _, elem := range s.Consequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RecoveryTime.Set {
			e.FieldStart("recovery_time")
			s.RecoveryTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingSessionAbortResult = [6]string{
	0: "session_id",
	1: "abort_reason",
	2: "data_preserved",
	3: "partial_results",
	4: "consequences",
	5: "recovery_time",
}

// Decode decodes HackingSessionAbortResult from json.
func (s *HackingSessionAbortResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionAbortResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "abort_reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AbortReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abort_reason\"")
			}
		case "data_preserved":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.DataPreserved = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_preserved\"")
			}
		case "partial_results":
			if err := func() error {
				s.PartialResults.Reset()
				if err := s.PartialResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial_results\"")
			}
		case "consequences":
			if err := func() error {
				s.Consequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Consequences = append(s.Consequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consequences\"")
			}
		case "recovery_time":
			if err := func() error {
				s.RecoveryTime.Reset()
				if err := s.RecoveryTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionAbortResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionAbortResult) {
					name = jsonFieldsNameOfHackingSessionAbortResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionAbortResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionAbortResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionAbortResultAbortReason as json.
func (s HackingSessionAbortResultAbortReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionAbortResultAbortReason from json.
func (s *HackingSessionAbortResultAbortReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionAbortResultAbortReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionAbortResultAbortReason(v) {
	case HackingSessionAbortResultAbortReasonUSERREQUEST:
		*s = HackingSessionAbortResultAbortReasonUSERREQUEST
	case HackingSessionAbortResultAbortReasonDETECTIONRISK:
		*s = HackingSessionAbortResultAbortReasonDETECTIONRISK
	case HackingSessionAbortResultAbortReasonICETHREAT:
		*s = HackingSessionAbortResultAbortReasonICETHREAT
	case HackingSessionAbortResultAbortReasonNEURALOVERLOAD:
		*s = HackingSessionAbortResultAbortReasonNEURALOVERLOAD
	case HackingSessionAbortResultAbortReasonSYSTEMERROR:
		*s = HackingSessionAbortResultAbortReasonSYSTEMERROR
	default:
		*s = HackingSessionAbortResultAbortReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionAbortResultAbortReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionAbortResultAbortReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingSessionAbortResultPartialResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingSessionAbortResultPartialResults) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingSessionAbortResultPartialResults from json.
func (s *HackingSessionAbortResultPartialResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionAbortResultPartialResults to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionAbortResultPartialResults")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionAbortResultPartialResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionAbortResultPartialResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionCompleteResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionCompleteResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session_id")
		json.EncodeUUID(e, s.SessionID)
	}
	{
		e.FieldStart("completion_status")
		s.CompletionStatus.Encode(e)
	}
	{
		e.FieldStart("total_duration")
		e.Int(s.TotalDuration)
	}
	{
		if s.DataExtractedTotal.Set {
			e.FieldStart("data_extracted_total")
			s.DataExtractedTotal.Encode(e)
		}
	}
	{
		if s.DataExtractedDetails.Set {
			e.FieldStart("data_extracted_details")
			s.DataExtractedDetails.Encode(e)
		}
	}
	{
		if s.IceEncountersTotal.Set {
			e.FieldStart("ice_encounters_total")
			s.IceEncountersTotal.Encode(e)
		}
	}
	{
		if s.IceNeutralized.Set {
			e.FieldStart("ice_neutralized")
			s.IceNeutralized.Encode(e)
		}
	}
	{
		if s.DetectionEvents.Set {
			e.FieldStart("detection_events")
			s.DetectionEvents.Encode(e)
		}
	}
	{
		if s.FinalRiskAssessment.Set {
			e.FieldStart("final_risk_assessment")
			s.FinalRiskAssessment.Encode(e)
		}
	}
	{
		if s.MissionReport.Set {
			e.FieldStart("mission_report")
			s.MissionReport.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingSessionCompleteResult = [10]string{
	0: "session_id",
	1: "completion_status",
	2: "total_duration",
	3: "data_extracted_total",
	4: "data_extracted_details",
	5: "ice_encounters_total",
	6: "ice_neutralized",
	7: "detection_events",
	8: "final_risk_assessment",
	9: "mission_report",
}

// Decode decodes HackingSessionCompleteResult from json.
func (s *HackingSessionCompleteResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionCompleteResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SessionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "completion_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CompletionStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_status\"")
			}
		case "total_duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalDuration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_duration\"")
			}
		case "data_extracted_total":
			if err := func() error {
				s.DataExtractedTotal.Reset()
				if err := s.DataExtractedTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted_total\"")
			}
		case "data_extracted_details":
			if err := func() error {
				s.DataExtractedDetails.Reset()
				if err := s.DataExtractedDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted_details\"")
			}
		case "ice_encounters_total":
			if err := func() error {
				s.IceEncountersTotal.Reset()
				if err := s.IceEncountersTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_encounters_total\"")
			}
		case "ice_neutralized":
			if err := func() error {
				s.IceNeutralized.Reset()
				if err := s.IceNeutralized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_neutralized\"")
			}
		case "detection_events":
			if err := func() error {
				s.DetectionEvents.Reset()
				if err := s.DetectionEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detection_events\"")
			}
		case "final_risk_assessment":
			if err := func() error {
				s.FinalRiskAssessment.Reset()
				if err := s.FinalRiskAssessment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_risk_assessment\"")
			}
		case "mission_report":
			if err := func() error {
				s.MissionReport.Reset()
				if err := s.MissionReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mission_report\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionCompleteResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionCompleteResult) {
					name = jsonFieldsNameOfHackingSessionCompleteResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionCompleteResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionCompleteResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionCompleteResultCompletionStatus as json.
func (s HackingSessionCompleteResultCompletionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionCompleteResultCompletionStatus from json.
func (s *HackingSessionCompleteResultCompletionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionCompleteResultCompletionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionCompleteResultCompletionStatus(v) {
	case HackingSessionCompleteResultCompletionStatusSUCCESS:
		*s = HackingSessionCompleteResultCompletionStatusSUCCESS
	case HackingSessionCompleteResultCompletionStatusPARTIALSUCCESS:
		*s = HackingSessionCompleteResultCompletionStatusPARTIALSUCCESS
	case HackingSessionCompleteResultCompletionStatusCLEANEXTRACTION:
		*s = HackingSessionCompleteResultCompletionStatusCLEANEXTRACTION
	case HackingSessionCompleteResultCompletionStatusTRACEDEXIT:
		*s = HackingSessionCompleteResultCompletionStatusTRACEDEXIT
	default:
		*s = HackingSessionCompleteResultCompletionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionCompleteResultCompletionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionCompleteResultCompletionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingSessionCompleteResultDataExtractedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingSessionCompleteResultDataExtractedDetails) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingSessionCompleteResultDataExtractedDetails from json.
func (s *HackingSessionCompleteResultDataExtractedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionCompleteResultDataExtractedDetails to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionCompleteResultDataExtractedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionCompleteResultDataExtractedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionCompleteResultDataExtractedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionCompleteResultFinalRiskAssessment as json.
func (s HackingSessionCompleteResultFinalRiskAssessment) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionCompleteResultFinalRiskAssessment from json.
func (s *HackingSessionCompleteResultFinalRiskAssessment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionCompleteResultFinalRiskAssessment to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionCompleteResultFinalRiskAssessment(v) {
	case HackingSessionCompleteResultFinalRiskAssessmentCLEAN:
		*s = HackingSessionCompleteResultFinalRiskAssessmentCLEAN
	case HackingSessionCompleteResultFinalRiskAssessmentMINORTRACES:
		*s = HackingSessionCompleteResultFinalRiskAssessmentMINORTRACES
	case HackingSessionCompleteResultFinalRiskAssessmentDETECTED:
		*s = HackingSessionCompleteResultFinalRiskAssessmentDETECTED
	case HackingSessionCompleteResultFinalRiskAssessmentFULLALERT:
		*s = HackingSessionCompleteResultFinalRiskAssessmentFULLALERT
	default:
		*s = HackingSessionCompleteResultFinalRiskAssessment(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionCompleteResultFinalRiskAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionCompleteResultFinalRiskAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingSessionCompleteResultMissionReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingSessionCompleteResultMissionReport) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingSessionCompleteResultMissionReport from json.
func (s *HackingSessionCompleteResultMissionReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionCompleteResultMissionReport to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionCompleteResultMissionReport")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionCompleteResultMissionReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionCompleteResultMissionReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.TargetType.Set {
			e.FieldStart("target_type")
			s.TargetType.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("risk_level")
		s.RiskLevel.Encode(e)
	}
	{
		if s.DetectionRisk.Set {
			e.FieldStart("detection_risk")
			s.DetectionRisk.Encode(e)
		}
	}
	{
		if s.NeuralLoad.Set {
			e.FieldStart("neural_load")
			s.NeuralLoad.Encode(e)
		}
	}
	{
		if s.SessionDuration.Set {
			e.FieldStart("session_duration")
			s.SessionDuration.Encode(e)
		}
	}
	{
		if s.IceEncounters != nil {
			e.FieldStart("ice_encounters")
			e.ArrStart()
			for _, elem := range s.IceEncounters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NetworkTopology.Set {
			e.FieldStart("network_topology")
			s.NetworkTopology.Encode(e)
		}
	}
	{
		if s.DataExtracted.Set {
			e.FieldStart("data_extracted")
			s.DataExtracted.Encode(e)
		}
	}
	{
		if s.ToolsUsed != nil {
			e.FieldStart("tools_used")
			e.ArrStart()
			for _, elem := range s.ToolsUsed {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfHackingSessionEntity = [19]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "player_id",
	6:  "target_id",
	7:  "target_type",
	8:  "status",
	9:  "risk_level",
	10: "detection_risk",
	11: "neural_load",
	12: "session_duration",
	13: "ice_encounters",
	14: "network_topology",
	15: "data_extracted",
	16: "tools_used",
	17: "start_time",
	18: "end_time",
}

// Decode decodes HackingSessionEntity from json.
func (s *HackingSessionEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntity to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "player_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "target_type":
			if err := func() error {
				s.TargetType.Reset()
				if err := s.TargetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_type\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "risk_level":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.RiskLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_level\"")
			}
		case "detection_risk":
			if err := func() error {
				s.DetectionRisk.Reset()
				if err := s.DetectionRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detection_risk\"")
			}
		case "neural_load":
			if err := func() error {
				s.NeuralLoad.Reset()
				if err := s.NeuralLoad.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_load\"")
			}
		case "session_duration":
			if err := func() error {
				s.SessionDuration.Reset()
				if err := s.SessionDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_duration\"")
			}
		case "ice_encounters":
			if err := func() error {
				s.IceEncounters = make([]ICEEncounter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ICEEncounter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IceEncounters = append(s.IceEncounters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_encounters\"")
			}
		case "network_topology":
			if err := func() error {
				s.NetworkTopology.Reset()
				if err := s.NetworkTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_topology\"")
			}
		case "data_extracted":
			if err := func() error {
				s.DataExtracted.Reset()
				if err := s.DataExtracted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted\"")
			}
		case "tools_used":
			if err := func() error {
				s.ToolsUsed = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ToolsUsed = append(s.ToolsUsed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools_used\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01100111,
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionEntity) {
					name = jsonFieldsNameOfHackingSessionEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingSessionEntityDataExtracted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingSessionEntityDataExtracted) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingSessionEntityDataExtracted from json.
func (s *HackingSessionEntityDataExtracted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntityDataExtracted to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionEntityDataExtracted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionEntityDataExtracted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntityDataExtracted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HackingSessionEntityNetworkTopology) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HackingSessionEntityNetworkTopology) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HackingSessionEntityNetworkTopology from json.
func (s *HackingSessionEntityNetworkTopology) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntityNetworkTopology to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionEntityNetworkTopology")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionEntityNetworkTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntityNetworkTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityRiskLevel as json.
func (s HackingSessionEntityRiskLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionEntityRiskLevel from json.
func (s *HackingSessionEntityRiskLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntityRiskLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionEntityRiskLevel(v) {
	case HackingSessionEntityRiskLevelLOW:
		*s = HackingSessionEntityRiskLevelLOW
	case HackingSessionEntityRiskLevelMEDIUM:
		*s = HackingSessionEntityRiskLevelMEDIUM
	case HackingSessionEntityRiskLevelHIGH:
		*s = HackingSessionEntityRiskLevelHIGH
	case HackingSessionEntityRiskLevelEXTREME:
		*s = HackingSessionEntityRiskLevelEXTREME
	default:
		*s = HackingSessionEntityRiskLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionEntityRiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntityRiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityStatus as json.
func (s HackingSessionEntityStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionEntityStatus from json.
func (s *HackingSessionEntityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntityStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionEntityStatus(v) {
	case HackingSessionEntityStatusINITIATING:
		*s = HackingSessionEntityStatusINITIATING
	case HackingSessionEntityStatusACTIVE:
		*s = HackingSessionEntityStatusACTIVE
	case HackingSessionEntityStatusCOMPLETED:
		*s = HackingSessionEntityStatusCOMPLETED
	case HackingSessionEntityStatusFAILED:
		*s = HackingSessionEntityStatusFAILED
	case HackingSessionEntityStatusABORTED:
		*s = HackingSessionEntityStatusABORTED
	default:
		*s = HackingSessionEntityStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionEntityStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntityStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityTargetType as json.
func (s HackingSessionEntityTargetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackingSessionEntityTargetType from json.
func (s *HackingSessionEntityTargetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionEntityTargetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackingSessionEntityTargetType(v) {
	case HackingSessionEntityTargetTypeCORPORATION:
		*s = HackingSessionEntityTargetTypeCORPORATION
	case HackingSessionEntityTargetTypePERSONAL:
		*s = HackingSessionEntityTargetTypePERSONAL
	case HackingSessionEntityTargetTypeGOVERNMENT:
		*s = HackingSessionEntityTargetTypeGOVERNMENT
	case HackingSessionEntityTargetTypeUNDERGROUND:
		*s = HackingSessionEntityTargetTypeUNDERGROUND
	default:
		*s = HackingSessionEntityTargetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackingSessionEntityTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionEntityTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfHackingSessionListResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes HackingSessionListResponse from json.
func (s *HackingSessionListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]HackingSessionEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HackingSessionEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionListResponse) {
					name = jsonFieldsNameOfHackingSessionListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionListResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionListResponseMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingSessionListResponseMeta = [5]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
	4: "processing_time_ms",
}

// Decode decodes HackingSessionListResponseMeta from json.
func (s *HackingSessionListResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionListResponseMeta to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionListResponseMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionListResponseMeta) {
					name = jsonFieldsNameOfHackingSessionListResponseMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionListResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionListResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingSessionResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes HackingSessionResponse from json.
func (s *HackingSessionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackingSessionResponse) {
					name = jsonFieldsNameOfHackingSessionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackingSessionResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackingSessionResponseMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackingSessionResponseMeta = [2]string{
	0: "version",
	1: "processing_time_ms",
}

// Decode decodes HackingSessionResponseMeta from json.
func (s *HackingSessionResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackingSessionResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackingSessionResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackingSessionResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackingSessionResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ICECountermeasureResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ICECountermeasureResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ice_id")
		json.EncodeUUID(e, s.IceID)
	}
	{
		e.FieldStart("countermeasure_type")
		s.CountermeasureType.Encode(e)
	}
	{
		e.FieldStart("effectiveness")
		e.Float32(s.Effectiveness)
	}
	{
		if s.IceStatusChange.Set {
			e.FieldStart("ice_status_change")
			s.IceStatusChange.Encode(e)
		}
	}
	{
		if s.DurationApplied.Set {
			e.FieldStart("duration_applied")
			s.DurationApplied.Encode(e)
		}
	}
	{
		if s.SideEffects != nil {
			e.FieldStart("side_effects")
			e.ArrStart()
			for _, elem := range s.SideEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfICECountermeasureResult = [6]string{
	0: "ice_id",
	1: "countermeasure_type",
	2: "effectiveness",
	3: "ice_status_change",
	4: "duration_applied",
	5: "side_effects",
}

// Decode decodes ICECountermeasureResult from json.
func (s *ICECountermeasureResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICECountermeasureResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ice_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.IceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_id\"")
			}
		case "countermeasure_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CountermeasureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countermeasure_type\"")
			}
		case "effectiveness":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Effectiveness = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effectiveness\"")
			}
		case "ice_status_change":
			if err := func() error {
				s.IceStatusChange.Reset()
				if err := s.IceStatusChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_status_change\"")
			}
		case "duration_applied":
			if err := func() error {
				s.DurationApplied.Reset()
				if err := s.DurationApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_applied\"")
			}
		case "side_effects":
			if err := func() error {
				s.SideEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SideEffects = append(s.SideEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side_effects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ICECountermeasureResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfICECountermeasureResult) {
					name = jsonFieldsNameOfICECountermeasureResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ICECountermeasureResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICECountermeasureResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICECountermeasureResultCountermeasureType as json.
func (s ICECountermeasureResultCountermeasureType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ICECountermeasureResultCountermeasureType from json.
func (s *ICECountermeasureResultCountermeasureType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICECountermeasureResultCountermeasureType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ICECountermeasureResultCountermeasureType(v) {
	case ICECountermeasureResultCountermeasureTypeDECOY:
		*s = ICECountermeasureResultCountermeasureTypeDECOY
	case ICECountermeasureResultCountermeasureTypeOVERLOAD:
		*s = ICECountermeasureResultCountermeasureTypeOVERLOAD
	case ICECountermeasureResultCountermeasureTypeNEURALSHIELD:
		*s = ICECountermeasureResultCountermeasureTypeNEURALSHIELD
	case ICECountermeasureResultCountermeasureTypeDATACORRUPTION:
		*s = ICECountermeasureResultCountermeasureTypeDATACORRUPTION
	case ICECountermeasureResultCountermeasureTypeSYSTEMCRASH:
		*s = ICECountermeasureResultCountermeasureTypeSYSTEMCRASH
	default:
		*s = ICECountermeasureResultCountermeasureType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ICECountermeasureResultCountermeasureType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICECountermeasureResultCountermeasureType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICECountermeasureResultIceStatusChange as json.
func (s ICECountermeasureResultIceStatusChange) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ICECountermeasureResultIceStatusChange from json.
func (s *ICECountermeasureResultIceStatusChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICECountermeasureResultIceStatusChange to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ICECountermeasureResultIceStatusChange(v) {
	case ICECountermeasureResultIceStatusChangeNEUTRALIZED:
		*s = ICECountermeasureResultIceStatusChangeNEUTRALIZED
	case ICECountermeasureResultIceStatusChangeWEAKENED:
		*s = ICECountermeasureResultIceStatusChangeWEAKENED
	case ICECountermeasureResultIceStatusChangeUNAFFECTED:
		*s = ICECountermeasureResultIceStatusChangeUNAFFECTED
	case ICECountermeasureResultIceStatusChangeESCALATED:
		*s = ICECountermeasureResultIceStatusChangeESCALATED
	default:
		*s = ICECountermeasureResultIceStatusChange(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ICECountermeasureResultIceStatusChange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICECountermeasureResultIceStatusChange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ICEEncounter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ICEEncounter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ice_id")
		json.EncodeUUID(e, s.IceID)
	}
	{
		e.FieldStart("ice_type")
		s.IceType.Encode(e)
	}
	{
		e.FieldStart("threat_level")
		s.ThreatLevel.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.DamagePotential.Set {
			e.FieldStart("damage_potential")
			s.DamagePotential.Encode(e)
		}
	}
	{
		if s.CountermeasuresApplied != nil {
			e.FieldStart("countermeasures_applied")
			e.ArrStart()
			for _, elem := range s.CountermeasuresApplied {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EncounterTime.Set {
			e.FieldStart("encounter_time")
			s.EncounterTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfICEEncounter = [7]string{
	0: "ice_id",
	1: "ice_type",
	2: "threat_level",
	3: "status",
	4: "damage_potential",
	5: "countermeasures_applied",
	6: "encounter_time",
}

// Decode decodes ICEEncounter from json.
func (s *ICEEncounter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICEEncounter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ice_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.IceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_id\"")
			}
		case "ice_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.IceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_type\"")
			}
		case "threat_level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ThreatLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threat_level\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "damage_potential":
			if err := func() error {
				s.DamagePotential.Reset()
				if err := s.DamagePotential.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_potential\"")
			}
		case "countermeasures_applied":
			if err := func() error {
				s.CountermeasuresApplied = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CountermeasuresApplied = append(s.CountermeasuresApplied, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countermeasures_applied\"")
			}
		case "encounter_time":
			if err := func() error {
				s.EncounterTime.Reset()
				if err := s.EncounterTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encounter_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ICEEncounter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfICEEncounter) {
					name = jsonFieldsNameOfICEEncounter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ICEEncounter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICEEncounter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICEEncounterIceType as json.
func (s ICEEncounterIceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ICEEncounterIceType from json.
func (s *ICEEncounterIceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICEEncounterIceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ICEEncounterIceType(v) {
	case ICEEncounterIceTypeSCORCHER:
		*s = ICEEncounterIceTypeSCORCHER
	case ICEEncounterIceTypeASP:
		*s = ICEEncounterIceTypeASP
	case ICEEncounterIceTypeCERBERUS:
		*s = ICEEncounterIceTypeCERBERUS
	case ICEEncounterIceTypeANGEL:
		*s = ICEEncounterIceTypeANGEL
	case ICEEncounterIceTypeJESTER:
		*s = ICEEncounterIceTypeJESTER
	case ICEEncounterIceTypeBARGHEST:
		*s = ICEEncounterIceTypeBARGHEST
	case ICEEncounterIceTypeRAVEN:
		*s = ICEEncounterIceTypeRAVEN
	default:
		*s = ICEEncounterIceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ICEEncounterIceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICEEncounterIceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICEEncounterStatus as json.
func (s ICEEncounterStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ICEEncounterStatus from json.
func (s *ICEEncounterStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICEEncounterStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ICEEncounterStatus(v) {
	case ICEEncounterStatusACTIVE:
		*s = ICEEncounterStatusACTIVE
	case ICEEncounterStatusNEUTRALIZED:
		*s = ICEEncounterStatusNEUTRALIZED
	case ICEEncounterStatusBYPASSED:
		*s = ICEEncounterStatusBYPASSED
	case ICEEncounterStatusESCALATING:
		*s = ICEEncounterStatusESCALATING
	default:
		*s = ICEEncounterStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ICEEncounterStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICEEncounterStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICEEncounterThreatLevel as json.
func (s ICEEncounterThreatLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ICEEncounterThreatLevel from json.
func (s *ICEEncounterThreatLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ICEEncounterThreatLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ICEEncounterThreatLevel(v) {
	case ICEEncounterThreatLevelLOW:
		*s = ICEEncounterThreatLevelLOW
	case ICEEncounterThreatLevelMEDIUM:
		*s = ICEEncounterThreatLevelMEDIUM
	case ICEEncounterThreatLevelHIGH:
		*s = ICEEncounterThreatLevelHIGH
	case ICEEncounterThreatLevelEXTREME:
		*s = ICEEncounterThreatLevelEXTREME
	default:
		*s = ICEEncounterThreatLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ICEEncounterThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ICEEncounterThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		if s.TargetType.Set {
			e.FieldStart("target_type")
			s.TargetType.Encode(e)
		}
	}
	{
		e.FieldStart("hacking_tools")
		e.ArrStart()
		for _, elem := range s.HackingTools {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.RiskTolerance.Set {
			e.FieldStart("risk_tolerance")
			s.RiskTolerance.Encode(e)
		}
	}
	{
		if s.SessionTimeout.Set {
			e.FieldStart("session_timeout")
			s.SessionTimeout.Encode(e)
		}
	}
	{
		if s.StealthMode.Set {
			e.FieldStart("stealth_mode")
			s.StealthMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateHackingRequest = [7]string{
	0: "player_id",
	1: "target_id",
	2: "target_type",
	3: "hacking_tools",
	4: "risk_tolerance",
	5: "session_timeout",
	6: "stealth_mode",
}

// Decode decodes InitiateHackingRequest from json.
func (s *InitiateHackingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "target_type":
			if err := func() error {
				s.TargetType.Reset()
				if err := s.TargetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_type\"")
			}
		case "hacking_tools":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.HackingTools = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.HackingTools = append(s.HackingTools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hacking_tools\"")
			}
		case "risk_tolerance":
			if err := func() error {
				s.RiskTolerance.Reset()
				if err := s.RiskTolerance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_tolerance\"")
			}
		case "session_timeout":
			if err := func() error {
				s.SessionTimeout.Reset()
				if err := s.SessionTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_timeout\"")
			}
		case "stealth_mode":
			if err := func() error {
				s.StealthMode.Reset()
				if err := s.StealthMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stealth_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateHackingRequest) {
					name = jsonFieldsNameOfInitiateHackingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateHackingRequestRiskTolerance as json.
func (s InitiateHackingRequestRiskTolerance) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateHackingRequestRiskTolerance from json.
func (s *InitiateHackingRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingRequestRiskTolerance to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateHackingRequestRiskTolerance(v) {
	case InitiateHackingRequestRiskToleranceLOW:
		*s = InitiateHackingRequestRiskToleranceLOW
	case InitiateHackingRequestRiskToleranceMEDIUM:
		*s = InitiateHackingRequestRiskToleranceMEDIUM
	case InitiateHackingRequestRiskToleranceHIGH:
		*s = InitiateHackingRequestRiskToleranceHIGH
	case InitiateHackingRequestRiskToleranceEXTREME:
		*s = InitiateHackingRequestRiskToleranceEXTREME
	default:
		*s = InitiateHackingRequestRiskTolerance(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateHackingRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateHackingRequestTargetType as json.
func (s InitiateHackingRequestTargetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateHackingRequestTargetType from json.
func (s *InitiateHackingRequestTargetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingRequestTargetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateHackingRequestTargetType(v) {
	case InitiateHackingRequestTargetTypeCORPORATION:
		*s = InitiateHackingRequestTargetTypeCORPORATION
	case InitiateHackingRequestTargetTypePERSONAL:
		*s = InitiateHackingRequestTargetTypePERSONAL
	case InitiateHackingRequestTargetTypeGOVERNMENT:
		*s = InitiateHackingRequestTargetTypeGOVERNMENT
	case InitiateHackingRequestTargetTypeUNDERGROUND:
		*s = InitiateHackingRequestTargetTypeUNDERGROUND
	default:
		*s = InitiateHackingRequestTargetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateHackingRequestTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingRequestTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateHackingSessionBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InitiateHackingSessionBadRequest from json.
func (s *InitiateHackingSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InitiateHackingSessionBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateHackingSessionBadRequest) {
					name = jsonFieldsNameOfInitiateHackingSessionBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitiateHackingSessionBadRequestDetails = [0]string{}

// Decode decodes InitiateHackingSessionBadRequestDetails from json.
func (s *InitiateHackingSessionBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateHackingSessionConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InitiateHackingSessionConflict from json.
func (s *InitiateHackingSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InitiateHackingSessionConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateHackingSessionConflict) {
					name = jsonFieldsNameOfInitiateHackingSessionConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitiateHackingSessionConflictDetails = [0]string{}

// Decode decodes InitiateHackingSessionConflictDetails from json.
func (s *InitiateHackingSessionConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateHackingSessionForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InitiateHackingSessionForbidden from json.
func (s *InitiateHackingSessionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InitiateHackingSessionForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateHackingSessionForbidden) {
					name = jsonFieldsNameOfInitiateHackingSessionForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitiateHackingSessionForbiddenDetails = [0]string{}

// Decode decodes InitiateHackingSessionForbiddenDetails from json.
func (s *InitiateHackingSessionForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateHackingSessionTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InitiateHackingSessionTooManyRequests from json.
func (s *InitiateHackingSessionTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InitiateHackingSessionTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateHackingSessionTooManyRequests) {
					name = jsonFieldsNameOfInitiateHackingSessionTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateHackingSessionTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateHackingSessionTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitiateHackingSessionTooManyRequestsDetails = [0]string{}

// Decode decodes InitiateHackingSessionTooManyRequestsDetails from json.
func (s *InitiateHackingSessionTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateHackingSessionTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitiateHackingSessionTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateHackingSessionTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateHackingSessionTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListHackingSessionsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListHackingSessionsBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfListHackingSessionsBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ListHackingSessionsBadRequest from json.
func (s *ListHackingSessionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHackingSessionsBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ListHackingSessionsBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListHackingSessionsBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListHackingSessionsBadRequest) {
					name = jsonFieldsNameOfListHackingSessionsBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListHackingSessionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHackingSessionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListHackingSessionsBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListHackingSessionsBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfListHackingSessionsBadRequestDetails = [0]string{}

// Decode decodes ListHackingSessionsBadRequestDetails from json.
func (s *ListHackingSessionsBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHackingSessionsBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ListHackingSessionsBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListHackingSessionsBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHackingSessionsBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListHackingSessionsTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListHackingSessionsTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfListHackingSessionsTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ListHackingSessionsTooManyRequests from json.
func (s *ListHackingSessionsTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHackingSessionsTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ListHackingSessionsTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListHackingSessionsTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListHackingSessionsTooManyRequests) {
					name = jsonFieldsNameOfListHackingSessionsTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListHackingSessionsTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHackingSessionsTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListHackingSessionsTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListHackingSessionsTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfListHackingSessionsTooManyRequestsDetails = [0]string{}

// Decode decodes ListHackingSessionsTooManyRequestsDetails from json.
func (s *ListHackingSessionsTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHackingSessionsTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ListHackingSessionsTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListHackingSessionsTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHackingSessionsTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkScanResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkScanResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("scan_id")
		json.EncodeUUID(e, s.ScanID)
	}
	{
		e.FieldStart("scan_depth")
		e.Int(s.ScanDepth)
	}
	{
		e.FieldStart("nodes_discovered")
		e.Int(s.NodesDiscovered)
	}
	{
		if s.VulnerabilitiesFound != nil {
			e.FieldStart("vulnerabilities_found")
			e.ArrStart()
			for _, elem := range s.VulnerabilitiesFound {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IcePresence != nil {
			e.FieldStart("ice_presence")
			e.ArrStart()
			for _, elem := range s.IcePresence {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AccessPoints != nil {
			e.FieldStart("access_points")
			e.ArrStart()
			for _, elem := range s.AccessPoints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RiskAssessment.Set {
			e.FieldStart("risk_assessment")
			s.RiskAssessment.Encode(e)
		}
	}
}

var jsonFieldsNameOfNetworkScanResult = [7]string{
	0: "scan_id",
	1: "scan_depth",
	2: "nodes_discovered",
	3: "vulnerabilities_found",
	4: "ice_presence",
	5: "access_points",
	6: "risk_assessment",
}

// Decode decodes NetworkScanResult from json.
func (s *NetworkScanResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scan_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ScanID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scan_id\"")
			}
		case "scan_depth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ScanDepth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scan_depth\"")
			}
		case "nodes_discovered":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.NodesDiscovered = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes_discovered\"")
			}
		case "vulnerabilities_found":
			if err := func() error {
				s.VulnerabilitiesFound = make([]NetworkScanResultVulnerabilitiesFoundItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkScanResultVulnerabilitiesFoundItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VulnerabilitiesFound = append(s.VulnerabilitiesFound, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vulnerabilities_found\"")
			}
		case "ice_presence":
			if err := func() error {
				s.IcePresence = make([]ICEEncounter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ICEEncounter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IcePresence = append(s.IcePresence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_presence\"")
			}
		case "access_points":
			if err := func() error {
				s.AccessPoints = make([]NetworkScanResultAccessPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkScanResultAccessPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessPoints = append(s.AccessPoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_points\"")
			}
		case "risk_assessment":
			if err := func() error {
				s.RiskAssessment.Reset()
				if err := s.RiskAssessment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_assessment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkScanResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkScanResult) {
					name = jsonFieldsNameOfNetworkScanResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkScanResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkScanResultAccessPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkScanResultAccessPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("node_id")
		json.EncodeUUID(e, s.NodeID)
	}
	{
		e.FieldStart("access_type")
		s.AccessType.Encode(e)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
}

var jsonFieldsNameOfNetworkScanResultAccessPointsItem = [3]string{
	0: "node_id",
	1: "access_type",
	2: "difficulty",
}

// Decode decodes NetworkScanResultAccessPointsItem from json.
func (s *NetworkScanResultAccessPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultAccessPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "access_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AccessType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_type\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkScanResultAccessPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkScanResultAccessPointsItem) {
					name = jsonFieldsNameOfNetworkScanResultAccessPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkScanResultAccessPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultAccessPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultAccessPointsItemAccessType as json.
func (s NetworkScanResultAccessPointsItemAccessType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultAccessPointsItemAccessType from json.
func (s *NetworkScanResultAccessPointsItemAccessType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultAccessPointsItemAccessType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultAccessPointsItemAccessType(v) {
	case NetworkScanResultAccessPointsItemAccessTypeDIRECT:
		*s = NetworkScanResultAccessPointsItemAccessTypeDIRECT
	case NetworkScanResultAccessPointsItemAccessTypeRELAY:
		*s = NetworkScanResultAccessPointsItemAccessTypeRELAY
	case NetworkScanResultAccessPointsItemAccessTypeBACKDOOR:
		*s = NetworkScanResultAccessPointsItemAccessTypeBACKDOOR
	case NetworkScanResultAccessPointsItemAccessTypeEXPLOIT:
		*s = NetworkScanResultAccessPointsItemAccessTypeEXPLOIT
	default:
		*s = NetworkScanResultAccessPointsItemAccessType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultAccessPointsItemAccessType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultAccessPointsItemAccessType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultAccessPointsItemDifficulty as json.
func (s NetworkScanResultAccessPointsItemDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultAccessPointsItemDifficulty from json.
func (s *NetworkScanResultAccessPointsItemDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultAccessPointsItemDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultAccessPointsItemDifficulty(v) {
	case NetworkScanResultAccessPointsItemDifficultyEASY:
		*s = NetworkScanResultAccessPointsItemDifficultyEASY
	case NetworkScanResultAccessPointsItemDifficultyMEDIUM:
		*s = NetworkScanResultAccessPointsItemDifficultyMEDIUM
	case NetworkScanResultAccessPointsItemDifficultyHARD:
		*s = NetworkScanResultAccessPointsItemDifficultyHARD
	case NetworkScanResultAccessPointsItemDifficultyEXTREME:
		*s = NetworkScanResultAccessPointsItemDifficultyEXTREME
	default:
		*s = NetworkScanResultAccessPointsItemDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultAccessPointsItemDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultAccessPointsItemDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkScanResultRiskAssessment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkScanResultRiskAssessment) encodeFields(e *jx.Encoder) {
	{
		if s.DetectionProbability.Set {
			e.FieldStart("detection_probability")
			s.DetectionProbability.Encode(e)
		}
	}
	{
		if s.AverageIceThreat.Set {
			e.FieldStart("average_ice_threat")
			s.AverageIceThreat.Encode(e)
		}
	}
	{
		if s.RecommendedApproach.Set {
			e.FieldStart("recommended_approach")
			s.RecommendedApproach.Encode(e)
		}
	}
}

var jsonFieldsNameOfNetworkScanResultRiskAssessment = [3]string{
	0: "detection_probability",
	1: "average_ice_threat",
	2: "recommended_approach",
}

// Decode decodes NetworkScanResultRiskAssessment from json.
func (s *NetworkScanResultRiskAssessment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultRiskAssessment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detection_probability":
			if err := func() error {
				s.DetectionProbability.Reset()
				if err := s.DetectionProbability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detection_probability\"")
			}
		case "average_ice_threat":
			if err := func() error {
				s.AverageIceThreat.Reset()
				if err := s.AverageIceThreat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_ice_threat\"")
			}
		case "recommended_approach":
			if err := func() error {
				s.RecommendedApproach.Reset()
				if err := s.RecommendedApproach.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommended_approach\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkScanResultRiskAssessment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkScanResultRiskAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultRiskAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultRiskAssessmentAverageIceThreat as json.
func (s NetworkScanResultRiskAssessmentAverageIceThreat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultRiskAssessmentAverageIceThreat from json.
func (s *NetworkScanResultRiskAssessmentAverageIceThreat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultRiskAssessmentAverageIceThreat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultRiskAssessmentAverageIceThreat(v) {
	case NetworkScanResultRiskAssessmentAverageIceThreatLOW:
		*s = NetworkScanResultRiskAssessmentAverageIceThreatLOW
	case NetworkScanResultRiskAssessmentAverageIceThreatMEDIUM:
		*s = NetworkScanResultRiskAssessmentAverageIceThreatMEDIUM
	case NetworkScanResultRiskAssessmentAverageIceThreatHIGH:
		*s = NetworkScanResultRiskAssessmentAverageIceThreatHIGH
	case NetworkScanResultRiskAssessmentAverageIceThreatEXTREME:
		*s = NetworkScanResultRiskAssessmentAverageIceThreatEXTREME
	default:
		*s = NetworkScanResultRiskAssessmentAverageIceThreat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultRiskAssessmentAverageIceThreat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultRiskAssessmentAverageIceThreat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultRiskAssessmentRecommendedApproach as json.
func (s NetworkScanResultRiskAssessmentRecommendedApproach) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultRiskAssessmentRecommendedApproach from json.
func (s *NetworkScanResultRiskAssessmentRecommendedApproach) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultRiskAssessmentRecommendedApproach to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultRiskAssessmentRecommendedApproach(v) {
	case NetworkScanResultRiskAssessmentRecommendedApproachSTEALTH:
		*s = NetworkScanResultRiskAssessmentRecommendedApproachSTEALTH
	case NetworkScanResultRiskAssessmentRecommendedApproachAGGRESSIVE:
		*s = NetworkScanResultRiskAssessmentRecommendedApproachAGGRESSIVE
	case NetworkScanResultRiskAssessmentRecommendedApproachMIXED:
		*s = NetworkScanResultRiskAssessmentRecommendedApproachMIXED
	default:
		*s = NetworkScanResultRiskAssessmentRecommendedApproach(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultRiskAssessmentRecommendedApproach) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultRiskAssessmentRecommendedApproach) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkScanResultVulnerabilitiesFoundItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkScanResultVulnerabilitiesFoundItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("node_id")
		json.EncodeUUID(e, s.NodeID)
	}
	{
		e.FieldStart("vulnerability_type")
		s.VulnerabilityType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
}

var jsonFieldsNameOfNetworkScanResultVulnerabilitiesFoundItem = [3]string{
	0: "node_id",
	1: "vulnerability_type",
	2: "severity",
}

// Decode decodes NetworkScanResultVulnerabilitiesFoundItem from json.
func (s *NetworkScanResultVulnerabilitiesFoundItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultVulnerabilitiesFoundItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "vulnerability_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.VulnerabilityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vulnerability_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkScanResultVulnerabilitiesFoundItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkScanResultVulnerabilitiesFoundItem) {
					name = jsonFieldsNameOfNetworkScanResultVulnerabilitiesFoundItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkScanResultVulnerabilitiesFoundItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultVulnerabilitiesFoundItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultVulnerabilitiesFoundItemSeverity as json.
func (s NetworkScanResultVulnerabilitiesFoundItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultVulnerabilitiesFoundItemSeverity from json.
func (s *NetworkScanResultVulnerabilitiesFoundItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultVulnerabilitiesFoundItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultVulnerabilitiesFoundItemSeverity(v) {
	case NetworkScanResultVulnerabilitiesFoundItemSeverityLOW:
		*s = NetworkScanResultVulnerabilitiesFoundItemSeverityLOW
	case NetworkScanResultVulnerabilitiesFoundItemSeverityMEDIUM:
		*s = NetworkScanResultVulnerabilitiesFoundItemSeverityMEDIUM
	case NetworkScanResultVulnerabilitiesFoundItemSeverityHIGH:
		*s = NetworkScanResultVulnerabilitiesFoundItemSeverityHIGH
	case NetworkScanResultVulnerabilitiesFoundItemSeverityCRITICAL:
		*s = NetworkScanResultVulnerabilitiesFoundItemSeverityCRITICAL
	default:
		*s = NetworkScanResultVulnerabilitiesFoundItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultVulnerabilitiesFoundItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultVulnerabilitiesFoundItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType as json.
func (s NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType from json.
func (s *NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType(v) {
	case NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeWEAKENCRYPTION:
		*s = NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeWEAKENCRYPTION
	case NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeOUTDATEDICE:
		*s = NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeOUTDATEDICE
	case NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeCONFIGERROR:
		*s = NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeCONFIGERROR
	case NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeBACKDOOR:
		*s = NetworkScanResultVulnerabilitiesFoundItemVulnerabilityTypeBACKDOOR
	default:
		*s = NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkScanResultVulnerabilitiesFoundItemVulnerabilityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes ExecuteHackingRequestParameters as json.
func (o OptExecuteHackingRequestParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExecuteHackingRequestParameters from json.
func (o *OptExecuteHackingRequestParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExecuteHackingRequestParameters to nil")
	}
	o.Set = true
	o.Value = make(ExecuteHackingRequestParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExecuteHackingRequestParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExecuteHackingRequestParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExecuteHackingRequestPriority as json.
func (o OptExecuteHackingRequestPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExecuteHackingRequestPriority from json.
func (o *OptExecuteHackingRequestPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExecuteHackingRequestPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExecuteHackingRequestPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExecuteHackingRequestPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingExecutionResultDataExtracted as json.
func (o OptHackingExecutionResultDataExtracted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingExecutionResultDataExtracted from json.
func (o *OptHackingExecutionResultDataExtracted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingExecutionResultDataExtracted to nil")
	}
	o.Set = true
	o.Value = make(HackingExecutionResultDataExtracted)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingExecutionResultDataExtracted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingExecutionResultDataExtracted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionAbortResultPartialResults as json.
func (o OptHackingSessionAbortResultPartialResults) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionAbortResultPartialResults from json.
func (o *OptHackingSessionAbortResultPartialResults) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionAbortResultPartialResults to nil")
	}
	o.Set = true
	o.Value = make(HackingSessionAbortResultPartialResults)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionAbortResultPartialResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionAbortResultPartialResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionCompleteResultDataExtractedDetails as json.
func (o OptHackingSessionCompleteResultDataExtractedDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionCompleteResultDataExtractedDetails from json.
func (o *OptHackingSessionCompleteResultDataExtractedDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionCompleteResultDataExtractedDetails to nil")
	}
	o.Set = true
	o.Value = make(HackingSessionCompleteResultDataExtractedDetails)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionCompleteResultDataExtractedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionCompleteResultDataExtractedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionCompleteResultFinalRiskAssessment as json.
func (o OptHackingSessionCompleteResultFinalRiskAssessment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HackingSessionCompleteResultFinalRiskAssessment from json.
func (o *OptHackingSessionCompleteResultFinalRiskAssessment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionCompleteResultFinalRiskAssessment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionCompleteResultFinalRiskAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionCompleteResultFinalRiskAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionCompleteResultMissionReport as json.
func (o OptHackingSessionCompleteResultMissionReport) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionCompleteResultMissionReport from json.
func (o *OptHackingSessionCompleteResultMissionReport) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionCompleteResultMissionReport to nil")
	}
	o.Set = true
	o.Value = make(HackingSessionCompleteResultMissionReport)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionCompleteResultMissionReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionCompleteResultMissionReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityDataExtracted as json.
func (o OptHackingSessionEntityDataExtracted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionEntityDataExtracted from json.
func (o *OptHackingSessionEntityDataExtracted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionEntityDataExtracted to nil")
	}
	o.Set = true
	o.Value = make(HackingSessionEntityDataExtracted)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionEntityDataExtracted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionEntityDataExtracted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityNetworkTopology as json.
func (o OptHackingSessionEntityNetworkTopology) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionEntityNetworkTopology from json.
func (o *OptHackingSessionEntityNetworkTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionEntityNetworkTopology to nil")
	}
	o.Set = true
	o.Value = make(HackingSessionEntityNetworkTopology)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionEntityNetworkTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionEntityNetworkTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionEntityTargetType as json.
func (o OptHackingSessionEntityTargetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HackingSessionEntityTargetType from json.
func (o *OptHackingSessionEntityTargetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionEntityTargetType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionEntityTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionEntityTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackingSessionResponseMeta as json.
func (o OptHackingSessionResponseMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HackingSessionResponseMeta from json.
func (o *OptHackingSessionResponseMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackingSessionResponseMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackingSessionResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackingSessionResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ICECountermeasureResultIceStatusChange as json.
func (o OptICECountermeasureResultIceStatusChange) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ICECountermeasureResultIceStatusChange from json.
func (o *OptICECountermeasureResultIceStatusChange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptICECountermeasureResultIceStatusChange to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptICECountermeasureResultIceStatusChange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptICECountermeasureResultIceStatusChange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateHackingRequestRiskTolerance as json.
func (o OptInitiateHackingRequestRiskTolerance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateHackingRequestRiskTolerance from json.
func (o *OptInitiateHackingRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateHackingRequestRiskTolerance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateHackingRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateHackingRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateHackingRequestTargetType as json.
func (o OptInitiateHackingRequestTargetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateHackingRequestTargetType from json.
func (o *OptInitiateHackingRequestTargetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateHackingRequestTargetType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateHackingRequestTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateHackingRequestTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultRiskAssessment as json.
func (o OptNetworkScanResultRiskAssessment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NetworkScanResultRiskAssessment from json.
func (o *OptNetworkScanResultRiskAssessment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkScanResultRiskAssessment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkScanResultRiskAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkScanResultRiskAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultRiskAssessmentAverageIceThreat as json.
func (o OptNetworkScanResultRiskAssessmentAverageIceThreat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NetworkScanResultRiskAssessmentAverageIceThreat from json.
func (o *OptNetworkScanResultRiskAssessmentAverageIceThreat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkScanResultRiskAssessmentAverageIceThreat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkScanResultRiskAssessmentAverageIceThreat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkScanResultRiskAssessmentAverageIceThreat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkScanResultRiskAssessmentRecommendedApproach as json.
func (o OptNetworkScanResultRiskAssessmentRecommendedApproach) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NetworkScanResultRiskAssessmentRecommendedApproach from json.
func (o *OptNetworkScanResultRiskAssessmentRecommendedApproach) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkScanResultRiskAssessmentRecommendedApproach to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkScanResultRiskAssessmentRecommendedApproach) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkScanResultRiskAssessmentRecommendedApproach) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHackingSessionRequestMetadata as json.
func (o OptUpdateHackingSessionRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateHackingSessionRequestMetadata from json.
func (o *OptUpdateHackingSessionRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHackingSessionRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHackingSessionRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHackingSessionRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHackingSessionRequestRiskTolerance as json.
func (o OptUpdateHackingSessionRequestRiskTolerance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHackingSessionRequestRiskTolerance from json.
func (o *OptUpdateHackingSessionRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHackingSessionRequestRiskTolerance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHackingSessionRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHackingSessionRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformNetworkScanBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformNetworkScanBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfPerformNetworkScanBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes PerformNetworkScanBadRequest from json.
func (s *PerformNetworkScanBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformNetworkScanBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem PerformNetworkScanBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PerformNetworkScanBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPerformNetworkScanBadRequest) {
					name = jsonFieldsNameOfPerformNetworkScanBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformNetworkScanBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformNetworkScanBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformNetworkScanBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformNetworkScanBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPerformNetworkScanBadRequestDetails = [0]string{}

// Decode decodes PerformNetworkScanBadRequestDetails from json.
func (s *PerformNetworkScanBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformNetworkScanBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PerformNetworkScanBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformNetworkScanBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformNetworkScanBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformNetworkScanConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformNetworkScanConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfPerformNetworkScanConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes PerformNetworkScanConflict from json.
func (s *PerformNetworkScanConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformNetworkScanConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem PerformNetworkScanConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PerformNetworkScanConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPerformNetworkScanConflict) {
					name = jsonFieldsNameOfPerformNetworkScanConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformNetworkScanConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformNetworkScanConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformNetworkScanConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformNetworkScanConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPerformNetworkScanConflictDetails = [0]string{}

// Decode decodes PerformNetworkScanConflictDetails from json.
func (s *PerformNetworkScanConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformNetworkScanConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PerformNetworkScanConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformNetworkScanConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformNetworkScanConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateHackingSessionBadRequest from json.
func (s *UpdateHackingSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateHackingSessionBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHackingSessionBadRequest) {
					name = jsonFieldsNameOfUpdateHackingSessionBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateHackingSessionBadRequestDetails = [0]string{}

// Decode decodes UpdateHackingSessionBadRequestDetails from json.
func (s *UpdateHackingSessionBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateHackingSessionConflict from json.
func (s *UpdateHackingSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateHackingSessionConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHackingSessionConflict) {
					name = jsonFieldsNameOfUpdateHackingSessionConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateHackingSessionConflictDetails = [0]string{}

// Decode decodes UpdateHackingSessionConflictDetails from json.
func (s *UpdateHackingSessionConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateHackingSessionNotFound from json.
func (s *UpdateHackingSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateHackingSessionNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHackingSessionNotFound) {
					name = jsonFieldsNameOfUpdateHackingSessionNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateHackingSessionNotFoundDetails = [0]string{}

// Decode decodes UpdateHackingSessionNotFoundDetails from json.
func (s *UpdateHackingSessionNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.RiskTolerance.Set {
			e.FieldStart("risk_tolerance")
			s.RiskTolerance.Encode(e)
		}
	}
	{
		if s.AddTools != nil {
			e.FieldStart("add_tools")
			e.ArrStart()
			for _, elem := range s.AddTools {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveTools != nil {
			e.FieldStart("remove_tools")
			e.ArrStart()
			for _, elem := range s.RemoveTools {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StealthMode.Set {
			e.FieldStart("stealth_mode")
			s.StealthMode.Encode(e)
		}
	}
	{
		if s.ExtendTimeout.Set {
			e.FieldStart("extend_timeout")
			s.ExtendTimeout.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionRequest = [8]string{
	0: "id",
	1: "version",
	2: "metadata",
	3: "risk_tolerance",
	4: "add_tools",
	5: "remove_tools",
	6: "stealth_mode",
	7: "extend_timeout",
}

// Decode decodes UpdateHackingSessionRequest from json.
func (s *UpdateHackingSessionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "risk_tolerance":
			if err := func() error {
				s.RiskTolerance.Reset()
				if err := s.RiskTolerance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_tolerance\"")
			}
		case "add_tools":
			if err := func() error {
				s.AddTools = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AddTools = append(s.AddTools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_tools\"")
			}
		case "remove_tools":
			if err := func() error {
				s.RemoveTools = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.RemoveTools = append(s.RemoveTools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_tools\"")
			}
		case "stealth_mode":
			if err := func() error {
				s.StealthMode.Reset()
				if err := s.StealthMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stealth_mode\"")
			}
		case "extend_timeout":
			if err := func() error {
				s.ExtendTimeout.Reset()
				if err := s.ExtendTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extend_timeout\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHackingSessionRequest) {
					name = jsonFieldsNameOfUpdateHackingSessionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionRequestMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionRequestMetadata = [2]string{
	0: "updated_by",
	1: "reason",
}

// Decode decodes UpdateHackingSessionRequestMetadata from json.
func (s *UpdateHackingSessionRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHackingSessionRequestRiskTolerance as json.
func (s UpdateHackingSessionRequestRiskTolerance) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHackingSessionRequestRiskTolerance from json.
func (s *UpdateHackingSessionRequestRiskTolerance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionRequestRiskTolerance to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHackingSessionRequestRiskTolerance(v) {
	case UpdateHackingSessionRequestRiskToleranceLOW:
		*s = UpdateHackingSessionRequestRiskToleranceLOW
	case UpdateHackingSessionRequestRiskToleranceMEDIUM:
		*s = UpdateHackingSessionRequestRiskToleranceMEDIUM
	case UpdateHackingSessionRequestRiskToleranceHIGH:
		*s = UpdateHackingSessionRequestRiskToleranceHIGH
	case UpdateHackingSessionRequestRiskToleranceEXTREME:
		*s = UpdateHackingSessionRequestRiskToleranceEXTREME
	default:
		*s = UpdateHackingSessionRequestRiskTolerance(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHackingSessionRequestRiskTolerance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionRequestRiskTolerance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHackingSessionTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateHackingSessionTooManyRequests from json.
func (s *UpdateHackingSessionTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateHackingSessionTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHackingSessionTooManyRequests) {
					name = jsonFieldsNameOfUpdateHackingSessionTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHackingSessionTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHackingSessionTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateHackingSessionTooManyRequestsDetails = [0]string{}

// Decode decodes UpdateHackingSessionTooManyRequestsDetails from json.
func (s *UpdateHackingSessionTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHackingSessionTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHackingSessionTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHackingSessionTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHackingSessionTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.MessageTimestamp.Set {
			e.FieldStart("message_timestamp")
			s.MessageTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("health")
		s.Health.Encode(e)
	}
}

var jsonFieldsNameOfWebSocketHealthMessage = [4]string{
	0: "type",
	1: "timestamp",
	2: "message_timestamp",
	3: "health",
}

// Decode decodes WebSocketHealthMessage from json.
func (s *WebSocketHealthMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "message_timestamp":
			if err := func() error {
				s.MessageTimestamp.Reset()
				if err := s.MessageTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_timestamp\"")
			}
		case "health":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Health.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessage) {
					name = jsonFieldsNameOfWebSocketHealthMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessageHealth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessageHealth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebSocketHealthMessageHealth = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes WebSocketHealthMessageHealth from json.
func (s *WebSocketHealthMessageHealth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessageHealth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessageHealth) {
					name = jsonFieldsNameOfWebSocketHealthMessageHealth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessageHealth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageHealthStatus as json.
func (s WebSocketHealthMessageHealthStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageHealthStatus from json.
func (s *WebSocketHealthMessageHealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealthStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageHealthStatus(v) {
	case WebSocketHealthMessageHealthStatusHealthy:
		*s = WebSocketHealthMessageHealthStatusHealthy
	case WebSocketHealthMessageHealthStatusDegraded:
		*s = WebSocketHealthMessageHealthStatusDegraded
	case WebSocketHealthMessageHealthStatusUnhealthy:
		*s = WebSocketHealthMessageHealthStatusUnhealthy
	default:
		*s = WebSocketHealthMessageHealthStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageHealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageType as json.
func (s WebSocketHealthMessageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageType from json.
func (s *WebSocketHealthMessageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageType(v) {
	case WebSocketHealthMessageTypeHealthUpdate:
		*s = WebSocketHealthMessageTypeHealthUpdate
	case WebSocketHealthMessageTypeHealthAlert:
		*s = WebSocketHealthMessageTypeHealthAlert
	case WebSocketHealthMessageTypeServiceDown:
		*s = WebSocketHealthMessageTypeServiceDown
	default:
		*s = WebSocketHealthMessageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
