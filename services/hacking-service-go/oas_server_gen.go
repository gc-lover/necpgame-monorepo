// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
)

// Handler handles operations described by OpenAPI v3 specification.
type Handler interface {
	// AbortHackingSession implements abortHackingSession operation.
	//
	// **Emergency session termination**
	// Immediately terminates hacking session with emergency shutdown protocols. Preserves session data
	// and generates incident report.
	// **High-Risk Operation:** May trigger ICE countermeasures.
	//
	// DELETE /hacking/sessions/{session_id}
	AbortHackingSession(ctx context.Context, params AbortHackingSessionParams) (AbortHackingSessionRes, error)
	// CompleteHackingSession implements completeHackingSession operation.
	//
	// **Session completion**
	// Finalizes successful hacking operation, extracts all data, and safely disconnects from target
	// network.
	// **Critical Operation:** Proper disconnection prevents traces.
	//
	// POST /hacking/sessions/{session_id}/complete
	CompleteHackingSession(ctx context.Context, req *CompleteHackingRequest, params CompleteHackingSessionParams) (CompleteHackingSessionRes, error)
	// DeployICECountermeasure implements deployICECountermeasure operation.
	//
	// **ICE defense operation**
	// Deploys countermeasures against specific ICE instance. Requires appropriate hacking tools and
	// neural capacity.
	// **Specialized Operation:** Tool and implant dependent.
	//
	// POST /hacking/sessions/{session_id}/ice/{ice_id}/counter
	DeployICECountermeasure(ctx context.Context, req *DeployICECountermeasureRequest, params DeployICECountermeasureParams) (DeployICECountermeasureRes, error)
	// ExecuteHackingOperation implements executeHackingOperation operation.
	//
	// **Core hacking execution**
	// Performs actual hacking operation: ICE penetration, data extraction, system manipulation.
	// Real-time risk monitoring and countermeasures.
	// **Critical Operation:** High neural load, risk of detection.
	//
	// POST /hacking/sessions/{session_id}/execute
	ExecuteHackingOperation(ctx context.Context, req *ExecuteHackingRequest, params ExecuteHackingOperationParams) (ExecuteHackingOperationRes, error)
	// GetHackingSession implements getHackingSession operation.
	//
	// **Enterprise-grade session retrieval**
	// Returns comprehensive hacking session information including real-time status, ICE encounters,
	// network topology, and risk metrics.
	// **Performance:** <5ms P95 with Redis caching.
	//
	// GET /hacking/sessions/{session_id}
	GetHackingSession(ctx context.Context, params GetHackingSessionParams) (GetHackingSessionRes, error)
	// HackingDomainBatchHealthCheck implements hackingDomainBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple domain health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	HackingDomainBatchHealthCheck(ctx context.Context, req *HackingDomainBatchHealthCheckReq) (HackingDomainBatchHealthCheckRes, error)
	// HackingDomainHealthCheck implements hackingDomainHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the hacking domain microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	HackingDomainHealthCheck(ctx context.Context, params HackingDomainHealthCheckParams) (HackingDomainHealthCheckRes, error)
	// HackingDomainHealthWebSocket implements hackingDomainHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	HackingDomainHealthWebSocket(ctx context.Context, params HackingDomainHealthWebSocketParams) (HackingDomainHealthWebSocketRes, error)
	// InitiateHackingSession implements initiateHackingSession operation.
	//
	// **Enterprise-grade hacking session initiation**
	// Creates secure hacking session with risk assessment, neural validation, and ICE detection.
	// Initializes all security protocols and monitoring.
	// **Critical Operation:** Requires full neural link verification.
	//
	// POST /hacking/sessions
	InitiateHackingSession(ctx context.Context, req *InitiateHackingRequest) (InitiateHackingSessionRes, error)
	// ListHackingSessions implements listHackingSessions operation.
	//
	// **Enterprise-grade session listing**
	// Lists active and historical hacking sessions with comprehensive filtering by status, target, risk
	// level, and time range.
	// **Performance:** <10ms P95, supports complex queries.
	//
	// GET /hacking/sessions
	ListHackingSessions(ctx context.Context, params ListHackingSessionsParams) (ListHackingSessionsRes, error)
	// PerformNetworkScan implements performNetworkScan operation.
	//
	// **Network reconnaissance**
	// Scans target network for vulnerabilities, ICE presence, and access points. Builds network topology
	// map for strategic planning.
	// **Intelligence Operation:** Provides critical mission data.
	//
	// POST /hacking/sessions/{session_id}/network/scan
	PerformNetworkScan(ctx context.Context, params PerformNetworkScanParams) (PerformNetworkScanRes, error)
	// UpdateHackingSession implements updateHackingSession operation.
	//
	// **Enterprise-grade session update**
	// Updates session parameters, risk tolerance, or defensive measures. Supports optimistic locking for
	// concurrent modifications.
	// **Performance:** <25ms P95, includes validation and conflict resolution.
	//
	// PUT /hacking/sessions/{session_id}
	UpdateHackingSession(ctx context.Context, req *UpdateHackingSessionRequest, params UpdateHackingSessionParams) (UpdateHackingSessionRes, error)
	// NewError creates *ErrRespStatusCode from error returned by handler.
	//
	// Used for common default response.
	NewError(ctx context.Context, err error) *ErrRespStatusCode
}

// Server implements http server based on OpenAPI v3 specification and
// calls Handler to handle requests.
type Server struct {
	h   Handler
	sec SecurityHandler
	baseServer
}

// NewServer creates new Server.
func NewServer(h Handler, sec SecurityHandler, opts ...ServerOption) (*Server, error) {
	s, err := newServerConfig(opts...).baseServer()
	if err != nil {
		return nil, err
	}
	return &Server{
		h:          h,
		sec:        sec,
		baseServer: s,
	}, nil
}
