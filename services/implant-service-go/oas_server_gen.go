// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
)

// Handler handles operations described by OpenAPI v3 specification.
type Handler interface {
	// ActivateImplant implements activateImplant operation.
	//
	// **Neural activation endpoint**
	// Initiates neural synchronization and power-up sequence. Validates system stability and neural
	// compatibility.
	// **Critical Operation:** Requires neural link verification.
	//
	// POST /implants/{implant_id}/activate
	ActivateImplant(ctx context.Context, req *ActivateImplantRequest, params ActivateImplantParams) (ActivateImplantRes, error)
	// DeactivateImplant implements deactivateImplant operation.
	//
	// **Safe deactivation endpoint**
	// Performs controlled shutdown and neural disconnection. Preserves implant integrity and system
	// stability.
	//
	// POST /implants/{implant_id}/deactivate
	DeactivateImplant(ctx context.Context, params DeactivateImplantParams) (DeactivateImplantRes, error)
	// GetImplant implements getImplant operation.
	//
	// **Enterprise-grade retrieval endpoint**
	// Optimized with proper caching strategies and database indexing.
	// Supports conditional requests with ETags.
	// **Performance:** <5ms P95 with Redis caching.
	//
	// GET /implants/{implant_id}
	GetImplant(ctx context.Context, params GetImplantParams) (GetImplantRes, error)
	// GetImplantDiagnostics implements getImplantDiagnostics operation.
	//
	// **System health monitoring**
	// Provides comprehensive implant status, neural connectivity, and performance metrics for
	// maintenance and troubleshooting.
	//
	// GET /implants/{implant_id}/diagnostics
	GetImplantDiagnostics(ctx context.Context, params GetImplantDiagnosticsParams) (GetImplantDiagnosticsRes, error)
	// ImplantDomainBatchHealthCheck implements implantDomainBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple domain health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	ImplantDomainBatchHealthCheck(ctx context.Context, req *ImplantDomainBatchHealthCheckReq) (ImplantDomainBatchHealthCheckRes, error)
	// ImplantDomainHealthCheck implements implantDomainHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the implant domain microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	ImplantDomainHealthCheck(ctx context.Context, params ImplantDomainHealthCheckParams) (ImplantDomainHealthCheckRes, error)
	// ImplantDomainHealthWebSocket implements implantDomainHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	ImplantDomainHealthWebSocket(ctx context.Context, params ImplantDomainHealthWebSocketParams) (ImplantDomainHealthWebSocketRes, error)
	// InstallImplant implements installImplant operation.
	//
	// **Enterprise-grade installation endpoint**
	// Validates neural compatibility, checks system capacity, and ensures safe integration with existing
	// cyberware.
	// Supports optimistic locking for concurrent operations.
	// **Performance:** <50ms P95, includes validation and neural sync.
	//
	// POST /implants
	InstallImplant(ctx context.Context, req *InstallImplantRequest) (InstallImplantRes, error)
	// ListImplants implements listImplants operation.
	//
	// **Enterprise-grade listing endpoint**
	// Supports complex filtering by category, tier, status, and neural compatibility.
	// Optimized for high-throughput scenarios with proper indexing.
	// **Performance:** <10ms P95, supports 1000+ concurrent requests.
	//
	// GET /implants
	ListImplants(ctx context.Context, params ListImplantsParams) (ListImplantsRes, error)
	// RemoveImplant implements removeImplant operation.
	//
	// **Enterprise-grade removal endpoint**
	// Supports soft deletes with audit trails and cleanup scheduling.
	// Ensures referential integrity and cascading cleanup.
	// **Performance:** <15ms P95, includes cleanup operations.
	//
	// DELETE /implants/{implant_id}
	RemoveImplant(ctx context.Context, params RemoveImplantParams) (RemoveImplantRes, error)
	// SyncNeuralLink implements syncNeuralLink operation.
	//
	// **Neural synchronization endpoint**
	// Performs full neural interface calibration and synchronization. Critical for implant functionality
	// and player neural health.
	// **High-Risk Operation:** May cause temporary neural feedback.
	//
	// POST /neural-links/{player_id}/sync
	SyncNeuralLink(ctx context.Context, req *NeuralSyncRequest, params SyncNeuralLinkParams) (SyncNeuralLinkRes, error)
	// UpdateImplant implements updateImplant operation.
	//
	// **Enterprise-grade update endpoint**
	// Supports partial updates, optimistic locking, and audit trails.
	// Ensures data consistency with event sourcing patterns.
	// **Performance:** <25ms P95, includes validation and conflict resolution.
	//
	// PUT /implants/{implant_id}
	UpdateImplant(ctx context.Context, req *UpdateImplantRequest, params UpdateImplantParams) (UpdateImplantRes, error)
	// UpgradeImplant implements upgradeImplant operation.
	//
	// **Tier progression endpoint**
	// Performs firmware upgrade and hardware enhancement. Requires compatible upgrade materials and
	// neural recalibration.
	// **Risk Operation:** May cause temporary neural disruption.
	//
	// POST /implants/{implant_id}/upgrade
	UpgradeImplant(ctx context.Context, req *UpgradeImplantRequest, params UpgradeImplantParams) (UpgradeImplantRes, error)
	// NewError creates *ErrorStatusCode from error returned by handler.
	//
	// Used for common default response.
	NewError(ctx context.Context, err error) *ErrorStatusCode
}

// Server implements http server based on OpenAPI v3 specification and
// calls Handler to handle requests.
type Server struct {
	h   Handler
	sec SecurityHandler
	baseServer
}

// NewServer creates new Server.
func NewServer(h Handler, sec SecurityHandler, opts ...ServerOption) (*Server, error) {
	s, err := newServerConfig(opts...).baseServer()
	if err != nil {
		return nil, err
	}
	return &Server{
		h:          h,
		sec:        sec,
		baseServer: s,
	}, nil
}
