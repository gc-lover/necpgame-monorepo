// Code generated by ogen, DO NOT EDIT.

package main

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AITerminal) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AITerminal) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.AiType.Set {
			e.FieldStart("ai_type")
			s.AiType.Encode(e)
		}
	}
	{
		if s.AccessLevel.Set {
			e.FieldStart("access_level")
			s.AccessLevel.Encode(e)
		}
	}
	{
		if s.DataValue.Set {
			e.FieldStart("data_value")
			s.DataValue.Encode(e)
		}
	}
	{
		if s.IceProtection.Set {
			e.FieldStart("ice_protection")
			s.IceProtection.Encode(e)
		}
	}
}

var jsonFieldsNameOfAITerminal = [5]string{
	0: "object_id",
	1: "ai_type",
	2: "access_level",
	3: "data_value",
	4: "ice_protection",
}

// Decode decodes AITerminal from json.
func (s *AITerminal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AITerminal to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "ai_type":
			if err := func() error {
				s.AiType.Reset()
				if err := s.AiType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai_type\"")
			}
		case "access_level":
			if err := func() error {
				s.AccessLevel.Reset()
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_level\"")
			}
		case "data_value":
			if err := func() error {
				s.DataValue.Reset()
				if err := s.DataValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_value\"")
			}
		case "ice_protection":
			if err := func() error {
				s.IceProtection.Reset()
				if err := s.IceProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_protection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AITerminal")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AITerminal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AITerminal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AITerminalAccessLevel as json.
func (s AITerminalAccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AITerminalAccessLevel from json.
func (s *AITerminalAccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AITerminalAccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AITerminalAccessLevel(v) {
	case AITerminalAccessLevelPublic:
		*s = AITerminalAccessLevelPublic
	case AITerminalAccessLevelRestricted:
		*s = AITerminalAccessLevelRestricted
	case AITerminalAccessLevelClassified:
		*s = AITerminalAccessLevelClassified
	case AITerminalAccessLevelTopSecret:
		*s = AITerminalAccessLevelTopSecret
	default:
		*s = AITerminalAccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AITerminalAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AITerminalAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AITerminalAiType as json.
func (s AITerminalAiType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AITerminalAiType from json.
func (s *AITerminalAiType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AITerminalAiType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AITerminalAiType(v) {
	case AITerminalAiTypeResearchAi:
		*s = AITerminalAiTypeResearchAi
	case AITerminalAiTypeSecurityAi:
		*s = AITerminalAiTypeSecurityAi
	case AITerminalAiTypeExperimentalAi:
		*s = AITerminalAiTypeExperimentalAi
	default:
		*s = AITerminalAiType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AITerminalAiType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AITerminalAiType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AirportObjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AirportObjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.AirportID.Set {
			e.FieldStart("airport_id")
			s.AirportID.Encode(e)
		}
	}
	{
		if s.Terminals != nil {
			e.FieldStart("terminals")
			e.ArrStart()
			for _, elem := range s.Terminals {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecuritySystems != nil {
			e.FieldStart("security_systems")
			e.ArrStart()
			for _, elem := range s.SecuritySystems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StorageContainers != nil {
			e.FieldStart("storage_containers")
			e.ArrStart()
			for _, elem := range s.StorageContainers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SurveillanceCameras != nil {
			e.FieldStart("surveillance_cameras")
			e.ArrStart()
			for _, elem := range s.SurveillanceCameras {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAirportObjectsResponse = [5]string{
	0: "airport_id",
	1: "terminals",
	2: "security_systems",
	3: "storage_containers",
	4: "surveillance_cameras",
}

// Decode decodes AirportObjectsResponse from json.
func (s *AirportObjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AirportObjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "airport_id":
			if err := func() error {
				s.AirportID.Reset()
				if err := s.AirportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"airport_id\"")
			}
		case "terminals":
			if err := func() error {
				s.Terminals = make([]AirportTerminal, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AirportTerminal
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Terminals = append(s.Terminals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminals\"")
			}
		case "security_systems":
			if err := func() error {
				s.SecuritySystems = make([]SecuritySystem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SecuritySystem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SecuritySystems = append(s.SecuritySystems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_systems\"")
			}
		case "storage_containers":
			if err := func() error {
				s.StorageContainers = make([]StorageContainer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StorageContainer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StorageContainers = append(s.StorageContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storage_containers\"")
			}
		case "surveillance_cameras":
			if err := func() error {
				s.SurveillanceCameras = make([]SurveillanceCamera, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SurveillanceCamera
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SurveillanceCameras = append(s.SurveillanceCameras, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"surveillance_cameras\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AirportObjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AirportObjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AirportObjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AirportTerminal) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AirportTerminal) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.TerminalType.Set {
			e.FieldStart("terminal_type")
			s.TerminalType.Encode(e)
		}
	}
	{
		if s.AccessLevel.Set {
			e.FieldStart("access_level")
			s.AccessLevel.Encode(e)
		}
	}
	{
		if s.DataValue.Set {
			e.FieldStart("data_value")
			s.DataValue.Encode(e)
		}
	}
	{
		if s.AlarmProbability.Set {
			e.FieldStart("alarm_probability")
			s.AlarmProbability.Encode(e)
		}
	}
}

var jsonFieldsNameOfAirportTerminal = [5]string{
	0: "object_id",
	1: "terminal_type",
	2: "access_level",
	3: "data_value",
	4: "alarm_probability",
}

// Decode decodes AirportTerminal from json.
func (s *AirportTerminal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AirportTerminal to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "terminal_type":
			if err := func() error {
				s.TerminalType.Reset()
				if err := s.TerminalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminal_type\"")
			}
		case "access_level":
			if err := func() error {
				s.AccessLevel.Reset()
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_level\"")
			}
		case "data_value":
			if err := func() error {
				s.DataValue.Reset()
				if err := s.DataValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_value\"")
			}
		case "alarm_probability":
			if err := func() error {
				s.AlarmProbability.Reset()
				if err := s.AlarmProbability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alarm_probability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AirportTerminal")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AirportTerminal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AirportTerminal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AirportTerminalAccessLevel as json.
func (s AirportTerminalAccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AirportTerminalAccessLevel from json.
func (s *AirportTerminalAccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AirportTerminalAccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AirportTerminalAccessLevel(v) {
	case AirportTerminalAccessLevelPublic:
		*s = AirportTerminalAccessLevelPublic
	case AirportTerminalAccessLevelStaffOnly:
		*s = AirportTerminalAccessLevelStaffOnly
	case AirportTerminalAccessLevelRestricted:
		*s = AirportTerminalAccessLevelRestricted
	default:
		*s = AirportTerminalAccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AirportTerminalAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AirportTerminalAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AirportTerminalTerminalType as json.
func (s AirportTerminalTerminalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AirportTerminalTerminalType from json.
func (s *AirportTerminalTerminalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AirportTerminalTerminalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AirportTerminalTerminalType(v) {
	case AirportTerminalTerminalTypeAtm:
		*s = AirportTerminalTerminalTypeAtm
	case AirportTerminalTerminalTypeInfoKiosk:
		*s = AirportTerminalTerminalTypeInfoKiosk
	case AirportTerminalTerminalTypeLuggageScanner:
		*s = AirportTerminalTerminalTypeLuggageScanner
	case AirportTerminalTerminalTypeBoardingGate:
		*s = AirportTerminalTerminalTypeBoardingGate
	default:
		*s = AirportTerminalTerminalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AirportTerminalTerminalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AirportTerminalTerminalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AmmoDepot) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AmmoDepot) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.AmmoType.Set {
			e.FieldStart("ammo_type")
			s.AmmoType.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.CurrentStock.Set {
			e.FieldStart("current_stock")
			s.CurrentStock.Encode(e)
		}
	}
	{
		if s.ExplosionRisk.Set {
			e.FieldStart("explosion_risk")
			s.ExplosionRisk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAmmoDepot = [5]string{
	0: "object_id",
	1: "ammo_type",
	2: "capacity",
	3: "current_stock",
	4: "explosion_risk",
}

// Decode decodes AmmoDepot from json.
func (s *AmmoDepot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AmmoDepot to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "ammo_type":
			if err := func() error {
				s.AmmoType.Reset()
				if err := s.AmmoType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ammo_type\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "current_stock":
			if err := func() error {
				s.CurrentStock.Reset()
				if err := s.CurrentStock.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_stock\"")
			}
		case "explosion_risk":
			if err := func() error {
				s.ExplosionRisk.Reset()
				if err := s.ExplosionRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explosion_risk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AmmoDepot")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AmmoDepot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AmmoDepot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AmmoDepotAmmoType as json.
func (s AmmoDepotAmmoType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AmmoDepotAmmoType from json.
func (s *AmmoDepotAmmoType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AmmoDepotAmmoType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AmmoDepotAmmoType(v) {
	case AmmoDepotAmmoTypeExplosive:
		*s = AmmoDepotAmmoTypeExplosive
	case AmmoDepotAmmoTypeIncendiary:
		*s = AmmoDepotAmmoTypeIncendiary
	case AmmoDepotAmmoTypeEmp:
		*s = AmmoDepotAmmoTypeEmp
	case AmmoDepotAmmoTypeArmorPiercing:
		*s = AmmoDepotAmmoTypeArmorPiercing
	default:
		*s = AmmoDepotAmmoType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AmmoDepotAmmoType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AmmoDepotAmmoType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BlackMarket) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BlackMarket) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.MerchantType.Set {
			e.FieldStart("merchant_type")
			s.MerchantType.Encode(e)
		}
	}
	{
		if s.InventorySlots.Set {
			e.FieldStart("inventory_slots")
			s.InventorySlots.Encode(e)
		}
	}
	{
		if s.CurrentStock.Set {
			e.FieldStart("current_stock")
			s.CurrentStock.Encode(e)
		}
	}
	{
		if s.RaidProbability.Set {
			e.FieldStart("raid_probability")
			s.RaidProbability.Encode(e)
		}
	}
}

var jsonFieldsNameOfBlackMarket = [5]string{
	0: "object_id",
	1: "merchant_type",
	2: "inventory_slots",
	3: "current_stock",
	4: "raid_probability",
}

// Decode decodes BlackMarket from json.
func (s *BlackMarket) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlackMarket to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "merchant_type":
			if err := func() error {
				s.MerchantType.Reset()
				if err := s.MerchantType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merchant_type\"")
			}
		case "inventory_slots":
			if err := func() error {
				s.InventorySlots.Reset()
				if err := s.InventorySlots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slots\"")
			}
		case "current_stock":
			if err := func() error {
				s.CurrentStock.Reset()
				if err := s.CurrentStock.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_stock\"")
			}
		case "raid_probability":
			if err := func() error {
				s.RaidProbability.Reset()
				if err := s.RaidProbability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raid_probability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BlackMarket")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BlackMarket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlackMarket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlackMarketMerchantType as json.
func (s BlackMarketMerchantType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BlackMarketMerchantType from json.
func (s *BlackMarketMerchantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BlackMarketMerchantType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BlackMarketMerchantType(v) {
	case BlackMarketMerchantTypeWeapons:
		*s = BlackMarketMerchantTypeWeapons
	case BlackMarketMerchantTypeImplants:
		*s = BlackMarketMerchantTypeImplants
	case BlackMarketMerchantTypeInformation:
		*s = BlackMarketMerchantTypeInformation
	case BlackMarketMerchantTypeContraband:
		*s = BlackMarketMerchantTypeContraband
	default:
		*s = BlackMarketMerchantType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BlackMarketMerchantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BlackMarketMerchantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChemicalSynthesizer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChemicalSynthesizer) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.SynthesizerType.Set {
			e.FieldStart("synthesizer_type")
			s.SynthesizerType.Encode(e)
		}
	}
	{
		if s.AvailableReagents != nil {
			e.FieldStart("available_reagents")
			e.ArrStart()
			for _, elem := range s.AvailableReagents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExplosionRisk.Set {
			e.FieldStart("explosion_risk")
			s.ExplosionRisk.Encode(e)
		}
	}
	{
		if s.OutputQuality.Set {
			e.FieldStart("output_quality")
			s.OutputQuality.Encode(e)
		}
	}
}

var jsonFieldsNameOfChemicalSynthesizer = [5]string{
	0: "object_id",
	1: "synthesizer_type",
	2: "available_reagents",
	3: "explosion_risk",
	4: "output_quality",
}

// Decode decodes ChemicalSynthesizer from json.
func (s *ChemicalSynthesizer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChemicalSynthesizer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "synthesizer_type":
			if err := func() error {
				s.SynthesizerType.Reset()
				if err := s.SynthesizerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synthesizer_type\"")
			}
		case "available_reagents":
			if err := func() error {
				s.AvailableReagents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AvailableReagents = append(s.AvailableReagents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_reagents\"")
			}
		case "explosion_risk":
			if err := func() error {
				s.ExplosionRisk.Reset()
				if err := s.ExplosionRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explosion_risk\"")
			}
		case "output_quality":
			if err := func() error {
				s.OutputQuality.Reset()
				if err := s.OutputQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output_quality\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChemicalSynthesizer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChemicalSynthesizer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChemicalSynthesizer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChemicalSynthesizerOutputQuality as json.
func (s ChemicalSynthesizerOutputQuality) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChemicalSynthesizerOutputQuality from json.
func (s *ChemicalSynthesizerOutputQuality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChemicalSynthesizerOutputQuality to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChemicalSynthesizerOutputQuality(v) {
	case ChemicalSynthesizerOutputQualityLow:
		*s = ChemicalSynthesizerOutputQualityLow
	case ChemicalSynthesizerOutputQualityMedium:
		*s = ChemicalSynthesizerOutputQualityMedium
	case ChemicalSynthesizerOutputQualityHigh:
		*s = ChemicalSynthesizerOutputQualityHigh
	case ChemicalSynthesizerOutputQualityPerfect:
		*s = ChemicalSynthesizerOutputQualityPerfect
	default:
		*s = ChemicalSynthesizerOutputQuality(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChemicalSynthesizerOutputQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChemicalSynthesizerOutputQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChemicalSynthesizerSynthesizerType as json.
func (s ChemicalSynthesizerSynthesizerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChemicalSynthesizerSynthesizerType from json.
func (s *ChemicalSynthesizerSynthesizerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChemicalSynthesizerSynthesizerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChemicalSynthesizerSynthesizerType(v) {
	case ChemicalSynthesizerSynthesizerTypeBasic:
		*s = ChemicalSynthesizerSynthesizerTypeBasic
	case ChemicalSynthesizerSynthesizerTypeAdvanced:
		*s = ChemicalSynthesizerSynthesizerTypeAdvanced
	case ChemicalSynthesizerSynthesizerTypeExperimental:
		*s = ChemicalSynthesizerSynthesizerTypeExperimental
	default:
		*s = ChemicalSynthesizerSynthesizerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChemicalSynthesizerSynthesizerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChemicalSynthesizerSynthesizerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateObjectRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateObjectRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object_type")
		s.ObjectType.Encode(e)
	}
	{
		e.FieldStart("zone_type")
		s.ZoneType.Encode(e)
	}
	{
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	{
		if s.InitialStatus.Set {
			e.FieldStart("initial_status")
			s.InitialStatus.Encode(e)
		}
	}
	{
		if s.ThreatLevel.Set {
			e.FieldStart("threat_level")
			s.ThreatLevel.Encode(e)
		}
	}
	{
		if s.CustomProperties != nil {
			e.FieldStart("custom_properties")
			s.CustomProperties.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateObjectRequest = [6]string{
	0: "object_type",
	1: "zone_type",
	2: "position",
	3: "initial_status",
	4: "threat_level",
	5: "custom_properties",
}

// Decode decodes CreateObjectRequest from json.
func (s *CreateObjectRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateObjectRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ObjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_type\"")
			}
		case "zone_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ZoneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_type\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "initial_status":
			if err := func() error {
				s.InitialStatus.Reset()
				if err := s.InitialStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_status\"")
			}
		case "threat_level":
			if err := func() error {
				s.ThreatLevel.Reset()
				if err := s.ThreatLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threat_level\"")
			}
		case "custom_properties":
			if err := func() error {
				s.CustomProperties = nil
				var elem CreateObjectRequestCustomProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomProperties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_properties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateObjectRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateObjectRequest) {
					name = jsonFieldsNameOfCreateObjectRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateObjectRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateObjectRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateObjectRequestCustomProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateObjectRequestCustomProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateObjectRequestCustomProperties = [0]string{}

// Decode decodes CreateObjectRequestCustomProperties from json.
func (s *CreateObjectRequestCustomProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateObjectRequestCustomProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateObjectRequestCustomProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateObjectRequestCustomProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateObjectRequestCustomProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateObjectRequestThreatLevel as json.
func (s CreateObjectRequestThreatLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateObjectRequestThreatLevel from json.
func (s *CreateObjectRequestThreatLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateObjectRequestThreatLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateObjectRequestThreatLevel(v) {
	case CreateObjectRequestThreatLevelLow:
		*s = CreateObjectRequestThreatLevelLow
	case CreateObjectRequestThreatLevelMedium:
		*s = CreateObjectRequestThreatLevelMedium
	case CreateObjectRequestThreatLevelHigh:
		*s = CreateObjectRequestThreatLevelHigh
	case CreateObjectRequestThreatLevelExtreme:
		*s = CreateObjectRequestThreatLevelExtreme
	default:
		*s = CreateObjectRequestThreatLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateObjectRequestThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateObjectRequestThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CryoChamber) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CryoChamber) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.SubjectType.Set {
			e.FieldStart("subject_type")
			s.SubjectType.Encode(e)
		}
	}
	{
		if s.ChamberStatus.Set {
			e.FieldStart("chamber_status")
			s.ChamberStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfCryoChamber = [3]string{
	0: "object_id",
	1: "subject_type",
	2: "chamber_status",
}

// Decode decodes CryoChamber from json.
func (s *CryoChamber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CryoChamber to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "subject_type":
			if err := func() error {
				s.SubjectType.Reset()
				if err := s.SubjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject_type\"")
			}
		case "chamber_status":
			if err := func() error {
				s.ChamberStatus.Reset()
				if err := s.ChamberStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chamber_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CryoChamber")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CryoChamber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CryoChamber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CryoChamberChamberStatus as json.
func (s CryoChamberChamberStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CryoChamberChamberStatus from json.
func (s *CryoChamberChamberStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CryoChamberChamberStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CryoChamberChamberStatus(v) {
	case CryoChamberChamberStatusActive:
		*s = CryoChamberChamberStatusActive
	case CryoChamberChamberStatusInactive:
		*s = CryoChamberChamberStatusInactive
	case CryoChamberChamberStatusBreached:
		*s = CryoChamberChamberStatusBreached
	case CryoChamberChamberStatusDestroyed:
		*s = CryoChamberChamberStatusDestroyed
	default:
		*s = CryoChamberChamberStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CryoChamberChamberStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CryoChamberChamberStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CryoChamberSubjectType as json.
func (s CryoChamberSubjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CryoChamberSubjectType from json.
func (s *CryoChamberSubjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CryoChamberSubjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CryoChamberSubjectType(v) {
	case CryoChamberSubjectTypeHuman:
		*s = CryoChamberSubjectTypeHuman
	case CryoChamberSubjectTypeCyberpsycho:
		*s = CryoChamberSubjectTypeCyberpsycho
	case CryoChamberSubjectTypeMutant:
		*s = CryoChamberSubjectTypeMutant
	case CryoChamberSubjectTypeExperimental:
		*s = CryoChamberSubjectTypeExperimental
	default:
		*s = CryoChamberSubjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CryoChamberSubjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CryoChamberSubjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EmergencyExit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EmergencyExit) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.ExitType.Set {
			e.FieldStart("exit_type")
			s.ExitType.Encode(e)
		}
	}
	{
		if s.DestinationZone.Set {
			e.FieldStart("destination_zone")
			s.DestinationZone.Encode(e)
		}
	}
	{
		if s.AlarmTriggered.Set {
			e.FieldStart("alarm_triggered")
			s.AlarmTriggered.Encode(e)
		}
	}
	{
		if s.Locked.Set {
			e.FieldStart("locked")
			s.Locked.Encode(e)
		}
	}
}

var jsonFieldsNameOfEmergencyExit = [5]string{
	0: "object_id",
	1: "exit_type",
	2: "destination_zone",
	3: "alarm_triggered",
	4: "locked",
}

// Decode decodes EmergencyExit from json.
func (s *EmergencyExit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmergencyExit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "exit_type":
			if err := func() error {
				s.ExitType.Reset()
				if err := s.ExitType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exit_type\"")
			}
		case "destination_zone":
			if err := func() error {
				s.DestinationZone.Reset()
				if err := s.DestinationZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_zone\"")
			}
		case "alarm_triggered":
			if err := func() error {
				s.AlarmTriggered.Reset()
				if err := s.AlarmTriggered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alarm_triggered\"")
			}
		case "locked":
			if err := func() error {
				s.Locked.Reset()
				if err := s.Locked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmergencyExit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EmergencyExit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmergencyExit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmergencyExitExitType as json.
func (s EmergencyExitExitType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EmergencyExitExitType from json.
func (s *EmergencyExitExitType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmergencyExitExitType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EmergencyExitExitType(v) {
	case EmergencyExitExitTypeFireEscape:
		*s = EmergencyExitExitTypeFireEscape
	case EmergencyExitExitTypeServiceDoor:
		*s = EmergencyExitExitTypeServiceDoor
	case EmergencyExitExitTypeVentilationShaft:
		*s = EmergencyExitExitTypeVentilationShaft
	case EmergencyExitExitTypeSewerAccess:
		*s = EmergencyExitExitTypeSewerAccess
	default:
		*s = EmergencyExitExitType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EmergencyExitExitType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmergencyExitExitType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentalSample) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentalSample) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.SampleType.Set {
			e.FieldStart("sample_type")
			s.SampleType.Encode(e)
		}
	}
	{
		if s.ContainmentLevel.Set {
			e.FieldStart("containment_level")
			s.ContainmentLevel.Encode(e)
		}
	}
	{
		if s.ResearchValue.Set {
			e.FieldStart("research_value")
			s.ResearchValue.Encode(e)
		}
	}
	{
		if s.InfectionRisk.Set {
			e.FieldStart("infection_risk")
			s.InfectionRisk.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentalSample = [5]string{
	0: "object_id",
	1: "sample_type",
	2: "containment_level",
	3: "research_value",
	4: "infection_risk",
}

// Decode decodes ExperimentalSample from json.
func (s *ExperimentalSample) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentalSample to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "sample_type":
			if err := func() error {
				s.SampleType.Reset()
				if err := s.SampleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_type\"")
			}
		case "containment_level":
			if err := func() error {
				s.ContainmentLevel.Reset()
				if err := s.ContainmentLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containment_level\"")
			}
		case "research_value":
			if err := func() error {
				s.ResearchValue.Reset()
				if err := s.ResearchValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"research_value\"")
			}
		case "infection_risk":
			if err := func() error {
				s.InfectionRisk.Reset()
				if err := s.InfectionRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infection_risk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentalSample")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentalSample) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentalSample) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentalSampleContainmentLevel as json.
func (s ExperimentalSampleContainmentLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentalSampleContainmentLevel from json.
func (s *ExperimentalSampleContainmentLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentalSampleContainmentLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentalSampleContainmentLevel(v) {
	case ExperimentalSampleContainmentLevelLow:
		*s = ExperimentalSampleContainmentLevelLow
	case ExperimentalSampleContainmentLevelMedium:
		*s = ExperimentalSampleContainmentLevelMedium
	case ExperimentalSampleContainmentLevelHigh:
		*s = ExperimentalSampleContainmentLevelHigh
	case ExperimentalSampleContainmentLevelExtreme:
		*s = ExperimentalSampleContainmentLevelExtreme
	default:
		*s = ExperimentalSampleContainmentLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentalSampleContainmentLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentalSampleContainmentLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentalSampleSampleType as json.
func (s ExperimentalSampleSampleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentalSampleSampleType from json.
func (s *ExperimentalSampleSampleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentalSampleSampleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentalSampleSampleType(v) {
	case ExperimentalSampleSampleTypeDna:
		*s = ExperimentalSampleSampleTypeDna
	case ExperimentalSampleSampleTypeVirus:
		*s = ExperimentalSampleSampleTypeVirus
	case ExperimentalSampleSampleTypeNanites:
		*s = ExperimentalSampleSampleTypeNanites
	case ExperimentalSampleSampleTypeChemicalCompound:
		*s = ExperimentalSampleSampleTypeChemicalCompound
	default:
		*s = ExperimentalSampleSampleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentalSampleSampleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentalSampleSampleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackFailure) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackFailure) encodeFields(e *jx.Encoder) {
	{
		if s.FailureReason.Set {
			e.FieldStart("failure_reason")
			s.FailureReason.Encode(e)
		}
	}
	{
		if s.AlarmLevel.Set {
			e.FieldStart("alarm_level")
			s.AlarmLevel.Encode(e)
		}
	}
	{
		if s.CooldownSeconds.Set {
			e.FieldStart("cooldown_seconds")
			s.CooldownSeconds.Encode(e)
		}
	}
	{
		if s.ReputationLoss.Set {
			e.FieldStart("reputation_loss")
			s.ReputationLoss.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackFailure = [4]string{
	0: "failure_reason",
	1: "alarm_level",
	2: "cooldown_seconds",
	3: "reputation_loss",
}

// Decode decodes HackFailure from json.
func (s *HackFailure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackFailure to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failure_reason":
			if err := func() error {
				s.FailureReason.Reset()
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_reason\"")
			}
		case "alarm_level":
			if err := func() error {
				s.AlarmLevel.Reset()
				if err := s.AlarmLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alarm_level\"")
			}
		case "cooldown_seconds":
			if err := func() error {
				s.CooldownSeconds.Reset()
				if err := s.CooldownSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_seconds\"")
			}
		case "reputation_loss":
			if err := func() error {
				s.ReputationLoss.Reset()
				if err := s.ReputationLoss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_loss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackFailure")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackFailure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackFailure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackFailureAlarmLevel as json.
func (s HackFailureAlarmLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackFailureAlarmLevel from json.
func (s *HackFailureAlarmLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackFailureAlarmLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackFailureAlarmLevel(v) {
	case HackFailureAlarmLevelSilent:
		*s = HackFailureAlarmLevelSilent
	case HackFailureAlarmLevelLocal:
		*s = HackFailureAlarmLevelLocal
	case HackFailureAlarmLevelZoneWide:
		*s = HackFailureAlarmLevelZoneWide
	case HackFailureAlarmLevelCityWide:
		*s = HackFailureAlarmLevelCityWide
	default:
		*s = HackFailureAlarmLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackFailureAlarmLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackFailureAlarmLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackFailureFailureReason as json.
func (s HackFailureFailureReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackFailureFailureReason from json.
func (s *HackFailureFailureReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackFailureFailureReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackFailureFailureReason(v) {
	case HackFailureFailureReasonDetection:
		*s = HackFailureFailureReasonDetection
	case HackFailureFailureReasonInsufficientSkill:
		*s = HackFailureFailureReasonInsufficientSkill
	case HackFailureFailureReasonSystemLocked:
		*s = HackFailureFailureReasonSystemLocked
	case HackFailureFailureReasonAlarmTriggered:
		*s = HackFailureFailureReasonAlarmTriggered
	default:
		*s = HackFailureFailureReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackFailureFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackFailureFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("hack_type")
		s.HackType.Encode(e)
	}
	{
		if s.HackingSkill.Set {
			e.FieldStart("hacking_skill")
			s.HackingSkill.Encode(e)
		}
	}
	{
		if s.ToolsUsed != nil {
			e.FieldStart("tools_used")
			e.ArrStart()
			for _, elem := range s.ToolsUsed {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHackRequest = [4]string{
	0: "player_id",
	1: "hack_type",
	2: "hacking_skill",
	3: "tools_used",
}

// Decode decodes HackRequest from json.
func (s *HackRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "hack_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HackType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hack_type\"")
			}
		case "hacking_skill":
			if err := func() error {
				s.HackingSkill.Reset()
				if err := s.HackingSkill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hacking_skill\"")
			}
		case "tools_used":
			if err := func() error {
				s.ToolsUsed = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ToolsUsed = append(s.ToolsUsed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools_used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHackRequest) {
					name = jsonFieldsNameOfHackRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackRequestHackType as json.
func (s HackRequestHackType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HackRequestHackType from json.
func (s *HackRequestHackType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackRequestHackType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HackRequestHackType(v) {
	case HackRequestHackTypeBypass:
		*s = HackRequestHackTypeBypass
	case HackRequestHackTypeOverride:
		*s = HackRequestHackTypeOverride
	case HackRequestHackTypeExtractData:
		*s = HackRequestHackTypeExtractData
	case HackRequestHackTypeDisableAlarm:
		*s = HackRequestHackTypeDisableAlarm
	default:
		*s = HackRequestHackType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HackRequestHackType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackRequestHackType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.HackDuration.Set {
			e.FieldStart("hack_duration")
			s.HackDuration.Encode(e)
		}
	}
	{
		if s.DataExtracted != nil {
			e.FieldStart("data_extracted")
			s.DataExtracted.Encode(e)
		}
	}
	{
		if s.AlarmTriggered.Set {
			e.FieldStart("alarm_triggered")
			s.AlarmTriggered.Encode(e)
		}
	}
	{
		if s.DetectionRisk.Set {
			e.FieldStart("detection_risk")
			s.DetectionRisk.Encode(e)
		}
	}
	{
		if s.NewObjectStatus.Set {
			e.FieldStart("new_object_status")
			s.NewObjectStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfHackResponse = [6]string{
	0: "success",
	1: "hack_duration",
	2: "data_extracted",
	3: "alarm_triggered",
	4: "detection_risk",
	5: "new_object_status",
}

// Decode decodes HackResponse from json.
func (s *HackResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "hack_duration":
			if err := func() error {
				s.HackDuration.Reset()
				if err := s.HackDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hack_duration\"")
			}
		case "data_extracted":
			if err := func() error {
				s.DataExtracted = nil
				var elem HackResponseDataExtracted
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.DataExtracted = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted\"")
			}
		case "alarm_triggered":
			if err := func() error {
				s.AlarmTriggered.Reset()
				if err := s.AlarmTriggered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alarm_triggered\"")
			}
		case "detection_risk":
			if err := func() error {
				s.DetectionRisk.Reset()
				if err := s.DetectionRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detection_risk\"")
			}
		case "new_object_status":
			if err := func() error {
				s.NewObjectStatus.Reset()
				if err := s.NewObjectStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_object_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HackResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HackResponseDataExtracted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HackResponseDataExtracted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHackResponseDataExtracted = [0]string{}

// Decode decodes HackResponseDataExtracted from json.
func (s *HackResponseDataExtracted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HackResponseDataExtracted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HackResponseDataExtracted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HackResponseDataExtracted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HackResponseDataExtracted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveObjects.Set {
			e.FieldStart("active_objects")
			s.ActiveObjects.Encode(e)
		}
	}
	{
		if s.ZonesServed.Set {
			e.FieldStart("zones_served")
			s.ZonesServed.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [6]string{
	0: "status",
	1: "timestamp",
	2: "version",
	3: "uptime_seconds",
	4: "active_objects",
	5: "zones_served",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_objects":
			if err := func() error {
				s.ActiveObjects.Reset()
				if err := s.ActiveObjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_objects\"")
			}
		case "zones_served":
			if err := func() error {
				s.ZonesServed.Reset()
				if err := s.ZonesServed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones_served\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	case HealthResponseStatusDegraded:
		*s = HealthResponseStatusDegraded
	case HealthResponseStatusUnhealthy:
		*s = HealthResponseStatusUnhealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractError) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.RequiredLevel.Set {
			e.FieldStart("required_level")
			s.RequiredLevel.Encode(e)
		}
	}
	{
		if s.CooldownSeconds.Set {
			e.FieldStart("cooldown_seconds")
			s.CooldownSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractError = [4]string{
	0: "error_code",
	1: "error_message",
	2: "required_level",
	3: "cooldown_seconds",
}

// Decode decodes InteractError from json.
func (s *InteractError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "required_level":
			if err := func() error {
				s.RequiredLevel.Reset()
				if err := s.RequiredLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_level\"")
			}
		case "cooldown_seconds":
			if err := func() error {
				s.CooldownSeconds.Reset()
				if err := s.CooldownSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractErrorErrorCode as json.
func (s InteractErrorErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractErrorErrorCode from json.
func (s *InteractErrorErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractErrorErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractErrorErrorCode(v) {
	case InteractErrorErrorCodeInsufficientLevel:
		*s = InteractErrorErrorCodeInsufficientLevel
	case InteractErrorErrorCodeWrongTools:
		*s = InteractErrorErrorCodeWrongTools
	case InteractErrorErrorCodeLocked:
		*s = InteractErrorErrorCodeLocked
	case InteractErrorErrorCodeDestroyed:
		*s = InteractErrorErrorCodeDestroyed
	case InteractErrorErrorCodeAlarmed:
		*s = InteractErrorErrorCodeAlarmed
	default:
		*s = InteractErrorErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractErrorErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractErrorErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("interaction_type")
		s.InteractionType.Encode(e)
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractRequest = [3]string{
	0: "player_id",
	1: "interaction_type",
	2: "parameters",
}

// Decode decodes InteractRequest from json.
func (s *InteractRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "interaction_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.InteractionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = nil
				var elem InteractRequestParameters
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parameters = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractRequest) {
					name = jsonFieldsNameOfInteractRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractRequestInteractionType as json.
func (s InteractRequestInteractionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractRequestInteractionType from json.
func (s *InteractRequestInteractionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractRequestInteractionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractRequestInteractionType(v) {
	case InteractRequestInteractionTypeUse:
		*s = InteractRequestInteractionTypeUse
	case InteractRequestInteractionTypeExamine:
		*s = InteractRequestInteractionTypeExamine
	case InteractRequestInteractionTypeDestroy:
		*s = InteractRequestInteractionTypeDestroy
	case InteractRequestInteractionTypeRepair:
		*s = InteractRequestInteractionTypeRepair
	case InteractRequestInteractionTypeSearch:
		*s = InteractRequestInteractionTypeSearch
	default:
		*s = InteractRequestInteractionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractRequestInteractionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractRequestInteractionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractRequestParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractRequestParameters) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInteractRequestParameters = [0]string{}

// Decode decodes InteractRequestParameters from json.
func (s *InteractRequestParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractRequestParameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InteractRequestParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractRequestParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractRequestParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.Result != nil {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ObjectStateChanged.Set {
			e.FieldStart("object_state_changed")
			s.ObjectStateChanged.Encode(e)
		}
	}
	{
		if s.NewObjectStatus.Set {
			e.FieldStart("new_object_status")
			s.NewObjectStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractResponse = [6]string{
	0: "success",
	1: "result",
	2: "rewards",
	3: "effects",
	4: "object_state_changed",
	5: "new_object_status",
}

// Decode decodes InteractResponse from json.
func (s *InteractResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "result":
			if err := func() error {
				s.Result = nil
				var elem InteractResponseResult
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]InteractResponseRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InteractResponseRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "object_state_changed":
			if err := func() error {
				s.ObjectStateChanged.Reset()
				if err := s.ObjectStateChanged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_state_changed\"")
			}
		case "new_object_status":
			if err := func() error {
				s.NewObjectStatus.Reset()
				if err := s.NewObjectStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_object_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractResponseResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractResponseResult) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInteractResponseResult = [0]string{}

// Decode decodes InteractResponseResult from json.
func (s *InteractResponseResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractResponseResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InteractResponseResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractResponseResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractResponseResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractResponseRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractResponseRewardsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractResponseRewardsItem = [2]string{
	0: "type",
	1: "value",
}

// Decode decodes InteractResponseRewardsItem from json.
func (s *InteractResponseRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractResponseRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractResponseRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractResponseRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractResponseRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractResponseRewardsItemType as json.
func (s InteractResponseRewardsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractResponseRewardsItemType from json.
func (s *InteractResponseRewardsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractResponseRewardsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractResponseRewardsItemType(v) {
	case InteractResponseRewardsItemTypeItem:
		*s = InteractResponseRewardsItemTypeItem
	case InteractResponseRewardsItemTypeCredit:
		*s = InteractResponseRewardsItemTypeCredit
	case InteractResponseRewardsItemTypeExperience:
		*s = InteractResponseRewardsItemTypeExperience
	case InteractResponseRewardsItemTypeReputation:
		*s = InteractResponseRewardsItemTypeReputation
	default:
		*s = InteractResponseRewardsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractResponseRewardsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractResponseRewardsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabObjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabObjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.LabID.Set {
			e.FieldStart("lab_id")
			s.LabID.Encode(e)
		}
	}
	{
		if s.ExperimentalSamples != nil {
			e.FieldStart("experimental_samples")
			e.ArrStart()
			for _, elem := range s.ExperimentalSamples {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AiTerminals != nil {
			e.FieldStart("ai_terminals")
			e.ArrStart()
			for _, elem := range s.AiTerminals {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ChemicalSynthesizers != nil {
			e.FieldStart("chemical_synthesizers")
			e.ArrStart()
			for _, elem := range s.ChemicalSynthesizers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CryoChambers != nil {
			e.FieldStart("cryo_chambers")
			e.ArrStart()
			for _, elem := range s.CryoChambers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLabObjectsResponse = [5]string{
	0: "lab_id",
	1: "experimental_samples",
	2: "ai_terminals",
	3: "chemical_synthesizers",
	4: "cryo_chambers",
}

// Decode decodes LabObjectsResponse from json.
func (s *LabObjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabObjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lab_id":
			if err := func() error {
				s.LabID.Reset()
				if err := s.LabID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lab_id\"")
			}
		case "experimental_samples":
			if err := func() error {
				s.ExperimentalSamples = make([]ExperimentalSample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentalSample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentalSamples = append(s.ExperimentalSamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experimental_samples\"")
			}
		case "ai_terminals":
			if err := func() error {
				s.AiTerminals = make([]AITerminal, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AITerminal
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AiTerminals = append(s.AiTerminals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai_terminals\"")
			}
		case "chemical_synthesizers":
			if err := func() error {
				s.ChemicalSynthesizers = make([]ChemicalSynthesizer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChemicalSynthesizer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChemicalSynthesizers = append(s.ChemicalSynthesizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chemical_synthesizers\"")
			}
		case "cryo_chambers":
			if err := func() error {
				s.CryoChambers = make([]CryoChamber, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CryoChamber
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CryoChambers = append(s.CryoChambers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryo_chambers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabObjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabObjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabObjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListeningDevice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListeningDevice) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.DeviceType.Set {
			e.FieldStart("device_type")
			s.DeviceType.Encode(e)
		}
	}
	{
		if s.RecordingQuality.Set {
			e.FieldStart("recording_quality")
			s.RecordingQuality.Encode(e)
		}
	}
	{
		if s.ActiveRecording.Set {
			e.FieldStart("active_recording")
			s.ActiveRecording.Encode(e)
		}
	}
}

var jsonFieldsNameOfListeningDevice = [4]string{
	0: "object_id",
	1: "device_type",
	2: "recording_quality",
	3: "active_recording",
}

// Decode decodes ListeningDevice from json.
func (s *ListeningDevice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListeningDevice to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "device_type":
			if err := func() error {
				s.DeviceType.Reset()
				if err := s.DeviceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device_type\"")
			}
		case "recording_quality":
			if err := func() error {
				s.RecordingQuality.Reset()
				if err := s.RecordingQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_quality\"")
			}
		case "active_recording":
			if err := func() error {
				s.ActiveRecording.Reset()
				if err := s.ActiveRecording.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_recording\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListeningDevice")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListeningDevice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListeningDevice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListeningDeviceDeviceType as json.
func (s ListeningDeviceDeviceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListeningDeviceDeviceType from json.
func (s *ListeningDeviceDeviceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListeningDeviceDeviceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListeningDeviceDeviceType(v) {
	case ListeningDeviceDeviceTypeMicrophone:
		*s = ListeningDeviceDeviceTypeMicrophone
	case ListeningDeviceDeviceTypeCamera:
		*s = ListeningDeviceDeviceTypeCamera
	case ListeningDeviceDeviceTypeBoth:
		*s = ListeningDeviceDeviceTypeBoth
	default:
		*s = ListeningDeviceDeviceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListeningDeviceDeviceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListeningDeviceDeviceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListeningDeviceRecordingQuality as json.
func (s ListeningDeviceRecordingQuality) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListeningDeviceRecordingQuality from json.
func (s *ListeningDeviceRecordingQuality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListeningDeviceRecordingQuality to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListeningDeviceRecordingQuality(v) {
	case ListeningDeviceRecordingQualityPoor:
		*s = ListeningDeviceRecordingQualityPoor
	case ListeningDeviceRecordingQualityGood:
		*s = ListeningDeviceRecordingQualityGood
	case ListeningDeviceRecordingQualityExcellent:
		*s = ListeningDeviceRecordingQualityExcellent
	default:
		*s = ListeningDeviceRecordingQuality(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListeningDeviceRecordingQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListeningDeviceRecordingQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MilitaryObjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MilitaryObjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.BaseID.Set {
			e.FieldStart("base_id")
			s.BaseID.Encode(e)
		}
	}
	{
		if s.WeaponSystems != nil {
			e.FieldStart("weapon_systems")
			e.ArrStart()
			for _, elem := range s.WeaponSystems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AmmoDepots != nil {
			e.FieldStart("ammo_depots")
			e.ArrStart()
			for _, elem := range s.AmmoDepots {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShieldGenerators != nil {
			e.FieldStart("shield_generators")
			e.ArrStart()
			for _, elem := range s.ShieldGenerators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMilitaryObjectsResponse = [4]string{
	0: "base_id",
	1: "weapon_systems",
	2: "ammo_depots",
	3: "shield_generators",
}

// Decode decodes MilitaryObjectsResponse from json.
func (s *MilitaryObjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MilitaryObjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base_id":
			if err := func() error {
				s.BaseID.Reset()
				if err := s.BaseID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_id\"")
			}
		case "weapon_systems":
			if err := func() error {
				s.WeaponSystems = make([]WeaponSystem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WeaponSystem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WeaponSystems = append(s.WeaponSystems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_systems\"")
			}
		case "ammo_depots":
			if err := func() error {
				s.AmmoDepots = make([]AmmoDepot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AmmoDepot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AmmoDepots = append(s.AmmoDepots, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ammo_depots\"")
			}
		case "shield_generators":
			if err := func() error {
				s.ShieldGenerators = make([]ShieldGenerator, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ShieldGenerator
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ShieldGenerators = append(s.ShieldGenerators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_generators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MilitaryObjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MilitaryObjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MilitaryObjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MotelObjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MotelObjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.MotelID.Set {
			e.FieldStart("motel_id")
			s.MotelID.Encode(e)
		}
	}
	{
		if s.Safes != nil {
			e.FieldStart("safes")
			e.ArrStart()
			for _, elem := range s.Safes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ListeningDevices != nil {
			e.FieldStart("listening_devices")
			e.ArrStart()
			for _, elem := range s.ListeningDevices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BlackMarkets != nil {
			e.FieldStart("black_markets")
			e.ArrStart()
			for _, elem := range s.BlackMarkets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EmergencyExits != nil {
			e.FieldStart("emergency_exits")
			e.ArrStart()
			for _, elem := range s.EmergencyExits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMotelObjectsResponse = [5]string{
	0: "motel_id",
	1: "safes",
	2: "listening_devices",
	3: "black_markets",
	4: "emergency_exits",
}

// Decode decodes MotelObjectsResponse from json.
func (s *MotelObjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MotelObjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "motel_id":
			if err := func() error {
				s.MotelID.Reset()
				if err := s.MotelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"motel_id\"")
			}
		case "safes":
			if err := func() error {
				s.Safes = make([]MotelSafe, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MotelSafe
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Safes = append(s.Safes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"safes\"")
			}
		case "listening_devices":
			if err := func() error {
				s.ListeningDevices = make([]ListeningDevice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListeningDevice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ListeningDevices = append(s.ListeningDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"listening_devices\"")
			}
		case "black_markets":
			if err := func() error {
				s.BlackMarkets = make([]BlackMarket, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BlackMarket
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BlackMarkets = append(s.BlackMarkets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"black_markets\"")
			}
		case "emergency_exits":
			if err := func() error {
				s.EmergencyExits = make([]EmergencyExit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EmergencyExit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EmergencyExits = append(s.EmergencyExits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emergency_exits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MotelObjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MotelObjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MotelObjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MotelSafe) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MotelSafe) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.SafeType.Set {
			e.FieldStart("safe_type")
			s.SafeType.Encode(e)
		}
	}
	{
		if s.LockDifficulty.Set {
			e.FieldStart("lock_difficulty")
			s.LockDifficulty.Encode(e)
		}
	}
	{
		if s.ContentsValue.Set {
			e.FieldStart("contents_value")
			s.ContentsValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfMotelSafe = [4]string{
	0: "object_id",
	1: "safe_type",
	2: "lock_difficulty",
	3: "contents_value",
}

// Decode decodes MotelSafe from json.
func (s *MotelSafe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MotelSafe to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "safe_type":
			if err := func() error {
				s.SafeType.Reset()
				if err := s.SafeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"safe_type\"")
			}
		case "lock_difficulty":
			if err := func() error {
				s.LockDifficulty.Reset()
				if err := s.LockDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_difficulty\"")
			}
		case "contents_value":
			if err := func() error {
				s.ContentsValue.Reset()
				if err := s.ContentsValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MotelSafe")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MotelSafe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MotelSafe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MotelSafeSafeType as json.
func (s MotelSafeSafeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MotelSafeSafeType from json.
func (s *MotelSafeSafeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MotelSafeSafeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MotelSafeSafeType(v) {
	case MotelSafeSafeTypeWallSafe:
		*s = MotelSafeSafeTypeWallSafe
	case MotelSafeSafeTypeFloorSafe:
		*s = MotelSafeSafeTypeFloorSafe
	case MotelSafeSafeTypeHiddenCompartment:
		*s = MotelSafeSafeTypeHiddenCompartment
	default:
		*s = MotelSafeSafeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MotelSafeSafeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MotelSafeSafeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Objects != nil {
			e.FieldStart("objects")
			e.ArrStart()
			for _, elem := range s.Objects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.ZoneFilter.Set {
			e.FieldStart("zone_filter")
			s.ZoneFilter.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectListResponse = [3]string{
	0: "objects",
	1: "total_count",
	2: "zone_filter",
}

// Decode decodes ObjectListResponse from json.
func (s *ObjectListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "objects":
			if err := func() error {
				s.Objects = make([]ObjectSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ObjectSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objects = append(s.Objects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objects\"")
			}
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "zone_filter":
			if err := func() error {
				s.ZoneFilter.Reset()
				if err := s.ZoneFilter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_filter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.ObjectType.Set {
			e.FieldStart("object_type")
			s.ObjectType.Encode(e)
		}
	}
	{
		if s.ZoneType.Set {
			e.FieldStart("zone_type")
			s.ZoneType.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ThreatLevel.Set {
			e.FieldStart("threat_level")
			s.ThreatLevel.Encode(e)
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.LastInteraction.Set {
			e.FieldStart("last_interaction")
			s.LastInteraction.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfObjectResponse = [10]string{
	0: "object_id",
	1: "object_type",
	2: "zone_type",
	3: "position",
	4: "status",
	5: "threat_level",
	6: "properties",
	7: "interaction_count",
	8: "last_interaction",
	9: "created_at",
}

// Decode decodes ObjectResponse from json.
func (s *ObjectResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "object_type":
			if err := func() error {
				s.ObjectType.Reset()
				if err := s.ObjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_type\"")
			}
		case "zone_type":
			if err := func() error {
				s.ZoneType.Reset()
				if err := s.ZoneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_type\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "threat_level":
			if err := func() error {
				s.ThreatLevel.Reset()
				if err := s.ThreatLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threat_level\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem ObjectResponseProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "last_interaction":
			if err := func() error {
				s.LastInteraction.Reset()
				if err := s.LastInteraction.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectResponseProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectResponseProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfObjectResponseProperties = [0]string{}

// Decode decodes ObjectResponseProperties from json.
func (s *ObjectResponseProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectResponseProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ObjectResponseProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectResponseProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectResponseProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectResponseThreatLevel as json.
func (s ObjectResponseThreatLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectResponseThreatLevel from json.
func (s *ObjectResponseThreatLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectResponseThreatLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectResponseThreatLevel(v) {
	case ObjectResponseThreatLevelLow:
		*s = ObjectResponseThreatLevelLow
	case ObjectResponseThreatLevelMedium:
		*s = ObjectResponseThreatLevelMedium
	case ObjectResponseThreatLevelHigh:
		*s = ObjectResponseThreatLevelHigh
	case ObjectResponseThreatLevelExtreme:
		*s = ObjectResponseThreatLevelExtreme
	default:
		*s = ObjectResponseThreatLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectResponseThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectResponseThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectStatus as json.
func (s ObjectStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectStatus from json.
func (s *ObjectStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectStatus(v) {
	case ObjectStatusActive:
		*s = ObjectStatusActive
	case ObjectStatusInactive:
		*s = ObjectStatusInactive
	case ObjectStatusDestroyed:
		*s = ObjectStatusDestroyed
	case ObjectStatusLocked:
		*s = ObjectStatusLocked
	case ObjectStatusHacked:
		*s = ObjectStatusHacked
	case ObjectStatusAlarmed:
		*s = ObjectStatusAlarmed
	default:
		*s = ObjectStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectSummary) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.ObjectType.Set {
			e.FieldStart("object_type")
			s.ObjectType.Encode(e)
		}
	}
	{
		if s.ZoneType.Set {
			e.FieldStart("zone_type")
			s.ZoneType.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ThreatLevel.Set {
			e.FieldStart("threat_level")
			s.ThreatLevel.Encode(e)
		}
	}
	{
		if s.LastInteraction.Set {
			e.FieldStart("last_interaction")
			s.LastInteraction.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfObjectSummary = [7]string{
	0: "object_id",
	1: "object_type",
	2: "zone_type",
	3: "position",
	4: "status",
	5: "threat_level",
	6: "last_interaction",
}

// Decode decodes ObjectSummary from json.
func (s *ObjectSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectSummary to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "object_type":
			if err := func() error {
				s.ObjectType.Reset()
				if err := s.ObjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_type\"")
			}
		case "zone_type":
			if err := func() error {
				s.ZoneType.Reset()
				if err := s.ZoneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_type\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "threat_level":
			if err := func() error {
				s.ThreatLevel.Reset()
				if err := s.ThreatLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threat_level\"")
			}
		case "last_interaction":
			if err := func() error {
				s.LastInteraction.Reset()
				if err := s.LastInteraction.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectSummaryThreatLevel as json.
func (s ObjectSummaryThreatLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectSummaryThreatLevel from json.
func (s *ObjectSummaryThreatLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectSummaryThreatLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectSummaryThreatLevel(v) {
	case ObjectSummaryThreatLevelLow:
		*s = ObjectSummaryThreatLevelLow
	case ObjectSummaryThreatLevelMedium:
		*s = ObjectSummaryThreatLevelMedium
	case ObjectSummaryThreatLevelHigh:
		*s = ObjectSummaryThreatLevelHigh
	case ObjectSummaryThreatLevelExtreme:
		*s = ObjectSummaryThreatLevelExtreme
	default:
		*s = ObjectSummaryThreatLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectSummaryThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectSummaryThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectType as json.
func (s ObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectType from json.
func (s *ObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectType(v) {
	case ObjectTypeTerminal:
		*s = ObjectTypeTerminal
	case ObjectTypeSecuritySystem:
		*s = ObjectTypeSecuritySystem
	case ObjectTypeStorageContainer:
		*s = ObjectTypeStorageContainer
	case ObjectTypeSurveillanceCamera:
		*s = ObjectTypeSurveillanceCamera
	case ObjectTypeWeaponSystem:
		*s = ObjectTypeWeaponSystem
	case ObjectTypeAmmoDepot:
		*s = ObjectTypeAmmoDepot
	case ObjectTypeShieldGenerator:
		*s = ObjectTypeShieldGenerator
	case ObjectTypeSafe:
		*s = ObjectTypeSafe
	case ObjectTypeListeningDevice:
		*s = ObjectTypeListeningDevice
	case ObjectTypeBlackMarket:
		*s = ObjectTypeBlackMarket
	case ObjectTypeEmergencyExit:
		*s = ObjectTypeEmergencyExit
	case ObjectTypeExperimentalSample:
		*s = ObjectTypeExperimentalSample
	case ObjectTypeAiTerminal:
		*s = ObjectTypeAiTerminal
	case ObjectTypeChemicalSynthesizer:
		*s = ObjectTypeChemicalSynthesizer
	case ObjectTypeCryoChamber:
		*s = ObjectTypeCryoChamber
	case ObjectTypeServerRack:
		*s = ObjectTypeServerRack
	case ObjectTypeBiometricLock:
		*s = ObjectTypeBiometricLock
	case ObjectTypeCorporateSafe:
		*s = ObjectTypeCorporateSafe
	case ObjectTypeConferenceSystem:
		*s = ObjectTypeConferenceSystem
	case ObjectTypeIllegalLab:
		*s = ObjectTypeIllegalLab
	case ObjectTypeSmugglingHatch:
		*s = ObjectTypeSmugglingHatch
	case ObjectTypeSecretTunnel:
		*s = ObjectTypeSecretTunnel
	case ObjectTypeFactionBlockpost:
		*s = ObjectTypeFactionBlockpost
	case ObjectTypeCommRelay:
		*s = ObjectTypeCommRelay
	case ObjectTypeMedicalStation:
		*s = ObjectTypeMedicalStation
	case ObjectTypeLogisticsContainer:
		*s = ObjectTypeLogisticsContainer
	default:
		*s = ObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AITerminalAccessLevel as json.
func (o OptAITerminalAccessLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AITerminalAccessLevel from json.
func (o *OptAITerminalAccessLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAITerminalAccessLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAITerminalAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAITerminalAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AITerminalAiType as json.
func (o OptAITerminalAiType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AITerminalAiType from json.
func (o *OptAITerminalAiType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAITerminalAiType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAITerminalAiType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAITerminalAiType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AirportTerminalAccessLevel as json.
func (o OptAirportTerminalAccessLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AirportTerminalAccessLevel from json.
func (o *OptAirportTerminalAccessLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAirportTerminalAccessLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAirportTerminalAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAirportTerminalAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AirportTerminalTerminalType as json.
func (o OptAirportTerminalTerminalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AirportTerminalTerminalType from json.
func (o *OptAirportTerminalTerminalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAirportTerminalTerminalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAirportTerminalTerminalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAirportTerminalTerminalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AmmoDepotAmmoType as json.
func (o OptAmmoDepotAmmoType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AmmoDepotAmmoType from json.
func (o *OptAmmoDepotAmmoType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAmmoDepotAmmoType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAmmoDepotAmmoType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAmmoDepotAmmoType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BlackMarketMerchantType as json.
func (o OptBlackMarketMerchantType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BlackMarketMerchantType from json.
func (o *OptBlackMarketMerchantType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBlackMarketMerchantType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBlackMarketMerchantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBlackMarketMerchantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChemicalSynthesizerOutputQuality as json.
func (o OptChemicalSynthesizerOutputQuality) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ChemicalSynthesizerOutputQuality from json.
func (o *OptChemicalSynthesizerOutputQuality) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChemicalSynthesizerOutputQuality to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChemicalSynthesizerOutputQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChemicalSynthesizerOutputQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChemicalSynthesizerSynthesizerType as json.
func (o OptChemicalSynthesizerSynthesizerType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ChemicalSynthesizerSynthesizerType from json.
func (o *OptChemicalSynthesizerSynthesizerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChemicalSynthesizerSynthesizerType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChemicalSynthesizerSynthesizerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChemicalSynthesizerSynthesizerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateObjectRequestThreatLevel as json.
func (o OptCreateObjectRequestThreatLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateObjectRequestThreatLevel from json.
func (o *OptCreateObjectRequestThreatLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateObjectRequestThreatLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateObjectRequestThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateObjectRequestThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CryoChamberChamberStatus as json.
func (o OptCryoChamberChamberStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CryoChamberChamberStatus from json.
func (o *OptCryoChamberChamberStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCryoChamberChamberStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCryoChamberChamberStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCryoChamberChamberStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CryoChamberSubjectType as json.
func (o OptCryoChamberSubjectType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CryoChamberSubjectType from json.
func (o *OptCryoChamberSubjectType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCryoChamberSubjectType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCryoChamberSubjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCryoChamberSubjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EmergencyExitExitType as json.
func (o OptEmergencyExitExitType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EmergencyExitExitType from json.
func (o *OptEmergencyExitExitType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmergencyExitExitType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmergencyExitExitType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmergencyExitExitType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentalSampleContainmentLevel as json.
func (o OptExperimentalSampleContainmentLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentalSampleContainmentLevel from json.
func (o *OptExperimentalSampleContainmentLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentalSampleContainmentLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentalSampleContainmentLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentalSampleContainmentLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentalSampleSampleType as json.
func (o OptExperimentalSampleSampleType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentalSampleSampleType from json.
func (o *OptExperimentalSampleSampleType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentalSampleSampleType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentalSampleSampleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentalSampleSampleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackFailureAlarmLevel as json.
func (o OptHackFailureAlarmLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HackFailureAlarmLevel from json.
func (o *OptHackFailureAlarmLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackFailureAlarmLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackFailureAlarmLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackFailureAlarmLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HackFailureFailureReason as json.
func (o OptHackFailureFailureReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HackFailureFailureReason from json.
func (o *OptHackFailureFailureReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHackFailureFailureReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHackFailureFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHackFailureFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (o OptHealthResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HealthResponseStatus from json.
func (o *OptHealthResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractErrorErrorCode as json.
func (o OptInteractErrorErrorCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InteractErrorErrorCode from json.
func (o *OptInteractErrorErrorCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInteractErrorErrorCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInteractErrorErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInteractErrorErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractResponseRewardsItemType as json.
func (o OptInteractResponseRewardsItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InteractResponseRewardsItemType from json.
func (o *OptInteractResponseRewardsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInteractResponseRewardsItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInteractResponseRewardsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInteractResponseRewardsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListeningDeviceDeviceType as json.
func (o OptListeningDeviceDeviceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ListeningDeviceDeviceType from json.
func (o *OptListeningDeviceDeviceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListeningDeviceDeviceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListeningDeviceDeviceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListeningDeviceDeviceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListeningDeviceRecordingQuality as json.
func (o OptListeningDeviceRecordingQuality) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ListeningDeviceRecordingQuality from json.
func (o *OptListeningDeviceRecordingQuality) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListeningDeviceRecordingQuality to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListeningDeviceRecordingQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListeningDeviceRecordingQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MotelSafeSafeType as json.
func (o OptMotelSafeSafeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MotelSafeSafeType from json.
func (o *OptMotelSafeSafeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMotelSafeSafeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMotelSafeSafeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMotelSafeSafeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectResponseThreatLevel as json.
func (o OptObjectResponseThreatLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ObjectResponseThreatLevel from json.
func (o *OptObjectResponseThreatLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectResponseThreatLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectResponseThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectResponseThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectStatus as json.
func (o OptObjectStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ObjectStatus from json.
func (o *OptObjectStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectSummaryThreatLevel as json.
func (o OptObjectSummaryThreatLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ObjectSummaryThreatLevel from json.
func (o *OptObjectSummaryThreatLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectSummaryThreatLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectSummaryThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectSummaryThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectType as json.
func (o OptObjectType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ObjectType from json.
func (o *OptObjectType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Position as json.
func (o OptPosition) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Position from json.
func (o *OptPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPosition to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySystemSecurityLevel as json.
func (o OptSecuritySystemSecurityLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecuritySystemSecurityLevel from json.
func (o *OptSecuritySystemSecurityLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecuritySystemSecurityLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecuritySystemSecurityLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecuritySystemSecurityLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySystemSystemType as json.
func (o OptSecuritySystemSystemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecuritySystemSystemType from json.
func (o *OptSecuritySystemSystemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecuritySystemSystemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecuritySystemSystemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecuritySystemSystemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageContainerContainerType as json.
func (o OptStorageContainerContainerType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StorageContainerContainerType from json.
func (o *OptStorageContainerContainerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorageContainerContainerType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorageContainerContainerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorageContainerContainerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageContainerLootQuality as json.
func (o OptStorageContainerLootQuality) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StorageContainerLootQuality from json.
func (o *OptStorageContainerLootQuality) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorageContainerLootQuality to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorageContainerLootQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorageContainerLootQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateObjectRequestThreatLevel as json.
func (o OptUpdateObjectRequestThreatLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateObjectRequestThreatLevel from json.
func (o *OptUpdateObjectRequestThreatLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateObjectRequestThreatLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateObjectRequestThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateObjectRequestThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WeaponSystemWeaponType as json.
func (o OptWeaponSystemWeaponType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WeaponSystemWeaponType from json.
func (o *OptWeaponSystemWeaponType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWeaponSystemWeaponType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWeaponSystemWeaponType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWeaponSystemWeaponType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZoneType as json.
func (o OptZoneType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ZoneType from json.
func (o *OptZoneType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptZoneType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptZoneType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptZoneType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Position) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Position) encodeFields(e *jx.Encoder) {
	{
		if s.X.Set {
			e.FieldStart("x")
			s.X.Encode(e)
		}
	}
	{
		if s.Y.Set {
			e.FieldStart("y")
			s.Y.Encode(e)
		}
	}
	{
		if s.Z.Set {
			e.FieldStart("z")
			s.Z.Encode(e)
		}
	}
	{
		if s.ZoneID.Set {
			e.FieldStart("zone_id")
			s.ZoneID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPosition = [4]string{
	0: "x",
	1: "y",
	2: "z",
	3: "zone_id",
}

// Decode decodes Position from json.
func (s *Position) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Position to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			if err := func() error {
				s.X.Reset()
				if err := s.X.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			if err := func() error {
				s.Y.Reset()
				if err := s.Y.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "z":
			if err := func() error {
				s.Z.Reset()
				if err := s.Z.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"z\"")
			}
		case "zone_id":
			if err := func() error {
				s.ZoneID.Reset()
				if err := s.ZoneID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Position")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Position) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Position) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReloadContentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReloadContentRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content_id")
		e.Str(s.ContentID)
	}
	{
		e.FieldStart("yaml_content")
		s.YamlContent.Encode(e)
	}
}

var jsonFieldsNameOfReloadContentRequest = [2]string{
	0: "content_id",
	1: "yaml_content",
}

// Decode decodes ReloadContentRequest from json.
func (s *ReloadContentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReloadContentRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_id\"")
			}
		case "yaml_content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.YamlContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yaml_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReloadContentRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReloadContentRequest) {
					name = jsonFieldsNameOfReloadContentRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReloadContentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReloadContentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ReloadContentRequestYamlContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ReloadContentRequestYamlContent) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ReloadContentRequestYamlContent from json.
func (s *ReloadContentRequestYamlContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReloadContentRequestYamlContent to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReloadContentRequestYamlContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReloadContentRequestYamlContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReloadContentRequestYamlContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReloadContentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReloadContentResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContentID.Set {
			e.FieldStart("content_id")
			s.ContentID.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ImportedAt.Set {
			e.FieldStart("imported_at")
			s.ImportedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ObjectsCount.Set {
			e.FieldStart("objects_count")
			s.ObjectsCount.Encode(e)
		}
	}
	{
		if s.AwakeningDifficulty.Set {
			e.FieldStart("awakening_difficulty")
			s.AwakeningDifficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfReloadContentResponse = [5]string{
	0: "content_id",
	1: "message",
	2: "imported_at",
	3: "objects_count",
	4: "awakening_difficulty",
}

// Decode decodes ReloadContentResponse from json.
func (s *ReloadContentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReloadContentResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_id":
			if err := func() error {
				s.ContentID.Reset()
				if err := s.ContentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_id\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "imported_at":
			if err := func() error {
				s.ImportedAt.Reset()
				if err := s.ImportedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported_at\"")
			}
		case "objects_count":
			if err := func() error {
				s.ObjectsCount.Reset()
				if err := s.ObjectsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objects_count\"")
			}
		case "awakening_difficulty":
			if err := func() error {
				s.AwakeningDifficulty.Reset()
				if err := s.AwakeningDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"awakening_difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReloadContentResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReloadContentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReloadContentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecuritySystem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecuritySystem) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.SystemType.Set {
			e.FieldStart("system_type")
			s.SystemType.Encode(e)
		}
	}
	{
		if s.SecurityLevel.Set {
			e.FieldStart("security_level")
			s.SecurityLevel.Encode(e)
		}
	}
	{
		if s.BypassDifficulty.Set {
			e.FieldStart("bypass_difficulty")
			s.BypassDifficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecuritySystem = [4]string{
	0: "object_id",
	1: "system_type",
	2: "security_level",
	3: "bypass_difficulty",
}

// Decode decodes SecuritySystem from json.
func (s *SecuritySystem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySystem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "system_type":
			if err := func() error {
				s.SystemType.Reset()
				if err := s.SystemType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_type\"")
			}
		case "security_level":
			if err := func() error {
				s.SecurityLevel.Reset()
				if err := s.SecurityLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_level\"")
			}
		case "bypass_difficulty":
			if err := func() error {
				s.BypassDifficulty.Reset()
				if err := s.BypassDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bypass_difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecuritySystem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecuritySystem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySystem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySystemSecurityLevel as json.
func (s SecuritySystemSecurityLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecuritySystemSecurityLevel from json.
func (s *SecuritySystemSecurityLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySystemSecurityLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecuritySystemSecurityLevel(v) {
	case SecuritySystemSecurityLevelBasic:
		*s = SecuritySystemSecurityLevelBasic
	case SecuritySystemSecurityLevelAdvanced:
		*s = SecuritySystemSecurityLevelAdvanced
	case SecuritySystemSecurityLevelMilitary:
		*s = SecuritySystemSecurityLevelMilitary
	default:
		*s = SecuritySystemSecurityLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecuritySystemSecurityLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySystemSecurityLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySystemSystemType as json.
func (s SecuritySystemSystemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecuritySystemSystemType from json.
func (s *SecuritySystemSystemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySystemSystemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecuritySystemSystemType(v) {
	case SecuritySystemSystemTypeMetalDetector:
		*s = SecuritySystemSystemTypeMetalDetector
	case SecuritySystemSystemTypeXrayScanner:
		*s = SecuritySystemSystemTypeXrayScanner
	case SecuritySystemSystemTypeBiometricLock:
		*s = SecuritySystemSystemTypeBiometricLock
	case SecuritySystemSystemTypeAccessControl:
		*s = SecuritySystemSystemTypeAccessControl
	default:
		*s = SecuritySystemSystemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecuritySystemSystemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySystemSystemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShieldGenerator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShieldGenerator) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.ProtectionRadius.Set {
			e.FieldStart("protection_radius")
			s.ProtectionRadius.Encode(e)
		}
	}
	{
		if s.EnergyCapacity.Set {
			e.FieldStart("energy_capacity")
			s.EnergyCapacity.Encode(e)
		}
	}
	{
		if s.RechargeRate.Set {
			e.FieldStart("recharge_rate")
			s.RechargeRate.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfShieldGenerator = [5]string{
	0: "object_id",
	1: "protection_radius",
	2: "energy_capacity",
	3: "recharge_rate",
	4: "active",
}

// Decode decodes ShieldGenerator from json.
func (s *ShieldGenerator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShieldGenerator to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "protection_radius":
			if err := func() error {
				s.ProtectionRadius.Reset()
				if err := s.ProtectionRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_radius\"")
			}
		case "energy_capacity":
			if err := func() error {
				s.EnergyCapacity.Reset()
				if err := s.EnergyCapacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"energy_capacity\"")
			}
		case "recharge_rate":
			if err := func() error {
				s.RechargeRate.Reset()
				if err := s.RechargeRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recharge_rate\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShieldGenerator")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShieldGenerator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShieldGenerator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageContainer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageContainer) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.ContainerType.Set {
			e.FieldStart("container_type")
			s.ContainerType.Encode(e)
		}
	}
	{
		if s.LootQuality.Set {
			e.FieldStart("loot_quality")
			s.LootQuality.Encode(e)
		}
	}
	{
		if s.TrapProbability.Set {
			e.FieldStart("trap_probability")
			s.TrapProbability.Encode(e)
		}
	}
}

var jsonFieldsNameOfStorageContainer = [4]string{
	0: "object_id",
	1: "container_type",
	2: "loot_quality",
	3: "trap_probability",
}

// Decode decodes StorageContainer from json.
func (s *StorageContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageContainer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "container_type":
			if err := func() error {
				s.ContainerType.Reset()
				if err := s.ContainerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_type\"")
			}
		case "loot_quality":
			if err := func() error {
				s.LootQuality.Reset()
				if err := s.LootQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loot_quality\"")
			}
		case "trap_probability":
			if err := func() error {
				s.TrapProbability.Reset()
				if err := s.TrapProbability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trap_probability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageContainer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageContainerContainerType as json.
func (s StorageContainerContainerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StorageContainerContainerType from json.
func (s *StorageContainerContainerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageContainerContainerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StorageContainerContainerType(v) {
	case StorageContainerContainerTypeSuitcase:
		*s = StorageContainerContainerTypeSuitcase
	case StorageContainerContainerTypeCargoBox:
		*s = StorageContainerContainerTypeCargoBox
	case StorageContainerContainerTypeLocker:
		*s = StorageContainerContainerTypeLocker
	case StorageContainerContainerTypeSafe:
		*s = StorageContainerContainerTypeSafe
	default:
		*s = StorageContainerContainerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StorageContainerContainerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageContainerContainerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageContainerLootQuality as json.
func (s StorageContainerLootQuality) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StorageContainerLootQuality from json.
func (s *StorageContainerLootQuality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageContainerLootQuality to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StorageContainerLootQuality(v) {
	case StorageContainerLootQualityTrash:
		*s = StorageContainerLootQualityTrash
	case StorageContainerLootQualityCommon:
		*s = StorageContainerLootQualityCommon
	case StorageContainerLootQualityRare:
		*s = StorageContainerLootQualityRare
	case StorageContainerLootQualityEpic:
		*s = StorageContainerLootQualityEpic
	default:
		*s = StorageContainerLootQuality(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StorageContainerLootQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageContainerLootQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SurveillanceCamera) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SurveillanceCamera) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.CoverageAngle.Set {
			e.FieldStart("coverage_angle")
			s.CoverageAngle.Encode(e)
		}
	}
	{
		if s.DetectionRange.Set {
			e.FieldStart("detection_range")
			s.DetectionRange.Encode(e)
		}
	}
	{
		if s.NightVision.Set {
			e.FieldStart("night_vision")
			s.NightVision.Encode(e)
		}
	}
	{
		if s.RecordingActive.Set {
			e.FieldStart("recording_active")
			s.RecordingActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfSurveillanceCamera = [5]string{
	0: "object_id",
	1: "coverage_angle",
	2: "detection_range",
	3: "night_vision",
	4: "recording_active",
}

// Decode decodes SurveillanceCamera from json.
func (s *SurveillanceCamera) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SurveillanceCamera to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "coverage_angle":
			if err := func() error {
				s.CoverageAngle.Reset()
				if err := s.CoverageAngle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coverage_angle\"")
			}
		case "detection_range":
			if err := func() error {
				s.DetectionRange.Reset()
				if err := s.DetectionRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detection_range\"")
			}
		case "night_vision":
			if err := func() error {
				s.NightVision.Reset()
				if err := s.NightVision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"night_vision\"")
			}
		case "recording_active":
			if err := func() error {
				s.RecordingActive.Reset()
				if err := s.RecordingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SurveillanceCamera")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SurveillanceCamera) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SurveillanceCamera) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelemetryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelemetryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Metric.Set {
			e.FieldStart("metric")
			s.Metric.Encode(e)
		}
	}
	{
		if s.ZoneType.Set {
			e.FieldStart("zone_type")
			s.ZoneType.Encode(e)
		}
	}
	{
		if s.Timeframe.Set {
			e.FieldStart("timeframe")
			s.Timeframe.Encode(e)
		}
	}
	{
		if s.DataPoints != nil {
			e.FieldStart("data_points")
			e.ArrStart()
			for _, elem := range s.DataPoints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Average.Set {
			e.FieldStart("average")
			s.Average.Encode(e)
		}
	}
	{
		if s.Peak.Set {
			e.FieldStart("peak")
			s.Peak.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelemetryResponse = [7]string{
	0: "metric",
	1: "zone_type",
	2: "timeframe",
	3: "data_points",
	4: "average",
	5: "peak",
	6: "total",
}

// Decode decodes TelemetryResponse from json.
func (s *TelemetryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelemetryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			if err := func() error {
				s.Metric.Reset()
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "zone_type":
			if err := func() error {
				s.ZoneType.Reset()
				if err := s.ZoneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_type\"")
			}
		case "timeframe":
			if err := func() error {
				s.Timeframe.Reset()
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "data_points":
			if err := func() error {
				s.DataPoints = make([]TelemetryResponseDataPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TelemetryResponseDataPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DataPoints = append(s.DataPoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_points\"")
			}
		case "average":
			if err := func() error {
				s.Average.Reset()
				if err := s.Average.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average\"")
			}
		case "peak":
			if err := func() error {
				s.Peak.Reset()
				if err := s.Peak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peak\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelemetryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelemetryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelemetryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelemetryResponseDataPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelemetryResponseDataPointsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelemetryResponseDataPointsItem = [2]string{
	0: "timestamp",
	1: "value",
}

// Decode decodes TelemetryResponseDataPointsItem from json.
func (s *TelemetryResponseDataPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelemetryResponseDataPointsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelemetryResponseDataPointsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelemetryResponseDataPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelemetryResponseDataPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateObjectRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateObjectRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.ThreatLevel.Set {
			e.FieldStart("threat_level")
			s.ThreatLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateObjectRequest = [4]string{
	0: "status",
	1: "position",
	2: "properties",
	3: "threat_level",
}

// Decode decodes UpdateObjectRequest from json.
func (s *UpdateObjectRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateObjectRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem UpdateObjectRequestProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "threat_level":
			if err := func() error {
				s.ThreatLevel.Reset()
				if err := s.ThreatLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threat_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateObjectRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateObjectRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateObjectRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateObjectRequestProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateObjectRequestProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateObjectRequestProperties = [0]string{}

// Decode decodes UpdateObjectRequestProperties from json.
func (s *UpdateObjectRequestProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateObjectRequestProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateObjectRequestProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateObjectRequestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateObjectRequestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateObjectRequestThreatLevel as json.
func (s UpdateObjectRequestThreatLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateObjectRequestThreatLevel from json.
func (s *UpdateObjectRequestThreatLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateObjectRequestThreatLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateObjectRequestThreatLevel(v) {
	case UpdateObjectRequestThreatLevelLow:
		*s = UpdateObjectRequestThreatLevelLow
	case UpdateObjectRequestThreatLevelMedium:
		*s = UpdateObjectRequestThreatLevelMedium
	case UpdateObjectRequestThreatLevelHigh:
		*s = UpdateObjectRequestThreatLevelHigh
	case UpdateObjectRequestThreatLevelExtreme:
		*s = UpdateObjectRequestThreatLevelExtreme
	default:
		*s = UpdateObjectRequestThreatLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateObjectRequestThreatLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateObjectRequestThreatLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WeaponSystem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WeaponSystem) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectID.Set {
			e.FieldStart("object_id")
			s.ObjectID.Encode(e)
		}
	}
	{
		if s.WeaponType.Set {
			e.FieldStart("weapon_type")
			s.WeaponType.Encode(e)
		}
	}
	{
		if s.DamagePerShot.Set {
			e.FieldStart("damage_per_shot")
			s.DamagePerShot.Encode(e)
		}
	}
	{
		if s.RateOfFire.Set {
			e.FieldStart("rate_of_fire")
			s.RateOfFire.Encode(e)
		}
	}
	{
		if s.Range.Set {
			e.FieldStart("range")
			s.Range.Encode(e)
		}
	}
}

var jsonFieldsNameOfWeaponSystem = [5]string{
	0: "object_id",
	1: "weapon_type",
	2: "damage_per_shot",
	3: "rate_of_fire",
	4: "range",
}

// Decode decodes WeaponSystem from json.
func (s *WeaponSystem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WeaponSystem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_id":
			if err := func() error {
				s.ObjectID.Reset()
				if err := s.ObjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_id\"")
			}
		case "weapon_type":
			if err := func() error {
				s.WeaponType.Reset()
				if err := s.WeaponType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_type\"")
			}
		case "damage_per_shot":
			if err := func() error {
				s.DamagePerShot.Reset()
				if err := s.DamagePerShot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage_per_shot\"")
			}
		case "rate_of_fire":
			if err := func() error {
				s.RateOfFire.Reset()
				if err := s.RateOfFire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_of_fire\"")
			}
		case "range":
			if err := func() error {
				s.Range.Reset()
				if err := s.Range.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WeaponSystem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WeaponSystem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WeaponSystem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WeaponSystemWeaponType as json.
func (s WeaponSystemWeaponType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WeaponSystemWeaponType from json.
func (s *WeaponSystemWeaponType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WeaponSystemWeaponType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WeaponSystemWeaponType(v) {
	case WeaponSystemWeaponTypeArtillery:
		*s = WeaponSystemWeaponTypeArtillery
	case WeaponSystemWeaponTypeMissileLauncher:
		*s = WeaponSystemWeaponTypeMissileLauncher
	case WeaponSystemWeaponTypeTurret:
		*s = WeaponSystemWeaponTypeTurret
	case WeaponSystemWeaponTypeRailgun:
		*s = WeaponSystemWeaponTypeRailgun
	default:
		*s = WeaponSystemWeaponType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WeaponSystemWeaponType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WeaponSystemWeaponType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ZoneObjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ZoneObjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ZoneID.Set {
			e.FieldStart("zone_id")
			s.ZoneID.Encode(e)
		}
	}
	{
		if s.ZoneType.Set {
			e.FieldStart("zone_type")
			s.ZoneType.Encode(e)
		}
	}
	{
		if s.Objects != nil {
			e.FieldStart("objects")
			e.ArrStart()
			for _, elem := range s.Objects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalObjects.Set {
			e.FieldStart("total_objects")
			s.TotalObjects.Encode(e)
		}
	}
	{
		if s.ActiveObjects.Set {
			e.FieldStart("active_objects")
			s.ActiveObjects.Encode(e)
		}
	}
}

var jsonFieldsNameOfZoneObjectsResponse = [5]string{
	0: "zone_id",
	1: "zone_type",
	2: "objects",
	3: "total_objects",
	4: "active_objects",
}

// Decode decodes ZoneObjectsResponse from json.
func (s *ZoneObjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZoneObjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "zone_id":
			if err := func() error {
				s.ZoneID.Reset()
				if err := s.ZoneID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_id\"")
			}
		case "zone_type":
			if err := func() error {
				s.ZoneType.Reset()
				if err := s.ZoneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone_type\"")
			}
		case "objects":
			if err := func() error {
				s.Objects = make([]ObjectResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ObjectResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objects = append(s.Objects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objects\"")
			}
		case "total_objects":
			if err := func() error {
				s.TotalObjects.Reset()
				if err := s.TotalObjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_objects\"")
			}
		case "active_objects":
			if err := func() error {
				s.ActiveObjects.Reset()
				if err := s.ActiveObjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_objects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ZoneObjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ZoneObjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZoneObjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZoneType as json.
func (s ZoneType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ZoneType from json.
func (s *ZoneType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZoneType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ZoneType(v) {
	case ZoneTypeAirport:
		*s = ZoneTypeAirport
	case ZoneTypeMilitaryBase:
		*s = ZoneTypeMilitaryBase
	case ZoneTypeNoTellMotel:
		*s = ZoneTypeNoTellMotel
	case ZoneTypeCovertLab:
		*s = ZoneTypeCovertLab
	default:
		*s = ZoneType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ZoneType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZoneType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
