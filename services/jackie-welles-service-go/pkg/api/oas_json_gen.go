// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AcceptJackieQuestConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AcceptJackieQuestConflict) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAcceptJackieQuestConflict = [1]string{
	0: "error",
}

// Decode decodes AcceptJackieQuestConflict from json.
func (s *AcceptJackieQuestConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AcceptJackieQuestConflict to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AcceptJackieQuestConflict")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AcceptJackieQuestConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AcceptJackieQuestConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Consequences != nil {
			e.FieldStart("consequences")
			e.ArrStart()
			for _, elem := range s.Consequences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDialogueOption = [3]string{
	0: "id",
	1: "text",
	2: "consequences",
}

// Decode decodes DialogueOption from json.
func (s *DialogueOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "consequences":
			if err := func() error {
				s.Consequences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Consequences = append(s.Consequences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consequences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDialogueOption) {
					name = jsonFieldsNameOfDialogueOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dialogue_id")
		json.EncodeUUID(e, s.DialogueID)
	}
	{
		e.FieldStart("speaker")
		e.Str(s.Speaker)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Emotion.Set {
			e.FieldStart("emotion")
			s.Emotion.Encode(e)
		}
	}
	{
		e.FieldStart("options")
		e.ArrStart()
		for _, elem := range s.Options {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BackgroundActions != nil {
			e.FieldStart("background_actions")
			e.ArrStart()
			for _, elem := range s.BackgroundActions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDialogueResponse = [6]string{
	0: "dialogue_id",
	1: "speaker",
	2: "text",
	3: "emotion",
	4: "options",
	5: "background_actions",
}

// Decode decodes DialogueResponse from json.
func (s *DialogueResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dialogue_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DialogueID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogue_id\"")
			}
		case "speaker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Speaker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "emotion":
			if err := func() error {
				s.Emotion.Reset()
				if err := s.Emotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emotion\"")
			}
		case "options":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Options = make([]DialogueOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "background_actions":
			if err := func() error {
				s.BackgroundActions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.BackgroundActions = append(s.BackgroundActions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDialogueResponse) {
					name = jsonFieldsNameOfDialogueResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DialogueResponseEmotion as json.
func (s DialogueResponseEmotion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DialogueResponseEmotion from json.
func (s *DialogueResponseEmotion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueResponseEmotion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DialogueResponseEmotion(v) {
	case DialogueResponseEmotionNeutral:
		*s = DialogueResponseEmotionNeutral
	case DialogueResponseEmotionHappy:
		*s = DialogueResponseEmotionHappy
	case DialogueResponseEmotionAngry:
		*s = DialogueResponseEmotionAngry
	case DialogueResponseEmotionConcerned:
		*s = DialogueResponseEmotionConcerned
	case DialogueResponseEmotionExcited:
		*s = DialogueResponseEmotionExcited
	case DialogueResponseEmotionSad:
		*s = DialogueResponseEmotionSad
	default:
		*s = DialogueResponseEmotion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DialogueResponseEmotion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueResponseEmotion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueResponseRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueResponseRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("option_id")
		e.Str(s.OptionID)
	}
	{
		if s.AdditionalContext != nil {
			e.FieldStart("additional_context")
			s.AdditionalContext.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialogueResponseRequest = [2]string{
	0: "option_id",
	1: "additional_context",
}

// Decode decodes DialogueResponseRequest from json.
func (s *DialogueResponseRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueResponseRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "option_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OptionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"option_id\"")
			}
		case "additional_context":
			if err := func() error {
				s.AdditionalContext = nil
				var elem DialogueResponseRequestAdditionalContext
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalContext = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueResponseRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDialogueResponseRequest) {
					name = jsonFieldsNameOfDialogueResponseRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueResponseRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueResponseRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueResponseRequestAdditionalContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueResponseRequestAdditionalContext) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDialogueResponseRequestAdditionalContext = [0]string{}

// Decode decodes DialogueResponseRequestAdditionalContext from json.
func (s *DialogueResponseRequestAdditionalContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueResponseRequestAdditionalContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DialogueResponseRequestAdditionalContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueResponseRequestAdditionalContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueResponseRequestAdditionalContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueStartRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueStartRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.UrgencyLevel.Set {
			e.FieldStart("urgency_level")
			s.UrgencyLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialogueStartRequest = [3]string{
	0: "context",
	1: "location",
	2: "urgency_level",
}

// Decode decodes DialogueStartRequest from json.
func (s *DialogueStartRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueStartRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "urgency_level":
			if err := func() error {
				s.UrgencyLevel.Reset()
				if err := s.UrgencyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urgency_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueStartRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueStartRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueStartRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DialogueStartRequestUrgencyLevel as json.
func (s DialogueStartRequestUrgencyLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DialogueStartRequestUrgencyLevel from json.
func (s *DialogueStartRequestUrgencyLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueStartRequestUrgencyLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DialogueStartRequestUrgencyLevel(v) {
	case DialogueStartRequestUrgencyLevelCasual:
		*s = DialogueStartRequestUrgencyLevelCasual
	case DialogueStartRequestUrgencyLevelUrgent:
		*s = DialogueStartRequestUrgencyLevelUrgent
	case DialogueStartRequestUrgencyLevelEmergency:
		*s = DialogueStartRequestUrgencyLevelEmergency
	default:
		*s = DialogueStartRequestUrgencyLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DialogueStartRequestUrgencyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueStartRequestUrgencyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "message",
	1: "domain",
	2: "timestamp",
	3: "code",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetJackieAvailableQuestsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetJackieAvailableQuestsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quests")
		e.ArrStart()
		for _, elem := range s.Quests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfGetJackieAvailableQuestsOK = [2]string{
	0: "quests",
	1: "total",
}

// Decode decodes GetJackieAvailableQuestsOK from json.
func (s *GetJackieAvailableQuestsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetJackieAvailableQuestsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quests":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Quests = make([]JackieQuest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JackieQuest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Quests = append(s.Quests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quests\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetJackieAvailableQuestsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetJackieAvailableQuestsOK) {
					name = jsonFieldsNameOfGetJackieAvailableQuestsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetJackieAvailableQuestsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetJackieAvailableQuestsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetJackieInventoryOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetJackieInventoryOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("last_updated")
		json.EncodeDateTime(e, s.LastUpdated)
	}
}

var jsonFieldsNameOfGetJackieInventoryOK = [2]string{
	0: "items",
	1: "last_updated",
}

// Decode decodes GetJackieInventoryOK from json.
func (s *GetJackieInventoryOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetJackieInventoryOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]InventoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "last_updated":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LastUpdated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetJackieInventoryOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetJackieInventoryOK) {
					name = jsonFieldsNameOfGetJackieInventoryOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetJackieInventoryOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetJackieInventoryOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractWithJackieBadRequest as json.
func (s *InteractWithJackieBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes InteractWithJackieBadRequest from json.
func (s *InteractWithJackieBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractWithJackieBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InteractWithJackieBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractWithJackieBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractWithJackieBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractWithJackieNotFound as json.
func (s *InteractWithJackieNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes InteractWithJackieNotFound from json.
func (s *InteractWithJackieNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractWithJackieNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InteractWithJackieNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractWithJackieNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractWithJackieNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("interaction_type")
		s.InteractionType.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Context != nil {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractionRequest = [3]string{
	0: "interaction_type",
	1: "location",
	2: "context",
}

// Decode decodes InteractionRequest from json.
func (s *InteractionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "interaction_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.InteractionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "context":
			if err := func() error {
				s.Context = nil
				var elem InteractionRequestContext
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Context = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionRequest) {
					name = jsonFieldsNameOfInteractionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractionRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractionRequestContext) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInteractionRequestContext = [0]string{}

// Decode decodes InteractionRequestContext from json.
func (s *InteractionRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionRequestContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InteractionRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractionRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractionRequestInteractionType as json.
func (s InteractionRequestInteractionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionRequestInteractionType from json.
func (s *InteractionRequestInteractionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionRequestInteractionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionRequestInteractionType(v) {
	case InteractionRequestInteractionTypeTalk:
		*s = InteractionRequestInteractionTypeTalk
	case InteractionRequestInteractionTypeTrade:
		*s = InteractionRequestInteractionTypeTrade
	case InteractionRequestInteractionTypeQuest:
		*s = InteractionRequestInteractionTypeQuest
	case InteractionRequestInteractionTypeHelp:
		*s = InteractionRequestInteractionTypeHelp
	case InteractionRequestInteractionTypeFight:
		*s = InteractionRequestInteractionTypeFight
	default:
		*s = InteractionRequestInteractionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractionRequestInteractionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionRequestInteractionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		if s.DialogueText.Set {
			e.FieldStart("dialogue_text")
			s.DialogueText.Encode(e)
		}
	}
	{
		e.FieldStart("dialogue_options")
		e.ArrStart()
		for _, elem := range s.DialogueOptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.AvailableActions != nil {
			e.FieldStart("available_actions")
			e.ArrStart()
			for _, elem := range s.AvailableActions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipChange.Set {
			e.FieldStart("relationship_change")
			s.RelationshipChange.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractionResponse = [5]string{
	0: "result",
	1: "dialogue_text",
	2: "dialogue_options",
	3: "available_actions",
	4: "relationship_change",
}

// Decode decodes InteractionResponse from json.
func (s *InteractionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "dialogue_text":
			if err := func() error {
				s.DialogueText.Reset()
				if err := s.DialogueText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogue_text\"")
			}
		case "dialogue_options":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.DialogueOptions = make([]DialogueOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DialogueOptions = append(s.DialogueOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogue_options\"")
			}
		case "available_actions":
			if err := func() error {
				s.AvailableActions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AvailableActions = append(s.AvailableActions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_actions\"")
			}
		case "relationship_change":
			if err := func() error {
				s.RelationshipChange.Reset()
				if err := s.RelationshipChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_change\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionResponse) {
					name = jsonFieldsNameOfInteractionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractionResponseResult as json.
func (s InteractionResponseResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionResponseResult from json.
func (s *InteractionResponseResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionResponseResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionResponseResult(v) {
	case InteractionResponseResultSuccess:
		*s = InteractionResponseResultSuccess
	case InteractionResponseResultPartialSuccess:
		*s = InteractionResponseResultPartialSuccess
	case InteractionResponseResultFailure:
		*s = InteractionResponseResultFailure
	case InteractionResponseResultUnavailable:
		*s = InteractionResponseResultUnavailable
	default:
		*s = InteractionResponseResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractionResponseResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionResponseResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InventoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InventoryItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item_id")
		json.EncodeUUID(e, s.ItemID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Rarity.Set {
			e.FieldStart("rarity")
			s.Rarity.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfInventoryItem = [6]string{
	0: "item_id",
	1: "name",
	2: "type",
	3: "rarity",
	4: "description",
	5: "price",
}

// Decode decodes InventoryItem from json.
func (s *InventoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventoryItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "rarity":
			if err := func() error {
				s.Rarity.Reset()
				if err := s.Rarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InventoryItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInventoryItem) {
					name = jsonFieldsNameOfInventoryItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InventoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InventoryItemRarity as json.
func (s InventoryItemRarity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InventoryItemRarity from json.
func (s *InventoryItemRarity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventoryItemRarity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InventoryItemRarity(v) {
	case InventoryItemRarityCommon:
		*s = InventoryItemRarityCommon
	case InventoryItemRarityUncommon:
		*s = InventoryItemRarityUncommon
	case InventoryItemRarityRare:
		*s = InventoryItemRarityRare
	case InventoryItemRarityEpic:
		*s = InventoryItemRarityEpic
	case InventoryItemRarityLegendary:
		*s = InventoryItemRarityLegendary
	default:
		*s = InventoryItemRarity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InventoryItemRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventoryItemRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InventoryItemType as json.
func (s InventoryItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InventoryItemType from json.
func (s *InventoryItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventoryItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InventoryItemType(v) {
	case InventoryItemTypeWeapon:
		*s = InventoryItemTypeWeapon
	case InventoryItemTypeArmor:
		*s = InventoryItemTypeArmor
	case InventoryItemTypeCyberware:
		*s = InventoryItemTypeCyberware
	case InventoryItemTypeConsumable:
		*s = InventoryItemTypeConsumable
	case InventoryItemTypeVehiclePart:
		*s = InventoryItemTypeVehiclePart
	default:
		*s = InventoryItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InventoryItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventoryItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JackieCombatStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JackieCombatStats) encodeFields(e *jx.Encoder) {
	{
		if s.SpecialAbilities != nil {
			e.FieldStart("special_abilities")
			e.ArrStart()
			for _, elem := range s.SpecialAbilities {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Health.Set {
			e.FieldStart("health")
			s.Health.Encode(e)
		}
	}
	{
		if s.Armor.Set {
			e.FieldStart("armor")
			s.Armor.Encode(e)
		}
	}
	{
		if s.Damage.Set {
			e.FieldStart("damage")
			s.Damage.Encode(e)
		}
	}
	{
		if s.Accuracy.Set {
			e.FieldStart("accuracy")
			s.Accuracy.Encode(e)
		}
	}
}

var jsonFieldsNameOfJackieCombatStats = [6]string{
	0: "special_abilities",
	1: "level",
	2: "health",
	3: "armor",
	4: "damage",
	5: "accuracy",
}

// Decode decodes JackieCombatStats from json.
func (s *JackieCombatStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieCombatStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "special_abilities":
			if err := func() error {
				s.SpecialAbilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SpecialAbilities = append(s.SpecialAbilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"special_abilities\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "health":
			if err := func() error {
				s.Health.Reset()
				if err := s.Health.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		case "armor":
			if err := func() error {
				s.Armor.Reset()
				if err := s.Armor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor\"")
			}
		case "damage":
			if err := func() error {
				s.Damage.Reset()
				if err := s.Damage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "accuracy":
			if err := func() error {
				s.Accuracy.Reset()
				if err := s.Accuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accuracy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JackieCombatStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JackieCombatStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieCombatStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JackieProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JackieProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("npc_id")
		json.EncodeUUID(e, s.NpcID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faction")
		e.Str(s.Faction)
	}
	{
		e.FieldStart("relationship_level")
		s.RelationshipLevel.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.CurrentActivity.Set {
			e.FieldStart("current_activity")
			s.CurrentActivity.Encode(e)
		}
	}
	{
		if s.CombatStats.Set {
			e.FieldStart("combat_stats")
			s.CombatStats.Encode(e)
		}
	}
	{
		if s.PersonalityTraits != nil {
			e.FieldStart("personality_traits")
			e.ArrStart()
			for _, elem := range s.PersonalityTraits {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AvailableServices != nil {
			e.FieldStart("available_services")
			e.ArrStart()
			for _, elem := range s.AvailableServices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Age.Set {
			e.FieldStart("age")
			s.Age.Encode(e)
		}
	}
}

var jsonFieldsNameOfJackieProfile = [10]string{
	0: "npc_id",
	1: "name",
	2: "faction",
	3: "relationship_level",
	4: "location",
	5: "current_activity",
	6: "combat_stats",
	7: "personality_traits",
	8: "available_services",
	9: "age",
}

// Decode decodes JackieProfile from json.
func (s *JackieProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "npc_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NpcID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faction":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Faction = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction\"")
			}
		case "relationship_level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RelationshipLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_level\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "current_activity":
			if err := func() error {
				s.CurrentActivity.Reset()
				if err := s.CurrentActivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_activity\"")
			}
		case "combat_stats":
			if err := func() error {
				s.CombatStats.Reset()
				if err := s.CombatStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_stats\"")
			}
		case "personality_traits":
			if err := func() error {
				s.PersonalityTraits = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PersonalityTraits = append(s.PersonalityTraits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personality_traits\"")
			}
		case "available_services":
			if err := func() error {
				s.AvailableServices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AvailableServices = append(s.AvailableServices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_services\"")
			}
		case "age":
			if err := func() error {
				s.Age.Reset()
				if err := s.Age.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JackieProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJackieProfile) {
					name = jsonFieldsNameOfJackieProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JackieProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieProfileRelationshipLevel as json.
func (s JackieProfileRelationshipLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieProfileRelationshipLevel from json.
func (s *JackieProfileRelationshipLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieProfileRelationshipLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieProfileRelationshipLevel(v) {
	case JackieProfileRelationshipLevelStranger:
		*s = JackieProfileRelationshipLevelStranger
	case JackieProfileRelationshipLevelAcquaintance:
		*s = JackieProfileRelationshipLevelAcquaintance
	case JackieProfileRelationshipLevelFriend:
		*s = JackieProfileRelationshipLevelFriend
	case JackieProfileRelationshipLevelCloseFriend:
		*s = JackieProfileRelationshipLevelCloseFriend
	case JackieProfileRelationshipLevelBrother:
		*s = JackieProfileRelationshipLevelBrother
	default:
		*s = JackieProfileRelationshipLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieProfileRelationshipLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieProfileRelationshipLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JackieQuest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JackieQuest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quest_id")
		json.EncodeUUID(e, s.QuestID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		if s.Requirements != nil {
			e.FieldStart("requirements")
			e.ArrStart()
			for _, elem := range s.Requirements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Prerequisites != nil {
			e.FieldStart("prerequisites")
			e.ArrStart()
			for _, elem := range s.Prerequisites {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfJackieQuest = [10]string{
	0: "quest_id",
	1: "title",
	2: "description",
	3: "type",
	4: "difficulty",
	5: "time_limit",
	6: "rewards",
	7: "requirements",
	8: "objectives",
	9: "prerequisites",
}

// Decode decodes JackieQuest from json.
func (s *JackieQuest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieQuest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.QuestID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "requirements":
			if err := func() error {
				s.Requirements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Requirements = append(s.Requirements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]QuestObjective, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestObjective
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "prerequisites":
			if err := func() error {
				s.Prerequisites = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Prerequisites = append(s.Prerequisites, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerequisites\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JackieQuest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJackieQuest) {
					name = jsonFieldsNameOfJackieQuest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JackieQuest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieQuest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieQuestDifficulty as json.
func (s JackieQuestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieQuestDifficulty from json.
func (s *JackieQuestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieQuestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieQuestDifficulty(v) {
	case JackieQuestDifficultyEasy:
		*s = JackieQuestDifficultyEasy
	case JackieQuestDifficultyMedium:
		*s = JackieQuestDifficultyMedium
	case JackieQuestDifficultyHard:
		*s = JackieQuestDifficultyHard
	case JackieQuestDifficultyVeryHard:
		*s = JackieQuestDifficultyVeryHard
	default:
		*s = JackieQuestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieQuestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieQuestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieQuestType as json.
func (s JackieQuestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieQuestType from json.
func (s *JackieQuestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieQuestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieQuestType(v) {
	case JackieQuestTypeDelivery:
		*s = JackieQuestTypeDelivery
	case JackieQuestTypeAssassination:
		*s = JackieQuestTypeAssassination
	case JackieQuestTypeProtection:
		*s = JackieQuestTypeProtection
	case JackieQuestTypeInvestigation:
		*s = JackieQuestTypeInvestigation
	case JackieQuestTypeEscort:
		*s = JackieQuestTypeEscort
	default:
		*s = JackieQuestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieQuestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieQuestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JackieRelationship) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JackieRelationship) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		e.FieldStart("trust_level")
		s.TrustLevel.Encode(e)
	}
	{
		if s.UnlockedFeatures != nil {
			e.FieldStart("unlocked_features")
			e.ArrStart()
			for _, elem := range s.UnlockedFeatures {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipEvents != nil {
			e.FieldStart("relationship_events")
			e.ArrStart()
			for _, elem := range s.RelationshipEvents {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("loyalty_points")
		e.Int(s.LoyaltyPoints)
	}
}

var jsonFieldsNameOfJackieRelationship = [5]string{
	0: "level",
	1: "trust_level",
	2: "unlocked_features",
	3: "relationship_events",
	4: "loyalty_points",
}

// Decode decodes JackieRelationship from json.
func (s *JackieRelationship) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieRelationship to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "trust_level":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TrustLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trust_level\"")
			}
		case "unlocked_features":
			if err := func() error {
				s.UnlockedFeatures = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UnlockedFeatures = append(s.UnlockedFeatures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlocked_features\"")
			}
		case "relationship_events":
			if err := func() error {
				s.RelationshipEvents = make([]RelationshipEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RelationshipEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RelationshipEvents = append(s.RelationshipEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_events\"")
			}
		case "loyalty_points":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.LoyaltyPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loyalty_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JackieRelationship")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJackieRelationship) {
					name = jsonFieldsNameOfJackieRelationship[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JackieRelationship) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieRelationship) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieRelationshipLevel as json.
func (s JackieRelationshipLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieRelationshipLevel from json.
func (s *JackieRelationshipLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieRelationshipLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieRelationshipLevel(v) {
	case JackieRelationshipLevelStranger:
		*s = JackieRelationshipLevelStranger
	case JackieRelationshipLevelAcquaintance:
		*s = JackieRelationshipLevelAcquaintance
	case JackieRelationshipLevelFriend:
		*s = JackieRelationshipLevelFriend
	case JackieRelationshipLevelCloseFriend:
		*s = JackieRelationshipLevelCloseFriend
	case JackieRelationshipLevelBrother:
		*s = JackieRelationshipLevelBrother
	default:
		*s = JackieRelationshipLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieRelationshipLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieRelationshipLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieRelationshipTrustLevel as json.
func (s JackieRelationshipTrustLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieRelationshipTrustLevel from json.
func (s *JackieRelationshipTrustLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieRelationshipTrustLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieRelationshipTrustLevel(v) {
	case JackieRelationshipTrustLevelLow:
		*s = JackieRelationshipTrustLevelLow
	case JackieRelationshipTrustLevelMedium:
		*s = JackieRelationshipTrustLevelMedium
	case JackieRelationshipTrustLevelHigh:
		*s = JackieRelationshipTrustLevelHigh
	case JackieRelationshipTrustLevelAbsolute:
		*s = JackieRelationshipTrustLevelAbsolute
	default:
		*s = JackieRelationshipTrustLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieRelationshipTrustLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieRelationshipTrustLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JackieStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JackieStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("npc_id")
		json.EncodeUUID(e, s.NpcID)
	}
	{
		e.FieldStart("location")
		e.Str(s.Location)
	}
	{
		if s.Activity.Set {
			e.FieldStart("activity")
			s.Activity.Encode(e)
		}
	}
	{
		if s.NextAvailable.Set {
			e.FieldStart("next_available")
			s.NextAvailable.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Mood.Set {
			e.FieldStart("mood")
			s.Mood.Encode(e)
		}
	}
	{
		e.FieldStart("available")
		e.Bool(s.Available)
	}
}

var jsonFieldsNameOfJackieStatus = [6]string{
	0: "npc_id",
	1: "location",
	2: "activity",
	3: "next_available",
	4: "mood",
	5: "available",
}

// Decode decodes JackieStatus from json.
func (s *JackieStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "npc_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NpcID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"npc_id\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Location = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "activity":
			if err := func() error {
				s.Activity.Reset()
				if err := s.Activity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activity\"")
			}
		case "next_available":
			if err := func() error {
				s.NextAvailable.Reset()
				if err := s.NextAvailable.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_available\"")
			}
		case "mood":
			if err := func() error {
				s.Mood.Reset()
				if err := s.Mood.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mood\"")
			}
		case "available":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Available = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JackieStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJackieStatus) {
					name = jsonFieldsNameOfJackieStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JackieStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieStatusMood as json.
func (s JackieStatusMood) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JackieStatusMood from json.
func (s *JackieStatusMood) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JackieStatusMood to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JackieStatusMood(v) {
	case JackieStatusMoodNeutral:
		*s = JackieStatusMoodNeutral
	case JackieStatusMoodHappy:
		*s = JackieStatusMoodHappy
	case JackieStatusMoodAngry:
		*s = JackieStatusMoodAngry
	case JackieStatusMoodConcerned:
		*s = JackieStatusMoodConcerned
	case JackieStatusMoodExcited:
		*s = JackieStatusMoodExcited
	default:
		*s = JackieStatusMood(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JackieStatusMood) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JackieStatusMood) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DialogueResponseEmotion as json.
func (o OptDialogueResponseEmotion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DialogueResponseEmotion from json.
func (o *OptDialogueResponseEmotion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDialogueResponseEmotion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDialogueResponseEmotion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDialogueResponseEmotion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DialogueStartRequestUrgencyLevel as json.
func (o OptDialogueStartRequestUrgencyLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DialogueStartRequestUrgencyLevel from json.
func (o *OptDialogueStartRequestUrgencyLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDialogueStartRequestUrgencyLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDialogueStartRequestUrgencyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDialogueStartRequestUrgencyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Duration as json.
func (o OptDuration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeDuration(e, o.Value)
}

// Decode decodes time.Duration from json.
func (o *OptDuration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDuration to nil")
	}
	o.Set = true
	v, err := json.DecodeDuration(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InventoryItemRarity as json.
func (o OptInventoryItemRarity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InventoryItemRarity from json.
func (o *OptInventoryItemRarity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInventoryItemRarity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInventoryItemRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInventoryItemRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieCombatStats as json.
func (o OptJackieCombatStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JackieCombatStats from json.
func (o *OptJackieCombatStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJackieCombatStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJackieCombatStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJackieCombatStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JackieStatusMood as json.
func (o OptJackieStatusMood) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes JackieStatusMood from json.
func (o *OptJackieStatusMood) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJackieStatusMood to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJackieStatusMood) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJackieStatusMood) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestObjectiveProgress as json.
func (o OptQuestObjectiveProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QuestObjectiveProgress from json.
func (o *OptQuestObjectiveProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestObjectiveProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestObjectiveProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestObjectiveProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestObjective) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestObjective) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Target.Set {
			e.FieldStart("target")
			s.Target.Encode(e)
		}
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestObjective = [5]string{
	0: "id",
	1: "description",
	2: "type",
	3: "target",
	4: "progress",
}

// Decode decodes QuestObjective from json.
func (s *QuestObjective) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjective to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestObjective")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQuestObjective) {
					name = jsonFieldsNameOfQuestObjective[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestObjective) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjective) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestObjectiveProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestObjectiveProgress) encodeFields(e *jx.Encoder) {
	{
		if s.Current.Set {
			e.FieldStart("current")
			s.Current.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestObjectiveProgress = [2]string{
	0: "current",
	1: "required",
}

// Decode decodes QuestObjectiveProgress from json.
func (s *QuestObjectiveProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjectiveProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			if err := func() error {
				s.Current.Reset()
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestObjectiveProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestObjectiveProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjectiveProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestObjectiveType as json.
func (s QuestObjectiveType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestObjectiveType from json.
func (s *QuestObjectiveType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjectiveType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestObjectiveType(v) {
	case QuestObjectiveTypeKill:
		*s = QuestObjectiveTypeKill
	case QuestObjectiveTypeCollect:
		*s = QuestObjectiveTypeCollect
	case QuestObjectiveTypeDeliver:
		*s = QuestObjectiveTypeDeliver
	case QuestObjectiveTypeReachLocation:
		*s = QuestObjectiveTypeReachLocation
	case QuestObjectiveTypeTalkToNpc:
		*s = QuestObjectiveTypeTalkToNpc
	default:
		*s = QuestObjectiveType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestObjectiveType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjectiveType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestRewards) encodeFields(e *jx.Encoder) {
	{
		if s.FactionReputation != nil {
			e.FieldStart("faction_reputation")
			s.FactionReputation.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Money.Set {
			e.FieldStart("money")
			s.Money.Encode(e)
		}
	}
	{
		if s.Experience.Set {
			e.FieldStart("experience")
			s.Experience.Encode(e)
		}
	}
	{
		if s.RelationshipPoints.Set {
			e.FieldStart("relationship_points")
			s.RelationshipPoints.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestRewards = [5]string{
	0: "faction_reputation",
	1: "items",
	2: "money",
	3: "experience",
	4: "relationship_points",
}

// Decode decodes QuestRewards from json.
func (s *QuestRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "faction_reputation":
			if err := func() error {
				s.FactionReputation = nil
				var elem QuestRewardsFactionReputation
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FactionReputation = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_reputation\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]InventoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "money":
			if err := func() error {
				s.Money.Reset()
				if err := s.Money.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"money\"")
			}
		case "experience":
			if err := func() error {
				s.Experience.Reset()
				if err := s.Experience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience\"")
			}
		case "relationship_points":
			if err := func() error {
				s.RelationshipPoints.Reset()
				if err := s.RelationshipPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestRewardsFactionReputation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestRewardsFactionReputation) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfQuestRewardsFactionReputation = [0]string{}

// Decode decodes QuestRewardsFactionReputation from json.
func (s *QuestRewardsFactionReputation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestRewardsFactionReputation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode QuestRewardsFactionReputation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestRewardsFactionReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestRewardsFactionReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_id")
		json.EncodeUUID(e, s.EventID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("impact")
		e.Int(s.Impact)
	}
}

var jsonFieldsNameOfRelationshipEvent = [5]string{
	0: "event_id",
	1: "type",
	2: "timestamp",
	3: "description",
	4: "impact",
}

// Decode decodes RelationshipEvent from json.
func (s *RelationshipEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipEvent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "impact":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Impact = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"impact\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipEvent) {
					name = jsonFieldsNameOfRelationshipEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipEventType as json.
func (s RelationshipEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipEventType from json.
func (s *RelationshipEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipEventType(v) {
	case RelationshipEventTypeQuestCompleted:
		*s = RelationshipEventTypeQuestCompleted
	case RelationshipEventTypeBetrayal:
		*s = RelationshipEventTypeBetrayal
	case RelationshipEventTypeHelpProvided:
		*s = RelationshipEventTypeHelpProvided
	case RelationshipEventTypeArgument:
		*s = RelationshipEventTypeArgument
	case RelationshipEventTypeGiftGiven:
		*s = RelationshipEventTypeGiftGiven
	default:
		*s = RelationshipEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradeItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item_id")
		json.EncodeUUID(e, s.ItemID)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		if s.OfferedPrice.Set {
			e.FieldStart("offered_price")
			s.OfferedPrice.Encode(e)
		}
	}
}

var jsonFieldsNameOfTradeItem = [3]string{
	0: "item_id",
	1: "quantity",
	2: "offered_price",
}

// Decode decodes TradeItem from json.
func (s *TradeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "offered_price":
			if err := func() error {
				s.OfferedPrice.Reset()
				if err := s.OfferedPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offered_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradeItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTradeItem) {
					name = jsonFieldsNameOfTradeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trade_type")
		s.TradeType.Encode(e)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTradeRequest = [2]string{
	0: "trade_type",
	1: "items",
}

// Decode decodes TradeRequest from json.
func (s *TradeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trade_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TradeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trade_type\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]TradeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TradeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTradeRequest) {
					name = jsonFieldsNameOfTradeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TradeRequestTradeType as json.
func (s TradeRequestTradeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TradeRequestTradeType from json.
func (s *TradeRequestTradeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeRequestTradeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TradeRequestTradeType(v) {
	case TradeRequestTradeTypeBuy:
		*s = TradeRequestTradeTypeBuy
	case TradeRequestTradeTypeSell:
		*s = TradeRequestTradeTypeSell
	default:
		*s = TradeRequestTradeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TradeRequestTradeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeRequestTradeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradeResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items_traded")
		e.ArrStart()
		for _, elem := range s.ItemsTraded {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.TotalCost.Set {
			e.FieldStart("total_cost")
			s.TotalCost.Encode(e)
		}
	}
	{
		if s.RelationshipChange.Set {
			e.FieldStart("relationship_change")
			s.RelationshipChange.Encode(e)
		}
	}
}

var jsonFieldsNameOfTradeResponse = [4]string{
	0: "items_traded",
	1: "success",
	2: "total_cost",
	3: "relationship_change",
}

// Decode decodes TradeResponse from json.
func (s *TradeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items_traded":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ItemsTraded = make([]TradedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TradedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ItemsTraded = append(s.ItemsTraded, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_traded\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "total_cost":
			if err := func() error {
				s.TotalCost.Reset()
				if err := s.TotalCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_cost\"")
			}
		case "relationship_change":
			if err := func() error {
				s.RelationshipChange.Reset()
				if err := s.RelationshipChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_change\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradeResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTradeResponse) {
					name = jsonFieldsNameOfTradeResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradeWithJackiePaymentRequired) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradeWithJackiePaymentRequired) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.RequiredAmount.Set {
			e.FieldStart("required_amount")
			s.RequiredAmount.Encode(e)
		}
	}
}

var jsonFieldsNameOfTradeWithJackiePaymentRequired = [2]string{
	0: "error",
	1: "required_amount",
}

// Decode decodes TradeWithJackiePaymentRequired from json.
func (s *TradeWithJackiePaymentRequired) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeWithJackiePaymentRequired to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "required_amount":
			if err := func() error {
				s.RequiredAmount.Reset()
				if err := s.RequiredAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradeWithJackiePaymentRequired")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradeWithJackiePaymentRequired) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradeWithJackiePaymentRequired) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TradedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TradedItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item_id")
		json.EncodeUUID(e, s.ItemID)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("final_price")
		e.Int(s.FinalPrice)
	}
}

var jsonFieldsNameOfTradedItem = [3]string{
	0: "item_id",
	1: "quantity",
	2: "final_price",
}

// Decode decodes TradedItem from json.
func (s *TradedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradedItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "final_price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FinalPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TradedItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTradedItem) {
					name = jsonFieldsNameOfTradedItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TradedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TradedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRelationshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRelationshipRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action_type")
		s.ActionType.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("impact")
		e.Int(s.Impact)
	}
}

var jsonFieldsNameOfUpdateRelationshipRequest = [3]string{
	0: "action_type",
	1: "description",
	2: "impact",
}

// Decode decodes UpdateRelationshipRequest from json.
func (s *UpdateRelationshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "impact":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Impact = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"impact\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRelationshipRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRelationshipRequest) {
					name = jsonFieldsNameOfUpdateRelationshipRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRelationshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRelationshipRequestActionType as json.
func (s UpdateRelationshipRequestActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRelationshipRequestActionType from json.
func (s *UpdateRelationshipRequestActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipRequestActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRelationshipRequestActionType(v) {
	case UpdateRelationshipRequestActionTypeQuestCompleted:
		*s = UpdateRelationshipRequestActionTypeQuestCompleted
	case UpdateRelationshipRequestActionTypeHelpProvided:
		*s = UpdateRelationshipRequestActionTypeHelpProvided
	case UpdateRelationshipRequestActionTypeBetrayal:
		*s = UpdateRelationshipRequestActionTypeBetrayal
	case UpdateRelationshipRequestActionTypeGiftGiven:
		*s = UpdateRelationshipRequestActionTypeGiftGiven
	case UpdateRelationshipRequestActionTypeArgument:
		*s = UpdateRelationshipRequestActionTypeArgument
	default:
		*s = UpdateRelationshipRequestActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRelationshipRequestActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipRequestActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
