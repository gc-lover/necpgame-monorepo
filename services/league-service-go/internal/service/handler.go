// Code generated by NECPGAME backend agent. Enterprise-grade League service handlers.
// PERFORMANCE: Optimized request handling with context timeouts and league-specific validations
// Issue: #2207 - League Service for Competitive Gaming Systems

package service

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"go.uber.org/zap"

	api "necpgame/services/league-service-go/pkg/api"
)

// Handler implements the generated API handler interface
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Handler struct {
	service *LeagueService
	logger  *zap.Logger
}

// NewHandler creates new optimized handler
func NewHandler(svc *LeagueService) *Handler {
	return &Handler{
		service: svc,
		logger:  svc.logger,
	}
}

// RegisterPlayer handles player registration in the league system
func (h *Handler) RegisterPlayer(ctx context.Context, req *api.RegisterPlayerRequest) (api.RegisterPlayerRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Processing player registration",
		zap.String("player_id", req.PlayerId),
		zap.String("nickname", req.Nickname))

	player, err := h.service.RegisterPlayer(ctx, req.PlayerId, req.Nickname)
	if err != nil {
		h.logger.Error("Player registration failed",
			zap.Error(err),
			zap.String("player_id", req.PlayerId))
		return &api.RegisterPlayerBadRequest{
			Data: api.Error{
				Code:    "REGISTRATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.RegisterPlayerCreated{
		Data: &api.PlayerResponse{
			Id:              player.ID,
			PlayerId:        player.PlayerID,
			Nickname:        player.Nickname,
			CurrentDivisionId: player.CurrentDivisionID,
			Rating:          player.Rating,
			IsActive:        player.IsActive,
			IsProvisional:   player.IsProvisional,
			JoinedAt:        player.JoinedAt,
		},
	}, nil
}

// GetPlayerProfile retrieves player profile and statistics
func (h *Handler) GetPlayerProfile(ctx context.Context, params api.GetPlayerProfileParams) (api.GetPlayerProfileRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	player, err := h.service.getPlayerByID(ctx, params.PlayerId)
	if err != nil {
		h.logger.Error("Failed to get player profile", zap.Error(err))
		return &api.GetPlayerProfileNotFound{
			Data: api.Error{
				Code:    "PLAYER_NOT_FOUND",
				Message: "Player not found",
			},
		}, nil
	}

	return &api.GetPlayerProfileOK{
		Data: &api.PlayerProfileResponse{
			Id:                player.ID,
			PlayerId:          player.PlayerID,
			Nickname:          player.Nickname,
			CurrentDivisionId: player.CurrentDivisionID,
			CurrentRank:       player.CurrentRank,
			Rating:            player.Rating,
			GamesPlayed:       player.GamesPlayed,
			GamesWon:          player.GamesWon,
			WinRate:           player.WinRate,
			AverageScore:      player.AverageScore,
			PerformanceRating: player.PerformanceRating,
			IsActive:          player.IsActive,
			IsProvisional:     player.IsProvisional,
			JoinedAt:          player.JoinedAt,
			LastActive:        player.LastActive,
		},
	}, nil
}

// GetLeaderboard retrieves the leaderboard for a division
// PERFORMANCE: High-throughput endpoint for leaderboard queries with caching
func (h *Handler) GetLeaderboard(ctx context.Context, params api.GetLeaderboardParams) (api.GetLeaderboardRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	limit := 100 // default
	if params.Limit != nil && *params.Limit > 0 {
		limit = *params.Limit
		if limit > 1000 {
			limit = 1000 // max limit
		}
	}

	entries, err := h.service.GetLeaderboard(ctx, params.DivisionId, limit)
	if err != nil {
		h.logger.Error("Failed to get leaderboard", zap.Error(err))
		return &api.GetLeaderboardInternalServerError{
			Data: api.Error{
				Code:    "LEADERBOARD_ERROR",
				Message: err.Error(),
			},
		}, nil
	}

	// Convert to API format
	var apiEntries []api.LeaderboardEntry
	for _, entry := range entries {
		apiEntries = append(apiEntries, api.LeaderboardEntry{
			Rank:         entry.Rank,
			PlayerId:     entry.PlayerID,
			Nickname:     entry.Nickname,
			Rating:       entry.Rating,
			GamesPlayed:  entry.GamesPlayed,
			GamesWon:     entry.GamesWon,
			WinRate:      entry.WinRate,
			AvgScore:     entry.AvgScore,
			DivisionName: entry.DivisionName,
			IsProvisional: entry.IsProvisional,
			LastActive:   entry.LastActive,
		})
	}

	return &api.GetLeaderboardOK{
		Data: apiEntries,
	}, nil
}

// CreateTournament creates a new tournament
func (h *Handler) CreateTournament(ctx context.Context, req *api.CreateTournamentRequest) (api.CreateTournamentRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Convert API request to internal model
	tournament := &models.Tournament{
		Name:                 req.Name,
		Description:          req.Description,
		GameMode:             req.GameMode,
		StartDate:            req.StartDate,
		EndDate:              req.EndDate,
		RegistrationDeadline: req.RegistrationDeadline,
		MaxParticipants:      req.MaxParticipants,
		EntryFee:             req.EntryFee,
		PrizePool:            req.PrizePool,
		MinDivisionLevel:     req.MinDivisionLevel,
		TournamentType:       req.TournamentType,
		IsRanked:             req.IsRanked,
		RequiresQualification: req.RequiresQualification,
	}

	createdTournament, err := h.service.CreateTournament(ctx, tournament)
	if err != nil {
		h.logger.Error("Failed to create tournament", zap.Error(err))
		return &api.CreateTournamentBadRequest{
			Data: api.Error{
				Code:    "TOURNAMENT_CREATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.CreateTournamentCreated{
		Data: &api.TournamentResponse{
			Id:                   createdTournament.ID,
			Name:                 createdTournament.Name,
			Description:          createdTournament.Description,
			GameMode:             createdTournament.GameMode,
			StartDate:            createdTournament.StartDate,
			EndDate:              createdTournament.EndDate,
			RegistrationDeadline: createdTournament.RegistrationDeadline,
			MaxParticipants:      createdTournament.MaxParticipants,
			CurrentParticipants:  createdTournament.CurrentParticipants,
			EntryFee:             createdTournament.EntryFee,
			PrizePool:            createdTournament.PrizePool,
			MinDivisionLevel:     createdTournament.MinDivisionLevel,
			Status:               createdTournament.Status,
			TournamentType:       createdTournament.TournamentType,
			IsRanked:             createdTournament.IsRanked,
			RequiresQualification: createdTournament.RequiresQualification,
			CreatedAt:            createdTournament.CreatedAt,
		},
	}, nil
}

// RegisterForTournament registers a player for a tournament
func (h *Handler) RegisterForTournament(ctx context.Context, req *api.RegisterForTournamentRequest, params api.RegisterForTournamentParams) (api.RegisterForTournamentRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Extract user ID from context (set by authentication middleware)
	userID := ctx.Value("user_id").(string)
	if userID == "" {
		return &api.RegisterForTournamentUnauthorized{
			Data: api.Error{
				Code:    "MISSING_USER_ID",
				Message: "User ID not found in context",
			},
		}, nil
	}

	err := h.service.RegisterForTournament(ctx, params.TournamentId, userID)
	if err != nil {
		h.logger.Error("Tournament registration failed",
			zap.Error(err),
			zap.String("tournament_id", params.TournamentId),
			zap.String("user_id", userID))
		return &api.RegisterForTournamentBadRequest{
			Data: api.Error{
				Code:    "REGISTRATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.RegisterForTournamentOK{
		Data: &api.MessageResponse{
			Message: "Successfully registered for tournament",
		},
	}, nil
}

// GetTournamentDetails retrieves tournament information
func (h *Handler) GetTournamentDetails(ctx context.Context, params api.GetTournamentDetailsParams) (api.GetTournamentDetailsRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	tournament, err := h.service.getTournamentByID(ctx, params.TournamentId)
	if err != nil {
		h.logger.Error("Failed to get tournament details", zap.Error(err))
		return &api.GetTournamentDetailsNotFound{
			Data: api.Error{
				Code:    "TOURNAMENT_NOT_FOUND",
				Message: "Tournament not found",
			},
		}, nil
	}

	return &api.GetTournamentDetailsOK{
		Data: &api.TournamentDetailsResponse{
			Id:                   tournament.ID,
			Name:                 tournament.Name,
			Description:          tournament.Description,
			GameMode:             tournament.GameMode,
			StartDate:            tournament.StartDate,
			EndDate:              tournament.EndDate,
			RegistrationDeadline: tournament.RegistrationDeadline,
			MaxParticipants:      tournament.MaxParticipants,
			CurrentParticipants:  tournament.CurrentParticipants,
			EntryFee:             tournament.EntryFee,
			PrizePool:            tournament.PrizePool,
			MinDivisionLevel:     tournament.MinDivisionLevel,
			Status:               tournament.Status,
			TournamentType:       tournament.TournamentType,
			IsRanked:             tournament.IsRanked,
			RequiresQualification: tournament.RequiresQualification,
			CreatedAt:            tournament.CreatedAt,
		},
	}, nil
}

// SubmitMatchResult submits the result of a completed match
func (h *Handler) SubmitMatchResult(ctx context.Context, req *api.SubmitMatchResultRequest) (api.SubmitMatchResultRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// Extract user ID from context
	userID := ctx.Value("user_id").(string)
	if userID == "" {
		return &api.SubmitMatchResultUnauthorized{
			Data: api.Error{
				Code:    "MISSING_USER_ID",
				Message: "User ID not found in context",
			},
		}, nil
	}

	// Convert API request to internal models
	match := &models.Match{
		MatchID:         uuid.New().String(),
		GameMode:        req.GameMode,
		MapName:         req.MapName,
		TournamentID:    req.TournamentId,
		DivisionID:      req.DivisionId,
		DurationSeconds: req.DurationSeconds,
		MaxScore:        req.MaxScore,
		StartTime:       req.StartTime,
		EndTime:         &req.EndTime,
		Status:          "completed",
		IsRanked:        req.IsRanked,
		CreatedAt:       time.Now().UTC(),
		UpdatedAt:       time.Now().UTC(),
	}

	// Determine winner
	var winnerID *string
	var participants []*models.MatchParticipant

	for _, p := range req.Participants {
		participant := &models.MatchParticipant{
			MatchID:         match.MatchID,
			PlayerID:        p.PlayerId,
			Score:           p.Score,
			Kills:           p.Kills,
			Deaths:          p.Deaths,
			Assists:         p.Assists,
			Position:        p.Position,
			KD_Ratio:        p.KdRatio,
			PerformanceScore: p.PerformanceScore,
			JoinedAt:        req.StartTime,
			IsWinner:        p.Position == 1, // First place is winner
			DNF:             false,
		}

		if p.Position == 1 {
			winnerID = &p.PlayerId
		}

		participants = append(participants, participant)
	}

	match.WinnerID = winnerID
	match.ID = uuid.New().String()

	// Process match result
	err := h.service.ProcessMatchResult(ctx, match, participants)
	if err != nil {
		h.logger.Error("Failed to process match result", zap.Error(err))
		return &api.SubmitMatchResultInternalServerError{
			Data: api.Error{
				Code:    "MATCH_PROCESSING_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.SubmitMatchResultOK{
		Data: &api.MatchResultResponse{
			MatchId:   match.MatchID,
			WinnerId:  winnerID,
			Processed: true,
		},
	}, nil
}

// GetPlayerMatchHistory retrieves a player's match history
func (h *Handler) GetPlayerMatchHistory(ctx context.Context, params api.GetPlayerMatchHistoryParams) (api.GetPlayerMatchHistoryRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	limit := 50 // default
	if params.Limit != nil && *params.Limit > 0 {
		limit = *params.Limit
		if limit > 500 {
			limit = 500 // max limit
		}
	}

	offset := 0 // default
	if params.Offset != nil && *params.Offset > 0 {
		offset = *params.Offset
	}

	matches, err := h.service.getPlayerMatchHistory(ctx, params.PlayerId, limit, offset)
	if err != nil {
		h.logger.Error("Failed to get player match history", zap.Error(err))
		return &api.GetPlayerMatchHistoryInternalServerError{
			Data: api.Error{
				Code:    "MATCH_HISTORY_ERROR",
				Message: err.Error(),
			},
		}, nil
	}

	// Convert to API format
	var apiMatches []api.MatchHistoryEntry
	for _, match := range matches {
		apiMatches = append(apiMatches, api.MatchHistoryEntry{
			MatchId:         match.MatchID,
			GameMode:        match.GameMode,
			MapName:         match.MapName,
			StartTime:       match.StartTime,
			DurationSeconds: match.DurationSeconds,
			Score:           match.Score,
			Position:        match.Position,
			IsWinner:        match.IsWinner,
		})
	}

	return &api.GetPlayerMatchHistoryOK{
		Data: apiMatches,
	}, nil
}

// GetActiveTournaments retrieves currently active tournaments
func (h *Handler) GetActiveTournaments(ctx context.Context) (api.GetActiveTournamentsRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	tournaments, err := h.service.getActiveTournaments(ctx)
	if err != nil {
		h.logger.Error("Failed to get active tournaments", zap.Error(err))
		return &api.GetActiveTournamentsInternalServerError{
			Data: api.Error{
				Code:    "TOURNAMENTS_ERROR",
				Message: err.Error(),
			},
		}, nil
	}

	// Convert to API format
	var apiTournaments []api.TournamentSummary
	for _, t := range tournaments {
		apiTournaments = append(apiTournaments, api.TournamentSummary{
			Id:                  t.ID,
			Name:                t.Name,
			GameMode:            t.GameMode,
			StartDate:           t.StartDate,
			MaxParticipants:     t.MaxParticipants,
			CurrentParticipants: t.CurrentParticipants,
			EntryFee:            t.EntryFee,
			PrizePool:           t.PrizePool,
			Status:              t.Status,
			IsRanked:            t.IsRanked,
		})
	}

	return &api.GetActiveTournamentsOK{
		Data: apiTournaments,
	}, nil
}

// Health check endpoint
func (h *Handler) HealthCheck(ctx context.Context) (api.HealthCheckRes, error) {
	return &api.HealthCheckOK{
		Data: &api.HealthResponse{
			Status:    api.HealthResponseStatusHealthy,
			Domain:    stringPtr("league-service"),
			Timestamp: time.Now(),
			Version:   stringPtr("1.0.0"),
		},
	}, nil
}

// Additional service methods needed by handlers

func (s *LeagueService) getPlayerMatchHistory(ctx context.Context, playerID string, limit, offset int) ([]*models.MatchParticipant, error) {
	rows, err := s.db.Query(ctx, `
		SELECT m.match_id, m.game_mode, m.map_name, m.start_time, m.duration_seconds,
			   mp.score, mp.position, mp.is_winner
		FROM matches m
		JOIN match_participants mp ON m.match_id = mp.match_id
		WHERE mp.player_id = $1
		ORDER BY m.start_time DESC
		LIMIT $2 OFFSET $3
	`, playerID, limit, offset)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var matches []*models.MatchParticipant
	for rows.Next() {
		var match models.MatchParticipant
		err := rows.Scan(
			&match.MatchID, &match.GameMode, &match.MapName, &match.JoinedAt,
			&match.DurationSeconds, &match.Score, &match.Position, &match.IsWinner)
		if err != nil {
			return nil, err
		}
		matches = append(matches, &match)
	}

	return matches, rows.Err()
}

func (s *LeagueService) getActiveTournaments(ctx context.Context) ([]*models.Tournament, error) {
	rows, err := s.db.Query(ctx, `
		SELECT id, name, game_mode, start_date, max_participants, current_participants,
			   entry_fee, prize_pool, status, is_ranked
		FROM tournaments
		WHERE status IN ('upcoming', 'registering', 'in_progress')
		ORDER BY start_date ASC
	`)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tournaments []*models.Tournament
	for rows.Next() {
		var tournament models.Tournament
		err := rows.Scan(
			&tournament.ID, &tournament.Name, &tournament.GameMode, &tournament.StartDate,
			&tournament.MaxParticipants, &tournament.CurrentParticipants, &tournament.EntryFee,
			&tournament.PrizePool, &tournament.Status, &tournament.IsRanked)
		if err != nil {
			return nil, err
		}
		tournaments = append(tournaments, &tournament)
	}

	return tournaments, rows.Err()
}

func stringPtr(s string) *string {
	return &s
}