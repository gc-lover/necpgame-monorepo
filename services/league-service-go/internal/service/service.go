// Code generated by NECPGAME backend agent. Enterprise-grade League service.
// PERFORMANCE: Optimized for real-time ranking calculations and tournament management
// Issue: #2207 - League Service for Competitive Gaming Systems

package service

import (
	"context"
	"database/sql"
	"fmt"
	"math"
	"sort"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/league-service-go/internal/models"
)

// PERFORMANCE: Memory pooling for hot path objects (Level 2 optimization)
// Reduces GC pressure in high-throughput ranking operations
var (
	playerPool = sync.Pool{
		New: func() interface{} {
			return &models.Player{}
		},
	}

	matchPool = sync.Pool{
		New: func() interface{} {
			return &models.Match{}
		},
	}

	leaderboardEntryPool = sync.Pool{
		New: func() interface{} {
			return &models.LeaderboardEntry{}
		},
	}
)

// Config holds service configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Config struct {
	Logger      *zap.Logger
	Tracer      trace.Tracer
	Meter       metric.Meter
	DatabaseURL string
	RedisURL    string
}

// LeagueService implements enterprise-grade competitive gaming league system
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type LeagueService struct {
	// Core dependencies (pointers first)
	logger        *zap.Logger
	tracer        trace.Tracer
	meter         metric.Meter
	db            *pgxpool.Pool
	redis         *redis.Client

	// League configuration
	minPlayersPerDivision int
	maxPlayersPerDivision int
	promotionThreshold    float64
	demotionThreshold     float64
	decayRate             float64

	// Prometheus metrics
	leagueOperations      *prometheus.CounterVec
	leagueOperationDuration *prometheus.HistogramVec
	activePlayers         prometheus.Gauge
	currentSeason         prometheus.Gauge
	tournamentParticipants *prometheus.GaugeVec
	rankingUpdates        *prometheus.CounterVec
	databaseQueryTime     *prometheus.HistogramVec
	redisOperationTime    *prometheus.HistogramVec
	goroutineCount        prometheus.Gauge
	gcPauseDuration       prometheus.Histogram
}

// NewLeagueService creates optimized league service instance
func NewLeagueService(cfg Config) (*LeagueService, error) {
	svc := &LeagueService{
		logger: cfg.Logger,
		tracer: cfg.Tracer,
		meter:  cfg.Meter,

		// Default league parameters
		minPlayersPerDivision: 10,
		maxPlayersPerDivision: 100,
		promotionThreshold:    0.75,
		demotionThreshold:     0.25,
		decayRate:             0.95,
	}

	// Initialize Prometheus metrics
	svc.initMetrics()

	// Initialize database with performance optimizations
	if cfg.DatabaseURL != "" {
		if err := svc.initDatabase(cfg.DatabaseURL); err != nil {
			return nil, errors.Wrap(err, "failed to init database")
		}
	}

	// Initialize Redis with performance optimizations
	if cfg.RedisURL != "" {
		if err := svc.initRedis(cfg.RedisURL); err != nil {
			return nil, errors.Wrap(err, "failed to init redis")
		}
	}

	svc.logger.Info("League service initialized successfully",
		zap.String("optimization_level", "Level 2 (User-Facing)"),
		zap.Bool("struct_alignment", true),
		zap.Bool("context_timeouts", true),
		zap.Bool("memory_pooling", true))
	return svc, nil
}

// initMetrics initializes Prometheus metrics
func (s *LeagueService) initMetrics() {
	s.leagueOperations = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "league_operations_total",
			Help: "Total number of league operations",
		},
		[]string{"operation", "status"},
	)

	s.leagueOperationDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "league_operation_duration_seconds",
			Help:    "League operation duration in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"operation"},
	)

	s.activePlayers = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "league_active_players",
			Help: "Number of active league players",
		},
	)

	s.currentSeason = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "league_current_season_id",
			Help: "Current active season ID",
		},
	)

	s.tournamentParticipants = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "league_tournament_participants",
			Help: "Number of participants in tournaments",
		},
		[]string{"tournament_id"},
	)

	s.rankingUpdates = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "league_ranking_updates_total",
			Help: "Total number of ranking updates",
		},
		[]string{"division", "direction"},
	)

	s.databaseQueryTime = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "league_database_query_duration_seconds",
			Help:    "Database query duration in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"operation"},
	)

	s.redisOperationTime = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "league_redis_operation_duration_seconds",
			Help:    "Redis operation duration in seconds",
			Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1},
		},
		[]string{"operation"},
	)

	s.goroutineCount = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "league_goroutines",
			Help: "Number of active goroutines",
		},
	)

	s.gcPauseDuration = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "league_gc_pause_duration_seconds",
			Help:    "GC pause duration in seconds",
			Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1},
		},
	)

	// Register metrics
	prometheus.MustRegister(
		s.leagueOperations,
		s.leagueOperationDuration,
		s.activePlayers,
		s.currentSeason,
		s.tournamentParticipants,
		s.rankingUpdates,
		s.databaseQueryTime,
		s.redisOperationTime,
		s.goroutineCount,
		s.gcPauseDuration,
	)
}

// initDatabase initializes PostgreSQL connection with performance optimizations
// PERFORMANCE: Optimized connection pool for league operations
func (s *LeagueService) initDatabase(databaseURL string) error {
	// PERFORMANCE: Optimized connection pool for league service
	// League service handles ranking queries and tournament management
	config, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse database URL")
	}

	// PERFORMANCE: Tune connection pool for league service
	config.MaxConns = 30                    // Higher pool for ranking operations
	config.MinConns = 10                    // Keep more connections for league queries
	config.MaxConnLifetime = 20 * time.Minute // Longer for complex ranking calculations
	config.MaxConnIdleTime = 3 * time.Minute  // Moderate cleanup

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return errors.Wrap(err, "failed to create connection pool")
	}

	// Test connection with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := pool.Ping(ctx); err != nil {
		return errors.Wrap(err, "failed to ping database")
	}

	s.db = pool
	s.logger.Info("Database connection established with league optimizations",
		zap.Int("max_conns", 30),
		zap.Int("min_conns", 10))
	return nil
}

// initRedis initializes Redis connection for caching and session storage
// PERFORMANCE: Optimized for league caching and real-time updates
func (s *LeagueService) initRedis(redisURL string) error {
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse redis URL")
	}

	// PERFORMANCE: Optimize Redis client for league operations
	// League service needs reliable caching for rankings and tournament data
	rdb := redis.NewClient(opt)
	rdb.Options().PoolSize = 20           // Higher pool for league operations
	rdb.Options().MinIdleConns = 5        // Keep connections ready
	rdb.Options().ConnMaxLifetime = 15 * time.Minute // Match league session lifetime

	// Test connection with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := rdb.Ping(ctx).Err(); err != nil {
		return errors.Wrap(err, "failed to ping redis")
	}

	s.redis = rdb
	s.logger.Info("Redis connection established with league optimizations",
		zap.Int("pool_size", 20),
		zap.Int("min_idle", 5))
	return nil
}

// PERFORMANCE: Memory pool management functions
func getPlayer() *models.Player {
	return playerPool.Get().(*models.Player)
}

func putPlayer(player *models.Player) {
	// Reset fields for reuse
	player.ID = ""
	player.PlayerID = ""
	player.Nickname = ""
	player.CurrentDivisionID = 0
	player.CurrentRank = 0
	player.Rating = 0
	player.GamesPlayed = 0
	player.GamesWon = 0
	player.TotalScore = 0
	player.WinRate = 0
	player.AverageScore = 0
	player.PerformanceRating = 0
	player.IsActive = false
	player.IsBanned = false
	player.IsProvisional = false
	player.JoinedAt = time.Time{}
	player.LastActive = time.Time{}
	player.CreatedAt = time.Time{}
	player.UpdatedAt = time.Time{}
	playerPool.Put(player)
}

func getMatch() *models.Match {
	return matchPool.Get().(*models.Match)
}

func putMatch(match *models.Match) {
	// Reset fields for reuse
	match.ID = ""
	match.MatchID = ""
	match.GameMode = ""
	match.MapName = ""
	match.TournamentID = nil
	match.DivisionID = 0
	match.WinnerID = nil
	match.DurationSeconds = 0
	match.MaxScore = 0
	match.Status = ""
	match.IsRanked = false
	match.StartTime = time.Time{}
	match.EndTime = nil
	match.CreatedAt = time.Time{}
	match.UpdatedAt = time.Time{}
	matchPool.Put(match)
}

func getLeaderboardEntry() *models.LeaderboardEntry {
	return leaderboardEntryPool.Get().(*models.LeaderboardEntry)
}

func putLeaderboardEntry(entry *models.LeaderboardEntry) {
	// Reset fields for reuse
	entry.PlayerID = ""
	entry.Nickname = ""
	entry.Rank = 0
	entry.Rating = 0
	entry.GamesPlayed = 0
	entry.GamesWon = 0
	entry.WinRate = 0
	entry.AvgScore = 0
	entry.LastActive = time.Time{}
	entry.DivisionName = ""
	entry.IsProvisional = false
	leaderboardEntryPool.Put(entry)
}

// RegisterPlayer registers a new player in the league system
func (s *LeagueService) RegisterPlayer(ctx context.Context, playerID, nickname string) (*models.Player, error) {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("register_player").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Validate input
	if playerID == "" || nickname == "" {
		s.leagueOperations.WithLabelValues("register_player", "invalid_input").Inc()
		return nil, errors.New("player_id and nickname are required")
	}

	// Check if player already exists
	exists, err := s.playerExists(ctx, playerID)
	if err != nil {
		s.databaseQueryTime.WithLabelValues("player_exists_check").Observe(time.Since(start).Seconds())
		return nil, errors.Wrap(err, "failed to check player existence")
	}
	if exists {
		s.leagueOperations.WithLabelValues("register_player", "player_exists").Inc()
		return nil, errors.New("player already registered")
	}

	// Create player
	player := getPlayer()
	defer putPlayer(player)

	player.ID = uuid.New().String()
	player.PlayerID = playerID
	player.Nickname = nickname
	player.CurrentDivisionID = 1 // Start in lowest division
	player.Rating = 1000         // Default ELO rating
	player.IsActive = true
	player.IsProvisional = true  // Provisional until enough games
	player.JoinedAt = time.Now().UTC()
	player.LastActive = time.Now().UTC()
	player.CreatedAt = time.Now().UTC()
	player.UpdatedAt = time.Now().UTC()

	// Save to database
	if err := s.savePlayer(ctx, player); err != nil {
		s.databaseQueryTime.WithLabelValues("player_save").Observe(time.Since(start).Seconds())
		return nil, errors.Wrap(err, "failed to save player")
	}

	s.activePlayers.Inc()
	s.leagueOperations.WithLabelValues("register_player", "success").Inc()
	s.logger.Info("Player registered successfully",
		zap.String("player_id", playerID),
		zap.String("nickname", nickname))

	return player, nil
}

// UpdatePlayerStats updates player statistics after a match
func (s *LeagueService) UpdatePlayerStats(ctx context.Context, playerID string, matchResult *models.MatchParticipant) error {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("update_player_stats").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 15*time.Second)
	defer cancel()

	// Get current player stats
	player, err := s.getPlayerByID(ctx, playerID)
	if err != nil {
		return errors.Wrap(err, "failed to get player")
	}

	// Update statistics
	player.GamesPlayed++
	if matchResult.IsWinner {
		player.GamesWon++
	}
	player.TotalScore += matchResult.Score
	player.WinRate = float64(player.GamesWon) / float64(player.GamesPlayed)
	player.AverageScore = float64(player.TotalScore) / float64(player.GamesPlayed)
	player.LastActive = time.Now().UTC()
	player.UpdatedAt = time.Now().UTC()

	// Calculate performance rating
	player.PerformanceRating = s.calculatePerformanceRating(player)

	// Check for promotion/demotion if not provisional
	if !player.IsProvisional && player.GamesPlayed >= 10 {
		if err := s.checkDivisionChange(ctx, player); err != nil {
			s.logger.Warn("Failed to check division change", zap.Error(err))
		}
	}

	// Mark as non-provisional after enough games
	if player.IsProvisional && player.GamesPlayed >= 5 {
		player.IsProvisional = false
	}

	// Save updated player
	if err := s.updatePlayer(ctx, player); err != nil {
		s.databaseQueryTime.WithLabelValues("player_update").Observe(time.Since(start).Seconds())
		return errors.Wrap(err, "failed to update player")
	}

	s.leagueOperations.WithLabelValues("update_player_stats", "success").Inc()
	return nil
}

// GetLeaderboard returns the current leaderboard for a division
func (s *LeagueService) GetLeaderboard(ctx context.Context, divisionID int, limit int) ([]*models.LeaderboardEntry, error) {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("get_leaderboard").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	if limit <= 0 || limit > 1000 {
		limit = 100 // Default limit
	}

	// Try to get from cache first
	cacheKey := fmt.Sprintf("leaderboard:division:%d:limit:%d", divisionID, limit)
	cached, err := s.getCachedLeaderboard(ctx, cacheKey)
	if err == nil && len(cached) > 0 {
		s.leagueOperations.WithLabelValues("get_leaderboard", "cache_hit").Inc()
		return cached, nil
	}

	// Get from database
	entries, err := s.getLeaderboardFromDB(ctx, divisionID, limit)
	if err != nil {
		s.databaseQueryTime.WithLabelValues("leaderboard_query").Observe(time.Since(start).Seconds())
		return nil, errors.Wrap(err, "failed to get leaderboard")
	}

	// Cache the result
	if err := s.cacheLeaderboard(ctx, cacheKey, entries, 5*time.Minute); err != nil {
		s.logger.Warn("Failed to cache leaderboard", zap.Error(err))
	}

	s.leagueOperations.WithLabelValues("get_leaderboard", "success").Inc()
	return entries, nil
}

// CreateTournament creates a new tournament
func (s *LeagueService) CreateTournament(ctx context.Context, tournament *models.Tournament) (*models.Tournament, error) {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("create_tournament").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Validate tournament data
	if err := s.validateTournament(tournament); err != nil {
		s.leagueOperations.WithLabelValues("create_tournament", "invalid_input").Inc()
		return nil, errors.Wrap(err, "invalid tournament data")
	}

	// Generate ID and timestamps
	tournament.ID = uuid.New().String()
	tournament.Status = "upcoming"
	tournament.CreatedAt = time.Now().UTC()
	tournament.UpdatedAt = time.Now().UTC()

	// Save to database
	if err := s.saveTournament(ctx, tournament); err != nil {
		s.databaseQueryTime.WithLabelValues("tournament_save").Observe(time.Since(start).Seconds())
		return nil, errors.Wrap(err, "failed to save tournament")
	}

	s.tournamentParticipants.WithLabelValues(tournament.ID).Set(0)
	s.leagueOperations.WithLabelValues("create_tournament", "success").Inc()
	s.logger.Info("Tournament created successfully",
		zap.String("tournament_id", tournament.ID),
		zap.String("name", tournament.Name))

	return tournament, nil
}

// RegisterForTournament registers a player for a tournament
func (s *LeagueService) RegisterForTournament(ctx context.Context, tournamentID, playerID string) error {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("register_tournament").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	// Check tournament exists and is open for registration
	tournament, err := s.getTournamentByID(ctx, tournamentID)
	if err != nil {
		return errors.Wrap(err, "tournament not found")
	}

	if tournament.Status != "upcoming" && tournament.Status != "registering" {
		return errors.New("tournament registration is closed")
	}

	if tournament.CurrentParticipants >= tournament.MaxParticipants {
		return errors.New("tournament is full")
	}

	// Check player eligibility
	player, err := s.getPlayerByID(ctx, playerID)
	if err != nil {
		return errors.Wrap(err, "player not found")
	}

	if player.CurrentDivisionID < tournament.MinDivisionLevel {
		return errors.New("player does not meet division requirements")
	}

	// Register player
	if err := s.addTournamentParticipant(ctx, tournamentID, playerID); err != nil {
		s.databaseQueryTime.WithLabelValues("tournament_registration").Observe(time.Since(start).Seconds())
		return errors.Wrap(err, "failed to register for tournament")
	}

	// Update participant count
	tournament.CurrentParticipants++
	s.tournamentParticipants.WithLabelValues(tournamentID).Set(float64(tournament.CurrentParticipants))

	s.leagueOperations.WithLabelValues("register_tournament", "success").Inc()
	return nil
}

// ProcessMatchResult processes the result of a completed match
func (s *LeagueService) ProcessMatchResult(ctx context.Context, match *models.Match, participants []*models.MatchParticipant) error {
	start := time.Now()
	defer func() {
		s.leagueOperationDuration.WithLabelValues("process_match_result").Observe(time.Since(start).Seconds())
	}()

	ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// Save match result
	if err := s.saveMatchResult(ctx, match); err != nil {
		return errors.Wrap(err, "failed to save match result")
	}

	// Update player statistics
	for _, participant := range participants {
		if err := s.UpdatePlayerStats(ctx, participant.PlayerID, participant); err != nil {
			s.logger.Error("Failed to update player stats",
				zap.String("player_id", participant.PlayerID),
				zap.Error(err))
			// Continue processing other participants
		}
	}

	// Invalidate leaderboard cache
	if err := s.invalidateLeaderboardCache(ctx, match.DivisionID); err != nil {
		s.logger.Warn("Failed to invalidate leaderboard cache", zap.Error(err))
	}

	s.leagueOperations.WithLabelValues("process_match_result", "success").Inc()
	return nil
}

// calculatePerformanceRating calculates a player's performance rating
func (s *LeagueService) calculatePerformanceRating(player *models.Player) float64 {
	if player.GamesPlayed == 0 {
		return 0
	}

	// Simple performance rating based on win rate and average score
	baseRating := player.WinRate * 100 // 0-100 based on win rate
	scoreBonus := math.Min(player.AverageScore/1000, 50) // Up to 50 bonus points

	return baseRating + scoreBonus
}

// checkDivisionChange checks if a player should be promoted or demoted
func (s *LeagueService) checkDivisionChange(ctx context.Context, player *models.Player) error {
	// Get division info
	division, err := s.getDivisionByID(ctx, player.CurrentDivisionID)
	if err != nil {
		return err
	}

	// Check promotion
	if player.PerformanceRating >= s.promotionThreshold*100 && division.Level < 10 {
		return s.promotePlayer(ctx, player)
	}

	// Check demotion
	if player.PerformanceRating <= s.demotionThreshold*100 && division.Level > 1 {
		return s.demotePlayer(ctx, player)
	}

	return nil
}

// promotePlayer promotes a player to the next division
func (s *LeagueService) promotePlayer(ctx context.Context, player *models.Player) error {
	player.CurrentDivisionID++
	player.UpdatedAt = time.Now().UTC()

	if err := s.updatePlayer(ctx, player); err != nil {
		return err
	}

	s.rankingUpdates.WithLabelValues(fmt.Sprintf("%d", player.CurrentDivisionID), "promotion").Inc()
	s.logger.Info("Player promoted",
		zap.String("player_id", player.PlayerID),
		zap.Int("new_division", player.CurrentDivisionID))

	return nil
}

// demotePlayer demotes a player to the previous division
func (s *LeagueService) demotePlayer(ctx context.Context, player *models.Player) error {
	player.CurrentDivisionID--
	player.UpdatedAt = time.Now().UTC()

	if err := s.updatePlayer(ctx, player); err != nil {
		return err
	}

	s.rankingUpdates.WithLabelValues(fmt.Sprintf("%d", player.CurrentDivisionID), "demotion").Inc()
	s.logger.Info("Player demoted",
		zap.String("player_id", player.PlayerID),
		zap.Int("new_division", player.CurrentDivisionID))

	return nil
}

// Helper methods

func (s *LeagueService) playerExists(ctx context.Context, playerID string) (bool, error) {
	var count int
	err := s.db.QueryRow(ctx, "SELECT COUNT(*) FROM players WHERE player_id = $1", playerID).Scan(&count)
	return count > 0, err
}

func (s *LeagueService) savePlayer(ctx context.Context, player *models.Player) error {
	_, err := s.db.Exec(ctx, `
		INSERT INTO players (id, player_id, nickname, current_division_id, rating,
		                    is_active, is_provisional, joined_at, last_active, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
	`, player.ID, player.PlayerID, player.Nickname, player.CurrentDivisionID, player.Rating,
		player.IsActive, player.IsProvisional, player.JoinedAt, player.LastActive,
		player.CreatedAt, player.UpdatedAt)

	return err
}

func (s *LeagueService) getPlayerByID(ctx context.Context, playerID string) (*models.Player, error) {
	player := getPlayer()
	defer putPlayer(player)

	err := s.db.QueryRow(ctx, `
		SELECT id, player_id, nickname, current_division_id, current_rank, rating,
			   games_played, games_won, total_score, win_rate, average_score, performance_rating,
			   joined_at, last_active, created_at, updated_at, is_active, is_banned, is_provisional
		FROM players WHERE player_id = $1
	`, playerID).Scan(
		&player.ID, &player.PlayerID, &player.Nickname, &player.CurrentDivisionID, &player.CurrentRank,
		&player.Rating, &player.GamesPlayed, &player.GamesWon, &player.TotalScore, &player.WinRate,
		&player.AverageScore, &player.PerformanceRating, &player.JoinedAt, &player.LastActive,
		&player.CreatedAt, &player.UpdatedAt, &player.IsActive, &player.IsBanned, &player.IsProvisional)

	return player, err
}

func (s *LeagueService) updatePlayer(ctx context.Context, player *models.Player) error {
	_, err := s.db.Exec(ctx, `
		UPDATE players SET
			current_rank = $1, rating = $2, games_played = $3, games_won = $4,
			total_score = $5, win_rate = $6, average_score = $7, performance_rating = $8,
			last_active = $9, updated_at = $10, is_provisional = $11
		WHERE id = $12
	`, player.CurrentRank, player.Rating, player.GamesPlayed, player.GamesWon,
		player.TotalScore, player.WinRate, player.AverageScore, player.PerformanceRating,
		player.LastActive, player.UpdatedAt, player.IsProvisional, player.ID)

	return err
}

func (s *LeagueService) getLeaderboardFromDB(ctx context.Context, divisionID, limit int) ([]*models.LeaderboardEntry, error) {
	rows, err := s.db.Query(ctx, `
		SELECT p.player_id, p.nickname, p.rating, p.games_played, p.games_won,
			   p.win_rate, p.average_score, p.last_active, p.is_provisional,
			   d.name as division_name
		FROM players p
		JOIN divisions d ON p.current_division_id = d.id
		WHERE p.current_division_id = $1 AND p.is_active = true
		ORDER BY p.rating DESC, p.performance_rating DESC
		LIMIT $2
	`, divisionID, limit)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entries []*models.LeaderboardEntry
	rank := 1

	for rows.Next() {
		entry := getLeaderboardEntry()
		err := rows.Scan(
			&entry.PlayerID, &entry.Nickname, &entry.Rating, &entry.GamesPlayed,
			&entry.GamesWon, &entry.WinRate, &entry.AvgScore, &entry.LastActive,
			&entry.IsProvisional, &entry.DivisionName)
		if err != nil {
			putLeaderboardEntry(entry)
			return nil, err
		}

		entry.Rank = rank
		entries = append(entries, entry)
		rank++
	}

	return entries, rows.Err()
}

func (s *LeagueService) getCachedLeaderboard(ctx context.Context, key string) ([]*models.LeaderboardEntry, error) {
	data, err := s.redis.Get(ctx, key).Result()
	if err != nil {
		return nil, err
	}

	// Parse cached data (simplified - would use proper serialization)
	return nil, errors.New("cache parsing not implemented")
}

func (s *LeagueService) cacheLeaderboard(ctx context.Context, key string, entries []*models.LeaderboardEntry, ttl time.Duration) error {
	// Simplified caching - would serialize entries
	return s.redis.Set(ctx, key, "cached_data", ttl).Err()
}

func (s *LeagueService) invalidateLeaderboardCache(ctx context.Context, divisionID int) error {
	pattern := fmt.Sprintf("leaderboard:division:%d:*", divisionID)
	keys, err := s.redis.Keys(ctx, pattern).Result()
	if err != nil {
		return err
	}

	if len(keys) > 0 {
		return s.redis.Del(ctx, keys...).Err()
	}

	return nil
}

func (s *LeagueService) validateTournament(tournament *models.Tournament) error {
	if tournament.Name == "" || tournament.MaxParticipants <= 0 {
		return errors.New("invalid tournament data")
	}

	if tournament.StartDate.After(tournament.EndDate) {
		return errors.New("start date must be before end date")
	}

	return nil
}

func (s *LeagueService) saveTournament(ctx context.Context, tournament *models.Tournament) error {
	_, err := s.db.Exec(ctx, `
		INSERT INTO tournaments (id, name, description, game_mode, start_date, end_date,
		                        registration_deadline, max_participants, entry_fee, prize_pool,
		                        min_division_level, status, tournament_type, is_ranked,
		                        requires_qualification, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
	`, tournament.ID, tournament.Name, tournament.Description, tournament.GameMode,
		tournament.StartDate, tournament.EndDate, tournament.RegistrationDeadline,
		tournament.MaxParticipants, tournament.EntryFee, tournament.PrizePool,
		tournament.MinDivisionLevel, tournament.Status, tournament.TournamentType,
		tournament.IsRanked, tournament.RequiresQualification,
		tournament.CreatedAt, tournament.UpdatedAt)

	return err
}

func (s *LeagueService) getTournamentByID(ctx context.Context, tournamentID string) (*models.Tournament, error) {
	var tournament models.Tournament
	err := s.db.QueryRow(ctx, `
		SELECT id, name, status, max_participants, current_participants, min_division_level
		FROM tournaments WHERE id = $1
	`, tournamentID).Scan(
		&tournament.ID, &tournament.Name, &tournament.Status,
		&tournament.MaxParticipants, &tournament.CurrentParticipants, &tournament.MinDivisionLevel)

	return &tournament, err
}

func (s *LeagueService) addTournamentParticipant(ctx context.Context, tournamentID, playerID string) error {
	_, err := s.db.Exec(ctx, `
		INSERT INTO tournament_participants (tournament_id, player_id, joined_at)
		VALUES ($1, $2, $3)
	`, tournamentID, playerID, time.Now().UTC())

	return err
}

func (s *LeagueService) saveMatchResult(ctx context.Context, match *models.Match) error {
	_, err := s.db.Exec(ctx, `
		INSERT INTO matches (id, match_id, game_mode, map_name, tournament_id,
		                    division_id, winner_id, duration_seconds, max_score,
		                    start_time, end_time, status, is_ranked, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
	`, match.ID, match.MatchID, match.GameMode, match.MapName, match.TournamentID,
		match.DivisionID, match.WinnerID, match.DurationSeconds, match.MaxScore,
		match.StartTime, match.EndTime, match.Status, match.IsRanked,
		match.CreatedAt, match.UpdatedAt)

	return err
}

func (s *LeagueService) getDivisionByID(ctx context.Context, divisionID int) (*models.Division, error) {
	var division models.Division
	err := s.db.QueryRow(ctx, `
		SELECT id, level, promotion_threshold, demotion_threshold, is_active
		FROM divisions WHERE id = $1
	`, divisionID).Scan(
		&division.ID, &division.Level, &division.PromotionThreshold,
		&division.DemotionThreshold, &division.IsActive)

	return &division, err
}

// Shutdown gracefully shuts down the service
func (s *LeagueService) Shutdown(ctx context.Context) error {
	if s.db != nil {
		s.db.Close()
	}
	if s.redis != nil {
		if err := s.redis.Close(); err != nil {
			s.logger.Error("Error closing Redis", zap.Error(err))
		}
	}
	return nil
}

// ServeHTTP implements http.Handler interface
func (s *LeagueService) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Route to appropriate handlers
	switch r.URL.Path {
	case "/metrics":
		promhttp.Handler().ServeHTTP(w, r)
	default:
		http.NotFound(w, r)
	}
}