// Code generated by NECPGAME backend agent. Comprehensive league service tests.
// PERFORMANCE: Tests validate enterprise-grade competitive gaming implementation

package service

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLeagueService_PlayerRegistration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupLeagueTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("successful player registration", func(t *testing.T) {
		playerID := "test_player_" + uuid.New().String()[:8]
		nickname := "TestPlayer" + uuid.New().String()[:8]

		player, err := svc.RegisterPlayer(ctx, playerID, nickname)

		require.NoError(t, err)
		assert.NotEmpty(t, player.ID)
		assert.Equal(t, playerID, player.PlayerID)
		assert.Equal(t, nickname, player.Nickname)
		assert.Equal(t, 1, player.CurrentDivisionID) // Bronze division
		assert.Equal(t, 1000, player.Rating)         // Default rating
		assert.True(t, player.IsActive)
		assert.True(t, player.IsProvisional)
	})

	t.Run("duplicate player registration", func(t *testing.T) {
		playerID := "duplicate_" + uuid.New().String()[:8]
		nickname := "DupPlayer" + uuid.New().String()[:8]

		// First registration
		_, err := svc.RegisterPlayer(ctx, playerID, nickname)
		require.NoError(t, err)

		// Duplicate registration should fail
		_, err = svc.RegisterPlayer(ctx, playerID, "DifferentNickname")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "already registered")
	})
}

func TestLeagueService_LeaderboardRetrieval(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupLeagueTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test players with different ratings
	players := []struct {
		playerID string
		nickname string
		rating   int
	}{
		{"leader_player_1", "LeaderOne", 1500},
		{"leader_player_2", "LeaderTwo", 1400},
		{"leader_player_3", "LeaderThree", 1300},
	}

	for _, p := range players {
		player, err := svc.RegisterPlayer(ctx, p.playerID, p.nickname)
		require.NoError(t, err)

		// Manually set rating for testing
		player.Rating = p.rating
		err = svc.updatePlayer(ctx, player)
		require.NoError(t, err)
	}

	t.Run("get leaderboard", func(t *testing.T) {
		entries, err := svc.GetLeaderboard(ctx, 1, 10) // Division 1 (Bronze)

		require.NoError(t, err)
		assert.GreaterOrEqual(t, len(entries), 3)

		// Verify ordering (highest rating first)
		assert.Equal(t, "LeaderOne", entries[0].Nickname)
		assert.Equal(t, 1500, entries[0].Rating)
		assert.Equal(t, 1, entries[0].Rank)

		assert.Equal(t, "LeaderTwo", entries[1].Nickname)
		assert.Equal(t, 1400, entries[1].Rating)
		assert.Equal(t, 2, entries[1].Rank)
	})

	t.Run("leaderboard limit", func(t *testing.T) {
		limit := 2
		entries, err := svc.GetLeaderboard(ctx, 1, limit)

		require.NoError(t, err)
		assert.Len(t, entries, limit)
	})
}

func TestLeagueService_TournamentManagement(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupLeagueTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("create tournament", func(t *testing.T) {
		startTime := time.Now().Add(24 * time.Hour)
		endTime := startTime.Add(4 * time.Hour)
		registrationDeadline := startTime.Add(-1 * time.Hour)

		tournament := &models.Tournament{
			Name:                 "Test Tournament",
			Description:          "Tournament for testing",
			GameMode:             "battle_royale",
			StartDate:            startTime,
			EndDate:              endTime,
			RegistrationDeadline: registrationDeadline,
			MaxParticipants:      64,
			EntryFee:             50,
			PrizePool:            2500,
			MinDivisionLevel:     1,
			TournamentType:       "single_elimination",
			IsRanked:             true,
			RequiresQualification: false,
		}

		created, err := svc.CreateTournament(ctx, tournament)

		require.NoError(t, err)
		assert.NotEmpty(t, created.ID)
		assert.Equal(t, "Test Tournament", created.Name)
		assert.Equal(t, 64, created.MaxParticipants)
		assert.Equal(t, "upcoming", created.Status)
	})

	t.Run("register for tournament", func(t *testing.T) {
		// Create tournament first
		tournament := &models.Tournament{
			Name:                 "Registration Test",
			GameMode:             "team_deathmatch",
			StartDate:            time.Now().Add(48 * time.Hour),
			EndDate:              time.Now().Add(52 * time.Hour),
			RegistrationDeadline: time.Now().Add(24 * time.Hour),
			MaxParticipants:      16,
			MinDivisionLevel:     1,
		}

		created, err := svc.CreateTournament(ctx, tournament)
		require.NoError(t, err)

		// Create player
		playerID := "tournament_player_" + uuid.New().String()[:8]
		_, err = svc.RegisterPlayer(ctx, playerID, "TournamentPlayer")
		require.NoError(t, err)

		// Register for tournament (would need auth context in real implementation)
		// This is a simplified test
		err = svc.addTournamentParticipant(ctx, created.ID, playerID)
		require.NoError(t, err)
	})
}

func TestLeagueService_MatchProcessing(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupLeagueTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test players
	player1ID := "match_player_1_" + uuid.New().String()[:8]
	player2ID := "match_player_2_" + uuid.New().String()[:8]

	player1, err := svc.RegisterPlayer(ctx, player1ID, "MatchPlayer1")
	require.NoError(t, err)

	player2, err := svc.RegisterPlayer(ctx, player2ID, "MatchPlayer2")
	require.NoError(t, err)

	t.Run("process match result", func(t *testing.T) {
		startTime := time.Now().Add(-30 * time.Minute)
		endTime := time.Now()

		match := &models.Match{
			MatchID:         uuid.New().String(),
			GameMode:        "battle_royale",
			MapName:         "Test_Map",
			DivisionID:      1,
			DurationSeconds: 1800, // 30 minutes
			MaxScore:        2500,
			StartTime:       startTime,
			EndTime:         &endTime,
			Status:          "completed",
			IsRanked:        true,
			CreatedAt:       time.Now().UTC(),
			UpdatedAt:       time.Now().UTC(),
		}

		participants := []*models.MatchParticipant{
			{
				MatchID:          match.MatchID,
				PlayerID:         player1.PlayerID,
				Score:            2100,
				Kills:            15,
				Deaths:           2,
				Assists:          8,
				Position:         1,
				KD_Ratio:         7.5,
				PerformanceScore: 92.5,
				IsWinner:         true,
				JoinedAt:         startTime,
			},
			{
				MatchID:          match.MatchID,
				PlayerID:         player2.PlayerID,
				Score:            1850,
				Kills:            12,
				Deaths:           8,
				Assists:          5,
				Position:         2,
				KD_Ratio:         1.5,
				PerformanceScore: 76.3,
				IsWinner:         false,
				JoinedAt:         startTime,
			},
		}

		err := svc.ProcessMatchResult(ctx, match, participants)
		require.NoError(t, err)

		// Verify player stats were updated
		updatedPlayer1, err := svc.getPlayerByID(ctx, player1.PlayerID)
		require.NoError(t, err)
		assert.Equal(t, 1, updatedPlayer1.GamesPlayed)
		assert.Equal(t, 1, updatedPlayer1.GamesWon)
		assert.Equal(t, 2100, updatedPlayer1.TotalScore)

		updatedPlayer2, err := svc.getPlayerByID(ctx, player2.PlayerID)
		require.NoError(t, err)
		assert.Equal(t, 1, updatedPlayer2.GamesPlayed)
		assert.Equal(t, 0, updatedPlayer2.GamesWon)
		assert.Equal(t, 1850, updatedPlayer2.TotalScore)
	})
}

func TestLeagueService_RatingCalculations(t *testing.T) {
	svc := &LeagueService{
		minPlayersPerDivision: 10,
		maxPlayersPerDivision: 100,
		promotionThreshold:    0.75,
		demotionThreshold:     0.25,
		decayRate:             0.95,
	}

	t.Run("performance rating calculation", func(t *testing.T) {
		player := &models.Player{
			GamesPlayed: 10,
			GamesWon:    7,
			TotalScore:  20000,
			WinRate:     0.7,
		}

		rating := svc.calculatePerformanceRating(player)
		assert.Greater(t, rating, 0.0)

		// Should be combination of win rate (70%) and score bonus
		expectedMin := 70.0 // Base win rate
		assert.GreaterOrEqual(t, rating, expectedMin)
	})

	t.Run("division promotion check", func(t *testing.T) {
		player := &models.Player{
			CurrentDivisionID: 1, // Bronze
			GamesPlayed:       15,
			IsProvisional:     false,
		}

		// High performance should trigger promotion consideration
		player.PerformanceRating = 85.0 // Above 75% threshold

		// Note: This would require division data in database for full test
		// In real implementation, this would check against division requirements
		assert.True(t, player.PerformanceRating >= svc.promotionThreshold*100)
	})

	t.Run("provisional player logic", func(t *testing.T) {
		player := &models.Player{
			IsProvisional: true,
			GamesPlayed:   5, // Below threshold
		}

		// Should remain provisional
		assert.True(t, player.IsProvisional)

		// After more games, would become non-provisional
		player.GamesPlayed = 10
		player.IsProvisional = false // Simulate update
		assert.False(t, player.IsProvisional)
	})
}

func BenchmarkLeagueService_GetLeaderboard(b *testing.B) {
	svc := setupLeagueTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := svc.GetLeaderboard(ctx, 1, 50)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkLeagueService_ProcessMatchResult(b *testing.B) {
	svc := setupLeagueTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test data
	match := &models.Match{
		MatchID:         uuid.New().String(),
		GameMode:        "battle_royale",
		DivisionID:      1,
		DurationSeconds: 1800,
		StartTime:       time.Now().Add(-30 * time.Minute),
		EndTime:         &[]time.Time{time.Now()}[0],
		Status:          "completed",
		IsRanked:        true,
	}

	participants := []*models.MatchParticipant{
		{
			MatchID:          match.MatchID,
			PlayerID:         "bench_player_1",
			Score:            2000,
			Position:         1,
			IsWinner:         true,
			PerformanceScore: 85.0,
		},
		{
			MatchID:          match.MatchID,
			PlayerID:         "bench_player_2",
			Score:            1800,
			Position:         2,
			IsWinner:         false,
			PerformanceScore: 75.0,
		},
	}

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			err := svc.ProcessMatchResult(ctx, match, participants)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

// Test utilities

func setupLeagueTestService(t *testing.T) *LeagueService {
	// Use test database configuration
	config := Config{
		Logger:      zap.NewNop(),
		Tracer:      nil,
		Meter:       nil,
		DatabaseURL: "postgres://postgres:postgres@localhost:5432/necpgame_test?sslmode=disable",
		RedisURL:    "redis://localhost:6379/2", // Use DB 2 for tests
	}

	svc, err := NewLeagueService(config)
	require.NoError(t, err)

	// Setup test database schema
	setupLeagueTestDatabase(t, svc)

	return svc
}

func setupLeagueTestDatabase(t *testing.T, svc *LeagueService) {
	// Create test tables if they don't exist
	_, err := svc.db.Exec(context.Background(), `
		CREATE TABLE IF NOT EXISTS players (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			player_id VARCHAR(100) UNIQUE,
			nickname VARCHAR(50),
			current_division_id INTEGER DEFAULT 1,
			current_rank INTEGER,
			rating INTEGER DEFAULT 1000,
			games_played INTEGER DEFAULT 0,
			games_won INTEGER DEFAULT 0,
			total_score BIGINT DEFAULT 0,
			win_rate DECIMAL(5,4) DEFAULT 0,
			average_score DECIMAL(10,2) DEFAULT 0,
			performance_rating DECIMAL(5,2) DEFAULT 0,
			joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			last_active TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			is_active BOOLEAN DEFAULT true,
			is_banned BOOLEAN DEFAULT false,
			is_provisional BOOLEAN DEFAULT true
		);

		CREATE TABLE IF NOT EXISTS divisions (
			id INTEGER PRIMARY KEY,
			name VARCHAR(50),
			level INTEGER DEFAULT 1,
			min_rating INTEGER DEFAULT 0,
			max_rating INTEGER,
			promotion_threshold DECIMAL(3,2) DEFAULT 0.75,
			demotion_threshold DECIMAL(3,2) DEFAULT 0.25,
			is_active BOOLEAN DEFAULT true,
			requires_qualification BOOLEAN DEFAULT false
		);

		CREATE TABLE IF NOT EXISTS tournaments (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			name VARCHAR(100),
			description TEXT,
			game_mode VARCHAR(50),
			start_date TIMESTAMP WITH TIME ZONE,
			end_date TIMESTAMP WITH TIME ZONE,
			registration_deadline TIMESTAMP WITH TIME ZONE,
			max_participants INTEGER,
			current_participants INTEGER DEFAULT 0,
			entry_fee INTEGER DEFAULT 0,
			prize_pool INTEGER DEFAULT 0,
			min_division_level INTEGER DEFAULT 1,
			status VARCHAR(20) DEFAULT 'upcoming',
			tournament_type VARCHAR(50) DEFAULT 'single_elimination',
			is_ranked BOOLEAN DEFAULT true,
			requires_qualification BOOLEAN DEFAULT false,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
		);

		CREATE TABLE IF NOT EXISTS matches (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			match_id VARCHAR(100) UNIQUE,
			game_mode VARCHAR(50),
			map_name VARCHAR(100),
			tournament_id UUID,
			division_id INTEGER,
			winner_id VARCHAR(100),
			duration_seconds INTEGER,
			max_score INTEGER,
			start_time TIMESTAMP WITH TIME ZONE,
			end_time TIMESTAMP WITH TIME ZONE,
			status VARCHAR(20) DEFAULT 'scheduled',
			is_ranked BOOLEAN DEFAULT true,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
		);

		CREATE TABLE IF NOT EXISTS match_participants (
			match_id VARCHAR(100),
			player_id VARCHAR(100),
			score INTEGER,
			kills INTEGER DEFAULT 0,
			deaths INTEGER DEFAULT 0,
			assists INTEGER DEFAULT 0,
			position INTEGER,
			kd_ratio DECIMAL(5,2) DEFAULT 0,
			performance_score DECIMAL(5,2) DEFAULT 0,
			joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			is_winner BOOLEAN DEFAULT false,
			dnf BOOLEAN DEFAULT false,
			PRIMARY KEY (match_id, player_id)
		);

		CREATE TABLE IF NOT EXISTS tournament_participants (
			tournament_id UUID,
			player_id VARCHAR(100),
			joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			PRIMARY KEY (tournament_id, player_id)
		);

		-- Insert default divisions
		INSERT INTO divisions (id, name, level, min_rating, max_rating) VALUES
		(1, 'Bronze', 1, 0, 1299),
		(2, 'Silver', 2, 1300, 1699),
		(3, 'Gold', 3, 1700, 2099),
		(4, 'Platinum', 4, 2100, 2499),
		(5, 'Diamond', 5, 2500, 9999)
		ON CONFLICT (id) DO NOTHING;
	`)
	require.NoError(t, err)

	// Clean up test data
	_, err = svc.db.Exec(context.Background(), `
		DELETE FROM match_participants WHERE player_id LIKE 'test_%' OR player_id LIKE 'leader_%' OR player_id LIKE 'match_%' OR player_id LIKE 'tournament_%' OR player_id LIKE 'bench_%';
		DELETE FROM matches WHERE match_id LIKE 'test_%';
		DELETE FROM tournament_participants WHERE player_id LIKE 'test_%' OR player_id LIKE 'tournament_%';
		DELETE FROM tournaments WHERE name LIKE 'Test%' OR name LIKE 'Registration%' OR name LIKE 'Bench%';
		DELETE FROM players WHERE player_id LIKE 'test_%' OR player_id LIKE 'leader_%' OR player_id LIKE 'match_%' OR player_id LIKE 'tournament_%' OR player_id LIKE 'bench_%';
	`)
	require.NoError(t, err)
}