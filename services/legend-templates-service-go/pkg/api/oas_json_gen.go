// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActiveTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("base_template")
		e.Str(s.BaseTemplate)
	}
	{
		e.FieldStart("variables")
		e.ArrStart()
		for _, elem := range s.Variables {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Variants != nil {
			e.FieldStart("variants")
			e.ArrStart()
			for _, elem := range s.Variants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfActiveTemplate = [6]string{
	0: "id",
	1: "type",
	2: "category",
	3: "base_template",
	4: "variables",
	5: "variants",
}

// Decode decodes ActiveTemplate from json.
func (s *ActiveTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "base_template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BaseTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_template\"")
			}
		case "variables":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Variables = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "variants":
			if err := func() error {
				s.Variants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variants = append(s.Variants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveTemplate) {
					name = jsonFieldsNameOfActiveTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveTemplateType as json.
func (s ActiveTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveTemplateType from json.
func (s *ActiveTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveTemplateType(v) {
	case ActiveTemplateTypeCombat:
		*s = ActiveTemplateTypeCombat
	case ActiveTemplateTypeSocial:
		*s = ActiveTemplateTypeSocial
	case ActiveTemplateTypeEconomic:
		*s = ActiveTemplateTypeEconomic
	case ActiveTemplateTypeExploration:
		*s = ActiveTemplateTypeExploration
	default:
		*s = ActiveTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveTemplatesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveTemplatesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Templates != nil {
			e.FieldStart("templates")
			e.ArrStart()
			for _, elem := range s.Templates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CacheTimestamp.Set {
			e.FieldStart("cache_timestamp")
			s.CacheTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfActiveTemplatesResponse = [2]string{
	0: "templates",
	1: "cache_timestamp",
}

// Decode decodes ActiveTemplatesResponse from json.
func (s *ActiveTemplatesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveTemplatesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templates":
			if err := func() error {
				s.Templates = make([]ActiveTemplate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveTemplate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "cache_timestamp":
			if err := func() error {
				s.CacheTimestamp.Reset()
				if err := s.CacheTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveTemplatesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveTemplatesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveTemplatesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [3]string{
	0: "error",
	1: "message",
	2: "details",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBadRequestDetails = [0]string{}

// Decode decodes BadRequestDetails from json.
func (s *BadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("base_template")
		e.Str(s.BaseTemplate)
	}
	{
		if s.Variables != nil {
			e.FieldStart("variables")
			e.ArrStart()
			for _, elem := range s.Variables {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Variants != nil {
			e.FieldStart("variants")
			e.ArrStart()
			for _, elem := range s.Variants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateTemplateRequest = [6]string{
	0: "type",
	1: "category",
	2: "base_template",
	3: "variables",
	4: "conditions",
	5: "variants",
}

// Decode decodes CreateTemplateRequest from json.
func (s *CreateTemplateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "base_template":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BaseTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_template\"")
			}
		case "variables":
			if err := func() error {
				s.Variables = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = nil
				var elem CreateTemplateRequestConditions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "variants":
			if err := func() error {
				s.Variants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variants = append(s.Variants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTemplateRequest) {
					name = jsonFieldsNameOfCreateTemplateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequestConditions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequestConditions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateTemplateRequestConditions = [0]string{}

// Decode decodes CreateTemplateRequestConditions from json.
func (s *CreateTemplateRequestConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequestConditions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequestConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTemplateRequestType as json.
func (s CreateTemplateRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTemplateRequestType from json.
func (s *CreateTemplateRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTemplateRequestType(v) {
	case CreateTemplateRequestTypeCombat:
		*s = CreateTemplateRequestTypeCombat
	case CreateTemplateRequestTypeSocial:
		*s = CreateTemplateRequestTypeSocial
	case CreateTemplateRequestTypeEconomic:
		*s = CreateTemplateRequestTypeEconomic
	case CreateTemplateRequestTypeExploration:
		*s = CreateTemplateRequestTypeExploration
	default:
		*s = CreateTemplateRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTemplateRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVariableRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVariableRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("rules")
		s.Rules.Encode(e)
	}
}

var jsonFieldsNameOfCreateVariableRequest = [3]string{
	0: "type",
	1: "name",
	2: "rules",
}

// Decode decodes CreateVariableRequest from json.
func (s *CreateVariableRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVariableRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Rules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVariableRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVariableRequest) {
					name = jsonFieldsNameOfCreateVariableRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVariableRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVariableRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVariableRequestRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVariableRequestRules) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateVariableRequestRules = [0]string{}

// Decode decodes CreateVariableRequestRules from json.
func (s *CreateVariableRequestRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVariableRequestRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateVariableRequestRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVariableRequestRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVariableRequestRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVariableRequestType as json.
func (s CreateVariableRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateVariableRequestType from json.
func (s *CreateVariableRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVariableRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateVariableRequestType(v) {
	case CreateVariableRequestTypePlayerName:
		*s = CreateVariableRequestTypePlayerName
	case CreateVariableRequestTypeActionVerb:
		*s = CreateVariableRequestTypeActionVerb
	case CreateVariableRequestTypeEnemyType:
		*s = CreateVariableRequestTypeEnemyType
	case CreateVariableRequestTypeLocation:
		*s = CreateVariableRequestTypeLocation
	case CreateVariableRequestTypeNumber:
		*s = CreateVariableRequestTypeNumber
	case CreateVariableRequestTypeTimeContext:
		*s = CreateVariableRequestTypeTimeContext
	case CreateVariableRequestTypeFaction:
		*s = CreateVariableRequestTypeFaction
	case CreateVariableRequestTypeEmotion:
		*s = CreateVariableRequestTypeEmotion
	default:
		*s = CreateVariableRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateVariableRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVariableRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVariantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVariantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("variant_text")
		e.Str(s.VariantText)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVariantRequest = [2]string{
	0: "variant_text",
	1: "weight",
}

// Decode decodes CreateVariantRequest from json.
func (s *CreateVariantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVariantRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variant_text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VariantText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant_text\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVariantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVariantRequest) {
					name = jsonFieldsNameOfCreateVariantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVariantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVariantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateLegendRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateLegendRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_data")
		s.EventData.Encode(e)
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.VariantCount.Set {
			e.FieldStart("variant_count")
			s.VariantCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateLegendRequest = [4]string{
	0: "event_type",
	1: "event_data",
	2: "context",
	3: "variant_count",
}

// Decode decodes GenerateLegendRequest from json.
func (s *GenerateLegendRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EventData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_data\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "variant_count":
			if err := func() error {
				s.VariantCount.Reset()
				if err := s.VariantCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateLegendRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateLegendRequest) {
					name = jsonFieldsNameOfGenerateLegendRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateLegendRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateLegendRequestContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateLegendRequestContext) encodeFields(e *jx.Encoder) {
	{
		if s.NarratorFaction.Set {
			e.FieldStart("narrator_faction")
			s.NarratorFaction.Encode(e)
		}
	}
	{
		if s.NarratorLocation.Set {
			e.FieldStart("narrator_location")
			s.NarratorLocation.Encode(e)
		}
	}
	{
		if s.TimeOfDay.Set {
			e.FieldStart("time_of_day")
			s.TimeOfDay.Encode(e)
		}
	}
	{
		if s.StoryStyle.Set {
			e.FieldStart("story_style")
			s.StoryStyle.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateLegendRequestContext = [4]string{
	0: "narrator_faction",
	1: "narrator_location",
	2: "time_of_day",
	3: "story_style",
}

// Decode decodes GenerateLegendRequestContext from json.
func (s *GenerateLegendRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "narrator_faction":
			if err := func() error {
				s.NarratorFaction.Reset()
				if err := s.NarratorFaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"narrator_faction\"")
			}
		case "narrator_location":
			if err := func() error {
				s.NarratorLocation.Reset()
				if err := s.NarratorLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"narrator_location\"")
			}
		case "time_of_day":
			if err := func() error {
				s.TimeOfDay.Reset()
				if err := s.TimeOfDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_of_day\"")
			}
		case "story_style":
			if err := func() error {
				s.StoryStyle.Reset()
				if err := s.StoryStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"story_style\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateLegendRequestContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateLegendRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestContextStoryStyle as json.
func (s GenerateLegendRequestContextStoryStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateLegendRequestContextStoryStyle from json.
func (s *GenerateLegendRequestContextStoryStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestContextStoryStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateLegendRequestContextStoryStyle(v) {
	case GenerateLegendRequestContextStoryStyleFormal:
		*s = GenerateLegendRequestContextStoryStyleFormal
	case GenerateLegendRequestContextStoryStyleCasual:
		*s = GenerateLegendRequestContextStoryStyleCasual
	case GenerateLegendRequestContextStoryStyleSlang:
		*s = GenerateLegendRequestContextStoryStyleSlang
	case GenerateLegendRequestContextStoryStyleDramatic:
		*s = GenerateLegendRequestContextStoryStyleDramatic
	default:
		*s = GenerateLegendRequestContextStoryStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateLegendRequestContextStoryStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestContextStoryStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestContextTimeOfDay as json.
func (s GenerateLegendRequestContextTimeOfDay) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateLegendRequestContextTimeOfDay from json.
func (s *GenerateLegendRequestContextTimeOfDay) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestContextTimeOfDay to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateLegendRequestContextTimeOfDay(v) {
	case GenerateLegendRequestContextTimeOfDayMorning:
		*s = GenerateLegendRequestContextTimeOfDayMorning
	case GenerateLegendRequestContextTimeOfDayAfternoon:
		*s = GenerateLegendRequestContextTimeOfDayAfternoon
	case GenerateLegendRequestContextTimeOfDayEvening:
		*s = GenerateLegendRequestContextTimeOfDayEvening
	case GenerateLegendRequestContextTimeOfDayNight:
		*s = GenerateLegendRequestContextTimeOfDayNight
	default:
		*s = GenerateLegendRequestContextTimeOfDay(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateLegendRequestContextTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestContextTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateLegendRequestEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateLegendRequestEventData) encodeFields(e *jx.Encoder) {
	{
		if s.PlayerName.Set {
			e.FieldStart("player_name")
			s.PlayerName.Encode(e)
		}
	}
	{
		if s.ActionVerb.Set {
			e.FieldStart("action_verb")
			s.ActionVerb.Encode(e)
		}
	}
	{
		if s.EnemyType.Set {
			e.FieldStart("enemy_type")
			s.EnemyType.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
	{
		if s.TimeContext.Set {
			e.FieldStart("time_context")
			s.TimeContext.Encode(e)
		}
	}
	{
		if s.Faction.Set {
			e.FieldStart("faction")
			s.Faction.Encode(e)
		}
	}
	{
		if s.Emotion.Set {
			e.FieldStart("emotion")
			s.Emotion.Encode(e)
		}
	}
	{
		if s.AdditionalData != nil {
			e.FieldStart("additional_data")
			s.AdditionalData.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateLegendRequestEventData = [9]string{
	0: "player_name",
	1: "action_verb",
	2: "enemy_type",
	3: "location",
	4: "number",
	5: "time_context",
	6: "faction",
	7: "emotion",
	8: "additional_data",
}

// Decode decodes GenerateLegendRequestEventData from json.
func (s *GenerateLegendRequestEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestEventData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_name":
			if err := func() error {
				s.PlayerName.Reset()
				if err := s.PlayerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_name\"")
			}
		case "action_verb":
			if err := func() error {
				s.ActionVerb.Reset()
				if err := s.ActionVerb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_verb\"")
			}
		case "enemy_type":
			if err := func() error {
				s.EnemyType.Reset()
				if err := s.EnemyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enemy_type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "time_context":
			if err := func() error {
				s.TimeContext.Reset()
				if err := s.TimeContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_context\"")
			}
		case "faction":
			if err := func() error {
				s.Faction.Reset()
				if err := s.Faction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction\"")
			}
		case "emotion":
			if err := func() error {
				s.Emotion.Reset()
				if err := s.Emotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emotion\"")
			}
		case "additional_data":
			if err := func() error {
				s.AdditionalData = nil
				var elem GenerateLegendRequestEventDataAdditionalData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateLegendRequestEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateLegendRequestEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateLegendRequestEventDataAdditionalData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateLegendRequestEventDataAdditionalData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGenerateLegendRequestEventDataAdditionalData = [0]string{}

// Decode decodes GenerateLegendRequestEventDataAdditionalData from json.
func (s *GenerateLegendRequestEventDataAdditionalData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestEventDataAdditionalData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GenerateLegendRequestEventDataAdditionalData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateLegendRequestEventDataAdditionalData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestEventDataAdditionalData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestEventDataEmotion as json.
func (s GenerateLegendRequestEventDataEmotion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateLegendRequestEventDataEmotion from json.
func (s *GenerateLegendRequestEventDataEmotion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestEventDataEmotion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateLegendRequestEventDataEmotion(v) {
	case GenerateLegendRequestEventDataEmotionFear:
		*s = GenerateLegendRequestEventDataEmotionFear
	case GenerateLegendRequestEventDataEmotionAdmiration:
		*s = GenerateLegendRequestEventDataEmotionAdmiration
	case GenerateLegendRequestEventDataEmotionRespect:
		*s = GenerateLegendRequestEventDataEmotionRespect
	case GenerateLegendRequestEventDataEmotionEnvy:
		*s = GenerateLegendRequestEventDataEmotionEnvy
	case GenerateLegendRequestEventDataEmotionNeutral:
		*s = GenerateLegendRequestEventDataEmotionNeutral
	default:
		*s = GenerateLegendRequestEventDataEmotion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateLegendRequestEventDataEmotion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestEventDataEmotion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestEventType as json.
func (s GenerateLegendRequestEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GenerateLegendRequestEventType from json.
func (s *GenerateLegendRequestEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateLegendRequestEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GenerateLegendRequestEventType(v) {
	case GenerateLegendRequestEventTypeCombat:
		*s = GenerateLegendRequestEventTypeCombat
	case GenerateLegendRequestEventTypeSocial:
		*s = GenerateLegendRequestEventTypeSocial
	case GenerateLegendRequestEventTypeEconomic:
		*s = GenerateLegendRequestEventTypeEconomic
	case GenerateLegendRequestEventTypeExploration:
		*s = GenerateLegendRequestEventTypeExploration
	default:
		*s = GenerateLegendRequestEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GenerateLegendRequestEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateLegendRequestEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneratedLegendResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneratedLegendResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Story.Set {
			e.FieldStart("story")
			s.Story.Encode(e)
		}
	}
	{
		if s.TemplateID.Set {
			e.FieldStart("template_id")
			s.TemplateID.Encode(e)
		}
	}
	{
		if s.VariantID.Set {
			e.FieldStart("variant_id")
			s.VariantID.Encode(e)
		}
	}
	{
		if s.VariablesUsed.Set {
			e.FieldStart("variables_used")
			s.VariablesUsed.Encode(e)
		}
	}
}

var jsonFieldsNameOfGeneratedLegendResponse = [4]string{
	0: "story",
	1: "template_id",
	2: "variant_id",
	3: "variables_used",
}

// Decode decodes GeneratedLegendResponse from json.
func (s *GeneratedLegendResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedLegendResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "story":
			if err := func() error {
				s.Story.Reset()
				if err := s.Story.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"story\"")
			}
		case "template_id":
			if err := func() error {
				s.TemplateID.Reset()
				if err := s.TemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "variant_id":
			if err := func() error {
				s.VariantID.Reset()
				if err := s.VariantID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant_id\"")
			}
		case "variables_used":
			if err := func() error {
				s.VariablesUsed.Reset()
				if err := s.VariablesUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables_used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeneratedLegendResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratedLegendResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedLegendResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GeneratedLegendResponseVariablesUsed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GeneratedLegendResponseVariablesUsed) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GeneratedLegendResponseVariablesUsed from json.
func (s *GeneratedLegendResponseVariablesUsed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratedLegendResponseVariablesUsed to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeneratedLegendResponseVariablesUsed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GeneratedLegendResponseVariablesUsed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratedLegendResponseVariablesUsed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [3]string{
	0: "status",
	1: "timestamp",
	2: "version",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalServerError = [2]string{
	0: "error",
	1: "message",
}

// Decode decodes InternalServerError from json.
func (s *InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [2]string{
	0: "error",
	1: "message",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes GenerateLegendRequestContext as json.
func (o OptGenerateLegendRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GenerateLegendRequestContext from json.
func (o *OptGenerateLegendRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateLegendRequestContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateLegendRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateLegendRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestContextStoryStyle as json.
func (o OptGenerateLegendRequestContextStoryStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GenerateLegendRequestContextStoryStyle from json.
func (o *OptGenerateLegendRequestContextStoryStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateLegendRequestContextStoryStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateLegendRequestContextStoryStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateLegendRequestContextStoryStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestContextTimeOfDay as json.
func (o OptGenerateLegendRequestContextTimeOfDay) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GenerateLegendRequestContextTimeOfDay from json.
func (o *OptGenerateLegendRequestContextTimeOfDay) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateLegendRequestContextTimeOfDay to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateLegendRequestContextTimeOfDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateLegendRequestContextTimeOfDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateLegendRequestEventDataEmotion as json.
func (o OptGenerateLegendRequestEventDataEmotion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GenerateLegendRequestEventDataEmotion from json.
func (o *OptGenerateLegendRequestEventDataEmotion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGenerateLegendRequestEventDataEmotion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGenerateLegendRequestEventDataEmotion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGenerateLegendRequestEventDataEmotion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratedLegendResponseVariablesUsed as json.
func (o OptGeneratedLegendResponseVariablesUsed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GeneratedLegendResponseVariablesUsed from json.
func (o *OptGeneratedLegendResponseVariablesUsed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGeneratedLegendResponseVariablesUsed to nil")
	}
	o.Set = true
	o.Value = make(GeneratedLegendResponseVariablesUsed)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGeneratedLegendResponseVariablesUsed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGeneratedLegendResponseVariablesUsed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StoryTemplate as json.
func (o OptStoryTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StoryTemplate from json.
func (o *OptStoryTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStoryTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStoryTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStoryTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TemplateVariant as json.
func (o OptTemplateVariant) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TemplateVariant from json.
func (o *OptTemplateVariant) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTemplateVariant to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTemplateVariant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTemplateVariant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateRequestType as json.
func (o OptUpdateTemplateRequestType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateTemplateRequestType from json.
func (o *OptUpdateTemplateRequestType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTemplateRequestType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTemplateRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTemplateRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVariableRequestType as json.
func (o OptUpdateVariableRequestType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateVariableRequestType from json.
func (o *OptUpdateVariableRequestType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateVariableRequestType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateVariableRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateVariableRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRule as json.
func (o OptVariableRule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VariableRule from json.
func (o *OptVariableRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVariableRule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVariableRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVariableRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRuleRulesContextRules as json.
func (o OptVariableRuleRulesContextRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VariableRuleRulesContextRules from json.
func (o *OptVariableRuleRulesContextRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVariableRuleRulesContextRules to nil")
	}
	o.Set = true
	o.Value = make(VariableRuleRulesContextRules)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVariableRuleRulesContextRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVariableRuleRulesContextRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRuleRulesTransformations as json.
func (o OptVariableRuleRulesTransformations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VariableRuleRulesTransformations from json.
func (o *OptVariableRuleRulesTransformations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVariableRuleRulesTransformations to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVariableRuleRulesTransformations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVariableRuleRulesTransformations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRuleRulesTransformationsCase as json.
func (o OptVariableRuleRulesTransformationsCase) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VariableRuleRulesTransformationsCase from json.
func (o *OptVariableRuleRulesTransformationsCase) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVariableRuleRulesTransformationsCase to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVariableRuleRulesTransformationsCase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVariableRuleRulesTransformationsCase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StoryTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StoryTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("base_template")
		e.Str(s.BaseTemplate)
	}
	{
		if s.Variables != nil {
			e.FieldStart("variables")
			e.ArrStart()
			for _, elem := range s.Variables {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Variants != nil {
			e.FieldStart("variants")
			e.ArrStart()
			for _, elem := range s.Variants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfStoryTemplate = [10]string{
	0: "id",
	1: "type",
	2: "category",
	3: "base_template",
	4: "variables",
	5: "conditions",
	6: "variants",
	7: "active",
	8: "created_at",
	9: "updated_at",
}

// Decode decodes StoryTemplate from json.
func (s *StoryTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StoryTemplate to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "base_template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BaseTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_template\"")
			}
		case "variables":
			if err := func() error {
				s.Variables = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = nil
				var elem StoryTemplateConditions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "variants":
			if err := func() error {
				s.Variants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variants = append(s.Variants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variants\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StoryTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStoryTemplate) {
					name = jsonFieldsNameOfStoryTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StoryTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StoryTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StoryTemplateConditions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StoryTemplateConditions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfStoryTemplateConditions = [0]string{}

// Decode decodes StoryTemplateConditions from json.
func (s *StoryTemplateConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StoryTemplateConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode StoryTemplateConditions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StoryTemplateConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StoryTemplateConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StoryTemplateType as json.
func (s StoryTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StoryTemplateType from json.
func (s *StoryTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StoryTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StoryTemplateType(v) {
	case StoryTemplateTypeCombat:
		*s = StoryTemplateTypeCombat
	case StoryTemplateTypeSocial:
		*s = StoryTemplateTypeSocial
	case StoryTemplateTypeEconomic:
		*s = StoryTemplateTypeEconomic
	case StoryTemplateTypeExploration:
		*s = StoryTemplateTypeExploration
	default:
		*s = StoryTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StoryTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StoryTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
}

var jsonFieldsNameOfTemplateResponse = [1]string{
	0: "template",
}

// Decode decodes TemplateResponse from json.
func (s *TemplateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateVariant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateVariant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("template_id")
		json.EncodeUUID(e, s.TemplateID)
	}
	{
		e.FieldStart("variant_text")
		e.Str(s.VariantText)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTemplateVariant = [6]string{
	0: "id",
	1: "template_id",
	2: "variant_text",
	3: "weight",
	4: "active",
	5: "created_at",
}

// Decode decodes TemplateVariant from json.
func (s *TemplateVariant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateVariant to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "template_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "variant_text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VariantText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant_text\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateVariant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplateVariant) {
					name = jsonFieldsNameOfTemplateVariant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateVariant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateVariant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateVariantsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateVariantsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Variants != nil {
			e.FieldStart("variants")
			e.ArrStart()
			for _, elem := range s.Variants {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TemplateID.Set {
			e.FieldStart("template_id")
			s.TemplateID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTemplateVariantsResponse = [2]string{
	0: "variants",
	1: "template_id",
}

// Decode decodes TemplateVariantsResponse from json.
func (s *TemplateVariantsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateVariantsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variants":
			if err := func() error {
				s.Variants = make([]TemplateVariant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TemplateVariant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Variants = append(s.Variants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variants\"")
			}
		case "template_id":
			if err := func() error {
				s.TemplateID.Reset()
				if err := s.TemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateVariantsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateVariantsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateVariantsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplatesListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplatesListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Templates != nil {
			e.FieldStart("templates")
			e.ArrStart()
			for _, elem := range s.Templates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfTemplatesListResponse = [4]string{
	0: "templates",
	1: "total",
	2: "offset",
	3: "limit",
}

// Decode decodes TemplatesListResponse from json.
func (s *TemplatesListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplatesListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templates":
			if err := func() error {
				s.Templates = make([]StoryTemplate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StoryTemplate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplatesListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplatesListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplatesListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.BaseTemplate.Set {
			e.FieldStart("base_template")
			s.BaseTemplate.Encode(e)
		}
	}
	{
		if s.Variables != nil {
			e.FieldStart("variables")
			e.ArrStart()
			for _, elem := range s.Variables {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Variants != nil {
			e.FieldStart("variants")
			e.ArrStart()
			for _, elem := range s.Variants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTemplateRequest = [7]string{
	0: "type",
	1: "category",
	2: "base_template",
	3: "variables",
	4: "conditions",
	5: "variants",
	6: "active",
}

// Decode decodes UpdateTemplateRequest from json.
func (s *UpdateTemplateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "base_template":
			if err := func() error {
				s.BaseTemplate.Reset()
				if err := s.BaseTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_template\"")
			}
		case "variables":
			if err := func() error {
				s.Variables = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = nil
				var elem UpdateTemplateRequestConditions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Conditions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "variants":
			if err := func() error {
				s.Variants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variants = append(s.Variants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variants\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestConditions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestConditions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateTemplateRequestConditions = [0]string{}

// Decode decodes UpdateTemplateRequestConditions from json.
func (s *UpdateTemplateRequestConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestConditions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateRequestType as json.
func (s UpdateTemplateRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateRequestType from json.
func (s *UpdateTemplateRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateRequestType(v) {
	case UpdateTemplateRequestTypeCombat:
		*s = UpdateTemplateRequestTypeCombat
	case UpdateTemplateRequestTypeSocial:
		*s = UpdateTemplateRequestTypeSocial
	case UpdateTemplateRequestTypeEconomic:
		*s = UpdateTemplateRequestTypeEconomic
	case UpdateTemplateRequestTypeExploration:
		*s = UpdateTemplateRequestTypeExploration
	default:
		*s = UpdateTemplateRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVariableRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVariableRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			s.Rules.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVariableRequest = [4]string{
	0: "type",
	1: "name",
	2: "rules",
	3: "active",
}

// Decode decodes UpdateVariableRequest from json.
func (s *UpdateVariableRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVariableRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = nil
				var elem UpdateVariableRequestRules
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Rules = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVariableRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVariableRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVariableRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVariableRequestRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVariableRequestRules) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateVariableRequestRules = [0]string{}

// Decode decodes UpdateVariableRequestRules from json.
func (s *UpdateVariableRequestRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVariableRequestRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVariableRequestRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVariableRequestRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVariableRequestRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVariableRequestType as json.
func (s UpdateVariableRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateVariableRequestType from json.
func (s *UpdateVariableRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVariableRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateVariableRequestType(v) {
	case UpdateVariableRequestTypePlayerName:
		*s = UpdateVariableRequestTypePlayerName
	case UpdateVariableRequestTypeActionVerb:
		*s = UpdateVariableRequestTypeActionVerb
	case UpdateVariableRequestTypeEnemyType:
		*s = UpdateVariableRequestTypeEnemyType
	case UpdateVariableRequestTypeLocation:
		*s = UpdateVariableRequestTypeLocation
	case UpdateVariableRequestTypeNumber:
		*s = UpdateVariableRequestTypeNumber
	case UpdateVariableRequestTypeTimeContext:
		*s = UpdateVariableRequestTypeTimeContext
	case UpdateVariableRequestTypeFaction:
		*s = UpdateVariableRequestTypeFaction
	case UpdateVariableRequestTypeEmotion:
		*s = UpdateVariableRequestTypeEmotion
	default:
		*s = UpdateVariableRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateVariableRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVariableRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVariantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVariantRequest) encodeFields(e *jx.Encoder) {
	{
		if s.VariantText.Set {
			e.FieldStart("variant_text")
			s.VariantText.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVariantRequest = [3]string{
	0: "variant_text",
	1: "weight",
	2: "active",
}

// Decode decodes UpdateVariantRequest from json.
func (s *UpdateVariantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVariantRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variant_text":
			if err := func() error {
				s.VariantText.Reset()
				if err := s.VariantText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant_text\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVariantRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVariantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVariantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateTemplateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateTemplateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
}

var jsonFieldsNameOfValidateTemplateRequest = [1]string{
	0: "template",
}

// Decode decodes ValidateTemplateRequest from json.
func (s *ValidateTemplateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateTemplateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateTemplateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateTemplateRequest) {
					name = jsonFieldsNameOfValidateTemplateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateTemplateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateTemplateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationError = [2]string{
	0: "valid",
	1: "errors",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationResponse = [2]string{
	0: "valid",
	1: "errors",
}

// Decode decodes ValidationResponse from json.
func (s *ValidationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariableResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariableResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Variable.Set {
			e.FieldStart("variable")
			s.Variable.Encode(e)
		}
	}
}

var jsonFieldsNameOfVariableResponse = [1]string{
	0: "variable",
}

// Decode decodes VariableResponse from json.
func (s *VariableResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variable":
			if err := func() error {
				s.Variable.Reset()
				if err := s.Variable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariableResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariableResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariableRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariableRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("rules")
		s.Rules.Encode(e)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfVariableRule = [7]string{
	0: "id",
	1: "type",
	2: "name",
	3: "rules",
	4: "active",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes VariableRule from json.
func (s *VariableRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRule to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Rules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariableRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVariableRule) {
					name = jsonFieldsNameOfVariableRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariableRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariableRuleRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariableRuleRules) encodeFields(e *jx.Encoder) {
	{
		if s.Synonyms != nil {
			e.FieldStart("synonyms")
			e.ArrStart()
			for _, elem := range s.Synonyms {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Transformations.Set {
			e.FieldStart("transformations")
			s.Transformations.Encode(e)
		}
	}
	{
		if s.ContextRules.Set {
			e.FieldStart("context_rules")
			s.ContextRules.Encode(e)
		}
	}
}

var jsonFieldsNameOfVariableRuleRules = [3]string{
	0: "synonyms",
	1: "transformations",
	2: "context_rules",
}

// Decode decodes VariableRuleRules from json.
func (s *VariableRuleRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "synonyms":
			if err := func() error {
				s.Synonyms = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Synonyms = append(s.Synonyms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synonyms\"")
			}
		case "transformations":
			if err := func() error {
				s.Transformations.Reset()
				if err := s.Transformations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformations\"")
			}
		case "context_rules":
			if err := func() error {
				s.ContextRules.Reset()
				if err := s.ContextRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariableRuleRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariableRuleRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VariableRuleRulesContextRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VariableRuleRulesContextRules) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes VariableRuleRulesContextRules from json.
func (s *VariableRuleRulesContextRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleRulesContextRules to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem VariableRuleRulesContextRulesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariableRuleRulesContextRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VariableRuleRulesContextRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleRulesContextRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariableRuleRulesContextRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariableRuleRulesContextRulesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfVariableRuleRulesContextRulesItem = [0]string{}

// Decode decodes VariableRuleRulesContextRulesItem from json.
func (s *VariableRuleRulesContextRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleRulesContextRulesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode VariableRuleRulesContextRulesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariableRuleRulesContextRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleRulesContextRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariableRuleRulesTransformations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariableRuleRulesTransformations) encodeFields(e *jx.Encoder) {
	{
		if s.Case.Set {
			e.FieldStart("case")
			s.Case.Encode(e)
		}
	}
	{
		if s.Plural.Set {
			e.FieldStart("plural")
			s.Plural.Encode(e)
		}
	}
	{
		if s.GenderAdapt.Set {
			e.FieldStart("gender_adapt")
			s.GenderAdapt.Encode(e)
		}
	}
}

var jsonFieldsNameOfVariableRuleRulesTransformations = [3]string{
	0: "case",
	1: "plural",
	2: "gender_adapt",
}

// Decode decodes VariableRuleRulesTransformations from json.
func (s *VariableRuleRulesTransformations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleRulesTransformations to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "case":
			if err := func() error {
				s.Case.Reset()
				if err := s.Case.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"case\"")
			}
		case "plural":
			if err := func() error {
				s.Plural.Reset()
				if err := s.Plural.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plural\"")
			}
		case "gender_adapt":
			if err := func() error {
				s.GenderAdapt.Reset()
				if err := s.GenderAdapt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gender_adapt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariableRuleRulesTransformations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariableRuleRulesTransformations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleRulesTransformations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRuleRulesTransformationsCase as json.
func (s VariableRuleRulesTransformationsCase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VariableRuleRulesTransformationsCase from json.
func (s *VariableRuleRulesTransformationsCase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleRulesTransformationsCase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VariableRuleRulesTransformationsCase(v) {
	case VariableRuleRulesTransformationsCaseLower:
		*s = VariableRuleRulesTransformationsCaseLower
	case VariableRuleRulesTransformationsCaseUpper:
		*s = VariableRuleRulesTransformationsCaseUpper
	case VariableRuleRulesTransformationsCaseTitle:
		*s = VariableRuleRulesTransformationsCaseTitle
	default:
		*s = VariableRuleRulesTransformationsCase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VariableRuleRulesTransformationsCase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleRulesTransformationsCase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VariableRuleType as json.
func (s VariableRuleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VariableRuleType from json.
func (s *VariableRuleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariableRuleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VariableRuleType(v) {
	case VariableRuleTypePlayerName:
		*s = VariableRuleTypePlayerName
	case VariableRuleTypeActionVerb:
		*s = VariableRuleTypeActionVerb
	case VariableRuleTypeEnemyType:
		*s = VariableRuleTypeEnemyType
	case VariableRuleTypeLocation:
		*s = VariableRuleTypeLocation
	case VariableRuleTypeNumber:
		*s = VariableRuleTypeNumber
	case VariableRuleTypeTimeContext:
		*s = VariableRuleTypeTimeContext
	case VariableRuleTypeFaction:
		*s = VariableRuleTypeFaction
	case VariableRuleTypeEmotion:
		*s = VariableRuleTypeEmotion
	default:
		*s = VariableRuleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VariableRuleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariableRuleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariablesListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariablesListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Variables != nil {
			e.FieldStart("variables")
			e.ArrStart()
			for _, elem := range s.Variables {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfVariablesListResponse = [4]string{
	0: "variables",
	1: "total",
	2: "offset",
	3: "limit",
}

// Decode decodes VariablesListResponse from json.
func (s *VariablesListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariablesListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variables":
			if err := func() error {
				s.Variables = make([]VariableRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VariableRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariablesListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariablesListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariablesListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VariantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VariantResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Variant.Set {
			e.FieldStart("variant")
			s.Variant.Encode(e)
		}
	}
}

var jsonFieldsNameOfVariantResponse = [1]string{
	0: "variant",
}

// Decode decodes VariantResponse from json.
func (s *VariantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VariantResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "variant":
			if err := func() error {
				s.Variant.Reset()
				if err := s.Variant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VariantResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VariantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VariantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
