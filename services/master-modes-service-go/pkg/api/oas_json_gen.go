// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ContentDifficultyMode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentDifficultyMode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contentId")
		json.EncodeUUID(e, s.ContentId)
	}
	{
		e.FieldStart("modeId")
		json.EncodeUUID(e, s.ModeId)
	}
	{
		e.FieldStart("requirements")
		s.Requirements.Encode(e)
	}
	{
		e.FieldStart("isEnabled")
		e.Bool(s.IsEnabled)
	}
	{
		if s.UnlockDate.Set {
			e.FieldStart("unlockDate")
			s.UnlockDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfContentDifficultyMode = [5]string{
	0: "contentId",
	1: "modeId",
	2: "requirements",
	3: "isEnabled",
	4: "unlockDate",
}

// Decode decodes ContentDifficultyMode from json.
func (s *ContentDifficultyMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentDifficultyMode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ContentId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentId\"")
			}
		case "modeId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ModeId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeId\"")
			}
		case "requirements":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Requirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirements\"")
			}
		case "isEnabled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		case "unlockDate":
			if err := func() error {
				s.UnlockDate.Reset()
				if err := s.UnlockDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unlockDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentDifficultyMode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentDifficultyMode) {
					name = jsonFieldsNameOfContentDifficultyMode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentDifficultyMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentDifficultyMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDifficultyModeBadRequest as json.
func (s *CreateDifficultyModeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDifficultyModeBadRequest from json.
func (s *CreateDifficultyModeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDifficultyModeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDifficultyModeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDifficultyModeForbidden as json.
func (s *CreateDifficultyModeForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDifficultyModeForbidden from json.
func (s *CreateDifficultyModeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDifficultyModeForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDifficultyModeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDifficultyModeInternalServerError as json.
func (s *CreateDifficultyModeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDifficultyModeInternalServerError from json.
func (s *CreateDifficultyModeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDifficultyModeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDifficultyModeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDifficultyModeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDifficultyModeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("hpModifier")
		e.Float32(s.HpModifier)
	}
	{
		e.FieldStart("damageModifier")
		e.Float32(s.DamageModifier)
	}
	{
		e.FieldStart("timeLimitMultiplier")
		e.Float32(s.TimeLimitMultiplier)
	}
	{
		e.FieldStart("respawnLimit")
		e.Int(s.RespawnLimit)
	}
	{
		e.FieldStart("checkpointLimit")
		e.Int(s.CheckpointLimit)
	}
	{
		e.FieldStart("rewardModifier")
		e.Float32(s.RewardModifier)
	}
	{
		e.FieldStart("permadeath")
		e.Bool(s.Permadeath)
	}
	{
		if s.SpecialMechanics != nil {
			e.FieldStart("specialMechanics")
			e.ArrStart()
			for _, elem := range s.SpecialMechanics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateDifficultyModeRequest = [11]string{
	0:  "name",
	1:  "level",
	2:  "description",
	3:  "hpModifier",
	4:  "damageModifier",
	5:  "timeLimitMultiplier",
	6:  "respawnLimit",
	7:  "checkpointLimit",
	8:  "rewardModifier",
	9:  "permadeath",
	10: "specialMechanics",
}

// Decode decodes CreateDifficultyModeRequest from json.
func (s *CreateDifficultyModeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "hpModifier":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.HpModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hpModifier\"")
			}
		case "damageModifier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float32()
				s.DamageModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageModifier\"")
			}
		case "timeLimitMultiplier":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.TimeLimitMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeLimitMultiplier\"")
			}
		case "respawnLimit":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.RespawnLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respawnLimit\"")
			}
		case "checkpointLimit":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CheckpointLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkpointLimit\"")
			}
		case "rewardModifier":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.RewardModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardModifier\"")
			}
		case "permadeath":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Permadeath = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permadeath\"")
			}
		case "specialMechanics":
			if err := func() error {
				s.SpecialMechanics = make([]CreateDifficultyModeRequestSpecialMechanicsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDifficultyModeRequestSpecialMechanicsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpecialMechanics = append(s.SpecialMechanics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specialMechanics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDifficultyModeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDifficultyModeRequest) {
					name = jsonFieldsNameOfCreateDifficultyModeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDifficultyModeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDifficultyModeRequestLevel as json.
func (s CreateDifficultyModeRequestLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDifficultyModeRequestLevel from json.
func (s *CreateDifficultyModeRequestLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeRequestLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDifficultyModeRequestLevel(v) {
	case CreateDifficultyModeRequestLevelMaster:
		*s = CreateDifficultyModeRequestLevelMaster
	case CreateDifficultyModeRequestLevelGrandmaster:
		*s = CreateDifficultyModeRequestLevelGrandmaster
	case CreateDifficultyModeRequestLevelLegendary:
		*s = CreateDifficultyModeRequestLevelLegendary
	default:
		*s = CreateDifficultyModeRequestLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDifficultyModeRequestLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeRequestLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDifficultyModeRequestSpecialMechanicsItem as json.
func (s CreateDifficultyModeRequestSpecialMechanicsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDifficultyModeRequestSpecialMechanicsItem from json.
func (s *CreateDifficultyModeRequestSpecialMechanicsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDifficultyModeRequestSpecialMechanicsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDifficultyModeRequestSpecialMechanicsItem(v) {
	case CreateDifficultyModeRequestSpecialMechanicsItemTimeDilation:
		*s = CreateDifficultyModeRequestSpecialMechanicsItemTimeDilation
	case CreateDifficultyModeRequestSpecialMechanicsItemEnhancedAi:
		*s = CreateDifficultyModeRequestSpecialMechanicsItemEnhancedAi
	case CreateDifficultyModeRequestSpecialMechanicsItemEnvironmentalHazards:
		*s = CreateDifficultyModeRequestSpecialMechanicsItemEnvironmentalHazards
	case CreateDifficultyModeRequestSpecialMechanicsItemResourceScarcity:
		*s = CreateDifficultyModeRequestSpecialMechanicsItemResourceScarcity
	case CreateDifficultyModeRequestSpecialMechanicsItemAdaptiveDifficulty:
		*s = CreateDifficultyModeRequestSpecialMechanicsItemAdaptiveDifficulty
	default:
		*s = CreateDifficultyModeRequestSpecialMechanicsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDifficultyModeRequestSpecialMechanicsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDifficultyModeRequestSpecialMechanicsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyMode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyMode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("hpModifier")
		e.Float32(s.HpModifier)
	}
	{
		e.FieldStart("damageModifier")
		e.Float32(s.DamageModifier)
	}
	{
		e.FieldStart("timeLimitMultiplier")
		e.Float32(s.TimeLimitMultiplier)
	}
	{
		e.FieldStart("respawnLimit")
		e.Int(s.RespawnLimit)
	}
	{
		e.FieldStart("checkpointLimit")
		e.Int(s.CheckpointLimit)
	}
	{
		e.FieldStart("rewardModifier")
		e.Float32(s.RewardModifier)
	}
	{
		e.FieldStart("permadeath")
		e.Bool(s.Permadeath)
	}
	{
		if s.SpecialMechanics != nil {
			e.FieldStart("specialMechanics")
			e.ArrStart()
			for _, elem := range s.SpecialMechanics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDifficultyMode = [14]string{
	0:  "id",
	1:  "name",
	2:  "level",
	3:  "description",
	4:  "hpModifier",
	5:  "damageModifier",
	6:  "timeLimitMultiplier",
	7:  "respawnLimit",
	8:  "checkpointLimit",
	9:  "rewardModifier",
	10: "permadeath",
	11: "specialMechanics",
	12: "createdAt",
	13: "updatedAt",
}

// Decode decodes DifficultyMode from json.
func (s *DifficultyMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyMode to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "hpModifier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float32()
				s.HpModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hpModifier\"")
			}
		case "damageModifier":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.DamageModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageModifier\"")
			}
		case "timeLimitMultiplier":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float32()
				s.TimeLimitMultiplier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeLimitMultiplier\"")
			}
		case "respawnLimit":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.RespawnLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respawnLimit\"")
			}
		case "checkpointLimit":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CheckpointLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkpointLimit\"")
			}
		case "rewardModifier":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.RewardModifier = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardModifier\"")
			}
		case "permadeath":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Permadeath = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permadeath\"")
			}
		case "specialMechanics":
			if err := func() error {
				s.SpecialMechanics = make([]DifficultyModeSpecialMechanicsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DifficultyModeSpecialMechanicsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpecialMechanics = append(s.SpecialMechanics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specialMechanics\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyMode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDifficultyMode) {
					name = jsonFieldsNameOfDifficultyMode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DifficultyModeLevel as json.
func (s DifficultyModeLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DifficultyModeLevel from json.
func (s *DifficultyModeLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyModeLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DifficultyModeLevel(v) {
	case DifficultyModeLevelMaster:
		*s = DifficultyModeLevelMaster
	case DifficultyModeLevelGrandmaster:
		*s = DifficultyModeLevelGrandmaster
	case DifficultyModeLevelLegendary:
		*s = DifficultyModeLevelLegendary
	default:
		*s = DifficultyModeLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DifficultyModeLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyModeLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DifficultyModeSpecialMechanicsItem as json.
func (s DifficultyModeSpecialMechanicsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DifficultyModeSpecialMechanicsItem from json.
func (s *DifficultyModeSpecialMechanicsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyModeSpecialMechanicsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DifficultyModeSpecialMechanicsItem(v) {
	case DifficultyModeSpecialMechanicsItemTimeDilation:
		*s = DifficultyModeSpecialMechanicsItemTimeDilation
	case DifficultyModeSpecialMechanicsItemEnhancedAi:
		*s = DifficultyModeSpecialMechanicsItemEnhancedAi
	case DifficultyModeSpecialMechanicsItemEnvironmentalHazards:
		*s = DifficultyModeSpecialMechanicsItemEnvironmentalHazards
	case DifficultyModeSpecialMechanicsItemResourceScarcity:
		*s = DifficultyModeSpecialMechanicsItemResourceScarcity
	case DifficultyModeSpecialMechanicsItemAdaptiveDifficulty:
		*s = DifficultyModeSpecialMechanicsItemAdaptiveDifficulty
	default:
		*s = DifficultyModeSpecialMechanicsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DifficultyModeSpecialMechanicsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyModeSpecialMechanicsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyModeStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyModeStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("modeId")
		json.EncodeUUID(e, s.ModeId)
	}
	{
		e.FieldStart("modeName")
		e.Str(s.ModeName)
	}
	{
		e.FieldStart("totalSessions")
		e.Int(s.TotalSessions)
	}
	{
		e.FieldStart("completedSessions")
		e.Int(s.CompletedSessions)
	}
	{
		e.FieldStart("failedSessions")
		e.Int(s.FailedSessions)
	}
	{
		e.FieldStart("completionRate")
		e.Float32(s.CompletionRate)
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("averageCompletionTime")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.BestScore.Set {
			e.FieldStart("bestScore")
			s.BestScore.Encode(e)
		}
	}
	{
		if s.AverageScore.Set {
			e.FieldStart("averageScore")
			s.AverageScore.Encode(e)
		}
	}
	{
		if s.TopPlayers != nil {
			e.FieldStart("topPlayers")
			e.ArrStart()
			for _, elem := range s.TopPlayers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDifficultyModeStats = [10]string{
	0: "modeId",
	1: "modeName",
	2: "totalSessions",
	3: "completedSessions",
	4: "failedSessions",
	5: "completionRate",
	6: "averageCompletionTime",
	7: "bestScore",
	8: "averageScore",
	9: "topPlayers",
}

// Decode decodes DifficultyModeStats from json.
func (s *DifficultyModeStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyModeStats to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modeId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ModeId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeId\"")
			}
		case "modeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ModeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeName\"")
			}
		case "totalSessions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalSessions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSessions\"")
			}
		case "completedSessions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CompletedSessions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedSessions\"")
			}
		case "failedSessions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.FailedSessions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedSessions\"")
			}
		case "completionRate":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float32()
				s.CompletionRate = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionRate\"")
			}
		case "averageCompletionTime":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageCompletionTime\"")
			}
		case "bestScore":
			if err := func() error {
				s.BestScore.Reset()
				if err := s.BestScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bestScore\"")
			}
		case "averageScore":
			if err := func() error {
				s.AverageScore.Reset()
				if err := s.AverageScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageScore\"")
			}
		case "topPlayers":
			if err := func() error {
				s.TopPlayers = make([]DifficultyModeStatsTopPlayersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DifficultyModeStatsTopPlayersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopPlayers = append(s.TopPlayers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topPlayers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyModeStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDifficultyModeStats) {
					name = jsonFieldsNameOfDifficultyModeStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyModeStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyModeStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyModeStatsTopPlayersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyModeStatsTopPlayersItem) encodeFields(e *jx.Encoder) {
	{
		if s.PlayerId.Set {
			e.FieldStart("playerId")
			s.PlayerId.Encode(e)
		}
	}
	{
		if s.PlayerName.Set {
			e.FieldStart("playerName")
			s.PlayerName.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completionTime")
			s.CompletionTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfDifficultyModeStatsTopPlayersItem = [4]string{
	0: "playerId",
	1: "playerName",
	2: "score",
	3: "completionTime",
}

// Decode decodes DifficultyModeStatsTopPlayersItem from json.
func (s *DifficultyModeStatsTopPlayersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyModeStatsTopPlayersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			if err := func() error {
				s.PlayerId.Reset()
				if err := s.PlayerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "playerName":
			if err := func() error {
				s.PlayerName.Reset()
				if err := s.PlayerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerName\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "completionTime":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyModeStatsTopPlayersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyModeStatsTopPlayersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyModeStatsTopPlayersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyRequirements) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("minLevel")
		e.Int(s.MinLevel)
	}
	{
		e.FieldStart("minSkillRating")
		e.Int(s.MinSkillRating)
	}
	{
		if s.CompletedMissions != nil {
			e.FieldStart("completedMissions")
			e.ArrStart()
			for _, elem := range s.CompletedMissions {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReputationLevel.Set {
			e.FieldStart("reputationLevel")
			s.ReputationLevel.Encode(e)
		}
	}
	{
		if s.PrerequisiteModes != nil {
			e.FieldStart("prerequisiteModes")
			e.ArrStart()
			for _, elem := range s.PrerequisiteModes {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDifficultyRequirements = [5]string{
	0: "minLevel",
	1: "minSkillRating",
	2: "completedMissions",
	3: "reputationLevel",
	4: "prerequisiteModes",
}

// Decode decodes DifficultyRequirements from json.
func (s *DifficultyRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyRequirements to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minLevel":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MinLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minLevel\"")
			}
		case "minSkillRating":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MinSkillRating = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minSkillRating\"")
			}
		case "completedMissions":
			if err := func() error {
				s.CompletedMissions = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.CompletedMissions = append(s.CompletedMissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedMissions\"")
			}
		case "reputationLevel":
			if err := func() error {
				s.ReputationLevel.Reset()
				if err := s.ReputationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputationLevel\"")
			}
		case "prerequisiteModes":
			if err := func() error {
				s.PrerequisiteModes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PrerequisiteModes = append(s.PrerequisiteModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerequisiteModes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyRequirements")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDifficultyRequirements) {
					name = jsonFieldsNameOfDifficultyRequirements[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DifficultyRequirementsReputationLevel as json.
func (s DifficultyRequirementsReputationLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DifficultyRequirementsReputationLevel from json.
func (s *DifficultyRequirementsReputationLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyRequirementsReputationLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DifficultyRequirementsReputationLevel(v) {
	case DifficultyRequirementsReputationLevelRookie:
		*s = DifficultyRequirementsReputationLevelRookie
	case DifficultyRequirementsReputationLevelSkilled:
		*s = DifficultyRequirementsReputationLevelSkilled
	case DifficultyRequirementsReputationLevelVeteran:
		*s = DifficultyRequirementsReputationLevelVeteran
	case DifficultyRequirementsReputationLevelElite:
		*s = DifficultyRequirementsReputationLevelElite
	case DifficultyRequirementsReputationLevelLegend:
		*s = DifficultyRequirementsReputationLevelLegend
	default:
		*s = DifficultyRequirementsReputationLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DifficultyRequirementsReputationLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyRequirementsReputationLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultySession) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultySession) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("instanceId")
		json.EncodeUUID(e, s.InstanceId)
	}
	{
		e.FieldStart("modeId")
		json.EncodeUUID(e, s.ModeId)
	}
	{
		e.FieldStart("playerId")
		json.EncodeUUID(e, s.PlayerId)
	}
	{
		if s.TimeRemaining.Set {
			e.FieldStart("timeRemaining")
			s.TimeRemaining.Encode(e)
		}
	}
	{
		if s.RespawnsRemaining.Set {
			e.FieldStart("respawnsRemaining")
			s.RespawnsRemaining.Encode(e)
		}
	}
	{
		if s.CheckpointsUsed.Set {
			e.FieldStart("checkpointsUsed")
			s.CheckpointsUsed.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("startedAt")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completedAt")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			e.FieldStart("restrictions")
			s.Restrictions.Encode(e)
		}
	}
}

var jsonFieldsNameOfDifficultySession = [12]string{
	0:  "id",
	1:  "instanceId",
	2:  "modeId",
	3:  "playerId",
	4:  "timeRemaining",
	5:  "respawnsRemaining",
	6:  "checkpointsUsed",
	7:  "status",
	8:  "startedAt",
	9:  "completedAt",
	10: "score",
	11: "restrictions",
}

// Decode decodes DifficultySession from json.
func (s *DifficultySession) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultySession to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "instanceId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InstanceId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceId\"")
			}
		case "modeId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ModeId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeId\"")
			}
		case "playerId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "timeRemaining":
			if err := func() error {
				s.TimeRemaining.Reset()
				if err := s.TimeRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeRemaining\"")
			}
		case "respawnsRemaining":
			if err := func() error {
				s.RespawnsRemaining.Reset()
				if err := s.RespawnsRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respawnsRemaining\"")
			}
		case "checkpointsUsed":
			if err := func() error {
				s.CheckpointsUsed.Reset()
				if err := s.CheckpointsUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkpointsUsed\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "startedAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		case "completedAt":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "restrictions":
			if err := func() error {
				s.Restrictions.Reset()
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultySession")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDifficultySession) {
					name = jsonFieldsNameOfDifficultySession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultySession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultySession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultySessionRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultySessionRestrictions) encodeFields(e *jx.Encoder) {
	{
		if s.TimeLimit.Set {
			e.FieldStart("timeLimit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.RespawnLimit.Set {
			e.FieldStart("respawnLimit")
			s.RespawnLimit.Encode(e)
		}
	}
	{
		if s.CheckpointLimit.Set {
			e.FieldStart("checkpointLimit")
			s.CheckpointLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfDifficultySessionRestrictions = [3]string{
	0: "timeLimit",
	1: "respawnLimit",
	2: "checkpointLimit",
}

// Decode decodes DifficultySessionRestrictions from json.
func (s *DifficultySessionRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultySessionRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeLimit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeLimit\"")
			}
		case "respawnLimit":
			if err := func() error {
				s.RespawnLimit.Reset()
				if err := s.RespawnLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respawnLimit\"")
			}
		case "checkpointLimit":
			if err := func() error {
				s.CheckpointLimit.Reset()
				if err := s.CheckpointLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkpointLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultySessionRestrictions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultySessionRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultySessionRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DifficultySessionStatus as json.
func (s DifficultySessionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DifficultySessionStatus from json.
func (s *DifficultySessionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultySessionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DifficultySessionStatus(v) {
	case DifficultySessionStatusActive:
		*s = DifficultySessionStatusActive
	case DifficultySessionStatusCompleted:
		*s = DifficultySessionStatusCompleted
	case DifficultySessionStatusFailed:
		*s = DifficultySessionStatusFailed
	case DifficultySessionStatusPaused:
		*s = DifficultySessionStatusPaused
	default:
		*s = DifficultySessionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DifficultySessionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultySessionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalSessions")
		e.Int(s.TotalSessions)
	}
	{
		e.FieldStart("completionRate")
		e.Float32(s.CompletionRate)
	}
	{
		e.FieldStart("averageScore")
		e.Float32(s.AverageScore)
	}
	{
		if s.PopularModes != nil {
			e.FieldStart("popularModes")
			e.ArrStart()
			for _, elem := range s.PopularModes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ModeStats != nil {
			e.FieldStart("modeStats")
			e.ArrStart()
			for _, elem := range s.ModeStats {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDifficultyStats = [5]string{
	0: "totalSessions",
	1: "completionRate",
	2: "averageScore",
	3: "popularModes",
	4: "modeStats",
}

// Decode decodes DifficultyStats from json.
func (s *DifficultyStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalSessions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSessions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSessions\"")
			}
		case "completionRate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.CompletionRate = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionRate\"")
			}
		case "averageScore":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.AverageScore = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageScore\"")
			}
		case "popularModes":
			if err := func() error {
				s.PopularModes = make([]DifficultyStatsPopularModesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DifficultyStatsPopularModesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PopularModes = append(s.PopularModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"popularModes\"")
			}
		case "modeStats":
			if err := func() error {
				s.ModeStats = make([]DifficultyModeStats, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DifficultyModeStats
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ModeStats = append(s.ModeStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeStats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDifficultyStats) {
					name = jsonFieldsNameOfDifficultyStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DifficultyStatsPopularModesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DifficultyStatsPopularModesItem) encodeFields(e *jx.Encoder) {
	{
		if s.ModeId.Set {
			e.FieldStart("modeId")
			s.ModeId.Encode(e)
		}
	}
	{
		if s.ModeName.Set {
			e.FieldStart("modeName")
			s.ModeName.Encode(e)
		}
	}
	{
		if s.SessionCount.Set {
			e.FieldStart("sessionCount")
			s.SessionCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfDifficultyStatsPopularModesItem = [3]string{
	0: "modeId",
	1: "modeName",
	2: "sessionCount",
}

// Decode decodes DifficultyStatsPopularModesItem from json.
func (s *DifficultyStatsPopularModesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DifficultyStatsPopularModesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modeId":
			if err := func() error {
				s.ModeId.Reset()
				if err := s.ModeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeId\"")
			}
		case "modeName":
			if err := func() error {
				s.ModeName.Reset()
				if err := s.ModeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeName\"")
			}
		case "sessionCount":
			if err := func() error {
				s.SessionCount.Reset()
				if err := s.SessionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DifficultyStatsPopularModesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DifficultyStatsPopularModesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DifficultyStatsPopularModesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [5]string{
	0: "code",
	1: "message",
	2: "details",
	3: "timestamp",
	4: "requestId",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentDifficultyModesInternalServerError as json.
func (s *GetContentDifficultyModesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetContentDifficultyModesInternalServerError from json.
func (s *GetContentDifficultyModesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentDifficultyModesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetContentDifficultyModesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentDifficultyModesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentDifficultyModesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentDifficultyModesNotFound as json.
func (s *GetContentDifficultyModesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetContentDifficultyModesNotFound from json.
func (s *GetContentDifficultyModesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentDifficultyModesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetContentDifficultyModesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentDifficultyModesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentDifficultyModesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentDifficultyModesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentDifficultyModesOK) encodeFields(e *jx.Encoder) {
	{
		if s.ContentId.Set {
			e.FieldStart("contentId")
			s.ContentId.Encode(e)
		}
	}
	{
		if s.AvailableModes != nil {
			e.FieldStart("availableModes")
			e.ArrStart()
			for _, elem := range s.AvailableModes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetContentDifficultyModesOK = [2]string{
	0: "contentId",
	1: "availableModes",
}

// Decode decodes GetContentDifficultyModesOK from json.
func (s *GetContentDifficultyModesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentDifficultyModesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentId":
			if err := func() error {
				s.ContentId.Reset()
				if err := s.ContentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentId\"")
			}
		case "availableModes":
			if err := func() error {
				s.AvailableModes = make([]ContentDifficultyMode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContentDifficultyMode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableModes = append(s.AvailableModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableModes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentDifficultyModesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentDifficultyModesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentDifficultyModesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeInternalServerError as json.
func (s *GetDifficultyModeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeInternalServerError from json.
func (s *GetDifficultyModeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeNotFound as json.
func (s *GetDifficultyModeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeNotFound from json.
func (s *GetDifficultyModeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeRequirementsInternalServerError as json.
func (s *GetDifficultyModeRequirementsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeRequirementsInternalServerError from json.
func (s *GetDifficultyModeRequirementsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeRequirementsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeRequirementsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeRequirementsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeRequirementsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeRequirementsNotFound as json.
func (s *GetDifficultyModeRequirementsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeRequirementsNotFound from json.
func (s *GetDifficultyModeRequirementsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeRequirementsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeRequirementsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeRequirementsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeRequirementsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeStatsInternalServerError as json.
func (s *GetDifficultyModeStatsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeStatsInternalServerError from json.
func (s *GetDifficultyModeStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeStatsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeStatsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDifficultyModeStatsNotFound as json.
func (s *GetDifficultyModeStatsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDifficultyModeStatsNotFound from json.
func (s *GetDifficultyModeStatsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModeStatsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDifficultyModeStatsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModeStatsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModeStatsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDifficultyModesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDifficultyModesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Modes != nil {
			e.FieldStart("modes")
			e.ArrStart()
			for _, elem := range s.Modes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDifficultyModesOK = [2]string{
	0: "modes",
	1: "total",
}

// Decode decodes GetDifficultyModesOK from json.
func (s *GetDifficultyModesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDifficultyModesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modes":
			if err := func() error {
				s.Modes = make([]DifficultyMode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DifficultyMode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Modes = append(s.Modes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modes\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDifficultyModesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDifficultyModesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDifficultyModesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetInstanceDifficultyInternalServerError as json.
func (s *GetInstanceDifficultyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetInstanceDifficultyInternalServerError from json.
func (s *GetInstanceDifficultyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInstanceDifficultyInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetInstanceDifficultyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInstanceDifficultyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInstanceDifficultyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetInstanceDifficultyNotFound as json.
func (s *GetInstanceDifficultyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetInstanceDifficultyNotFound from json.
func (s *GetInstanceDifficultyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInstanceDifficultyNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetInstanceDifficultyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInstanceDifficultyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInstanceDifficultyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DifficultyRequirementsReputationLevel as json.
func (o OptDifficultyRequirementsReputationLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DifficultyRequirementsReputationLevel from json.
func (o *OptDifficultyRequirementsReputationLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDifficultyRequirementsReputationLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDifficultyRequirementsReputationLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDifficultyRequirementsReputationLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DifficultySessionRestrictions as json.
func (o OptDifficultySessionRestrictions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DifficultySessionRestrictions from json.
func (o *OptDifficultySessionRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDifficultySessionRestrictions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDifficultySessionRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDifficultySessionRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectInstanceDifficultyBadRequest as json.
func (s *SelectInstanceDifficultyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SelectInstanceDifficultyBadRequest from json.
func (s *SelectInstanceDifficultyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectInstanceDifficultyBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectInstanceDifficultyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectInstanceDifficultyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectInstanceDifficultyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectInstanceDifficultyForbidden as json.
func (s *SelectInstanceDifficultyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SelectInstanceDifficultyForbidden from json.
func (s *SelectInstanceDifficultyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectInstanceDifficultyForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectInstanceDifficultyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectInstanceDifficultyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectInstanceDifficultyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectInstanceDifficultyInternalServerError as json.
func (s *SelectInstanceDifficultyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SelectInstanceDifficultyInternalServerError from json.
func (s *SelectInstanceDifficultyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectInstanceDifficultyInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectInstanceDifficultyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectInstanceDifficultyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectInstanceDifficultyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectInstanceDifficultyNotFound as json.
func (s *SelectInstanceDifficultyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SelectInstanceDifficultyNotFound from json.
func (s *SelectInstanceDifficultyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectInstanceDifficultyNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectInstanceDifficultyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectInstanceDifficultyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectInstanceDifficultyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectInstanceDifficultyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectInstanceDifficultyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("modeId")
		json.EncodeUUID(e, s.ModeId)
	}
}

var jsonFieldsNameOfSelectInstanceDifficultyReq = [1]string{
	0: "modeId",
}

// Decode decodes SelectInstanceDifficultyReq from json.
func (s *SelectInstanceDifficultyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectInstanceDifficultyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modeId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ModeId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modeId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectInstanceDifficultyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSelectInstanceDifficultyReq) {
					name = jsonFieldsNameOfSelectInstanceDifficultyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectInstanceDifficultyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectInstanceDifficultyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDifficultyModeBadRequest as json.
func (s *UpdateDifficultyModeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDifficultyModeBadRequest from json.
func (s *UpdateDifficultyModeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDifficultyModeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDifficultyModeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDifficultyModeForbidden as json.
func (s *UpdateDifficultyModeForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDifficultyModeForbidden from json.
func (s *UpdateDifficultyModeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDifficultyModeForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDifficultyModeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDifficultyModeInternalServerError as json.
func (s *UpdateDifficultyModeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDifficultyModeInternalServerError from json.
func (s *UpdateDifficultyModeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDifficultyModeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDifficultyModeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDifficultyModeNotFound as json.
func (s *UpdateDifficultyModeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDifficultyModeNotFound from json.
func (s *UpdateDifficultyModeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDifficultyModeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDifficultyModeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDifficultyModeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDifficultyModeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.HpModifier.Set {
			e.FieldStart("hpModifier")
			s.HpModifier.Encode(e)
		}
	}
	{
		if s.DamageModifier.Set {
			e.FieldStart("damageModifier")
			s.DamageModifier.Encode(e)
		}
	}
	{
		if s.TimeLimitMultiplier.Set {
			e.FieldStart("timeLimitMultiplier")
			s.TimeLimitMultiplier.Encode(e)
		}
	}
	{
		if s.RespawnLimit.Set {
			e.FieldStart("respawnLimit")
			s.RespawnLimit.Encode(e)
		}
	}
	{
		if s.CheckpointLimit.Set {
			e.FieldStart("checkpointLimit")
			s.CheckpointLimit.Encode(e)
		}
	}
	{
		if s.RewardModifier.Set {
			e.FieldStart("rewardModifier")
			s.RewardModifier.Encode(e)
		}
	}
	{
		if s.Permadeath.Set {
			e.FieldStart("permadeath")
			s.Permadeath.Encode(e)
		}
	}
	{
		if s.SpecialMechanics != nil {
			e.FieldStart("specialMechanics")
			e.ArrStart()
			for _, elem := range s.SpecialMechanics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateDifficultyModeRequest = [11]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "hpModifier",
	4:  "damageModifier",
	5:  "timeLimitMultiplier",
	6:  "respawnLimit",
	7:  "checkpointLimit",
	8:  "rewardModifier",
	9:  "permadeath",
	10: "specialMechanics",
}

// Decode decodes UpdateDifficultyModeRequest from json.
func (s *UpdateDifficultyModeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "hpModifier":
			if err := func() error {
				s.HpModifier.Reset()
				if err := s.HpModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hpModifier\"")
			}
		case "damageModifier":
			if err := func() error {
				s.DamageModifier.Reset()
				if err := s.DamageModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageModifier\"")
			}
		case "timeLimitMultiplier":
			if err := func() error {
				s.TimeLimitMultiplier.Reset()
				if err := s.TimeLimitMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeLimitMultiplier\"")
			}
		case "respawnLimit":
			if err := func() error {
				s.RespawnLimit.Reset()
				if err := s.RespawnLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respawnLimit\"")
			}
		case "checkpointLimit":
			if err := func() error {
				s.CheckpointLimit.Reset()
				if err := s.CheckpointLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkpointLimit\"")
			}
		case "rewardModifier":
			if err := func() error {
				s.RewardModifier.Reset()
				if err := s.RewardModifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardModifier\"")
			}
		case "permadeath":
			if err := func() error {
				s.Permadeath.Reset()
				if err := s.Permadeath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permadeath\"")
			}
		case "specialMechanics":
			if err := func() error {
				s.SpecialMechanics = make([]UpdateDifficultyModeRequestSpecialMechanicsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateDifficultyModeRequestSpecialMechanicsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpecialMechanics = append(s.SpecialMechanics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specialMechanics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDifficultyModeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDifficultyModeRequest) {
					name = jsonFieldsNameOfUpdateDifficultyModeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDifficultyModeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDifficultyModeRequestSpecialMechanicsItem as json.
func (s UpdateDifficultyModeRequestSpecialMechanicsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDifficultyModeRequestSpecialMechanicsItem from json.
func (s *UpdateDifficultyModeRequestSpecialMechanicsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDifficultyModeRequestSpecialMechanicsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDifficultyModeRequestSpecialMechanicsItem(v) {
	case UpdateDifficultyModeRequestSpecialMechanicsItemTimeDilation:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItemTimeDilation
	case UpdateDifficultyModeRequestSpecialMechanicsItemEnhancedAi:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItemEnhancedAi
	case UpdateDifficultyModeRequestSpecialMechanicsItemEnvironmentalHazards:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItemEnvironmentalHazards
	case UpdateDifficultyModeRequestSpecialMechanicsItemResourceScarcity:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItemResourceScarcity
	case UpdateDifficultyModeRequestSpecialMechanicsItemAdaptiveDifficulty:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItemAdaptiveDifficulty
	default:
		*s = UpdateDifficultyModeRequestSpecialMechanicsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDifficultyModeRequestSpecialMechanicsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDifficultyModeRequestSpecialMechanicsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
