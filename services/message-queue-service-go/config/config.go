// Code generated by NECPGAME backend agent. Enterprise-grade Message Queue service configuration.
// PERFORMANCE: Optimized configuration loading for high-volume message processing

package config

import (
	"os"
	"strconv"
	"strings"
	"time"
)

// Config holds the complete service configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Config struct {
	Server   ServerConfig   `yaml:"server"`
	Database DatabaseConfig `yaml:"database"`
	Redis    RedisConfig    `yaml:"redis"`
	Kafka    KafkaConfig    `yaml:"kafka"`
	Message  MessageConfig  `yaml:"message"`
	Security SecurityConfig `yaml:"security"`
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
	Port         string        `yaml:"port"`
	ReadTimeout  time.Duration `yaml:"read_timeout"`
	WriteTimeout time.Duration `yaml:"write_timeout"`
	IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

// DatabaseConfig holds PostgreSQL database configuration
type DatabaseConfig struct {
	Host            string `yaml:"host"`
	Port            int    `yaml:"port"`
	User            string `yaml:"user"`
	Password        string `yaml:"password"`
	Database        string `yaml:"database"`
	SSLMode         string `yaml:"ssl_mode"`
	MaxOpenConns    int    `yaml:"max_open_conns"`
	MaxIdleConns    int    `yaml:"max_idle_conns"`
	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `yaml:"conn_max_idle_time"`
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
	Host         string `yaml:"host"`
	Port         int    `yaml:"port"`
	Password     string `yaml:"password"`
	DB           int    `yaml:"db"`
	PoolSize     int    `yaml:"pool_size"`
	MinIdleConns int    `yaml:"min_idle_conns"`
}

// KafkaConfig holds Kafka configuration
type KafkaConfig struct {
	Brokers         []string      `yaml:"brokers"`
	ClientID        string        `yaml:"client_id"`
	GroupID         string        `yaml:"group_id"`
	SessionTimeout  time.Duration `yaml:"session_timeout"`
	HeartbeatInterval time.Duration `yaml:"heartbeat_interval"`
	RebalanceTimeout time.Duration `yaml:"rebalance_timeout"`
	AutoOffsetReset string        `yaml:"auto_offset_reset"`
	EnableAutoCommit bool         `yaml:"enable_auto_commit"`
	FlushFrequency  time.Duration `yaml:"flush_frequency"`
	FlushMessages   int           `yaml:"flush_messages"`
	FlushBytes      int           `yaml:"flush_bytes"`
	MaxMessageBytes int           `yaml:"max_message_bytes"`
	RequiredAcks    int           `yaml:"required_cks"`
	RetryMax        int           `yaml:"retry_max"`
	RetryBackoff    time.Duration `yaml:"retry_backoff"`
}

// MessageConfig holds message-specific configuration
type MessageConfig struct {
	MaxQueueSize       int           `yaml:"max_queue_size"`
	MaxMessageSize     int           `yaml:"max_message_size"`
	MessageTTL         time.Duration `yaml:"message_ttl"`
	ProcessingTimeout  time.Duration `yaml:"processing_timeout"`
	RetryAttempts      int           `yaml:"retry_attempts"`
	RetryDelay         time.Duration `yaml:"retry_delay"`
	DeadLetterEnabled  bool          `yaml:"dead_letter_enabled"`
	DeadLetterTopic    string        `yaml:"dead_letter_topic"`
	MonitoringInterval time.Duration `yaml:"monitoring_interval"`
}

// SecurityConfig holds security specific configuration
type SecurityConfig struct {
	EnableEncryption bool     `yaml:"enable_encryption"`
	EncryptionKey    string   `yaml:"encryption_key"`
	AllowedOrigins   []string `yaml:"allowed_origins"`
	RateLimitRequests int     `yaml:"rate_limit_requests"`
	RateLimitWindow  time.Duration `yaml:"rate_limit_window"`
	IPWhitelist      []string `yaml:"ip_whitelist"`
	UserAuthRequired bool     `yaml:"user_auth_required"`
	TokenExpiration  time.Duration `yaml:"token_expiration"`
}

// Load loads configuration from environment variables with message-queue defaults
func Load() *Config {
	cfg := &Config{
		Server: ServerConfig{
			Port:         getEnv("MESSAGE_QUEUE_PORT", "8087"),
			ReadTimeout:  getDurationEnv("MESSAGE_QUEUE_READ_TIMEOUT", 30*time.Second),
			WriteTimeout: getDurationEnv("MESSAGE_QUEUE_WRITE_TIMEOUT", 30*time.Second),
			IdleTimeout:  getDurationEnv("MESSAGE_QUEUE_IDLE_TIMEOUT", 120*time.Second),
		},
		Database: DatabaseConfig{
			Host:            getEnv("DB_HOST", "localhost"),
			Port:            getIntEnv("DB_PORT", 5432),
			User:            getEnv("DB_USER", "postgres"),
			Password:        getEnv("DB_PASSWORD", "postgres"),
			Database:        getEnv("DB_NAME", "necpgame"),
			SSLMode:         getEnv("DB_SSL_MODE", "disable"),
			MaxOpenConns:    getIntEnv("DB_MAX_OPEN_CONNS", 25),
			MaxIdleConns:    getIntEnv("DB_MAX_IDLE_CONNS", 10),
			ConnMaxLifetime: getDurationEnv("DB_CONN_MAX_LIFETIME", 30*time.Minute),
			ConnMaxIdleTime: getDurationEnv("DB_CONN_MAX_IDLE_TIME", 5*time.Minute),
		},
		Redis: RedisConfig{
			Host:         getEnv("REDIS_HOST", "localhost"),
			Port:         getIntEnv("REDIS_PORT", 6379),
			Password:     getEnv("REDIS_PASSWORD", ""),
			DB:           getIntEnv("REDIS_DB", 3), // Use DB 3 for message queue
			PoolSize:     getIntEnv("REDIS_POOL_SIZE", 25),
			MinIdleConns: getIntEnv("REDIS_MIN_IDLE_CONNS", 10),
		},
		Kafka: KafkaConfig{
			Brokers:           getStringSliceEnv("KAFKA_BROKERS", []string{"localhost:9092"}),
			ClientID:          getEnv("KAFKA_CLIENT_ID", "message-queue-service"),
			GroupID:           getEnv("KAFKA_GROUP_ID", "message-queue-group"),
			SessionTimeout:    getDurationEnv("KAFKA_SESSION_TIMEOUT", 10*time.Second),
			HeartbeatInterval: getDurationEnv("KAFKA_HEARTBEAT_INTERVAL", 3*time.Second),
			RebalanceTimeout:  getDurationEnv("KAFKA_REBALANCE_TIMEOUT", 60*time.Second),
			AutoOffsetReset:   getEnv("KAFKA_AUTO_OFFSET_RESET", "latest"),
			EnableAutoCommit:  getBoolEnv("KAFKA_ENABLE_AUTO_COMMIT", true),
			FlushFrequency:    getDurationEnv("KAFKA_FLUSH_FREQUENCY", 500*time.Millisecond),
			FlushMessages:     getIntEnv("KAFKA_FLUSH_MESSAGES", 100),
			FlushBytes:        getIntEnv("KAFKA_FLUSH_BYTES", 1048576), // 1MB
			MaxMessageBytes:   getIntEnv("KAFKA_MAX_MESSAGE_BYTES", 1048576), // 1MB
			RequiredAcks:      getIntEnv("KAFKA_REQUIRED_ACKS", 1),
			RetryMax:          getIntEnv("KAFKA_RETRY_MAX", 3),
			RetryBackoff:      getDurationEnv("KAFKA_RETRY_BACKOFF", 100*time.Millisecond),
		},
		Message: MessageConfig{
			MaxQueueSize:       getIntEnv("MESSAGE_QUEUE_MAX_SIZE", 10000),
			MaxMessageSize:     getIntEnv("MESSAGE_QUEUE_MAX_MESSAGE_SIZE", 1048576), // 1MB
			MessageTTL:         getDurationEnv("MESSAGE_QUEUE_TTL", 24*time.Hour),
			ProcessingTimeout:  getDurationEnv("MESSAGE_QUEUE_PROCESSING_TIMEOUT", 30*time.Second),
			RetryAttempts:      getIntEnv("MESSAGE_QUEUE_RETRY_ATTEMPTS", 3),
			RetryDelay:         getDurationEnv("MESSAGE_QUEUE_RETRY_DELAY", 5*time.Second),
			DeadLetterEnabled:  getBoolEnv("MESSAGE_QUEUE_DEAD_LETTER_ENABLED", true),
			DeadLetterTopic:    getEnv("MESSAGE_QUEUE_DEAD_LETTER_TOPIC", "dead-letter-queue"),
			MonitoringInterval: getDurationEnv("MESSAGE_QUEUE_MONITORING_INTERVAL", 10*time.Second),
		},
		Security: SecurityConfig{
			EnableEncryption: getBoolEnv("MESSAGE_QUEUE_ENCRYPTION_ENABLED", true),
			EncryptionKey:    getEnv("MESSAGE_QUEUE_ENCRYPTION_KEY", ""),
			AllowedOrigins:   getStringSliceEnv("MESSAGE_QUEUE_ALLOWED_ORIGINS", []string{"*"}),
			RateLimitRequests: getIntEnv("MESSAGE_QUEUE_RATE_LIMIT_REQUESTS", 1000),
			RateLimitWindow:  getDurationEnv("MESSAGE_QUEUE_RATE_LIMIT_WINDOW", time.Minute),
			IPWhitelist:      getStringSliceEnv("MESSAGE_QUEUE_IP_WHITELIST", []string{}),
			UserAuthRequired: getBoolEnv("MESSAGE_QUEUE_USER_AUTH_REQUIRED", true),
			TokenExpiration:  getDurationEnv("MESSAGE_QUEUE_TOKEN_EXPIRATION", 24*time.Hour),
		},
	}

	return cfg
}

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getIntEnv(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getBoolEnv(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}

func getStringSliceEnv(key string, defaultValue []string) []string {
	if value := os.Getenv(key); value != "" {
		return strings.Split(value, ",")
	}
	return defaultValue
}