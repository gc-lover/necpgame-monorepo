// Code generated by NECPGAME backend agent. Kafka message producer.
// PERFORMANCE: Optimized for high-throughput message production

package service

import (
	"context"
	"time"

	"github.com/segmentio/kafka-go"
	"go.uber.org/zap"

	"necpgame/services/message-queue-service-go/internal/models"
)

// KafkaProducer implements the Producer interface using Kafka
type KafkaProducer struct {
	writer *kafka.Writer
	logger *zap.Logger
}

// NewKafkaProducer creates a new Kafka producer
func NewKafkaProducer(writer *kafka.Writer, logger *zap.Logger) *KafkaProducer {
	return &KafkaProducer{
		writer: writer,
		logger: logger,
	}
}

// Produce sends messages to Kafka
func (p *KafkaProducer) Produce(ctx context.Context, messages []*models.Message) error {
	kafkaMessages := make([]kafka.Message, len(messages))

	for i, msg := range messages {
		kafkaMessages[i] = kafka.Message{
			Topic: msg.Topic,
			Key:   []byte(msg.Key),
			Value: msg.Content,
			Time:  msg.Timestamp,
			Headers: []kafka.Header{
				{Key: "message_id", Value: []byte(msg.MessageID)},
				{Key: "producer_id", Value: []byte(msg.ProducerID)},
				{Key: "source", Value: []byte(msg.Source)},
			},
		}

		// Add custom headers
		for k, v := range msg.Headers {
			kafkaMessages[i].Headers = append(kafkaMessages[i].Headers, kafka.Header{
				Key:   k,
				Value: []byte(v),
			})
		}
	}

	// Send messages to Kafka
	err := p.writer.WriteMessages(ctx, kafkaMessages...)
	if err != nil {
		p.logger.Error("Failed to write messages to Kafka",
			zap.Error(err),
			zap.Int("message_count", len(messages)))
		return err
	}

	p.logger.Info("Messages produced to Kafka",
		zap.Int("message_count", len(messages)),
		zap.String("topic", messages[0].Topic))

	return nil
}

// Close closes the Kafka producer
func (p *KafkaProducer) Close() error {
	p.logger.Info("Closing Kafka producer")
	return p.writer.Close()
}