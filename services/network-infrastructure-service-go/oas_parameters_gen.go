// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddStreamParticipantParams is parameters of addStreamParticipant operation.
type AddStreamParticipantParams struct {
	// Audio stream unique identifier.
	StreamID uuid.UUID
}

func unpackAddStreamParticipantParams(packed middleware.Parameters) (params AddStreamParticipantParams) {
	{
		key := middleware.ParameterKey{
			Name: "stream_id",
			In:   "path",
		}
		params.StreamID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeAddStreamParticipantParams(args [1]string, argsEscaped bool, r *http.Request) (params AddStreamParticipantParams, _ error) {
	// Decode path: stream_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "stream_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.StreamID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "stream_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CloseAudioStreamParams is parameters of closeAudioStream operation.
type CloseAudioStreamParams struct {
	// Audio stream unique identifier.
	StreamID uuid.UUID
}

func unpackCloseAudioStreamParams(packed middleware.Parameters) (params CloseAudioStreamParams) {
	{
		key := middleware.ParameterKey{
			Name: "stream_id",
			In:   "path",
		}
		params.StreamID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeCloseAudioStreamParams(args [1]string, argsEscaped bool, r *http.Request) (params CloseAudioStreamParams, _ error) {
	// Decode path: stream_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "stream_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.StreamID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "stream_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CloseConnectionParams is parameters of closeConnection operation.
type CloseConnectionParams struct {
	// Connection unique identifier.
	ConnectionID uuid.UUID
}

func unpackCloseConnectionParams(packed middleware.Parameters) (params CloseConnectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "connection_id",
			In:   "path",
		}
		params.ConnectionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeCloseConnectionParams(args [1]string, argsEscaped bool, r *http.Request) (params CloseConnectionParams, _ error) {
	// Decode path: connection_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connection_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ConnectionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connection_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// EstablishWebSocketParams is parameters of establishWebSocket operation.
type EstablishWebSocketParams struct {
	// Communication protocol type.
	Protocol OptEstablishWebSocketProtocol `json:",omitempty,omitzero"`
	// Message compression method.
	Compression OptEstablishWebSocketCompression `json:",omitempty,omitzero"`
}

func unpackEstablishWebSocketParams(packed middleware.Parameters) (params EstablishWebSocketParams) {
	{
		key := middleware.ParameterKey{
			Name: "protocol",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Protocol = v.(OptEstablishWebSocketProtocol)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compression",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compression = v.(OptEstablishWebSocketCompression)
		}
	}
	return params
}

func decodeEstablishWebSocketParams(args [0]string, argsEscaped bool, r *http.Request) (params EstablishWebSocketParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: protocol.
	{
		val := EstablishWebSocketProtocol("game-events")
		params.Protocol.SetTo(val)
	}
	// Decode query: protocol.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protocol",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtocolVal EstablishWebSocketProtocol
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProtocolVal = EstablishWebSocketProtocol(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Protocol.SetTo(paramsDotProtocolVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Protocol.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "protocol",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compression.
	{
		val := EstablishWebSocketCompression("gzip")
		params.Compression.SetTo(val)
	}
	// Decode query: compression.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compression",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompressionVal EstablishWebSocketCompression
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCompressionVal = EstablishWebSocketCompression(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Compression.SetTo(paramsDotCompressionVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Compression.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compression",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAudioStreamParams is parameters of getAudioStream operation.
type GetAudioStreamParams struct {
	// Audio stream unique identifier.
	StreamID uuid.UUID
}

func unpackGetAudioStreamParams(packed middleware.Parameters) (params GetAudioStreamParams) {
	{
		key := middleware.ParameterKey{
			Name: "stream_id",
			In:   "path",
		}
		params.StreamID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetAudioStreamParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAudioStreamParams, _ error) {
	// Decode path: stream_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "stream_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.StreamID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "stream_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectionParams is parameters of getConnection operation.
type GetConnectionParams struct {
	// Connection unique identifier.
	ConnectionID uuid.UUID
}

func unpackGetConnectionParams(packed middleware.Parameters) (params GetConnectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "connection_id",
			In:   "path",
		}
		params.ConnectionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetConnectionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetConnectionParams, _ error) {
	// Decode path: connection_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connection_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ConnectionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connection_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectionAnalysisParams is parameters of getConnectionAnalysis operation.
type GetConnectionAnalysisParams struct {
	// Filter by geographic region.
	Region OptString `json:",omitempty,omitzero"`
	// Protocol type filter.
	Protocol OptGetConnectionAnalysisProtocol `json:",omitempty,omitzero"`
	// Analysis timeframe.
	Timeframe OptGetConnectionAnalysisTimeframe `json:",omitempty,omitzero"`
}

func unpackGetConnectionAnalysisParams(packed middleware.Parameters) (params GetConnectionAnalysisParams) {
	{
		key := middleware.ParameterKey{
			Name: "region",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Region = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "protocol",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Protocol = v.(OptGetConnectionAnalysisProtocol)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeframe",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timeframe = v.(OptGetConnectionAnalysisTimeframe)
		}
	}
	return params
}

func decodeGetConnectionAnalysisParams(args [0]string, argsEscaped bool, r *http.Request) (params GetConnectionAnalysisParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: region.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRegionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRegionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Region.SetTo(paramsDotRegionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "region",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: protocol.
	{
		val := GetConnectionAnalysisProtocol("all")
		params.Protocol.SetTo(val)
	}
	// Decode query: protocol.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protocol",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtocolVal GetConnectionAnalysisProtocol
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProtocolVal = GetConnectionAnalysisProtocol(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Protocol.SetTo(paramsDotProtocolVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Protocol.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "protocol",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: timeframe.
	{
		val := GetConnectionAnalysisTimeframe("24h")
		params.Timeframe.SetTo(val)
	}
	// Decode query: timeframe.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeframe",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeframeVal GetConnectionAnalysisTimeframe
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTimeframeVal = GetConnectionAnalysisTimeframe(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Timeframe.SetTo(paramsDotTimeframeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timeframe.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeframe",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetHealthParams is parameters of getHealth operation.
type GetHealthParams struct {
	AcceptEncoding OptGetHealthAcceptEncoding `json:",omitempty,omitzero"`
}

func unpackGetHealthParams(packed middleware.Parameters) (params GetHealthParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Encoding",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptEncoding = v.(OptGetHealthAcceptEncoding)
		}
	}
	return params
}

func decodeGetHealthParams(args [0]string, argsEscaped bool, r *http.Request) (params GetHealthParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: Accept-Encoding.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptEncodingVal GetHealthAcceptEncoding
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptEncodingVal = GetHealthAcceptEncoding(c)
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptEncoding.SetTo(paramsDotAcceptEncodingVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.AcceptEncoding.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Encoding",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworkTrafficParams is parameters of getNetworkTraffic operation.
type GetNetworkTrafficParams struct {
	// Analysis timeframe.
	Timeframe OptGetNetworkTrafficTimeframe `json:",omitempty,omitzero"`
	// Data granularity.
	Granularity OptGetNetworkTrafficGranularity `json:",omitempty,omitzero"`
	// Specific metric to analyze.
	Metric OptGetNetworkTrafficMetric `json:",omitempty,omitzero"`
}

func unpackGetNetworkTrafficParams(packed middleware.Parameters) (params GetNetworkTrafficParams) {
	{
		key := middleware.ParameterKey{
			Name: "timeframe",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timeframe = v.(OptGetNetworkTrafficTimeframe)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "granularity",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Granularity = v.(OptGetNetworkTrafficGranularity)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "metric",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Metric = v.(OptGetNetworkTrafficMetric)
		}
	}
	return params
}

func decodeGetNetworkTrafficParams(args [0]string, argsEscaped bool, r *http.Request) (params GetNetworkTrafficParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: timeframe.
	{
		val := GetNetworkTrafficTimeframe("1h")
		params.Timeframe.SetTo(val)
	}
	// Decode query: timeframe.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeframe",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeframeVal GetNetworkTrafficTimeframe
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTimeframeVal = GetNetworkTrafficTimeframe(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Timeframe.SetTo(paramsDotTimeframeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timeframe.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeframe",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: granularity.
	{
		val := GetNetworkTrafficGranularity("minute")
		params.Granularity.SetTo(val)
	}
	// Decode query: granularity.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "granularity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotGranularityVal GetNetworkTrafficGranularity
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotGranularityVal = GetNetworkTrafficGranularity(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Granularity.SetTo(paramsDotGranularityVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Granularity.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "granularity",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: metric.
	{
		val := GetNetworkTrafficMetric("all")
		params.Metric.SetTo(val)
	}
	// Decode query: metric.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "metric",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMetricVal GetNetworkTrafficMetric
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMetricVal = GetNetworkTrafficMetric(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Metric.SetTo(paramsDotMetricVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Metric.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "metric",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRoutingAnalysisParams is parameters of getRoutingAnalysis operation.
type GetRoutingAnalysisParams struct {
	// Route type filter.
	RouteType OptGetRoutingAnalysisRouteType `json:",omitempty,omitzero"`
	// Analysis timeframe.
	Timeframe OptGetRoutingAnalysisTimeframe `json:",omitempty,omitzero"`
}

func unpackGetRoutingAnalysisParams(packed middleware.Parameters) (params GetRoutingAnalysisParams) {
	{
		key := middleware.ParameterKey{
			Name: "route_type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.RouteType = v.(OptGetRoutingAnalysisRouteType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeframe",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timeframe = v.(OptGetRoutingAnalysisTimeframe)
		}
	}
	return params
}

func decodeGetRoutingAnalysisParams(args [0]string, argsEscaped bool, r *http.Request) (params GetRoutingAnalysisParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: route_type.
	{
		val := GetRoutingAnalysisRouteType("all")
		params.RouteType.SetTo(val)
	}
	// Decode query: route_type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "route_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRouteTypeVal GetRoutingAnalysisRouteType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRouteTypeVal = GetRoutingAnalysisRouteType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.RouteType.SetTo(paramsDotRouteTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.RouteType.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "route_type",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: timeframe.
	{
		val := GetRoutingAnalysisTimeframe("1h")
		params.Timeframe.SetTo(val)
	}
	// Decode query: timeframe.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeframe",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeframeVal GetRoutingAnalysisTimeframe
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTimeframeVal = GetRoutingAnalysisTimeframe(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Timeframe.SetTo(paramsDotTimeframeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timeframe.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeframe",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAudioStreamsParams is parameters of listAudioStreams operation.
type ListAudioStreamsParams struct {
	// Filter by stream type.
	Type OptListAudioStreamsType `json:",omitempty,omitzero"`
	// Filter by stream status.
	Status OptListAudioStreamsStatus `json:",omitempty,omitzero"`
}

func unpackListAudioStreamsParams(packed middleware.Parameters) (params ListAudioStreamsParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptListAudioStreamsType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptListAudioStreamsStatus)
		}
	}
	return params
}

func decodeListAudioStreamsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAudioStreamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: type.
	{
		val := ListAudioStreamsType("all")
		params.Type.SetTo(val)
	}
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ListAudioStreamsType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ListAudioStreamsType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Type.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: status.
	{
		val := ListAudioStreamsStatus("active")
		params.Status.SetTo(val)
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ListAudioStreamsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ListAudioStreamsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListConnectionsParams is parameters of listConnections operation.
type ListConnectionsParams struct {
	// Filter by connection status.
	Status OptListConnectionsStatus `json:",omitempty,omitzero"`
	// Filter by protocol type.
	Protocol OptListConnectionsProtocol `json:",omitempty,omitzero"`
	// Maximum number of connections to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackListConnectionsParams(packed middleware.Parameters) (params ListConnectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptListConnectionsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "protocol",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Protocol = v.(OptListConnectionsProtocol)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListConnectionsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListConnectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: status.
	{
		val := ListConnectionsStatus("active")
		params.Status.SetTo(val)
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ListConnectionsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ListConnectionsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: protocol.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protocol",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtocolVal ListConnectionsProtocol
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProtocolVal = ListConnectionsProtocol(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Protocol.SetTo(paramsDotProtocolVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Protocol.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "protocol",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListStreamParticipantsParams is parameters of listStreamParticipants operation.
type ListStreamParticipantsParams struct {
	// Audio stream unique identifier.
	StreamID uuid.UUID
}

func unpackListStreamParticipantsParams(packed middleware.Parameters) (params ListStreamParticipantsParams) {
	{
		key := middleware.ParameterKey{
			Name: "stream_id",
			In:   "path",
		}
		params.StreamID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeListStreamParticipantsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListStreamParticipantsParams, _ error) {
	// Decode path: stream_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "stream_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.StreamID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "stream_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SubscribeConnectionParams is parameters of subscribeConnection operation.
type SubscribeConnectionParams struct {
	// Connection unique identifier.
	ConnectionID uuid.UUID
}

func unpackSubscribeConnectionParams(packed middleware.Parameters) (params SubscribeConnectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "connection_id",
			In:   "path",
		}
		params.ConnectionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeSubscribeConnectionParams(args [1]string, argsEscaped bool, r *http.Request) (params SubscribeConnectionParams, _ error) {
	// Decode path: connection_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connection_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ConnectionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connection_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UnsubscribeConnectionParams is parameters of unsubscribeConnection operation.
type UnsubscribeConnectionParams struct {
	// Connection unique identifier.
	ConnectionID uuid.UUID
}

func unpackUnsubscribeConnectionParams(packed middleware.Parameters) (params UnsubscribeConnectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "connection_id",
			In:   "path",
		}
		params.ConnectionID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeUnsubscribeConnectionParams(args [1]string, argsEscaped bool, r *http.Request) (params UnsubscribeConnectionParams, _ error) {
	// Decode path: connection_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connection_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ConnectionID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connection_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
