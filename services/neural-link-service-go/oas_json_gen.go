// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthAssessmentBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthAssessmentBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthAssessmentBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes BatchNeuralHealthAssessmentBadRequest from json.
func (s *BatchNeuralHealthAssessmentBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthAssessmentBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BatchNeuralHealthAssessmentBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthAssessmentBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthAssessmentBadRequest) {
					name = jsonFieldsNameOfBatchNeuralHealthAssessmentBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthAssessmentBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthAssessmentBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthAssessmentBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthAssessmentBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBatchNeuralHealthAssessmentBadRequestDetails = [0]string{}

// Decode decodes BatchNeuralHealthAssessmentBadRequestDetails from json.
func (s *BatchNeuralHealthAssessmentBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthAssessmentBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthAssessmentBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthAssessmentBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthAssessmentBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthAssessmentTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthAssessmentTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes BatchNeuralHealthAssessmentTooManyRequests from json.
func (s *BatchNeuralHealthAssessmentTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthAssessmentTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem BatchNeuralHealthAssessmentTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthAssessmentTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthAssessmentTooManyRequests) {
					name = jsonFieldsNameOfBatchNeuralHealthAssessmentTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthAssessmentTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBatchNeuralHealthAssessmentTooManyRequestsDetails = [0]string{}

// Decode decodes BatchNeuralHealthAssessmentTooManyRequestsDetails from json.
func (s *BatchNeuralHealthAssessmentTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthAssessmentTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthAssessmentTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthAssessmentTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_ids")
		e.ArrStart()
		for _, elem := range s.LinkIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.AssessmentType.Set {
			e.FieldStart("assessment_type")
			s.AssessmentType.Encode(e)
		}
	}
	{
		if s.IncludePredictions.Set {
			e.FieldStart("include_predictions")
			s.IncludePredictions.Encode(e)
		}
	}
	{
		if s.PriorityOrder != nil {
			e.FieldStart("priority_order")
			e.ArrStart()
			for _, elem := range s.PriorityOrder {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthRequest = [4]string{
	0: "link_ids",
	1: "assessment_type",
	2: "include_predictions",
	3: "priority_order",
}

// Decode decodes BatchNeuralHealthRequest from json.
func (s *BatchNeuralHealthRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.LinkIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.LinkIds = append(s.LinkIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_ids\"")
			}
		case "assessment_type":
			if err := func() error {
				s.AssessmentType.Reset()
				if err := s.AssessmentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessment_type\"")
			}
		case "include_predictions":
			if err := func() error {
				s.IncludePredictions.Reset()
				if err := s.IncludePredictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_predictions\"")
			}
		case "priority_order":
			if err := func() error {
				s.PriorityOrder = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PriorityOrder = append(s.PriorityOrder, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority_order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthRequest) {
					name = jsonFieldsNameOfBatchNeuralHealthRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthRequestAssessmentType as json.
func (s BatchNeuralHealthRequestAssessmentType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchNeuralHealthRequestAssessmentType from json.
func (s *BatchNeuralHealthRequestAssessmentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthRequestAssessmentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchNeuralHealthRequestAssessmentType(v) {
	case BatchNeuralHealthRequestAssessmentTypeQUICK:
		*s = BatchNeuralHealthRequestAssessmentTypeQUICK
	case BatchNeuralHealthRequestAssessmentTypeCOMPREHENSIVE:
		*s = BatchNeuralHealthRequestAssessmentTypeCOMPREHENSIVE
	default:
		*s = BatchNeuralHealthRequestAssessmentType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchNeuralHealthRequestAssessmentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthRequestAssessmentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assessment_id")
		json.EncodeUUID(e, s.AssessmentID)
	}
	{
		e.FieldStart("links_assessed")
		e.Int(s.LinksAssessed)
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SummaryStatistics.Set {
			e.FieldStart("summary_statistics")
			s.SummaryStatistics.Encode(e)
		}
	}
	{
		if s.CriticalFindings != nil {
			e.FieldStart("critical_findings")
			e.ArrStart()
			for _, elem := range s.CriticalFindings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthResult = [5]string{
	0: "assessment_id",
	1: "links_assessed",
	2: "results",
	3: "summary_statistics",
	4: "critical_findings",
}

// Decode decodes BatchNeuralHealthResult from json.
func (s *BatchNeuralHealthResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assessment_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AssessmentID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessment_id\"")
			}
		case "links_assessed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.LinksAssessed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links_assessed\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Results = make([]BatchNeuralHealthResultResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchNeuralHealthResultResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "summary_statistics":
			if err := func() error {
				s.SummaryStatistics.Reset()
				if err := s.SummaryStatistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary_statistics\"")
			}
		case "critical_findings":
			if err := func() error {
				s.CriticalFindings = make([]BatchNeuralHealthResultCriticalFindingsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchNeuralHealthResultCriticalFindingsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CriticalFindings = append(s.CriticalFindings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_findings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthResult) {
					name = jsonFieldsNameOfBatchNeuralHealthResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthResultCriticalFindingsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthResultCriticalFindingsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("finding_type")
		s.FindingType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfBatchNeuralHealthResultCriticalFindingsItem = [4]string{
	0: "link_id",
	1: "finding_type",
	2: "severity",
	3: "description",
}

// Decode decodes BatchNeuralHealthResultCriticalFindingsItem from json.
func (s *BatchNeuralHealthResultCriticalFindingsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultCriticalFindingsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "finding_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FindingType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finding_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthResultCriticalFindingsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthResultCriticalFindingsItem) {
					name = jsonFieldsNameOfBatchNeuralHealthResultCriticalFindingsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthResultCriticalFindingsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultCriticalFindingsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthResultCriticalFindingsItemFindingType as json.
func (s BatchNeuralHealthResultCriticalFindingsItemFindingType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchNeuralHealthResultCriticalFindingsItemFindingType from json.
func (s *BatchNeuralHealthResultCriticalFindingsItemFindingType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultCriticalFindingsItemFindingType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchNeuralHealthResultCriticalFindingsItemFindingType(v) {
	case BatchNeuralHealthResultCriticalFindingsItemFindingTypeNEURALDEGRADATION:
		*s = BatchNeuralHealthResultCriticalFindingsItemFindingTypeNEURALDEGRADATION
	case BatchNeuralHealthResultCriticalFindingsItemFindingTypeSYNCFAILURE:
		*s = BatchNeuralHealthResultCriticalFindingsItemFindingTypeSYNCFAILURE
	case BatchNeuralHealthResultCriticalFindingsItemFindingTypeIMPLANTCONFLICT:
		*s = BatchNeuralHealthResultCriticalFindingsItemFindingTypeIMPLANTCONFLICT
	case BatchNeuralHealthResultCriticalFindingsItemFindingTypeFIRMWAREISSUE:
		*s = BatchNeuralHealthResultCriticalFindingsItemFindingTypeFIRMWAREISSUE
	default:
		*s = BatchNeuralHealthResultCriticalFindingsItemFindingType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchNeuralHealthResultCriticalFindingsItemFindingType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultCriticalFindingsItemFindingType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthResultCriticalFindingsItemSeverity as json.
func (s BatchNeuralHealthResultCriticalFindingsItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchNeuralHealthResultCriticalFindingsItemSeverity from json.
func (s *BatchNeuralHealthResultCriticalFindingsItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultCriticalFindingsItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchNeuralHealthResultCriticalFindingsItemSeverity(v) {
	case BatchNeuralHealthResultCriticalFindingsItemSeverityLOW:
		*s = BatchNeuralHealthResultCriticalFindingsItemSeverityLOW
	case BatchNeuralHealthResultCriticalFindingsItemSeverityMEDIUM:
		*s = BatchNeuralHealthResultCriticalFindingsItemSeverityMEDIUM
	case BatchNeuralHealthResultCriticalFindingsItemSeverityHIGH:
		*s = BatchNeuralHealthResultCriticalFindingsItemSeverityHIGH
	case BatchNeuralHealthResultCriticalFindingsItemSeverityCRITICAL:
		*s = BatchNeuralHealthResultCriticalFindingsItemSeverityCRITICAL
	default:
		*s = BatchNeuralHealthResultCriticalFindingsItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchNeuralHealthResultCriticalFindingsItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultCriticalFindingsItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthResultResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthResultResultsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("health_status")
		s.HealthStatus.Encode(e)
	}
	{
		e.FieldStart("sync_quality")
		e.Float32(s.SyncQuality)
	}
	{
		e.FieldStart("neural_health")
		e.Float32(s.NeuralHealth)
	}
	{
		if s.CriticalIssues != nil {
			e.FieldStart("critical_issues")
			e.ArrStart()
			for _, elem := range s.CriticalIssues {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthResultResultsItem = [5]string{
	0: "link_id",
	1: "health_status",
	2: "sync_quality",
	3: "neural_health",
	4: "critical_issues",
}

// Decode decodes BatchNeuralHealthResultResultsItem from json.
func (s *BatchNeuralHealthResultResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultResultsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "health_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HealthStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_status\"")
			}
		case "sync_quality":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.SyncQuality = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_quality\"")
			}
		case "neural_health":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.NeuralHealth = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_health\"")
			}
		case "critical_issues":
			if err := func() error {
				s.CriticalIssues = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CriticalIssues = append(s.CriticalIssues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_issues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthResultResultsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchNeuralHealthResultResultsItem) {
					name = jsonFieldsNameOfBatchNeuralHealthResultResultsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthResultResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthResultResultsItemHealthStatus as json.
func (s BatchNeuralHealthResultResultsItemHealthStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchNeuralHealthResultResultsItemHealthStatus from json.
func (s *BatchNeuralHealthResultResultsItemHealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultResultsItemHealthStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchNeuralHealthResultResultsItemHealthStatus(v) {
	case BatchNeuralHealthResultResultsItemHealthStatusHEALTHY:
		*s = BatchNeuralHealthResultResultsItemHealthStatusHEALTHY
	case BatchNeuralHealthResultResultsItemHealthStatusWARNING:
		*s = BatchNeuralHealthResultResultsItemHealthStatusWARNING
	case BatchNeuralHealthResultResultsItemHealthStatusCRITICAL:
		*s = BatchNeuralHealthResultResultsItemHealthStatusCRITICAL
	case BatchNeuralHealthResultResultsItemHealthStatusUNKNOWN:
		*s = BatchNeuralHealthResultResultsItemHealthStatusUNKNOWN
	default:
		*s = BatchNeuralHealthResultResultsItemHealthStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchNeuralHealthResultResultsItemHealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultResultsItemHealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchNeuralHealthResultSummaryStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchNeuralHealthResultSummaryStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.HealthyLinks.Set {
			e.FieldStart("healthy_links")
			s.HealthyLinks.Encode(e)
		}
	}
	{
		if s.WarningLinks.Set {
			e.FieldStart("warning_links")
			s.WarningLinks.Encode(e)
		}
	}
	{
		if s.CriticalLinks.Set {
			e.FieldStart("critical_links")
			s.CriticalLinks.Encode(e)
		}
	}
	{
		if s.AverageSyncQuality.Set {
			e.FieldStart("average_sync_quality")
			s.AverageSyncQuality.Encode(e)
		}
	}
	{
		if s.AverageNeuralHealth.Set {
			e.FieldStart("average_neural_health")
			s.AverageNeuralHealth.Encode(e)
		}
	}
	{
		if s.AssessmentDurationMs.Set {
			e.FieldStart("assessment_duration_ms")
			s.AssessmentDurationMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchNeuralHealthResultSummaryStatistics = [6]string{
	0: "healthy_links",
	1: "warning_links",
	2: "critical_links",
	3: "average_sync_quality",
	4: "average_neural_health",
	5: "assessment_duration_ms",
}

// Decode decodes BatchNeuralHealthResultSummaryStatistics from json.
func (s *BatchNeuralHealthResultSummaryStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchNeuralHealthResultSummaryStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "healthy_links":
			if err := func() error {
				s.HealthyLinks.Reset()
				if err := s.HealthyLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthy_links\"")
			}
		case "warning_links":
			if err := func() error {
				s.WarningLinks.Reset()
				if err := s.WarningLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warning_links\"")
			}
		case "critical_links":
			if err := func() error {
				s.CriticalLinks.Reset()
				if err := s.CriticalLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_links\"")
			}
		case "average_sync_quality":
			if err := func() error {
				s.AverageSyncQuality.Reset()
				if err := s.AverageSyncQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_sync_quality\"")
			}
		case "average_neural_health":
			if err := func() error {
				s.AverageNeuralHealth.Reset()
				if err := s.AverageNeuralHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_neural_health\"")
			}
		case "assessment_duration_ms":
			if err := func() error {
				s.AssessmentDurationMs.Reset()
				if err := s.AssessmentDurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessment_duration_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchNeuralHealthResultSummaryStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchNeuralHealthResultSummaryStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchNeuralHealthResultSummaryStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCalibrateNeuralLinkBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CalibrateNeuralLinkBadRequest from json.
func (s *CalibrateNeuralLinkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CalibrateNeuralLinkBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCalibrateNeuralLinkBadRequest) {
					name = jsonFieldsNameOfCalibrateNeuralLinkBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCalibrateNeuralLinkBadRequestDetails = [0]string{}

// Decode decodes CalibrateNeuralLinkBadRequestDetails from json.
func (s *CalibrateNeuralLinkBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCalibrateNeuralLinkConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CalibrateNeuralLinkConflict from json.
func (s *CalibrateNeuralLinkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CalibrateNeuralLinkConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCalibrateNeuralLinkConflict) {
					name = jsonFieldsNameOfCalibrateNeuralLinkConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCalibrateNeuralLinkConflictDetails = [0]string{}

// Decode decodes CalibrateNeuralLinkConflictDetails from json.
func (s *CalibrateNeuralLinkConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkRequest) encodeFields(e *jx.Encoder) {
	{
		if s.CalibrationType.Set {
			e.FieldStart("calibration_type")
			s.CalibrationType.Encode(e)
		}
	}
	{
		if s.TargetSyncQuality.Set {
			e.FieldStart("target_sync_quality")
			s.TargetSyncQuality.Encode(e)
		}
	}
	{
		if s.OptimizeFor != nil {
			e.FieldStart("optimize_for")
			e.ArrStart()
			for _, elem := range s.OptimizeFor {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NeuralStressTolerance.Set {
			e.FieldStart("neural_stress_tolerance")
			s.NeuralStressTolerance.Encode(e)
		}
	}
	{
		if s.IncludePathwayMapping.Set {
			e.FieldStart("include_pathway_mapping")
			s.IncludePathwayMapping.Encode(e)
		}
	}
	{
		if s.CustomParameters.Set {
			e.FieldStart("custom_parameters")
			s.CustomParameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfCalibrateNeuralLinkRequest = [6]string{
	0: "calibration_type",
	1: "target_sync_quality",
	2: "optimize_for",
	3: "neural_stress_tolerance",
	4: "include_pathway_mapping",
	5: "custom_parameters",
}

// Decode decodes CalibrateNeuralLinkRequest from json.
func (s *CalibrateNeuralLinkRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "calibration_type":
			if err := func() error {
				s.CalibrationType.Reset()
				if err := s.CalibrationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calibration_type\"")
			}
		case "target_sync_quality":
			if err := func() error {
				s.TargetSyncQuality.Reset()
				if err := s.TargetSyncQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_sync_quality\"")
			}
		case "optimize_for":
			if err := func() error {
				s.OptimizeFor = make([]CalibrateNeuralLinkRequestOptimizeForItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CalibrateNeuralLinkRequestOptimizeForItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OptimizeFor = append(s.OptimizeFor, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimize_for\"")
			}
		case "neural_stress_tolerance":
			if err := func() error {
				s.NeuralStressTolerance.Reset()
				if err := s.NeuralStressTolerance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_stress_tolerance\"")
			}
		case "include_pathway_mapping":
			if err := func() error {
				s.IncludePathwayMapping.Reset()
				if err := s.IncludePathwayMapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_pathway_mapping\"")
			}
		case "custom_parameters":
			if err := func() error {
				s.CustomParameters.Reset()
				if err := s.CustomParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalibrateNeuralLinkRequestCalibrationType as json.
func (s CalibrateNeuralLinkRequestCalibrationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CalibrateNeuralLinkRequestCalibrationType from json.
func (s *CalibrateNeuralLinkRequestCalibrationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkRequestCalibrationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CalibrateNeuralLinkRequestCalibrationType(v) {
	case CalibrateNeuralLinkRequestCalibrationTypeQUICK:
		*s = CalibrateNeuralLinkRequestCalibrationTypeQUICK
	case CalibrateNeuralLinkRequestCalibrationTypeSTANDARD:
		*s = CalibrateNeuralLinkRequestCalibrationTypeSTANDARD
	case CalibrateNeuralLinkRequestCalibrationTypeDEEP:
		*s = CalibrateNeuralLinkRequestCalibrationTypeDEEP
	case CalibrateNeuralLinkRequestCalibrationTypeCUSTOM:
		*s = CalibrateNeuralLinkRequestCalibrationTypeCUSTOM
	default:
		*s = CalibrateNeuralLinkRequestCalibrationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CalibrateNeuralLinkRequestCalibrationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkRequestCalibrationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CalibrateNeuralLinkRequestCustomParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CalibrateNeuralLinkRequestCustomParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CalibrateNeuralLinkRequestCustomParameters from json.
func (s *CalibrateNeuralLinkRequestCustomParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkRequestCustomParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkRequestCustomParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CalibrateNeuralLinkRequestCustomParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkRequestCustomParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalibrateNeuralLinkRequestOptimizeForItem as json.
func (s CalibrateNeuralLinkRequestOptimizeForItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CalibrateNeuralLinkRequestOptimizeForItem from json.
func (s *CalibrateNeuralLinkRequestOptimizeForItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkRequestOptimizeForItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CalibrateNeuralLinkRequestOptimizeForItem(v) {
	case CalibrateNeuralLinkRequestOptimizeForItemSPEED:
		*s = CalibrateNeuralLinkRequestOptimizeForItemSPEED
	case CalibrateNeuralLinkRequestOptimizeForItemACCURACY:
		*s = CalibrateNeuralLinkRequestOptimizeForItemACCURACY
	case CalibrateNeuralLinkRequestOptimizeForItemSTABILITY:
		*s = CalibrateNeuralLinkRequestOptimizeForItemSTABILITY
	case CalibrateNeuralLinkRequestOptimizeForItemLOWLATENCY:
		*s = CalibrateNeuralLinkRequestOptimizeForItemLOWLATENCY
	case CalibrateNeuralLinkRequestOptimizeForItemHIGHBANDWIDTH:
		*s = CalibrateNeuralLinkRequestOptimizeForItemHIGHBANDWIDTH
	default:
		*s = CalibrateNeuralLinkRequestOptimizeForItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CalibrateNeuralLinkRequestOptimizeForItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkRequestOptimizeForItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCalibrateNeuralLinkTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CalibrateNeuralLinkTooManyRequests from json.
func (s *CalibrateNeuralLinkTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CalibrateNeuralLinkTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCalibrateNeuralLinkTooManyRequests) {
					name = jsonFieldsNameOfCalibrateNeuralLinkTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CalibrateNeuralLinkTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CalibrateNeuralLinkTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCalibrateNeuralLinkTooManyRequestsDetails = [0]string{}

// Decode decodes CalibrateNeuralLinkTooManyRequestsDetails from json.
func (s *CalibrateNeuralLinkTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CalibrateNeuralLinkTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CalibrateNeuralLinkTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CalibrateNeuralLinkTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CalibrateNeuralLinkTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkDiagnosticsConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkDiagnosticsConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNeuralLinkDiagnosticsConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNeuralLinkDiagnosticsConflict from json.
func (s *GetNeuralLinkDiagnosticsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkDiagnosticsConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNeuralLinkDiagnosticsConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkDiagnosticsConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNeuralLinkDiagnosticsConflict) {
					name = jsonFieldsNameOfGetNeuralLinkDiagnosticsConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkDiagnosticsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkDiagnosticsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkDiagnosticsConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkDiagnosticsConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNeuralLinkDiagnosticsConflictDetails = [0]string{}

// Decode decodes GetNeuralLinkDiagnosticsConflictDetails from json.
func (s *GetNeuralLinkDiagnosticsConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkDiagnosticsConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkDiagnosticsConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkDiagnosticsConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkDiagnosticsConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkDiagnosticsNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkDiagnosticsNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNeuralLinkDiagnosticsNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNeuralLinkDiagnosticsNotFound from json.
func (s *GetNeuralLinkDiagnosticsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkDiagnosticsNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNeuralLinkDiagnosticsNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkDiagnosticsNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNeuralLinkDiagnosticsNotFound) {
					name = jsonFieldsNameOfGetNeuralLinkDiagnosticsNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkDiagnosticsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkDiagnosticsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkDiagnosticsNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkDiagnosticsNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNeuralLinkDiagnosticsNotFoundDetails = [0]string{}

// Decode decodes GetNeuralLinkDiagnosticsNotFoundDetails from json.
func (s *GetNeuralLinkDiagnosticsNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkDiagnosticsNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkDiagnosticsNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkDiagnosticsNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkDiagnosticsNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNeuralLinkNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNeuralLinkNotFound from json.
func (s *GetNeuralLinkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNeuralLinkNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNeuralLinkNotFound) {
					name = jsonFieldsNameOfGetNeuralLinkNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNeuralLinkNotFoundDetails = [0]string{}

// Decode decodes GetNeuralLinkNotFoundDetails from json.
func (s *GetNeuralLinkNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetNeuralLinkTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetNeuralLinkTooManyRequests from json.
func (s *GetNeuralLinkTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetNeuralLinkTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNeuralLinkTooManyRequests) {
					name = jsonFieldsNameOfGetNeuralLinkTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNeuralLinkTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNeuralLinkTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetNeuralLinkTooManyRequestsDetails = [0]string{}

// Decode decodes GetNeuralLinkTooManyRequestsDetails from json.
func (s *GetNeuralLinkTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNeuralLinkTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetNeuralLinkTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNeuralLinkTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNeuralLinkTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstallNeuralLinkBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InstallNeuralLinkBadRequest from json.
func (s *InstallNeuralLinkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InstallNeuralLinkBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallNeuralLinkBadRequest) {
					name = jsonFieldsNameOfInstallNeuralLinkBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInstallNeuralLinkBadRequestDetails = [0]string{}

// Decode decodes InstallNeuralLinkBadRequestDetails from json.
func (s *InstallNeuralLinkBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstallNeuralLinkConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InstallNeuralLinkConflict from json.
func (s *InstallNeuralLinkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InstallNeuralLinkConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallNeuralLinkConflict) {
					name = jsonFieldsNameOfInstallNeuralLinkConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInstallNeuralLinkConflictDetails = [0]string{}

// Decode decodes InstallNeuralLinkConflictDetails from json.
func (s *InstallNeuralLinkConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("implant_type")
		s.ImplantType.Encode(e)
	}
	{
		e.FieldStart("neural_interface_model")
		s.NeuralInterfaceModel.Encode(e)
	}
	{
		if s.FirmwareVersion.Set {
			e.FieldStart("firmware_version")
			s.FirmwareVersion.Encode(e)
		}
	}
	{
		if s.SecurityClearance.Set {
			e.FieldStart("security_clearance")
			s.SecurityClearance.Encode(e)
		}
	}
	{
		if s.RiskAssessmentOverride.Set {
			e.FieldStart("risk_assessment_override")
			s.RiskAssessmentOverride.Encode(e)
		}
	}
	{
		if s.PostInstallationMonitoring.Set {
			e.FieldStart("post_installation_monitoring")
			s.PostInstallationMonitoring.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstallNeuralLinkRequest = [7]string{
	0: "player_id",
	1: "implant_type",
	2: "neural_interface_model",
	3: "firmware_version",
	4: "security_clearance",
	5: "risk_assessment_override",
	6: "post_installation_monitoring",
}

// Decode decodes InstallNeuralLinkRequest from json.
func (s *InstallNeuralLinkRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "implant_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ImplantType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_type\"")
			}
		case "neural_interface_model":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.NeuralInterfaceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_interface_model\"")
			}
		case "firmware_version":
			if err := func() error {
				s.FirmwareVersion.Reset()
				if err := s.FirmwareVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firmware_version\"")
			}
		case "security_clearance":
			if err := func() error {
				s.SecurityClearance.Reset()
				if err := s.SecurityClearance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_clearance\"")
			}
		case "risk_assessment_override":
			if err := func() error {
				s.RiskAssessmentOverride.Reset()
				if err := s.RiskAssessmentOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_assessment_override\"")
			}
		case "post_installation_monitoring":
			if err := func() error {
				s.PostInstallationMonitoring.Reset()
				if err := s.PostInstallationMonitoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_installation_monitoring\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallNeuralLinkRequest) {
					name = jsonFieldsNameOfInstallNeuralLinkRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallNeuralLinkRequestImplantType as json.
func (s InstallNeuralLinkRequestImplantType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstallNeuralLinkRequestImplantType from json.
func (s *InstallNeuralLinkRequestImplantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkRequestImplantType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallNeuralLinkRequestImplantType(v) {
	case InstallNeuralLinkRequestImplantTypeSURGICAL:
		*s = InstallNeuralLinkRequestImplantTypeSURGICAL
	case InstallNeuralLinkRequestImplantTypeNONSURGICAL:
		*s = InstallNeuralLinkRequestImplantTypeNONSURGICAL
	case InstallNeuralLinkRequestImplantTypeHYBRID:
		*s = InstallNeuralLinkRequestImplantTypeHYBRID
	default:
		*s = InstallNeuralLinkRequestImplantType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstallNeuralLinkRequestImplantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkRequestImplantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallNeuralLinkRequestNeuralInterfaceModel as json.
func (s InstallNeuralLinkRequestNeuralInterfaceModel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstallNeuralLinkRequestNeuralInterfaceModel from json.
func (s *InstallNeuralLinkRequestNeuralInterfaceModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkRequestNeuralInterfaceModel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallNeuralLinkRequestNeuralInterfaceModel(v) {
	case InstallNeuralLinkRequestNeuralInterfaceModelBASICCHROME:
		*s = InstallNeuralLinkRequestNeuralInterfaceModelBASICCHROME
	case InstallNeuralLinkRequestNeuralInterfaceModelMILITECHPARASITE:
		*s = InstallNeuralLinkRequestNeuralInterfaceModelMILITECHPARASITE
	case InstallNeuralLinkRequestNeuralInterfaceModelARASAKASYNTHLINK:
		*s = InstallNeuralLinkRequestNeuralInterfaceModelARASAKASYNTHLINK
	case InstallNeuralLinkRequestNeuralInterfaceModelTRAUMATEAMNEURALWEB:
		*s = InstallNeuralLinkRequestNeuralInterfaceModelTRAUMATEAMNEURALWEB
	case InstallNeuralLinkRequestNeuralInterfaceModelDYNAMITENEUROPEPTIDE:
		*s = InstallNeuralLinkRequestNeuralInterfaceModelDYNAMITENEUROPEPTIDE
	default:
		*s = InstallNeuralLinkRequestNeuralInterfaceModel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstallNeuralLinkRequestNeuralInterfaceModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkRequestNeuralInterfaceModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallNeuralLinkRequestSecurityClearance as json.
func (s InstallNeuralLinkRequestSecurityClearance) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstallNeuralLinkRequestSecurityClearance from json.
func (s *InstallNeuralLinkRequestSecurityClearance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkRequestSecurityClearance to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallNeuralLinkRequestSecurityClearance(v) {
	case InstallNeuralLinkRequestSecurityClearanceBASIC:
		*s = InstallNeuralLinkRequestSecurityClearanceBASIC
	case InstallNeuralLinkRequestSecurityClearanceSTANDARD:
		*s = InstallNeuralLinkRequestSecurityClearanceSTANDARD
	case InstallNeuralLinkRequestSecurityClearanceELEVATED:
		*s = InstallNeuralLinkRequestSecurityClearanceELEVATED
	default:
		*s = InstallNeuralLinkRequestSecurityClearance(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstallNeuralLinkRequestSecurityClearance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkRequestSecurityClearance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstallNeuralLinkTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InstallNeuralLinkTooManyRequests from json.
func (s *InstallNeuralLinkTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InstallNeuralLinkTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallNeuralLinkTooManyRequests) {
					name = jsonFieldsNameOfInstallNeuralLinkTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInstallNeuralLinkTooManyRequestsDetails = [0]string{}

// Decode decodes InstallNeuralLinkTooManyRequestsDetails from json.
func (s *InstallNeuralLinkTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkUnprocessableEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstallNeuralLinkUnprocessableEntity = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InstallNeuralLinkUnprocessableEntity from json.
func (s *InstallNeuralLinkUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkUnprocessableEntity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InstallNeuralLinkUnprocessableEntityDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkUnprocessableEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallNeuralLinkUnprocessableEntity) {
					name = jsonFieldsNameOfInstallNeuralLinkUnprocessableEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallNeuralLinkUnprocessableEntityDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallNeuralLinkUnprocessableEntityDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInstallNeuralLinkUnprocessableEntityDetails = [0]string{}

// Decode decodes InstallNeuralLinkUnprocessableEntityDetails from json.
func (s *InstallNeuralLinkUnprocessableEntityDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallNeuralLinkUnprocessableEntityDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InstallNeuralLinkUnprocessableEntityDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallNeuralLinkUnprocessableEntityDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallNeuralLinkUnprocessableEntityDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListNeuralLinksBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListNeuralLinksBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfListNeuralLinksBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ListNeuralLinksBadRequest from json.
func (s *ListNeuralLinksBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListNeuralLinksBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ListNeuralLinksBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListNeuralLinksBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListNeuralLinksBadRequest) {
					name = jsonFieldsNameOfListNeuralLinksBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListNeuralLinksBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListNeuralLinksBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListNeuralLinksBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListNeuralLinksBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfListNeuralLinksBadRequestDetails = [0]string{}

// Decode decodes ListNeuralLinksBadRequestDetails from json.
func (s *ListNeuralLinksBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListNeuralLinksBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ListNeuralLinksBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListNeuralLinksBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListNeuralLinksBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListNeuralLinksTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListNeuralLinksTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfListNeuralLinksTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ListNeuralLinksTooManyRequests from json.
func (s *ListNeuralLinksTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListNeuralLinksTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ListNeuralLinksTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListNeuralLinksTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListNeuralLinksTooManyRequests) {
					name = jsonFieldsNameOfListNeuralLinksTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListNeuralLinksTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListNeuralLinksTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListNeuralLinksTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListNeuralLinksTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfListNeuralLinksTooManyRequestsDetails = [0]string{}

// Decode decodes ListNeuralLinksTooManyRequestsDetails from json.
func (s *ListNeuralLinksTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListNeuralLinksTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ListNeuralLinksTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListNeuralLinksTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListNeuralLinksTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralCalibrationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralCalibrationResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("calibration_status")
		s.CalibrationStatus.Encode(e)
	}
	{
		e.FieldStart("performance_improvements")
		s.PerformanceImprovements.Encode(e)
	}
	{
		if s.PathwaysMapped.Set {
			e.FieldStart("pathways_mapped")
			s.PathwaysMapped.Encode(e)
		}
	}
	{
		if s.CalibrationDurationSeconds.Set {
			e.FieldStart("calibration_duration_seconds")
			s.CalibrationDurationSeconds.Encode(e)
		}
	}
	{
		if s.NeuralStressInduced.Set {
			e.FieldStart("neural_stress_induced")
			s.NeuralStressInduced.Encode(e)
		}
	}
	{
		if s.PathwayHealthChanges.Set {
			e.FieldStart("pathway_health_changes")
			s.PathwayHealthChanges.Encode(e)
		}
	}
	{
		if s.OptimizationAchieved != nil {
			e.FieldStart("optimization_achieved")
			e.ArrStart()
			for _, elem := range s.OptimizationAchieved {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextCalibrationRecommended.Set {
			e.FieldStart("next_calibration_recommended")
			s.NextCalibrationRecommended.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CalibrationWarnings != nil {
			e.FieldStart("calibration_warnings")
			e.ArrStart()
			for _, elem := range s.CalibrationWarnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralCalibrationResult = [10]string{
	0: "link_id",
	1: "calibration_status",
	2: "performance_improvements",
	3: "pathways_mapped",
	4: "calibration_duration_seconds",
	5: "neural_stress_induced",
	6: "pathway_health_changes",
	7: "optimization_achieved",
	8: "next_calibration_recommended",
	9: "calibration_warnings",
}

// Decode decodes NeuralCalibrationResult from json.
func (s *NeuralCalibrationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralCalibrationResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "calibration_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CalibrationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calibration_status\"")
			}
		case "performance_improvements":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PerformanceImprovements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_improvements\"")
			}
		case "pathways_mapped":
			if err := func() error {
				s.PathwaysMapped.Reset()
				if err := s.PathwaysMapped.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathways_mapped\"")
			}
		case "calibration_duration_seconds":
			if err := func() error {
				s.CalibrationDurationSeconds.Reset()
				if err := s.CalibrationDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calibration_duration_seconds\"")
			}
		case "neural_stress_induced":
			if err := func() error {
				s.NeuralStressInduced.Reset()
				if err := s.NeuralStressInduced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_stress_induced\"")
			}
		case "pathway_health_changes":
			if err := func() error {
				s.PathwayHealthChanges.Reset()
				if err := s.PathwayHealthChanges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathway_health_changes\"")
			}
		case "optimization_achieved":
			if err := func() error {
				s.OptimizationAchieved = make([]NeuralCalibrationResultOptimizationAchievedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralCalibrationResultOptimizationAchievedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OptimizationAchieved = append(s.OptimizationAchieved, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_achieved\"")
			}
		case "next_calibration_recommended":
			if err := func() error {
				s.NextCalibrationRecommended.Reset()
				if err := s.NextCalibrationRecommended.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_calibration_recommended\"")
			}
		case "calibration_warnings":
			if err := func() error {
				s.CalibrationWarnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CalibrationWarnings = append(s.CalibrationWarnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calibration_warnings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralCalibrationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralCalibrationResult) {
					name = jsonFieldsNameOfNeuralCalibrationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralCalibrationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralCalibrationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralCalibrationResultCalibrationStatus as json.
func (s NeuralCalibrationResultCalibrationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralCalibrationResultCalibrationStatus from json.
func (s *NeuralCalibrationResultCalibrationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralCalibrationResultCalibrationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralCalibrationResultCalibrationStatus(v) {
	case NeuralCalibrationResultCalibrationStatusSUCCESS:
		*s = NeuralCalibrationResultCalibrationStatusSUCCESS
	case NeuralCalibrationResultCalibrationStatusPARTIALSUCCESS:
		*s = NeuralCalibrationResultCalibrationStatusPARTIALSUCCESS
	case NeuralCalibrationResultCalibrationStatusFAILED:
		*s = NeuralCalibrationResultCalibrationStatusFAILED
	case NeuralCalibrationResultCalibrationStatusREQUIRESMAINTENANCE:
		*s = NeuralCalibrationResultCalibrationStatusREQUIRESMAINTENANCE
	default:
		*s = NeuralCalibrationResultCalibrationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralCalibrationResultCalibrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralCalibrationResultCalibrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralCalibrationResultOptimizationAchievedItem as json.
func (s NeuralCalibrationResultOptimizationAchievedItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralCalibrationResultOptimizationAchievedItem from json.
func (s *NeuralCalibrationResultOptimizationAchievedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralCalibrationResultOptimizationAchievedItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralCalibrationResultOptimizationAchievedItem(v) {
	case NeuralCalibrationResultOptimizationAchievedItemSPEEDOPTIMIZED:
		*s = NeuralCalibrationResultOptimizationAchievedItemSPEEDOPTIMIZED
	case NeuralCalibrationResultOptimizationAchievedItemACCURACYOPTIMIZED:
		*s = NeuralCalibrationResultOptimizationAchievedItemACCURACYOPTIMIZED
	case NeuralCalibrationResultOptimizationAchievedItemSTABILITYOPTIMIZED:
		*s = NeuralCalibrationResultOptimizationAchievedItemSTABILITYOPTIMIZED
	case NeuralCalibrationResultOptimizationAchievedItemLATENCYOPTIMIZED:
		*s = NeuralCalibrationResultOptimizationAchievedItemLATENCYOPTIMIZED
	case NeuralCalibrationResultOptimizationAchievedItemBANDWIDTHOPTIMIZED:
		*s = NeuralCalibrationResultOptimizationAchievedItemBANDWIDTHOPTIMIZED
	default:
		*s = NeuralCalibrationResultOptimizationAchievedItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralCalibrationResultOptimizationAchievedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralCalibrationResultOptimizationAchievedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NeuralCalibrationResultPathwayHealthChanges) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NeuralCalibrationResultPathwayHealthChanges) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float32(elem)
	}
}

// Decode decodes NeuralCalibrationResultPathwayHealthChanges from json.
func (s *NeuralCalibrationResultPathwayHealthChanges) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralCalibrationResultPathwayHealthChanges to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float32
		if err := func() error {
			v, err := d.Float32()
			elem = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralCalibrationResultPathwayHealthChanges")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralCalibrationResultPathwayHealthChanges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralCalibrationResultPathwayHealthChanges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralCalibrationResultPerformanceImprovements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralCalibrationResultPerformanceImprovements) encodeFields(e *jx.Encoder) {
	{
		if s.SyncQualityImprovement.Set {
			e.FieldStart("sync_quality_improvement")
			s.SyncQualityImprovement.Encode(e)
		}
	}
	{
		if s.LatencyReductionMs.Set {
			e.FieldStart("latency_reduction_ms")
			s.LatencyReductionMs.Encode(e)
		}
	}
	{
		if s.BandwidthOptimization.Set {
			e.FieldStart("bandwidth_optimization")
			s.BandwidthOptimization.Encode(e)
		}
	}
	{
		if s.SignalStabilityImprovement.Set {
			e.FieldStart("signal_stability_improvement")
			s.SignalStabilityImprovement.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralCalibrationResultPerformanceImprovements = [4]string{
	0: "sync_quality_improvement",
	1: "latency_reduction_ms",
	2: "bandwidth_optimization",
	3: "signal_stability_improvement",
}

// Decode decodes NeuralCalibrationResultPerformanceImprovements from json.
func (s *NeuralCalibrationResultPerformanceImprovements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralCalibrationResultPerformanceImprovements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sync_quality_improvement":
			if err := func() error {
				s.SyncQualityImprovement.Reset()
				if err := s.SyncQualityImprovement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_quality_improvement\"")
			}
		case "latency_reduction_ms":
			if err := func() error {
				s.LatencyReductionMs.Reset()
				if err := s.LatencyReductionMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_reduction_ms\"")
			}
		case "bandwidth_optimization":
			if err := func() error {
				s.BandwidthOptimization.Reset()
				if err := s.BandwidthOptimization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_optimization\"")
			}
		case "signal_stability_improvement":
			if err := func() error {
				s.SignalStabilityImprovement.Reset()
				if err := s.SignalStabilityImprovement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_stability_improvement\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralCalibrationResultPerformanceImprovements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralCalibrationResultPerformanceImprovements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralCalibrationResultPerformanceImprovements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralFirmwareUpdateResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralFirmwareUpdateResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("update_id")
		json.EncodeUUID(e, s.UpdateID)
	}
	{
		e.FieldStart("overall_status")
		s.OverallStatus.Encode(e)
	}
	{
		e.FieldStart("links_updated")
		e.Int(s.LinksUpdated)
	}
	{
		if s.TargetVersion.Set {
			e.FieldStart("target_version")
			s.TargetVersion.Encode(e)
		}
	}
	{
		if s.UpdateDurationSeconds.Set {
			e.FieldStart("update_duration_seconds")
			s.UpdateDurationSeconds.Encode(e)
		}
	}
	{
		if s.IndividualResults != nil {
			e.FieldStart("individual_results")
			e.ArrStart()
			for _, elem := range s.IndividualResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PerformanceImpact.Set {
			e.FieldStart("performance_impact")
			s.PerformanceImpact.Encode(e)
		}
	}
	{
		if s.RollbackInformation.Set {
			e.FieldStart("rollback_information")
			s.RollbackInformation.Encode(e)
		}
	}
	{
		if s.NextUpdateRecommended.Set {
			e.FieldStart("next_update_recommended")
			s.NextUpdateRecommended.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfNeuralFirmwareUpdateResult = [9]string{
	0: "update_id",
	1: "overall_status",
	2: "links_updated",
	3: "target_version",
	4: "update_duration_seconds",
	5: "individual_results",
	6: "performance_impact",
	7: "rollback_information",
	8: "next_update_recommended",
}

// Decode decodes NeuralFirmwareUpdateResult from json.
func (s *NeuralFirmwareUpdateResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UpdateID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_id\"")
			}
		case "overall_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.OverallStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overall_status\"")
			}
		case "links_updated":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.LinksUpdated = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links_updated\"")
			}
		case "target_version":
			if err := func() error {
				s.TargetVersion.Reset()
				if err := s.TargetVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_version\"")
			}
		case "update_duration_seconds":
			if err := func() error {
				s.UpdateDurationSeconds.Reset()
				if err := s.UpdateDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_duration_seconds\"")
			}
		case "individual_results":
			if err := func() error {
				s.IndividualResults = make([]NeuralFirmwareUpdateResultIndividualResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralFirmwareUpdateResultIndividualResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IndividualResults = append(s.IndividualResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"individual_results\"")
			}
		case "performance_impact":
			if err := func() error {
				s.PerformanceImpact.Reset()
				if err := s.PerformanceImpact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_impact\"")
			}
		case "rollback_information":
			if err := func() error {
				s.RollbackInformation.Reset()
				if err := s.RollbackInformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_information\"")
			}
		case "next_update_recommended":
			if err := func() error {
				s.NextUpdateRecommended.Reset()
				if err := s.NextUpdateRecommended.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_update_recommended\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralFirmwareUpdateResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralFirmwareUpdateResult) {
					name = jsonFieldsNameOfNeuralFirmwareUpdateResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralFirmwareUpdateResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralFirmwareUpdateResultIndividualResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralFirmwareUpdateResultIndividualResultsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("update_status")
		s.UpdateStatus.Encode(e)
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.RollbackReason.Set {
			e.FieldStart("rollback_reason")
			s.RollbackReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralFirmwareUpdateResultIndividualResultsItem = [4]string{
	0: "link_id",
	1: "update_status",
	2: "error_message",
	3: "rollback_reason",
}

// Decode decodes NeuralFirmwareUpdateResultIndividualResultsItem from json.
func (s *NeuralFirmwareUpdateResultIndividualResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResultIndividualResultsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "update_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.UpdateStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_status\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "rollback_reason":
			if err := func() error {
				s.RollbackReason.Reset()
				if err := s.RollbackReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralFirmwareUpdateResultIndividualResultsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralFirmwareUpdateResultIndividualResultsItem) {
					name = jsonFieldsNameOfNeuralFirmwareUpdateResultIndividualResultsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralFirmwareUpdateResultIndividualResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResultIndividualResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus as json.
func (s NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus from json.
func (s *NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus(v) {
	case NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusSUCCESS:
		*s = NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusSUCCESS
	case NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusFAILED:
		*s = NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusFAILED
	case NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusROLLEDBACK:
		*s = NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusROLLEDBACK
	case NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusSKIPPED:
		*s = NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatusSKIPPED
	default:
		*s = NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResultIndividualResultsItemUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralFirmwareUpdateResultOverallStatus as json.
func (s NeuralFirmwareUpdateResultOverallStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralFirmwareUpdateResultOverallStatus from json.
func (s *NeuralFirmwareUpdateResultOverallStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResultOverallStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralFirmwareUpdateResultOverallStatus(v) {
	case NeuralFirmwareUpdateResultOverallStatusSUCCESS:
		*s = NeuralFirmwareUpdateResultOverallStatusSUCCESS
	case NeuralFirmwareUpdateResultOverallStatusPARTIALSUCCESS:
		*s = NeuralFirmwareUpdateResultOverallStatusPARTIALSUCCESS
	case NeuralFirmwareUpdateResultOverallStatusFAILED:
		*s = NeuralFirmwareUpdateResultOverallStatusFAILED
	case NeuralFirmwareUpdateResultOverallStatusROLLEDBACK:
		*s = NeuralFirmwareUpdateResultOverallStatusROLLEDBACK
	default:
		*s = NeuralFirmwareUpdateResultOverallStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralFirmwareUpdateResultOverallStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResultOverallStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralFirmwareUpdateResultPerformanceImpact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralFirmwareUpdateResultPerformanceImpact) encodeFields(e *jx.Encoder) {
	{
		if s.AverageSyncImprovement.Set {
			e.FieldStart("average_sync_improvement")
			s.AverageSyncImprovement.Encode(e)
		}
	}
	{
		if s.AverageLatencyReduction.Set {
			e.FieldStart("average_latency_reduction")
			s.AverageLatencyReduction.Encode(e)
		}
	}
	{
		if s.NewFeaturesEnabled != nil {
			e.FieldStart("new_features_enabled")
			e.ArrStart()
			for _, elem := range s.NewFeaturesEnabled {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KnownIssuesResolved != nil {
			e.FieldStart("known_issues_resolved")
			e.ArrStart()
			for _, elem := range s.KnownIssuesResolved {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralFirmwareUpdateResultPerformanceImpact = [4]string{
	0: "average_sync_improvement",
	1: "average_latency_reduction",
	2: "new_features_enabled",
	3: "known_issues_resolved",
}

// Decode decodes NeuralFirmwareUpdateResultPerformanceImpact from json.
func (s *NeuralFirmwareUpdateResultPerformanceImpact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResultPerformanceImpact to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "average_sync_improvement":
			if err := func() error {
				s.AverageSyncImprovement.Reset()
				if err := s.AverageSyncImprovement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_sync_improvement\"")
			}
		case "average_latency_reduction":
			if err := func() error {
				s.AverageLatencyReduction.Reset()
				if err := s.AverageLatencyReduction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_latency_reduction\"")
			}
		case "new_features_enabled":
			if err := func() error {
				s.NewFeaturesEnabled = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NewFeaturesEnabled = append(s.NewFeaturesEnabled, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_features_enabled\"")
			}
		case "known_issues_resolved":
			if err := func() error {
				s.KnownIssuesResolved = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.KnownIssuesResolved = append(s.KnownIssuesResolved, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"known_issues_resolved\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralFirmwareUpdateResultPerformanceImpact")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralFirmwareUpdateResultPerformanceImpact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResultPerformanceImpact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralFirmwareUpdateResultRollbackInformation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralFirmwareUpdateResultRollbackInformation) encodeFields(e *jx.Encoder) {
	{
		if s.RollbackTriggered.Set {
			e.FieldStart("rollback_triggered")
			s.RollbackTriggered.Encode(e)
		}
	}
	{
		if s.RollbackReason.Set {
			e.FieldStart("rollback_reason")
			s.RollbackReason.Encode(e)
		}
	}
	{
		if s.LinksRolledBack.Set {
			e.FieldStart("links_rolled_back")
			s.LinksRolledBack.Encode(e)
		}
	}
	{
		if s.RollbackDurationSeconds.Set {
			e.FieldStart("rollback_duration_seconds")
			s.RollbackDurationSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralFirmwareUpdateResultRollbackInformation = [4]string{
	0: "rollback_triggered",
	1: "rollback_reason",
	2: "links_rolled_back",
	3: "rollback_duration_seconds",
}

// Decode decodes NeuralFirmwareUpdateResultRollbackInformation from json.
func (s *NeuralFirmwareUpdateResultRollbackInformation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralFirmwareUpdateResultRollbackInformation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollback_triggered":
			if err := func() error {
				s.RollbackTriggered.Reset()
				if err := s.RollbackTriggered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_triggered\"")
			}
		case "rollback_reason":
			if err := func() error {
				s.RollbackReason.Reset()
				if err := s.RollbackReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_reason\"")
			}
		case "links_rolled_back":
			if err := func() error {
				s.LinksRolledBack.Reset()
				if err := s.LinksRolledBack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links_rolled_back\"")
			}
		case "rollback_duration_seconds":
			if err := func() error {
				s.RollbackDurationSeconds.Reset()
				if err := s.RollbackDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_duration_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralFirmwareUpdateResultRollbackInformation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralFirmwareUpdateResultRollbackInformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralFirmwareUpdateResultRollbackInformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnostics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnostics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("diagnostic_timestamp")
		json.EncodeDateTime(e, s.DiagnosticTimestamp)
	}
	{
		e.FieldStart("overall_health_score")
		e.Float32(s.OverallHealthScore)
	}
	{
		if s.SyncQualityAssessment.Set {
			e.FieldStart("sync_quality_assessment")
			s.SyncQualityAssessment.Encode(e)
		}
	}
	{
		if s.NeuralPathwayAnalysis != nil {
			e.FieldStart("neural_pathway_analysis")
			e.ArrStart()
			for _, elem := range s.NeuralPathwayAnalysis {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImplantIntegrationStatus.Set {
			e.FieldStart("implant_integration_status")
			s.ImplantIntegrationStatus.Encode(e)
		}
	}
	{
		if s.CyberpsychosisIndicators.Set {
			e.FieldStart("cyberpsychosis_indicators")
			s.CyberpsychosisIndicators.Encode(e)
		}
	}
	{
		if s.PerformanceMetrics.Set {
			e.FieldStart("performance_metrics")
			s.PerformanceMetrics.Encode(e)
		}
	}
	{
		if s.PredictiveAnalysis.Set {
			e.FieldStart("predictive_analysis")
			s.PredictiveAnalysis.Encode(e)
		}
	}
	{
		if s.MaintenanceRecommendations != nil {
			e.FieldStart("maintenance_recommendations")
			e.ArrStart()
			for _, elem := range s.MaintenanceRecommendations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HistoricalTrends.Set {
			e.FieldStart("historical_trends")
			s.HistoricalTrends.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnostics = [11]string{
	0:  "link_id",
	1:  "diagnostic_timestamp",
	2:  "overall_health_score",
	3:  "sync_quality_assessment",
	4:  "neural_pathway_analysis",
	5:  "implant_integration_status",
	6:  "cyberpsychosis_indicators",
	7:  "performance_metrics",
	8:  "predictive_analysis",
	9:  "maintenance_recommendations",
	10: "historical_trends",
}

// Decode decodes NeuralLinkDiagnostics from json.
func (s *NeuralLinkDiagnostics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnostics to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "diagnostic_timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DiagnosticTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_timestamp\"")
			}
		case "overall_health_score":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.OverallHealthScore = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overall_health_score\"")
			}
		case "sync_quality_assessment":
			if err := func() error {
				s.SyncQualityAssessment.Reset()
				if err := s.SyncQualityAssessment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_quality_assessment\"")
			}
		case "neural_pathway_analysis":
			if err := func() error {
				s.NeuralPathwayAnalysis = make([]NeuralPathwayEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralPathwayEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NeuralPathwayAnalysis = append(s.NeuralPathwayAnalysis, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_pathway_analysis\"")
			}
		case "implant_integration_status":
			if err := func() error {
				s.ImplantIntegrationStatus.Reset()
				if err := s.ImplantIntegrationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implant_integration_status\"")
			}
		case "cyberpsychosis_indicators":
			if err := func() error {
				s.CyberpsychosisIndicators.Reset()
				if err := s.CyberpsychosisIndicators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpsychosis_indicators\"")
			}
		case "performance_metrics":
			if err := func() error {
				s.PerformanceMetrics.Reset()
				if err := s.PerformanceMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_metrics\"")
			}
		case "predictive_analysis":
			if err := func() error {
				s.PredictiveAnalysis.Reset()
				if err := s.PredictiveAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"predictive_analysis\"")
			}
		case "maintenance_recommendations":
			if err := func() error {
				s.MaintenanceRecommendations = make([]NeuralLinkDiagnosticsMaintenanceRecommendationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralLinkDiagnosticsMaintenanceRecommendationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MaintenanceRecommendations = append(s.MaintenanceRecommendations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_recommendations\"")
			}
		case "historical_trends":
			if err := func() error {
				s.HistoricalTrends.Reset()
				if err := s.HistoricalTrends.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"historical_trends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnostics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDiagnostics) {
					name = jsonFieldsNameOfNeuralLinkDiagnostics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnostics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnostics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicators) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentRiskLevel.Set {
			e.FieldStart("current_risk_level")
			s.CurrentRiskLevel.Encode(e)
		}
	}
	{
		if s.RiskFactors != nil {
			e.FieldStart("risk_factors")
			e.ArrStart()
			for _, elem := range s.RiskFactors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MitigationSuggestions != nil {
			e.FieldStart("mitigation_suggestions")
			e.ArrStart()
			for _, elem := range s.MitigationSuggestions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsCyberpsychosisIndicators = [3]string{
	0: "current_risk_level",
	1: "risk_factors",
	2: "mitigation_suggestions",
}

// Decode decodes NeuralLinkDiagnosticsCyberpsychosisIndicators from json.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsCyberpsychosisIndicators to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_risk_level":
			if err := func() error {
				s.CurrentRiskLevel.Reset()
				if err := s.CurrentRiskLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_risk_level\"")
			}
		case "risk_factors":
			if err := func() error {
				s.RiskFactors = make([]NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RiskFactors = append(s.RiskFactors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_factors\"")
			}
		case "mitigation_suggestions":
			if err := func() error {
				s.MitigationSuggestions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MitigationSuggestions = append(s.MitigationSuggestions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitigation_suggestions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsCyberpsychosisIndicators")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel as json.
func (s NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel from json.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel(v) {
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelLOW:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelLOW
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelMEDIUM:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelMEDIUM
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelHIGH:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelHIGH
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelCRITICAL:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevelCRITICAL
	default:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem as json.
func (s NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem from json.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem(v) {
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemHIGHIMPLANTCOUNT:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemHIGHIMPLANTCOUNT
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemRAPIDADAPTATION:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemRAPIDADAPTATION
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemNEURALOVERLOAD:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemNEURALOVERLOAD
	case NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemEMOTIONALSUPPRESSION:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItemEMOTIONALSUPPRESSION
	default:
		*s = NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsCyberpsychosisIndicatorsRiskFactorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NeuralLinkDiagnosticsHistoricalTrends) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NeuralLinkDiagnosticsHistoricalTrends) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes NeuralLinkDiagnosticsHistoricalTrends from json.
func (s *NeuralLinkDiagnosticsHistoricalTrends) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsHistoricalTrends to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsHistoricalTrends")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsHistoricalTrends) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsHistoricalTrends) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NeuralLinkDiagnosticsImplantIntegrationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NeuralLinkDiagnosticsImplantIntegrationStatus) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes NeuralLinkDiagnosticsImplantIntegrationStatus from json.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsImplantIntegrationStatus to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NeuralLinkDiagnosticsImplantIntegrationStatusItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsImplantIntegrationStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsImplantIntegrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatusItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatusItem) encodeFields(e *jx.Encoder) {
	{
		if s.IntegrationQuality.Set {
			e.FieldStart("integration_quality")
			s.IntegrationQuality.Encode(e)
		}
	}
	{
		if s.ConflictsDetected != nil {
			e.FieldStart("conflicts_detected")
			e.ArrStart()
			for _, elem := range s.ConflictsDetected {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RecommendedActions != nil {
			e.FieldStart("recommended_actions")
			e.ArrStart()
			for _, elem := range s.RecommendedActions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsImplantIntegrationStatusItem = [3]string{
	0: "integration_quality",
	1: "conflicts_detected",
	2: "recommended_actions",
}

// Decode decodes NeuralLinkDiagnosticsImplantIntegrationStatusItem from json.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatusItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsImplantIntegrationStatusItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "integration_quality":
			if err := func() error {
				s.IntegrationQuality.Reset()
				if err := s.IntegrationQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_quality\"")
			}
		case "conflicts_detected":
			if err := func() error {
				s.ConflictsDetected = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ConflictsDetected = append(s.ConflictsDetected, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conflicts_detected\"")
			}
		case "recommended_actions":
			if err := func() error {
				s.RecommendedActions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RecommendedActions = append(s.RecommendedActions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommended_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsImplantIntegrationStatusItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatusItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsImplantIntegrationStatusItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action_type")
		s.ActionType.Encode(e)
	}
	{
		e.FieldStart("priority")
		s.Priority.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.EstimatedTimeMinutes.Set {
			e.FieldStart("estimated_time_minutes")
			s.EstimatedTimeMinutes.Encode(e)
		}
	}
	{
		if s.EstimatedRisk.Set {
			e.FieldStart("estimated_risk")
			s.EstimatedRisk.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsMaintenanceRecommendationsItem = [5]string{
	0: "action_type",
	1: "priority",
	2: "description",
	3: "estimated_time_minutes",
	4: "estimated_risk",
}

// Decode decodes NeuralLinkDiagnosticsMaintenanceRecommendationsItem from json.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsMaintenanceRecommendationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "estimated_time_minutes":
			if err := func() error {
				s.EstimatedTimeMinutes.Reset()
				if err := s.EstimatedTimeMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_time_minutes\"")
			}
		case "estimated_risk":
			if err := func() error {
				s.EstimatedRisk.Reset()
				if err := s.EstimatedRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_risk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsMaintenanceRecommendationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDiagnosticsMaintenanceRecommendationsItem) {
					name = jsonFieldsNameOfNeuralLinkDiagnosticsMaintenanceRecommendationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType as json.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType from json.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType(v) {
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeCALIBRATION:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeCALIBRATION
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeFIRMWAREUPDATE:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeFIRMWAREUPDATE
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeIMPLANTCHECK:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeIMPLANTCHECK
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeNEURALTHERAPY:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeNEURALTHERAPY
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeEMERGENCYSHUTDOWN:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionTypeEMERGENCYSHUTDOWN
	default:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk as json.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk from json.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk(v) {
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskLOW:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskLOW
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskMEDIUM:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskMEDIUM
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskHIGH:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRiskHIGH
	default:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority as json.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority from json.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority(v) {
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityLOW:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityLOW
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityMEDIUM:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityMEDIUM
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityHIGH:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityHIGH
	case NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityCRITICAL:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriorityCRITICAL
	default:
		*s = NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsMaintenanceRecommendationsItemPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsPerformanceMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsPerformanceMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.AverageLatencyMs.Set {
			e.FieldStart("average_latency_ms")
			s.AverageLatencyMs.Encode(e)
		}
	}
	{
		if s.PeakBandwidthMbps.Set {
			e.FieldStart("peak_bandwidth_mbps")
			s.PeakBandwidthMbps.Encode(e)
		}
	}
	{
		if s.SignalStabilityPercentage.Set {
			e.FieldStart("signal_stability_percentage")
			s.SignalStabilityPercentage.Encode(e)
		}
	}
	{
		if s.ProcessingEfficiency.Set {
			e.FieldStart("processing_efficiency")
			s.ProcessingEfficiency.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsPerformanceMetrics = [4]string{
	0: "average_latency_ms",
	1: "peak_bandwidth_mbps",
	2: "signal_stability_percentage",
	3: "processing_efficiency",
}

// Decode decodes NeuralLinkDiagnosticsPerformanceMetrics from json.
func (s *NeuralLinkDiagnosticsPerformanceMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsPerformanceMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "average_latency_ms":
			if err := func() error {
				s.AverageLatencyMs.Reset()
				if err := s.AverageLatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_latency_ms\"")
			}
		case "peak_bandwidth_mbps":
			if err := func() error {
				s.PeakBandwidthMbps.Reset()
				if err := s.PeakBandwidthMbps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peak_bandwidth_mbps\"")
			}
		case "signal_stability_percentage":
			if err := func() error {
				s.SignalStabilityPercentage.Reset()
				if err := s.SignalStabilityPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_stability_percentage\"")
			}
		case "processing_efficiency":
			if err := func() error {
				s.ProcessingEfficiency.Reset()
				if err := s.ProcessingEfficiency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_efficiency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsPerformanceMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsPerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsPerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsPredictiveAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsPredictiveAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.HealthTrajectory30Days.Set {
			e.FieldStart("health_trajectory_30_days")
			s.HealthTrajectory30Days.Encode(e)
		}
	}
	{
		if s.RecommendedCalibrationDate.Set {
			e.FieldStart("recommended_calibration_date")
			s.RecommendedCalibrationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PotentialFailurePoints != nil {
			e.FieldStart("potential_failure_points")
			e.ArrStart()
			for _, elem := range s.PotentialFailurePoints {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsPredictiveAnalysis = [3]string{
	0: "health_trajectory_30_days",
	1: "recommended_calibration_date",
	2: "potential_failure_points",
}

// Decode decodes NeuralLinkDiagnosticsPredictiveAnalysis from json.
func (s *NeuralLinkDiagnosticsPredictiveAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsPredictiveAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_trajectory_30_days":
			if err := func() error {
				s.HealthTrajectory30Days.Reset()
				if err := s.HealthTrajectory30Days.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_trajectory_30_days\"")
			}
		case "recommended_calibration_date":
			if err := func() error {
				s.RecommendedCalibrationDate.Reset()
				if err := s.RecommendedCalibrationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommended_calibration_date\"")
			}
		case "potential_failure_points":
			if err := func() error {
				s.PotentialFailurePoints = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PotentialFailurePoints = append(s.PotentialFailurePoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"potential_failure_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsPredictiveAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsPredictiveAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsPredictiveAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days as json.
func (s NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days from json.
func (s *NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days(v) {
	case NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysSTABLE:
		*s = NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysSTABLE
	case NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysIMPROVING:
		*s = NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysIMPROVING
	case NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysDECLINING:
		*s = NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysDECLINING
	case NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysCRITICAL:
		*s = NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30DaysCRITICAL
	default:
		*s = NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDiagnosticsSyncQualityAssessment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDiagnosticsSyncQualityAssessment) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentQuality.Set {
			e.FieldStart("current_quality")
			s.CurrentQuality.Encode(e)
		}
	}
	{
		if s.QualityTrend.Set {
			e.FieldStart("quality_trend")
			s.QualityTrend.Encode(e)
		}
	}
	{
		if s.QualityVolatility.Set {
			e.FieldStart("quality_volatility")
			s.QualityVolatility.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDiagnosticsSyncQualityAssessment = [3]string{
	0: "current_quality",
	1: "quality_trend",
	2: "quality_volatility",
}

// Decode decodes NeuralLinkDiagnosticsSyncQualityAssessment from json.
func (s *NeuralLinkDiagnosticsSyncQualityAssessment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsSyncQualityAssessment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_quality":
			if err := func() error {
				s.CurrentQuality.Reset()
				if err := s.CurrentQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_quality\"")
			}
		case "quality_trend":
			if err := func() error {
				s.QualityTrend.Reset()
				if err := s.QualityTrend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality_trend\"")
			}
		case "quality_volatility":
			if err := func() error {
				s.QualityVolatility.Reset()
				if err := s.QualityVolatility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality_volatility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDiagnosticsSyncQualityAssessment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDiagnosticsSyncQualityAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsSyncQualityAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend as json.
func (s NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend from json.
func (s *NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend(v) {
	case NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendIMPROVING:
		*s = NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendIMPROVING
	case NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendSTABLE:
		*s = NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendSTABLE
	case NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendDECLINING:
		*s = NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendDECLINING
	case NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendCRITICAL:
		*s = NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrendCRITICAL
	default:
		*s = NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainBatchHealthCheckBadRequest from json.
func (s *NeuralLinkDomainBatchHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainBatchHealthCheckBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckBadRequest) {
					name = jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckBadRequestDetails = [0]string{}

// Decode decodes NeuralLinkDomainBatchHealthCheckBadRequestDetails from json.
func (s *NeuralLinkDomainBatchHealthCheckBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_time_ms")
		e.Int(s.TotalTimeMs)
	}
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckOK = [2]string{
	0: "results",
	1: "total_time_ms",
}

// Decode decodes NeuralLinkDomainBatchHealthCheckOK from json.
func (s *NeuralLinkDomainBatchHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "total_time_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalTimeMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_time_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckOK) {
					name = jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("services")
		e.ArrStart()
		for _, elem := range s.Services {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckReq = [1]string{
	0: "services",
}

// Decode decodes NeuralLinkDomainBatchHealthCheckReq from json.
func (s *NeuralLinkDomainBatchHealthCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "services":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Services = make([]NeuralLinkDomainBatchHealthCheckReqServicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralLinkDomainBatchHealthCheckReqServicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckReq) {
					name = jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDomainBatchHealthCheckReqServicesItem as json.
func (s NeuralLinkDomainBatchHealthCheckReqServicesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDomainBatchHealthCheckReqServicesItem from json.
func (s *NeuralLinkDomainBatchHealthCheckReqServicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckReqServicesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDomainBatchHealthCheckReqServicesItem(v) {
	case NeuralLinkDomainBatchHealthCheckReqServicesItemNeuralLink:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItemNeuralLink
	case NeuralLinkDomainBatchHealthCheckReqServicesItemImplant:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItemImplant
	case NeuralLinkDomainBatchHealthCheckReqServicesItemCyberspace:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItemCyberspace
	case NeuralLinkDomainBatchHealthCheckReqServicesItemCyberware:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItemCyberware
	case NeuralLinkDomainBatchHealthCheckReqServicesItemHacking:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItemHacking
	default:
		*s = NeuralLinkDomainBatchHealthCheckReqServicesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDomainBatchHealthCheckReqServicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckReqServicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainBatchHealthCheckTooManyRequests from json.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainBatchHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails from json.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainBatchHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthCheckOK = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes NeuralLinkDomainHealthCheckOK from json.
func (s *NeuralLinkDomainHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthCheckOK) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDomainHealthCheckOKStatus as json.
func (s NeuralLinkDomainHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDomainHealthCheckOKStatus from json.
func (s *NeuralLinkDomainHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDomainHealthCheckOKStatus(v) {
	case NeuralLinkDomainHealthCheckOKStatusHealthy:
		*s = NeuralLinkDomainHealthCheckOKStatusHealthy
	case NeuralLinkDomainHealthCheckOKStatusDegraded:
		*s = NeuralLinkDomainHealthCheckOKStatusDegraded
	case NeuralLinkDomainHealthCheckOKStatusUnhealthy:
		*s = NeuralLinkDomainHealthCheckOKStatusUnhealthy
	default:
		*s = NeuralLinkDomainHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDomainHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthCheckServiceUnavailable = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes NeuralLinkDomainHealthCheckServiceUnavailable from json.
func (s *NeuralLinkDomainHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckServiceUnavailable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthCheckServiceUnavailable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthCheckServiceUnavailable) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthCheckServiceUnavailable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDomainHealthCheckServiceUnavailableStatus as json.
func (s NeuralLinkDomainHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkDomainHealthCheckServiceUnavailableStatus from json.
func (s *NeuralLinkDomainHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkDomainHealthCheckServiceUnavailableStatus(v) {
	case NeuralLinkDomainHealthCheckServiceUnavailableStatusHealthy:
		*s = NeuralLinkDomainHealthCheckServiceUnavailableStatusHealthy
	case NeuralLinkDomainHealthCheckServiceUnavailableStatusDegraded:
		*s = NeuralLinkDomainHealthCheckServiceUnavailableStatusDegraded
	case NeuralLinkDomainHealthCheckServiceUnavailableStatusUnhealthy:
		*s = NeuralLinkDomainHealthCheckServiceUnavailableStatusUnhealthy
	default:
		*s = NeuralLinkDomainHealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkDomainHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthCheckTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthCheckTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainHealthCheckTooManyRequests from json.
func (s *NeuralLinkDomainHealthCheckTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainHealthCheckTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthCheckTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthCheckTooManyRequests) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthCheckTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthCheckTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainHealthCheckTooManyRequestsDetails = [0]string{}

// Decode decodes NeuralLinkDomainHealthCheckTooManyRequestsDetails from json.
func (s *NeuralLinkDomainHealthCheckTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthCheckTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthCheckTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthCheckTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainHealthWebSocketBadRequest from json.
func (s *NeuralLinkDomainHealthWebSocketBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainHealthWebSocketBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthWebSocketBadRequest) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthWebSocketBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketBadRequestDetails = [0]string{}

// Decode decodes NeuralLinkDomainHealthWebSocketBadRequestDetails from json.
func (s *NeuralLinkDomainHealthWebSocketBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketOK) encodeFields(e *jx.Encoder) {
	{
		if s.WebsocketURL.Set {
			e.FieldStart("websocket_url")
			s.WebsocketURL.Encode(e)
		}
	}
	{
		if s.SupportedProtocols != nil {
			e.FieldStart("supported_protocols")
			e.ArrStart()
			for _, elem := range s.SupportedProtocols {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketOK = [2]string{
	0: "websocket_url",
	1: "supported_protocols",
}

// Decode decodes NeuralLinkDomainHealthWebSocketOK from json.
func (s *NeuralLinkDomainHealthWebSocketOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "websocket_url":
			if err := func() error {
				s.WebsocketURL.Reset()
				if err := s.WebsocketURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"websocket_url\"")
			}
		case "supported_protocols":
			if err := func() error {
				s.SupportedProtocols = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SupportedProtocols = append(s.SupportedProtocols, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_protocols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainHealthWebSocketTooManyRequests from json.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainHealthWebSocketTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthWebSocketTooManyRequests) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthWebSocketTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketTooManyRequestsDetails = [0]string{}

// Decode decodes NeuralLinkDomainHealthWebSocketTooManyRequestsDetails from json.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes NeuralLinkDomainHealthWebSocketUnauthorized from json.
func (s *NeuralLinkDomainHealthWebSocketUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem NeuralLinkDomainHealthWebSocketUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkDomainHealthWebSocketUnauthorized) {
					name = jsonFieldsNameOfNeuralLinkDomainHealthWebSocketUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkDomainHealthWebSocketUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNeuralLinkDomainHealthWebSocketUnauthorizedDetails = [0]string{}

// Decode decodes NeuralLinkDomainHealthWebSocketUnauthorizedDetails from json.
func (s *NeuralLinkDomainHealthWebSocketUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkDomainHealthWebSocketUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkDomainHealthWebSocketUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkDomainHealthWebSocketUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("firmware_version")
		e.Str(s.FirmwareVersion)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.SyncQuality.Set {
			e.FieldStart("sync_quality")
			s.SyncQuality.Encode(e)
		}
	}
	{
		if s.NeuralHealth.Set {
			e.FieldStart("neural_health")
			s.NeuralHealth.Encode(e)
		}
	}
	{
		if s.SignalStrength.Set {
			e.FieldStart("signal_strength")
			s.SignalStrength.Encode(e)
		}
	}
	{
		if s.ProcessingLatency.Set {
			e.FieldStart("processing_latency")
			s.ProcessingLatency.Encode(e)
		}
	}
	{
		if s.BandwidthCapacity.Set {
			e.FieldStart("bandwidth_capacity")
			s.BandwidthCapacity.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
	{
		if s.TotalUptime.Set {
			e.FieldStart("total_uptime")
			s.TotalUptime.Encode(e)
		}
	}
	{
		if s.LastSync.Set {
			e.FieldStart("last_sync")
			s.LastSync.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastCalibration.Set {
			e.FieldStart("last_calibration")
			s.LastCalibration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastMaintenance.Set {
			e.FieldStart("last_maintenance")
			s.LastMaintenance.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ConnectedImplants != nil {
			e.FieldStart("connected_implants")
			e.ArrStart()
			for _, elem := range s.ConnectedImplants {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CyberpsychosisRisk.Set {
			e.FieldStart("cyberpsychosis_risk")
			s.CyberpsychosisRisk.Encode(e)
		}
	}
	{
		if s.AdaptationLevel.Set {
			e.FieldStart("adaptation_level")
			s.AdaptationLevel.Encode(e)
		}
	}
	{
		if s.EmergencyShutdowns.Set {
			e.FieldStart("emergency_shutdowns")
			s.EmergencyShutdowns.Encode(e)
		}
	}
	{
		if s.FirmwareUpdateAvailable.Set {
			e.FieldStart("firmware_update_available")
			s.FirmwareUpdateAvailable.Encode(e)
		}
	}
	{
		if s.SecurityClearanceLevel.Set {
			e.FieldStart("security_clearance_level")
			s.SecurityClearanceLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkEntity = [24]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "player_id",
	6:  "firmware_version",
	7:  "status",
	8:  "sync_quality",
	9:  "neural_health",
	10: "signal_strength",
	11: "processing_latency",
	12: "bandwidth_capacity",
	13: "active_connections",
	14: "total_uptime",
	15: "last_sync",
	16: "last_calibration",
	17: "last_maintenance",
	18: "connected_implants",
	19: "cyberpsychosis_risk",
	20: "adaptation_level",
	21: "emergency_shutdowns",
	22: "firmware_update_available",
	23: "security_clearance_level",
}

// Decode decodes NeuralLinkEntity from json.
func (s *NeuralLinkEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkEntity to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "player_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "firmware_version":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.FirmwareVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firmware_version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "sync_quality":
			if err := func() error {
				s.SyncQuality.Reset()
				if err := s.SyncQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_quality\"")
			}
		case "neural_health":
			if err := func() error {
				s.NeuralHealth.Reset()
				if err := s.NeuralHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_health\"")
			}
		case "signal_strength":
			if err := func() error {
				s.SignalStrength.Reset()
				if err := s.SignalStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_strength\"")
			}
		case "processing_latency":
			if err := func() error {
				s.ProcessingLatency.Reset()
				if err := s.ProcessingLatency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_latency\"")
			}
		case "bandwidth_capacity":
			if err := func() error {
				s.BandwidthCapacity.Reset()
				if err := s.BandwidthCapacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_capacity\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		case "total_uptime":
			if err := func() error {
				s.TotalUptime.Reset()
				if err := s.TotalUptime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_uptime\"")
			}
		case "last_sync":
			if err := func() error {
				s.LastSync.Reset()
				if err := s.LastSync.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_sync\"")
			}
		case "last_calibration":
			if err := func() error {
				s.LastCalibration.Reset()
				if err := s.LastCalibration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_calibration\"")
			}
		case "last_maintenance":
			if err := func() error {
				s.LastMaintenance.Reset()
				if err := s.LastMaintenance.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_maintenance\"")
			}
		case "connected_implants":
			if err := func() error {
				s.ConnectedImplants = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ConnectedImplants = append(s.ConnectedImplants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connected_implants\"")
			}
		case "cyberpsychosis_risk":
			if err := func() error {
				s.CyberpsychosisRisk.Reset()
				if err := s.CyberpsychosisRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpsychosis_risk\"")
			}
		case "adaptation_level":
			if err := func() error {
				s.AdaptationLevel.Reset()
				if err := s.AdaptationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adaptation_level\"")
			}
		case "emergency_shutdowns":
			if err := func() error {
				s.EmergencyShutdowns.Reset()
				if err := s.EmergencyShutdowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emergency_shutdowns\"")
			}
		case "firmware_update_available":
			if err := func() error {
				s.FirmwareUpdateAvailable.Reset()
				if err := s.FirmwareUpdateAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firmware_update_available\"")
			}
		case "security_clearance_level":
			if err := func() error {
				s.SecurityClearanceLevel.Reset()
				if err := s.SecurityClearanceLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_clearance_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11100111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkEntity) {
					name = jsonFieldsNameOfNeuralLinkEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkEntitySecurityClearanceLevel as json.
func (s NeuralLinkEntitySecurityClearanceLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkEntitySecurityClearanceLevel from json.
func (s *NeuralLinkEntitySecurityClearanceLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkEntitySecurityClearanceLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkEntitySecurityClearanceLevel(v) {
	case NeuralLinkEntitySecurityClearanceLevelBASIC:
		*s = NeuralLinkEntitySecurityClearanceLevelBASIC
	case NeuralLinkEntitySecurityClearanceLevelSTANDARD:
		*s = NeuralLinkEntitySecurityClearanceLevelSTANDARD
	case NeuralLinkEntitySecurityClearanceLevelELEVATED:
		*s = NeuralLinkEntitySecurityClearanceLevelELEVATED
	case NeuralLinkEntitySecurityClearanceLevelMAXIMUM:
		*s = NeuralLinkEntitySecurityClearanceLevelMAXIMUM
	default:
		*s = NeuralLinkEntitySecurityClearanceLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkEntitySecurityClearanceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkEntitySecurityClearanceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkEntityStatus as json.
func (s NeuralLinkEntityStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkEntityStatus from json.
func (s *NeuralLinkEntityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkEntityStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkEntityStatus(v) {
	case NeuralLinkEntityStatusACTIVE:
		*s = NeuralLinkEntityStatusACTIVE
	case NeuralLinkEntityStatusINACTIVE:
		*s = NeuralLinkEntityStatusINACTIVE
	case NeuralLinkEntityStatusMALFUNCTIONING:
		*s = NeuralLinkEntityStatusMALFUNCTIONING
	case NeuralLinkEntityStatusMAINTENANCE:
		*s = NeuralLinkEntityStatusMAINTENANCE
	case NeuralLinkEntityStatusCALIBRATING:
		*s = NeuralLinkEntityStatusCALIBRATING
	case NeuralLinkEntityStatusSYNCHRONIZING:
		*s = NeuralLinkEntityStatusSYNCHRONIZING
	default:
		*s = NeuralLinkEntityStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkEntityStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkEntityStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfNeuralLinkListResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes NeuralLinkListResponse from json.
func (s *NeuralLinkListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]NeuralLinkEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralLinkEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkListResponse) {
					name = jsonFieldsNameOfNeuralLinkListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkListResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkListResponseMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
	{
		if s.AverageSyncQuality.Set {
			e.FieldStart("average_sync_quality")
			s.AverageSyncQuality.Encode(e)
		}
	}
	{
		if s.HealthConcernsCount.Set {
			e.FieldStart("health_concerns_count")
			s.HealthConcernsCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkListResponseMeta = [7]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
	4: "processing_time_ms",
	5: "average_sync_quality",
	6: "health_concerns_count",
}

// Decode decodes NeuralLinkListResponseMeta from json.
func (s *NeuralLinkListResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkListResponseMeta to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		case "average_sync_quality":
			if err := func() error {
				s.AverageSyncQuality.Reset()
				if err := s.AverageSyncQuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_sync_quality\"")
			}
		case "health_concerns_count":
			if err := func() error {
				s.HealthConcernsCount.Reset()
				if err := s.HealthConcernsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_concerns_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkListResponseMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkListResponseMeta) {
					name = jsonFieldsNameOfNeuralLinkListResponseMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkListResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkListResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkRemovalResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkRemovalResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("removal_status")
		s.RemovalStatus.Encode(e)
	}
	{
		e.FieldStart("neural_integrity_preserved")
		e.Float32(s.NeuralIntegrityPreserved)
	}
	{
		if s.PhysicalDamage.Set {
			e.FieldStart("physical_damage")
			s.PhysicalDamage.Encode(e)
		}
	}
	{
		if s.FunctionalityRestored != nil {
			e.FieldStart("functionality_restored")
			e.ArrStart()
			for _, elem := range s.FunctionalityRestored {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PermanentImpairments != nil {
			e.FieldStart("permanent_impairments")
			e.ArrStart()
			for _, elem := range s.PermanentImpairments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RecoveryRequirements.Set {
			e.FieldStart("recovery_requirements")
			s.RecoveryRequirements.Encode(e)
		}
	}
	{
		if s.CyberwareCompatibilityAffected != nil {
			e.FieldStart("cyberware_compatibility_affected")
			e.ArrStart()
			for _, elem := range s.CyberwareCompatibilityAffected {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkRemovalResult = [8]string{
	0: "link_id",
	1: "removal_status",
	2: "neural_integrity_preserved",
	3: "physical_damage",
	4: "functionality_restored",
	5: "permanent_impairments",
	6: "recovery_requirements",
	7: "cyberware_compatibility_affected",
}

// Decode decodes NeuralLinkRemovalResult from json.
func (s *NeuralLinkRemovalResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkRemovalResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "removal_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RemovalStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"removal_status\"")
			}
		case "neural_integrity_preserved":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.NeuralIntegrityPreserved = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_integrity_preserved\"")
			}
		case "physical_damage":
			if err := func() error {
				s.PhysicalDamage.Reset()
				if err := s.PhysicalDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physical_damage\"")
			}
		case "functionality_restored":
			if err := func() error {
				s.FunctionalityRestored = make([]NeuralLinkRemovalResultFunctionalityRestoredItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralLinkRemovalResultFunctionalityRestoredItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FunctionalityRestored = append(s.FunctionalityRestored, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functionality_restored\"")
			}
		case "permanent_impairments":
			if err := func() error {
				s.PermanentImpairments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PermanentImpairments = append(s.PermanentImpairments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permanent_impairments\"")
			}
		case "recovery_requirements":
			if err := func() error {
				s.RecoveryRequirements.Reset()
				if err := s.RecoveryRequirements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_requirements\"")
			}
		case "cyberware_compatibility_affected":
			if err := func() error {
				s.CyberwareCompatibilityAffected = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.CyberwareCompatibilityAffected = append(s.CyberwareCompatibilityAffected, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberware_compatibility_affected\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkRemovalResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkRemovalResult) {
					name = jsonFieldsNameOfNeuralLinkRemovalResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkRemovalResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkRemovalResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkRemovalResultFunctionalityRestoredItem as json.
func (s NeuralLinkRemovalResultFunctionalityRestoredItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkRemovalResultFunctionalityRestoredItem from json.
func (s *NeuralLinkRemovalResultFunctionalityRestoredItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkRemovalResultFunctionalityRestoredItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkRemovalResultFunctionalityRestoredItem(v) {
	case NeuralLinkRemovalResultFunctionalityRestoredItemMOTORCONTROL:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItemMOTORCONTROL
	case NeuralLinkRemovalResultFunctionalityRestoredItemSENSORYPROCESSING:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItemSENSORYPROCESSING
	case NeuralLinkRemovalResultFunctionalityRestoredItemMEMORYACCESS:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItemMEMORYACCESS
	case NeuralLinkRemovalResultFunctionalityRestoredItemEMOTIONALREGULATION:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItemEMOTIONALREGULATION
	case NeuralLinkRemovalResultFunctionalityRestoredItemCOGNITIVEFUNCTIONS:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItemCOGNITIVEFUNCTIONS
	default:
		*s = NeuralLinkRemovalResultFunctionalityRestoredItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkRemovalResultFunctionalityRestoredItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkRemovalResultFunctionalityRestoredItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NeuralLinkRemovalResultRecoveryRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NeuralLinkRemovalResultRecoveryRequirements) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes NeuralLinkRemovalResultRecoveryRequirements from json.
func (s *NeuralLinkRemovalResultRecoveryRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkRemovalResultRecoveryRequirements to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkRemovalResultRecoveryRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkRemovalResultRecoveryRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkRemovalResultRecoveryRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkRemovalResultRemovalStatus as json.
func (s NeuralLinkRemovalResultRemovalStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralLinkRemovalResultRemovalStatus from json.
func (s *NeuralLinkRemovalResultRemovalStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkRemovalResultRemovalStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralLinkRemovalResultRemovalStatus(v) {
	case NeuralLinkRemovalResultRemovalStatusSUCCESS:
		*s = NeuralLinkRemovalResultRemovalStatusSUCCESS
	case NeuralLinkRemovalResultRemovalStatusPARTIALSUCCESS:
		*s = NeuralLinkRemovalResultRemovalStatusPARTIALSUCCESS
	case NeuralLinkRemovalResultRemovalStatusFAILED:
		*s = NeuralLinkRemovalResultRemovalStatusFAILED
	case NeuralLinkRemovalResultRemovalStatusEMERGENCYREMOVAL:
		*s = NeuralLinkRemovalResultRemovalStatusEMERGENCYREMOVAL
	default:
		*s = NeuralLinkRemovalResultRemovalStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralLinkRemovalResultRemovalStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkRemovalResultRemovalStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralLinkResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes NeuralLinkResponse from json.
func (s *NeuralLinkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralLinkResponse) {
					name = jsonFieldsNameOfNeuralLinkResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralLinkResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralLinkResponseMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.ProcessingTimeMs.Set {
			e.FieldStart("processing_time_ms")
			s.ProcessingTimeMs.Encode(e)
		}
	}
	{
		if s.NeuralWarnings != nil {
			e.FieldStart("neural_warnings")
			e.ArrStart()
			for _, elem := range s.NeuralWarnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralLinkResponseMeta = [3]string{
	0: "version",
	1: "processing_time_ms",
	2: "neural_warnings",
}

// Decode decodes NeuralLinkResponseMeta from json.
func (s *NeuralLinkResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralLinkResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "processing_time_ms":
			if err := func() error {
				s.ProcessingTimeMs.Reset()
				if err := s.ProcessingTimeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_time_ms\"")
			}
		case "neural_warnings":
			if err := func() error {
				s.NeuralWarnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NeuralWarnings = append(s.NeuralWarnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_warnings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralLinkResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralLinkResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralLinkResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralPathwayEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralPathwayEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pathway_id")
		json.EncodeUUID(e, s.PathwayID)
	}
	{
		e.FieldStart("pathway_type")
		s.PathwayType.Encode(e)
	}
	{
		e.FieldStart("health_status")
		s.HealthStatus.Encode(e)
	}
	{
		if s.Conductivity.Set {
			e.FieldStart("conductivity")
			s.Conductivity.Encode(e)
		}
	}
	{
		if s.LatencyMs.Set {
			e.FieldStart("latency_ms")
			s.LatencyMs.Encode(e)
		}
	}
	{
		if s.AdaptationProgress.Set {
			e.FieldStart("adaptation_progress")
			s.AdaptationProgress.Encode(e)
		}
	}
	{
		if s.StressIndicators != nil {
			e.FieldStart("stress_indicators")
			e.ArrStart()
			for _, elem := range s.StressIndicators {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralPathwayEntity = [7]string{
	0: "pathway_id",
	1: "pathway_type",
	2: "health_status",
	3: "conductivity",
	4: "latency_ms",
	5: "adaptation_progress",
	6: "stress_indicators",
}

// Decode decodes NeuralPathwayEntity from json.
func (s *NeuralPathwayEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralPathwayEntity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pathway_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PathwayID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathway_id\"")
			}
		case "pathway_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PathwayType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathway_type\"")
			}
		case "health_status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HealthStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_status\"")
			}
		case "conductivity":
			if err := func() error {
				s.Conductivity.Reset()
				if err := s.Conductivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conductivity\"")
			}
		case "latency_ms":
			if err := func() error {
				s.LatencyMs.Reset()
				if err := s.LatencyMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_ms\"")
			}
		case "adaptation_progress":
			if err := func() error {
				s.AdaptationProgress.Reset()
				if err := s.AdaptationProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adaptation_progress\"")
			}
		case "stress_indicators":
			if err := func() error {
				s.StressIndicators = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StressIndicators = append(s.StressIndicators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stress_indicators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralPathwayEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralPathwayEntity) {
					name = jsonFieldsNameOfNeuralPathwayEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralPathwayEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralPathwayEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralPathwayEntityHealthStatus as json.
func (s NeuralPathwayEntityHealthStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralPathwayEntityHealthStatus from json.
func (s *NeuralPathwayEntityHealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralPathwayEntityHealthStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralPathwayEntityHealthStatus(v) {
	case NeuralPathwayEntityHealthStatusHEALTHY:
		*s = NeuralPathwayEntityHealthStatusHEALTHY
	case NeuralPathwayEntityHealthStatusDEGRADED:
		*s = NeuralPathwayEntityHealthStatusDEGRADED
	case NeuralPathwayEntityHealthStatusDAMAGED:
		*s = NeuralPathwayEntityHealthStatusDAMAGED
	case NeuralPathwayEntityHealthStatusCRITICAL:
		*s = NeuralPathwayEntityHealthStatusCRITICAL
	default:
		*s = NeuralPathwayEntityHealthStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralPathwayEntityHealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralPathwayEntityHealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralPathwayEntityPathwayType as json.
func (s NeuralPathwayEntityPathwayType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralPathwayEntityPathwayType from json.
func (s *NeuralPathwayEntityPathwayType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralPathwayEntityPathwayType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralPathwayEntityPathwayType(v) {
	case NeuralPathwayEntityPathwayTypeMOTORCONTROL:
		*s = NeuralPathwayEntityPathwayTypeMOTORCONTROL
	case NeuralPathwayEntityPathwayTypeSENSORYPROCESSING:
		*s = NeuralPathwayEntityPathwayTypeSENSORYPROCESSING
	case NeuralPathwayEntityPathwayTypeMEMORYACCESS:
		*s = NeuralPathwayEntityPathwayTypeMEMORYACCESS
	case NeuralPathwayEntityPathwayTypeEMOTIONALREGULATION:
		*s = NeuralPathwayEntityPathwayTypeEMOTIONALREGULATION
	case NeuralPathwayEntityPathwayTypeCOGNITIVEENHANCEMENT:
		*s = NeuralPathwayEntityPathwayTypeCOGNITIVEENHANCEMENT
	case NeuralPathwayEntityPathwayTypeREFLEXARC:
		*s = NeuralPathwayEntityPathwayTypeREFLEXARC
	default:
		*s = NeuralPathwayEntityPathwayType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralPathwayEntityPathwayType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralPathwayEntityPathwayType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralSyncRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralSyncRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		if s.SyncType.Set {
			e.FieldStart("sync_type")
			s.SyncType.Encode(e)
		}
	}
	{
		if s.ForceSync.Set {
			e.FieldStart("force_sync")
			s.ForceSync.Encode(e)
		}
	}
	{
		if s.IncludeImplants != nil {
			e.FieldStart("include_implants")
			e.ArrStart()
			for _, elem := range s.IncludeImplants {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExcludeImplants != nil {
			e.FieldStart("exclude_implants")
			e.ArrStart()
			for _, elem := range s.ExcludeImplants {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SyncPriority.Set {
			e.FieldStart("sync_priority")
			s.SyncPriority.Encode(e)
		}
	}
	{
		if s.NeuralLoadLimit.Set {
			e.FieldStart("neural_load_limit")
			s.NeuralLoadLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralSyncRequest = [7]string{
	0: "player_id",
	1: "sync_type",
	2: "force_sync",
	3: "include_implants",
	4: "exclude_implants",
	5: "sync_priority",
	6: "neural_load_limit",
}

// Decode decodes NeuralSyncRequest from json.
func (s *NeuralSyncRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "sync_type":
			if err := func() error {
				s.SyncType.Reset()
				if err := s.SyncType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_type\"")
			}
		case "force_sync":
			if err := func() error {
				s.ForceSync.Reset()
				if err := s.ForceSync.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_sync\"")
			}
		case "include_implants":
			if err := func() error {
				s.IncludeImplants = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.IncludeImplants = append(s.IncludeImplants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_implants\"")
			}
		case "exclude_implants":
			if err := func() error {
				s.ExcludeImplants = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ExcludeImplants = append(s.ExcludeImplants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_implants\"")
			}
		case "sync_priority":
			if err := func() error {
				s.SyncPriority.Reset()
				if err := s.SyncPriority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_priority\"")
			}
		case "neural_load_limit":
			if err := func() error {
				s.NeuralLoadLimit.Reset()
				if err := s.NeuralLoadLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_load_limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralSyncRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralSyncRequest) {
					name = jsonFieldsNameOfNeuralSyncRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralSyncRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncRequestSyncPriority as json.
func (s NeuralSyncRequestSyncPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralSyncRequestSyncPriority from json.
func (s *NeuralSyncRequestSyncPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncRequestSyncPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralSyncRequestSyncPriority(v) {
	case NeuralSyncRequestSyncPrioritySPEED:
		*s = NeuralSyncRequestSyncPrioritySPEED
	case NeuralSyncRequestSyncPrioritySAFETY:
		*s = NeuralSyncRequestSyncPrioritySAFETY
	case NeuralSyncRequestSyncPriorityTHOROUGHNESS:
		*s = NeuralSyncRequestSyncPriorityTHOROUGHNESS
	default:
		*s = NeuralSyncRequestSyncPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralSyncRequestSyncPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncRequestSyncPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncRequestSyncType as json.
func (s NeuralSyncRequestSyncType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralSyncRequestSyncType from json.
func (s *NeuralSyncRequestSyncType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncRequestSyncType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralSyncRequestSyncType(v) {
	case NeuralSyncRequestSyncTypeFULL:
		*s = NeuralSyncRequestSyncTypeFULL
	case NeuralSyncRequestSyncTypePARTIAL:
		*s = NeuralSyncRequestSyncTypePARTIAL
	case NeuralSyncRequestSyncTypeEMERGENCY:
		*s = NeuralSyncRequestSyncTypeEMERGENCY
	default:
		*s = NeuralSyncRequestSyncType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralSyncRequestSyncType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncRequestSyncType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralSyncResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralSyncResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_id")
		json.EncodeUUID(e, s.LinkID)
	}
	{
		e.FieldStart("sync_status")
		s.SyncStatus.Encode(e)
	}
	{
		e.FieldStart("final_sync_quality")
		e.Float32(s.FinalSyncQuality)
	}
	{
		if s.ImplantsSynchronized.Set {
			e.FieldStart("implants_synchronized")
			s.ImplantsSynchronized.Encode(e)
		}
	}
	{
		if s.SyncDurationSeconds.Set {
			e.FieldStart("sync_duration_seconds")
			s.SyncDurationSeconds.Encode(e)
		}
	}
	{
		if s.NeuralLoadPeak.Set {
			e.FieldStart("neural_load_peak")
			s.NeuralLoadPeak.Encode(e)
		}
	}
	{
		if s.BandwidthUtilized.Set {
			e.FieldStart("bandwidth_utilized")
			s.BandwidthUtilized.Encode(e)
		}
	}
	{
		if s.ErrorsEncountered != nil {
			e.FieldStart("errors_encountered")
			e.ArrStart()
			for _, elem := range s.ErrorsEncountered {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PerformanceImprovements.Set {
			e.FieldStart("performance_improvements")
			s.PerformanceImprovements.Encode(e)
		}
	}
	{
		if s.Recommendations != nil {
			e.FieldStart("recommendations")
			e.ArrStart()
			for _, elem := range s.Recommendations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNeuralSyncResult = [10]string{
	0: "link_id",
	1: "sync_status",
	2: "final_sync_quality",
	3: "implants_synchronized",
	4: "sync_duration_seconds",
	5: "neural_load_peak",
	6: "bandwidth_utilized",
	7: "errors_encountered",
	8: "performance_improvements",
	9: "recommendations",
}

// Decode decodes NeuralSyncResult from json.
func (s *NeuralSyncResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.LinkID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_id\"")
			}
		case "sync_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SyncStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_status\"")
			}
		case "final_sync_quality":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.FinalSyncQuality = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_sync_quality\"")
			}
		case "implants_synchronized":
			if err := func() error {
				s.ImplantsSynchronized.Reset()
				if err := s.ImplantsSynchronized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implants_synchronized\"")
			}
		case "sync_duration_seconds":
			if err := func() error {
				s.SyncDurationSeconds.Reset()
				if err := s.SyncDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sync_duration_seconds\"")
			}
		case "neural_load_peak":
			if err := func() error {
				s.NeuralLoadPeak.Reset()
				if err := s.NeuralLoadPeak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neural_load_peak\"")
			}
		case "bandwidth_utilized":
			if err := func() error {
				s.BandwidthUtilized.Reset()
				if err := s.BandwidthUtilized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_utilized\"")
			}
		case "errors_encountered":
			if err := func() error {
				s.ErrorsEncountered = make([]NeuralSyncResultErrorsEncounteredItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NeuralSyncResultErrorsEncounteredItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ErrorsEncountered = append(s.ErrorsEncountered, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors_encountered\"")
			}
		case "performance_improvements":
			if err := func() error {
				s.PerformanceImprovements.Reset()
				if err := s.PerformanceImprovements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performance_improvements\"")
			}
		case "recommendations":
			if err := func() error {
				s.Recommendations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Recommendations = append(s.Recommendations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommendations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralSyncResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralSyncResult) {
					name = jsonFieldsNameOfNeuralSyncResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralSyncResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralSyncResultErrorsEncounteredItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralSyncResultErrorsEncounteredItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error_type")
		s.ErrorType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfNeuralSyncResultErrorsEncounteredItem = [3]string{
	0: "error_type",
	1: "severity",
	2: "description",
}

// Decode decodes NeuralSyncResultErrorsEncounteredItem from json.
func (s *NeuralSyncResultErrorsEncounteredItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResultErrorsEncounteredItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ErrorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralSyncResultErrorsEncounteredItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNeuralSyncResultErrorsEncounteredItem) {
					name = jsonFieldsNameOfNeuralSyncResultErrorsEncounteredItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralSyncResultErrorsEncounteredItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResultErrorsEncounteredItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncResultErrorsEncounteredItemErrorType as json.
func (s NeuralSyncResultErrorsEncounteredItemErrorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralSyncResultErrorsEncounteredItemErrorType from json.
func (s *NeuralSyncResultErrorsEncounteredItemErrorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResultErrorsEncounteredItemErrorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralSyncResultErrorsEncounteredItemErrorType(v) {
	case NeuralSyncResultErrorsEncounteredItemErrorTypeCONNECTIONFAILURE:
		*s = NeuralSyncResultErrorsEncounteredItemErrorTypeCONNECTIONFAILURE
	case NeuralSyncResultErrorsEncounteredItemErrorTypeIMPLANTINCOMPATIBILITY:
		*s = NeuralSyncResultErrorsEncounteredItemErrorTypeIMPLANTINCOMPATIBILITY
	case NeuralSyncResultErrorsEncounteredItemErrorTypeNEURALOVERLOAD:
		*s = NeuralSyncResultErrorsEncounteredItemErrorTypeNEURALOVERLOAD
	case NeuralSyncResultErrorsEncounteredItemErrorTypeSIGNALINTERFERENCE:
		*s = NeuralSyncResultErrorsEncounteredItemErrorTypeSIGNALINTERFERENCE
	default:
		*s = NeuralSyncResultErrorsEncounteredItemErrorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralSyncResultErrorsEncounteredItemErrorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResultErrorsEncounteredItemErrorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncResultErrorsEncounteredItemSeverity as json.
func (s NeuralSyncResultErrorsEncounteredItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralSyncResultErrorsEncounteredItemSeverity from json.
func (s *NeuralSyncResultErrorsEncounteredItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResultErrorsEncounteredItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralSyncResultErrorsEncounteredItemSeverity(v) {
	case NeuralSyncResultErrorsEncounteredItemSeverityLOW:
		*s = NeuralSyncResultErrorsEncounteredItemSeverityLOW
	case NeuralSyncResultErrorsEncounteredItemSeverityMEDIUM:
		*s = NeuralSyncResultErrorsEncounteredItemSeverityMEDIUM
	case NeuralSyncResultErrorsEncounteredItemSeverityHIGH:
		*s = NeuralSyncResultErrorsEncounteredItemSeverityHIGH
	case NeuralSyncResultErrorsEncounteredItemSeverityCRITICAL:
		*s = NeuralSyncResultErrorsEncounteredItemSeverityCRITICAL
	default:
		*s = NeuralSyncResultErrorsEncounteredItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralSyncResultErrorsEncounteredItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResultErrorsEncounteredItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NeuralSyncResultPerformanceImprovements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NeuralSyncResultPerformanceImprovements) encodeFields(e *jx.Encoder) {
	{
		if s.LatencyReductionMs.Set {
			e.FieldStart("latency_reduction_ms")
			s.LatencyReductionMs.Encode(e)
		}
	}
	{
		if s.BandwidthIncreaseMbps.Set {
			e.FieldStart("bandwidth_increase_mbps")
			s.BandwidthIncreaseMbps.Encode(e)
		}
	}
	{
		if s.SignalStabilityImprovement.Set {
			e.FieldStart("signal_stability_improvement")
			s.SignalStabilityImprovement.Encode(e)
		}
	}
}

var jsonFieldsNameOfNeuralSyncResultPerformanceImprovements = [3]string{
	0: "latency_reduction_ms",
	1: "bandwidth_increase_mbps",
	2: "signal_stability_improvement",
}

// Decode decodes NeuralSyncResultPerformanceImprovements from json.
func (s *NeuralSyncResultPerformanceImprovements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResultPerformanceImprovements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latency_reduction_ms":
			if err := func() error {
				s.LatencyReductionMs.Reset()
				if err := s.LatencyReductionMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_reduction_ms\"")
			}
		case "bandwidth_increase_mbps":
			if err := func() error {
				s.BandwidthIncreaseMbps.Reset()
				if err := s.BandwidthIncreaseMbps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth_increase_mbps\"")
			}
		case "signal_stability_improvement":
			if err := func() error {
				s.SignalStabilityImprovement.Reset()
				if err := s.SignalStabilityImprovement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_stability_improvement\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NeuralSyncResultPerformanceImprovements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NeuralSyncResultPerformanceImprovements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResultPerformanceImprovements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncResultSyncStatus as json.
func (s NeuralSyncResultSyncStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NeuralSyncResultSyncStatus from json.
func (s *NeuralSyncResultSyncStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NeuralSyncResultSyncStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NeuralSyncResultSyncStatus(v) {
	case NeuralSyncResultSyncStatusSUCCESS:
		*s = NeuralSyncResultSyncStatusSUCCESS
	case NeuralSyncResultSyncStatusPARTIALSUCCESS:
		*s = NeuralSyncResultSyncStatusPARTIALSUCCESS
	case NeuralSyncResultSyncStatusFAILED:
		*s = NeuralSyncResultSyncStatusFAILED
	case NeuralSyncResultSyncStatusINTERRUPTED:
		*s = NeuralSyncResultSyncStatusINTERRUPTED
	default:
		*s = NeuralSyncResultSyncStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NeuralSyncResultSyncStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NeuralSyncResultSyncStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthRequestAssessmentType as json.
func (o OptBatchNeuralHealthRequestAssessmentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BatchNeuralHealthRequestAssessmentType from json.
func (o *OptBatchNeuralHealthRequestAssessmentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchNeuralHealthRequestAssessmentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchNeuralHealthRequestAssessmentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchNeuralHealthRequestAssessmentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchNeuralHealthResultSummaryStatistics as json.
func (o OptBatchNeuralHealthResultSummaryStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BatchNeuralHealthResultSummaryStatistics from json.
func (o *OptBatchNeuralHealthResultSummaryStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchNeuralHealthResultSummaryStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchNeuralHealthResultSummaryStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchNeuralHealthResultSummaryStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalibrateNeuralLinkRequestCalibrationType as json.
func (o OptCalibrateNeuralLinkRequestCalibrationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CalibrateNeuralLinkRequestCalibrationType from json.
func (o *OptCalibrateNeuralLinkRequestCalibrationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCalibrateNeuralLinkRequestCalibrationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCalibrateNeuralLinkRequestCalibrationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCalibrateNeuralLinkRequestCalibrationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CalibrateNeuralLinkRequestCustomParameters as json.
func (o OptCalibrateNeuralLinkRequestCustomParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CalibrateNeuralLinkRequestCustomParameters from json.
func (o *OptCalibrateNeuralLinkRequestCustomParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCalibrateNeuralLinkRequestCustomParameters to nil")
	}
	o.Set = true
	o.Value = make(CalibrateNeuralLinkRequestCustomParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCalibrateNeuralLinkRequestCustomParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCalibrateNeuralLinkRequestCustomParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallNeuralLinkRequestSecurityClearance as json.
func (o OptInstallNeuralLinkRequestSecurityClearance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstallNeuralLinkRequestSecurityClearance from json.
func (o *OptInstallNeuralLinkRequestSecurityClearance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstallNeuralLinkRequestSecurityClearance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstallNeuralLinkRequestSecurityClearance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstallNeuralLinkRequestSecurityClearance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralCalibrationResultPathwayHealthChanges as json.
func (o OptNeuralCalibrationResultPathwayHealthChanges) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralCalibrationResultPathwayHealthChanges from json.
func (o *OptNeuralCalibrationResultPathwayHealthChanges) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralCalibrationResultPathwayHealthChanges to nil")
	}
	o.Set = true
	o.Value = make(NeuralCalibrationResultPathwayHealthChanges)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralCalibrationResultPathwayHealthChanges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralCalibrationResultPathwayHealthChanges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralFirmwareUpdateResultPerformanceImpact as json.
func (o OptNeuralFirmwareUpdateResultPerformanceImpact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralFirmwareUpdateResultPerformanceImpact from json.
func (o *OptNeuralFirmwareUpdateResultPerformanceImpact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralFirmwareUpdateResultPerformanceImpact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralFirmwareUpdateResultPerformanceImpact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralFirmwareUpdateResultPerformanceImpact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralFirmwareUpdateResultRollbackInformation as json.
func (o OptNeuralFirmwareUpdateResultRollbackInformation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralFirmwareUpdateResultRollbackInformation from json.
func (o *OptNeuralFirmwareUpdateResultRollbackInformation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralFirmwareUpdateResultRollbackInformation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralFirmwareUpdateResultRollbackInformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralFirmwareUpdateResultRollbackInformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsCyberpsychosisIndicators as json.
func (o OptNeuralLinkDiagnosticsCyberpsychosisIndicators) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsCyberpsychosisIndicators from json.
func (o *OptNeuralLinkDiagnosticsCyberpsychosisIndicators) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsCyberpsychosisIndicators to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsCyberpsychosisIndicators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsCyberpsychosisIndicators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel as json.
func (o OptNeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel from json.
func (o *OptNeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsCyberpsychosisIndicatorsCurrentRiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsHistoricalTrends as json.
func (o OptNeuralLinkDiagnosticsHistoricalTrends) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsHistoricalTrends from json.
func (o *OptNeuralLinkDiagnosticsHistoricalTrends) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsHistoricalTrends to nil")
	}
	o.Set = true
	o.Value = make(NeuralLinkDiagnosticsHistoricalTrends)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsHistoricalTrends) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsHistoricalTrends) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsImplantIntegrationStatus as json.
func (o OptNeuralLinkDiagnosticsImplantIntegrationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsImplantIntegrationStatus from json.
func (o *OptNeuralLinkDiagnosticsImplantIntegrationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsImplantIntegrationStatus to nil")
	}
	o.Set = true
	o.Value = make(NeuralLinkDiagnosticsImplantIntegrationStatus)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsImplantIntegrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsImplantIntegrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk as json.
func (o OptNeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk from json.
func (o *OptNeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsMaintenanceRecommendationsItemEstimatedRisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsPerformanceMetrics as json.
func (o OptNeuralLinkDiagnosticsPerformanceMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsPerformanceMetrics from json.
func (o *OptNeuralLinkDiagnosticsPerformanceMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsPerformanceMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsPerformanceMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsPerformanceMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsPredictiveAnalysis as json.
func (o OptNeuralLinkDiagnosticsPredictiveAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsPredictiveAnalysis from json.
func (o *OptNeuralLinkDiagnosticsPredictiveAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsPredictiveAnalysis to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsPredictiveAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsPredictiveAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days as json.
func (o OptNeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days from json.
func (o *OptNeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsPredictiveAnalysisHealthTrajectory30Days) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsSyncQualityAssessment as json.
func (o OptNeuralLinkDiagnosticsSyncQualityAssessment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkDiagnosticsSyncQualityAssessment from json.
func (o *OptNeuralLinkDiagnosticsSyncQualityAssessment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsSyncQualityAssessment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsSyncQualityAssessment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsSyncQualityAssessment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend as json.
func (o OptNeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend from json.
func (o *OptNeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkDiagnosticsSyncQualityAssessmentQualityTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkEntitySecurityClearanceLevel as json.
func (o OptNeuralLinkEntitySecurityClearanceLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralLinkEntitySecurityClearanceLevel from json.
func (o *OptNeuralLinkEntitySecurityClearanceLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkEntitySecurityClearanceLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkEntitySecurityClearanceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkEntitySecurityClearanceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkRemovalResultRecoveryRequirements as json.
func (o OptNeuralLinkRemovalResultRecoveryRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkRemovalResultRecoveryRequirements from json.
func (o *OptNeuralLinkRemovalResultRecoveryRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkRemovalResultRecoveryRequirements to nil")
	}
	o.Set = true
	o.Value = make(NeuralLinkRemovalResultRecoveryRequirements)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkRemovalResultRecoveryRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkRemovalResultRecoveryRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralLinkResponseMeta as json.
func (o OptNeuralLinkResponseMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralLinkResponseMeta from json.
func (o *OptNeuralLinkResponseMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralLinkResponseMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralLinkResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralLinkResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncRequestSyncPriority as json.
func (o OptNeuralSyncRequestSyncPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralSyncRequestSyncPriority from json.
func (o *OptNeuralSyncRequestSyncPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralSyncRequestSyncPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralSyncRequestSyncPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralSyncRequestSyncPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncRequestSyncType as json.
func (o OptNeuralSyncRequestSyncType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NeuralSyncRequestSyncType from json.
func (o *OptNeuralSyncRequestSyncType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralSyncRequestSyncType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralSyncRequestSyncType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralSyncRequestSyncType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NeuralSyncResultPerformanceImprovements as json.
func (o OptNeuralSyncResultPerformanceImprovements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NeuralSyncResultPerformanceImprovements from json.
func (o *OptNeuralSyncResultPerformanceImprovements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNeuralSyncResultPerformanceImprovements to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNeuralSyncResultPerformanceImprovements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNeuralSyncResultPerformanceImprovements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralFirmwareRequestUpdateStrategy as json.
func (o OptUpdateNeuralFirmwareRequestUpdateStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateNeuralFirmwareRequestUpdateStrategy from json.
func (o *OptUpdateNeuralFirmwareRequestUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralFirmwareRequestUpdateStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralFirmwareRequestUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralFirmwareRequestUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestCalibrationSettings as json.
func (o OptUpdateNeuralLinkRequestCalibrationSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNeuralLinkRequestCalibrationSettings from json.
func (o *OptUpdateNeuralLinkRequestCalibrationSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralLinkRequestCalibrationSettings to nil")
	}
	o.Set = true
	o.Value = make(UpdateNeuralLinkRequestCalibrationSettings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralLinkRequestCalibrationSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralLinkRequestCalibrationSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestEmergencyProtocols as json.
func (o OptUpdateNeuralLinkRequestEmergencyProtocols) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNeuralLinkRequestEmergencyProtocols from json.
func (o *OptUpdateNeuralLinkRequestEmergencyProtocols) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralLinkRequestEmergencyProtocols to nil")
	}
	o.Set = true
	o.Value = make(UpdateNeuralLinkRequestEmergencyProtocols)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralLinkRequestEmergencyProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralLinkRequestEmergencyProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestMetadata as json.
func (o OptUpdateNeuralLinkRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNeuralLinkRequestMetadata from json.
func (o *OptUpdateNeuralLinkRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralLinkRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralLinkRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralLinkRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestMonitoringSensitivity as json.
func (o OptUpdateNeuralLinkRequestMonitoringSensitivity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateNeuralLinkRequestMonitoringSensitivity from json.
func (o *OptUpdateNeuralLinkRequestMonitoringSensitivity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralLinkRequestMonitoringSensitivity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralLinkRequestMonitoringSensitivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralLinkRequestMonitoringSensitivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestSecurityClearanceUpgrade as json.
func (o OptUpdateNeuralLinkRequestSecurityClearanceUpgrade) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateNeuralLinkRequestSecurityClearanceUpgrade from json.
func (o *OptUpdateNeuralLinkRequestSecurityClearanceUpgrade) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNeuralLinkRequestSecurityClearanceUpgrade to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNeuralLinkRequestSecurityClearanceUpgrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNeuralLinkRequestSecurityClearanceUpgrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemoveNeuralLinkConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RemoveNeuralLinkConflict from json.
func (s *RemoveNeuralLinkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RemoveNeuralLinkConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveNeuralLinkConflict) {
					name = jsonFieldsNameOfRemoveNeuralLinkConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemoveNeuralLinkConflictDetails = [0]string{}

// Decode decodes RemoveNeuralLinkConflictDetails from json.
func (s *RemoveNeuralLinkConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemoveNeuralLinkNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RemoveNeuralLinkNotFound from json.
func (s *RemoveNeuralLinkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RemoveNeuralLinkNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveNeuralLinkNotFound) {
					name = jsonFieldsNameOfRemoveNeuralLinkNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemoveNeuralLinkNotFoundDetails = [0]string{}

// Decode decodes RemoveNeuralLinkNotFoundDetails from json.
func (s *RemoveNeuralLinkNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkUnprocessableEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemoveNeuralLinkUnprocessableEntity = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RemoveNeuralLinkUnprocessableEntity from json.
func (s *RemoveNeuralLinkUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkUnprocessableEntity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RemoveNeuralLinkUnprocessableEntityDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkUnprocessableEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveNeuralLinkUnprocessableEntity) {
					name = jsonFieldsNameOfRemoveNeuralLinkUnprocessableEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNeuralLinkUnprocessableEntityDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNeuralLinkUnprocessableEntityDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemoveNeuralLinkUnprocessableEntityDetails = [0]string{}

// Decode decodes RemoveNeuralLinkUnprocessableEntityDetails from json.
func (s *RemoveNeuralLinkUnprocessableEntityDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNeuralLinkUnprocessableEntityDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNeuralLinkUnprocessableEntityDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNeuralLinkUnprocessableEntityDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNeuralLinkUnprocessableEntityDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynchronizeNeuralLinkBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes SynchronizeNeuralLinkBadRequest from json.
func (s *SynchronizeNeuralLinkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem SynchronizeNeuralLinkBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynchronizeNeuralLinkBadRequest) {
					name = jsonFieldsNameOfSynchronizeNeuralLinkBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSynchronizeNeuralLinkBadRequestDetails = [0]string{}

// Decode decodes SynchronizeNeuralLinkBadRequestDetails from json.
func (s *SynchronizeNeuralLinkBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynchronizeNeuralLinkConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes SynchronizeNeuralLinkConflict from json.
func (s *SynchronizeNeuralLinkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem SynchronizeNeuralLinkConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynchronizeNeuralLinkConflict) {
					name = jsonFieldsNameOfSynchronizeNeuralLinkConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSynchronizeNeuralLinkConflictDetails = [0]string{}

// Decode decodes SynchronizeNeuralLinkConflictDetails from json.
func (s *SynchronizeNeuralLinkConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfSynchronizeNeuralLinkTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes SynchronizeNeuralLinkTooManyRequests from json.
func (s *SynchronizeNeuralLinkTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem SynchronizeNeuralLinkTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSynchronizeNeuralLinkTooManyRequests) {
					name = jsonFieldsNameOfSynchronizeNeuralLinkTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SynchronizeNeuralLinkTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SynchronizeNeuralLinkTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSynchronizeNeuralLinkTooManyRequestsDetails = [0]string{}

// Decode decodes SynchronizeNeuralLinkTooManyRequestsDetails from json.
func (s *SynchronizeNeuralLinkTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SynchronizeNeuralLinkTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SynchronizeNeuralLinkTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SynchronizeNeuralLinkTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SynchronizeNeuralLinkTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralFirmwareBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralFirmwareBadRequest from json.
func (s *UpdateNeuralFirmwareBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralFirmwareBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralFirmwareBadRequest) {
					name = jsonFieldsNameOfUpdateNeuralFirmwareBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralFirmwareBadRequestDetails = [0]string{}

// Decode decodes UpdateNeuralFirmwareBadRequestDetails from json.
func (s *UpdateNeuralFirmwareBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralFirmwareConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralFirmwareConflict from json.
func (s *UpdateNeuralFirmwareConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralFirmwareConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralFirmwareConflict) {
					name = jsonFieldsNameOfUpdateNeuralFirmwareConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralFirmwareConflictDetails = [0]string{}

// Decode decodes UpdateNeuralFirmwareConflictDetails from json.
func (s *UpdateNeuralFirmwareConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_version")
		e.Str(s.TargetVersion)
	}
	{
		e.FieldStart("link_ids")
		e.ArrStart()
		for _, elem := range s.LinkIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.UpdateStrategy.Set {
			e.FieldStart("update_strategy")
			s.UpdateStrategy.Encode(e)
		}
	}
	{
		if s.RollbackEnabled.Set {
			e.FieldStart("rollback_enabled")
			s.RollbackEnabled.Encode(e)
		}
	}
	{
		if s.HealthMonitoring.Set {
			e.FieldStart("health_monitoring")
			s.HealthMonitoring.Encode(e)
		}
	}
	{
		if s.MaintenanceWindowMinutes.Set {
			e.FieldStart("maintenance_window_minutes")
			s.MaintenanceWindowMinutes.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralFirmwareRequest = [6]string{
	0: "target_version",
	1: "link_ids",
	2: "update_strategy",
	3: "rollback_enabled",
	4: "health_monitoring",
	5: "maintenance_window_minutes",
}

// Decode decodes UpdateNeuralFirmwareRequest from json.
func (s *UpdateNeuralFirmwareRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TargetVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_version\"")
			}
		case "link_ids":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.LinkIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.LinkIds = append(s.LinkIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_ids\"")
			}
		case "update_strategy":
			if err := func() error {
				s.UpdateStrategy.Reset()
				if err := s.UpdateStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_strategy\"")
			}
		case "rollback_enabled":
			if err := func() error {
				s.RollbackEnabled.Reset()
				if err := s.RollbackEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollback_enabled\"")
			}
		case "health_monitoring":
			if err := func() error {
				s.HealthMonitoring.Reset()
				if err := s.HealthMonitoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_monitoring\"")
			}
		case "maintenance_window_minutes":
			if err := func() error {
				s.MaintenanceWindowMinutes.Reset()
				if err := s.MaintenanceWindowMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_window_minutes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralFirmwareRequest) {
					name = jsonFieldsNameOfUpdateNeuralFirmwareRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralFirmwareRequestUpdateStrategy as json.
func (s UpdateNeuralFirmwareRequestUpdateStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateNeuralFirmwareRequestUpdateStrategy from json.
func (s *UpdateNeuralFirmwareRequestUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareRequestUpdateStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateNeuralFirmwareRequestUpdateStrategy(v) {
	case UpdateNeuralFirmwareRequestUpdateStrategySEQUENTIAL:
		*s = UpdateNeuralFirmwareRequestUpdateStrategySEQUENTIAL
	case UpdateNeuralFirmwareRequestUpdateStrategyPARALLEL:
		*s = UpdateNeuralFirmwareRequestUpdateStrategyPARALLEL
	case UpdateNeuralFirmwareRequestUpdateStrategyPHASED:
		*s = UpdateNeuralFirmwareRequestUpdateStrategyPHASED
	default:
		*s = UpdateNeuralFirmwareRequestUpdateStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNeuralFirmwareRequestUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareRequestUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareUnprocessableEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralFirmwareUnprocessableEntity = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralFirmwareUnprocessableEntity from json.
func (s *UpdateNeuralFirmwareUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareUnprocessableEntity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralFirmwareUnprocessableEntityDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareUnprocessableEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralFirmwareUnprocessableEntity) {
					name = jsonFieldsNameOfUpdateNeuralFirmwareUnprocessableEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntityDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralFirmwareUnprocessableEntityDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralFirmwareUnprocessableEntityDetails = [0]string{}

// Decode decodes UpdateNeuralFirmwareUnprocessableEntityDetails from json.
func (s *UpdateNeuralFirmwareUnprocessableEntityDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralFirmwareUnprocessableEntityDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralFirmwareUnprocessableEntityDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntityDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralFirmwareUnprocessableEntityDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralLinkBadRequest from json.
func (s *UpdateNeuralLinkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralLinkBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralLinkBadRequest) {
					name = jsonFieldsNameOfUpdateNeuralLinkBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralLinkBadRequestDetails = [0]string{}

// Decode decodes UpdateNeuralLinkBadRequestDetails from json.
func (s *UpdateNeuralLinkBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkConflict = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralLinkConflict from json.
func (s *UpdateNeuralLinkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralLinkConflictDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralLinkConflict) {
					name = jsonFieldsNameOfUpdateNeuralLinkConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkConflictDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkConflictDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralLinkConflictDetails = [0]string{}

// Decode decodes UpdateNeuralLinkConflictDetails from json.
func (s *UpdateNeuralLinkConflictDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkConflictDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkConflictDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkConflictDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkConflictDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralLinkNotFound from json.
func (s *UpdateNeuralLinkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralLinkNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralLinkNotFound) {
					name = jsonFieldsNameOfUpdateNeuralLinkNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralLinkNotFoundDetails = [0]string{}

// Decode decodes UpdateNeuralLinkNotFoundDetails from json.
func (s *UpdateNeuralLinkNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.FirmwareUpdate.Set {
			e.FieldStart("firmware_update")
			s.FirmwareUpdate.Encode(e)
		}
	}
	{
		if s.SecurityClearanceUpgrade.Set {
			e.FieldStart("security_clearance_upgrade")
			s.SecurityClearanceUpgrade.Encode(e)
		}
	}
	{
		if s.CalibrationSettings.Set {
			e.FieldStart("calibration_settings")
			s.CalibrationSettings.Encode(e)
		}
	}
	{
		if s.MonitoringSensitivity.Set {
			e.FieldStart("monitoring_sensitivity")
			s.MonitoringSensitivity.Encode(e)
		}
	}
	{
		if s.EmergencyProtocols.Set {
			e.FieldStart("emergency_protocols")
			s.EmergencyProtocols.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkRequest = [8]string{
	0: "id",
	1: "version",
	2: "metadata",
	3: "firmware_update",
	4: "security_clearance_upgrade",
	5: "calibration_settings",
	6: "monitoring_sensitivity",
	7: "emergency_protocols",
}

// Decode decodes UpdateNeuralLinkRequest from json.
func (s *UpdateNeuralLinkRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "firmware_update":
			if err := func() error {
				s.FirmwareUpdate.Reset()
				if err := s.FirmwareUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firmware_update\"")
			}
		case "security_clearance_upgrade":
			if err := func() error {
				s.SecurityClearanceUpgrade.Reset()
				if err := s.SecurityClearanceUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_clearance_upgrade\"")
			}
		case "calibration_settings":
			if err := func() error {
				s.CalibrationSettings.Reset()
				if err := s.CalibrationSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calibration_settings\"")
			}
		case "monitoring_sensitivity":
			if err := func() error {
				s.MonitoringSensitivity.Reset()
				if err := s.MonitoringSensitivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitoring_sensitivity\"")
			}
		case "emergency_protocols":
			if err := func() error {
				s.EmergencyProtocols.Reset()
				if err := s.EmergencyProtocols.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emergency_protocols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralLinkRequest) {
					name = jsonFieldsNameOfUpdateNeuralLinkRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateNeuralLinkRequestCalibrationSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateNeuralLinkRequestCalibrationSettings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UpdateNeuralLinkRequestCalibrationSettings from json.
func (s *UpdateNeuralLinkRequestCalibrationSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequestCalibrationSettings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkRequestCalibrationSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNeuralLinkRequestCalibrationSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequestCalibrationSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateNeuralLinkRequestEmergencyProtocols) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateNeuralLinkRequestEmergencyProtocols) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UpdateNeuralLinkRequestEmergencyProtocols from json.
func (s *UpdateNeuralLinkRequestEmergencyProtocols) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequestEmergencyProtocols to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkRequestEmergencyProtocols")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNeuralLinkRequestEmergencyProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequestEmergencyProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkRequestMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkRequestMetadata = [2]string{
	0: "updated_by",
	1: "reason",
}

// Decode decodes UpdateNeuralLinkRequestMetadata from json.
func (s *UpdateNeuralLinkRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestMonitoringSensitivity as json.
func (s UpdateNeuralLinkRequestMonitoringSensitivity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateNeuralLinkRequestMonitoringSensitivity from json.
func (s *UpdateNeuralLinkRequestMonitoringSensitivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequestMonitoringSensitivity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateNeuralLinkRequestMonitoringSensitivity(v) {
	case UpdateNeuralLinkRequestMonitoringSensitivityLOW:
		*s = UpdateNeuralLinkRequestMonitoringSensitivityLOW
	case UpdateNeuralLinkRequestMonitoringSensitivityMEDIUM:
		*s = UpdateNeuralLinkRequestMonitoringSensitivityMEDIUM
	case UpdateNeuralLinkRequestMonitoringSensitivityHIGH:
		*s = UpdateNeuralLinkRequestMonitoringSensitivityHIGH
	default:
		*s = UpdateNeuralLinkRequestMonitoringSensitivity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNeuralLinkRequestMonitoringSensitivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequestMonitoringSensitivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNeuralLinkRequestSecurityClearanceUpgrade as json.
func (s UpdateNeuralLinkRequestSecurityClearanceUpgrade) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateNeuralLinkRequestSecurityClearanceUpgrade from json.
func (s *UpdateNeuralLinkRequestSecurityClearanceUpgrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkRequestSecurityClearanceUpgrade to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateNeuralLinkRequestSecurityClearanceUpgrade(v) {
	case UpdateNeuralLinkRequestSecurityClearanceUpgradeSTANDARD:
		*s = UpdateNeuralLinkRequestSecurityClearanceUpgradeSTANDARD
	case UpdateNeuralLinkRequestSecurityClearanceUpgradeELEVATED:
		*s = UpdateNeuralLinkRequestSecurityClearanceUpgradeELEVATED
	case UpdateNeuralLinkRequestSecurityClearanceUpgradeMAXIMUM:
		*s = UpdateNeuralLinkRequestSecurityClearanceUpgradeMAXIMUM
	default:
		*s = UpdateNeuralLinkRequestSecurityClearanceUpgrade(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateNeuralLinkRequestSecurityClearanceUpgrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkRequestSecurityClearanceUpgrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkTooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkTooManyRequests) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNeuralLinkTooManyRequests = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateNeuralLinkTooManyRequests from json.
func (s *UpdateNeuralLinkTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkTooManyRequests to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateNeuralLinkTooManyRequestsDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkTooManyRequests")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNeuralLinkTooManyRequests) {
					name = jsonFieldsNameOfUpdateNeuralLinkTooManyRequests[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNeuralLinkTooManyRequestsDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNeuralLinkTooManyRequestsDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateNeuralLinkTooManyRequestsDetails = [0]string{}

// Decode decodes UpdateNeuralLinkTooManyRequestsDetails from json.
func (s *UpdateNeuralLinkTooManyRequestsDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNeuralLinkTooManyRequestsDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNeuralLinkTooManyRequestsDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNeuralLinkTooManyRequestsDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNeuralLinkTooManyRequestsDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.MessageTimestamp.Set {
			e.FieldStart("message_timestamp")
			s.MessageTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("health")
		s.Health.Encode(e)
	}
}

var jsonFieldsNameOfWebSocketHealthMessage = [4]string{
	0: "type",
	1: "timestamp",
	2: "message_timestamp",
	3: "health",
}

// Decode decodes WebSocketHealthMessage from json.
func (s *WebSocketHealthMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "message_timestamp":
			if err := func() error {
				s.MessageTimestamp.Reset()
				if err := s.MessageTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_timestamp\"")
			}
		case "health":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Health.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessage) {
					name = jsonFieldsNameOfWebSocketHealthMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebSocketHealthMessageHealth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebSocketHealthMessageHealth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebSocketHealthMessageHealth = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes WebSocketHealthMessageHealth from json.
func (s *WebSocketHealthMessageHealth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebSocketHealthMessageHealth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebSocketHealthMessageHealth) {
					name = jsonFieldsNameOfWebSocketHealthMessageHealth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebSocketHealthMessageHealth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageHealthStatus as json.
func (s WebSocketHealthMessageHealthStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageHealthStatus from json.
func (s *WebSocketHealthMessageHealthStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageHealthStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageHealthStatus(v) {
	case WebSocketHealthMessageHealthStatusHealthy:
		*s = WebSocketHealthMessageHealthStatusHealthy
	case WebSocketHealthMessageHealthStatusDegraded:
		*s = WebSocketHealthMessageHealthStatusDegraded
	case WebSocketHealthMessageHealthStatusUnhealthy:
		*s = WebSocketHealthMessageHealthStatusUnhealthy
	default:
		*s = WebSocketHealthMessageHealthStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageHealthStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageHealthStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebSocketHealthMessageType as json.
func (s WebSocketHealthMessageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebSocketHealthMessageType from json.
func (s *WebSocketHealthMessageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebSocketHealthMessageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebSocketHealthMessageType(v) {
	case WebSocketHealthMessageTypeHealthUpdate:
		*s = WebSocketHealthMessageTypeHealthUpdate
	case WebSocketHealthMessageTypeHealthAlert:
		*s = WebSocketHealthMessageTypeHealthAlert
	case WebSocketHealthMessageTypeServiceDown:
		*s = WebSocketHealthMessageTypeServiceDown
	default:
		*s = WebSocketHealthMessageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebSocketHealthMessageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebSocketHealthMessageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
