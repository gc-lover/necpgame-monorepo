// Code generated by ogen, DO NOT EDIT.

package main

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AcceptContractRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AcceptContractRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("contract_id")
		json.EncodeUUID(e, s.ContractID)
	}
}

var jsonFieldsNameOfAcceptContractRequest = [2]string{
	0: "player_id",
	1: "contract_id",
}

// Decode decodes AcceptContractRequest from json.
func (s *AcceptContractRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AcceptContractRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "contract_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ContractID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AcceptContractRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAcceptContractRequest) {
					name = jsonFieldsNameOfAcceptContractRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AcceptContractRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AcceptContractRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimTerritoryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimTerritoryRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("territory_id")
		json.EncodeUUID(e, s.TerritoryID)
	}
	{
		e.FieldStart("guild_id")
		json.EncodeUUID(e, s.GuildID)
	}
	{
		if s.CapturePoints.Set {
			e.FieldStart("capture_points")
			s.CapturePoints.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimTerritoryRequest = [3]string{
	0: "territory_id",
	1: "guild_id",
	2: "capture_points",
}

// Decode decodes ClaimTerritoryRequest from json.
func (s *ClaimTerritoryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimTerritoryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "territory_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TerritoryID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territory_id\"")
			}
		case "guild_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.GuildID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guild_id\"")
			}
		case "capture_points":
			if err := func() error {
				s.CapturePoints.Reset()
				if err := s.CapturePoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capture_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimTerritoryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimTerritoryRequest) {
					name = jsonFieldsNameOfClaimTerritoryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimTerritoryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimTerritoryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteContractRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteContractRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteContractRequest = [3]string{
	0: "player_id",
	1: "success",
	2: "completion_time",
}

// Decode decodes CompleteContractRequest from json.
func (s *CompleteContractRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteContractRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteContractRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteContractRequest) {
					name = jsonFieldsNameOfCompleteContractRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteContractRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteContractRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteObjectiveRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteObjectiveRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("objective_id")
		json.EncodeUUID(e, s.ObjectiveID)
	}
	{
		if s.ProgressIncrement.Set {
			e.FieldStart("progress_increment")
			s.ProgressIncrement.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteObjectiveRequest = [2]string{
	0: "objective_id",
	1: "progress_increment",
}

// Decode decodes CompleteObjectiveRequest from json.
func (s *CompleteObjectiveRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteObjectiveRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "objective_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ObjectiveID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_id\"")
			}
		case "progress_increment":
			if err := func() error {
				s.ProgressIncrement.Reset()
				if err := s.ProgressIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_increment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteObjectiveRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteObjectiveRequest) {
					name = jsonFieldsNameOfCompleteObjectiveRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteObjectiveRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteObjectiveRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteQuestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteQuestRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ForceComplete.Set {
			e.FieldStart("force_complete")
			s.ForceComplete.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteQuestRequest = [2]string{
	0: "force_complete",
	1: "metadata",
}

// Decode decodes CompleteQuestRequest from json.
func (s *CompleteQuestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteQuestRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force_complete":
			if err := func() error {
				s.ForceComplete.Reset()
				if err := s.ForceComplete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_complete\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem CompleteQuestRequestMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteQuestRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteQuestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteQuestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteQuestRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteQuestRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCompleteQuestRequestMetadata = [0]string{}

// Decode decodes CompleteQuestRequestMetadata from json.
func (s *CompleteQuestRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteQuestRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CompleteQuestRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteQuestRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteQuestRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContractCompletionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContractCompletionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContractID.Set {
			e.FieldStart("contract_id")
			s.ContractID.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.ReputationGained.Set {
			e.FieldStart("reputation_gained")
			s.ReputationGained.Encode(e)
		}
	}
	{
		if s.CreditsEarned.Set {
			e.FieldStart("credits_earned")
			s.CreditsEarned.Encode(e)
		}
	}
	{
		if s.FactionReputation.Set {
			e.FieldStart("faction_reputation")
			s.FactionReputation.Encode(e)
		}
	}
}

var jsonFieldsNameOfContractCompletionResponse = [5]string{
	0: "contract_id",
	1: "success",
	2: "reputation_gained",
	3: "credits_earned",
	4: "faction_reputation",
}

// Decode decodes ContractCompletionResponse from json.
func (s *ContractCompletionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractCompletionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contract_id":
			if err := func() error {
				s.ContractID.Reset()
				if err := s.ContractID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_id\"")
			}
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "reputation_gained":
			if err := func() error {
				s.ReputationGained.Reset()
				if err := s.ReputationGained.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_gained\"")
			}
		case "credits_earned":
			if err := func() error {
				s.CreditsEarned.Reset()
				if err := s.CreditsEarned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credits_earned\"")
			}
		case "faction_reputation":
			if err := func() error {
				s.FactionReputation.Reset()
				if err := s.FactionReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_reputation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractCompletionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContractCompletionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractCompletionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ContractCompletionResponseFactionReputation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ContractCompletionResponseFactionReputation) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes ContractCompletionResponseFactionReputation from json.
func (s *ContractCompletionResponseFactionReputation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractCompletionResponseFactionReputation to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractCompletionResponseFactionReputation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContractCompletionResponseFactionReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractCompletionResponseFactionReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContractListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContractListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Contracts != nil {
			e.FieldStart("contracts")
			e.ArrStart()
			for _, elem := range s.Contracts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PlayerReputation.Set {
			e.FieldStart("player_reputation")
			s.PlayerReputation.Encode(e)
		}
	}
}

var jsonFieldsNameOfContractListResponse = [2]string{
	0: "contracts",
	1: "player_reputation",
}

// Decode decodes ContractListResponse from json.
func (s *ContractListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contracts":
			if err := func() error {
				s.Contracts = make([]ReputationContract, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReputationContract
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contracts = append(s.Contracts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contracts\"")
			}
		case "player_reputation":
			if err := func() error {
				s.PlayerReputation.Reset()
				if err := s.PlayerReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_reputation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContractListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ContractListResponsePlayerReputation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ContractListResponsePlayerReputation) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes ContractListResponsePlayerReputation from json.
func (s *ContractListResponsePlayerReputation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractListResponsePlayerReputation to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractListResponsePlayerReputation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContractListResponsePlayerReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractListResponsePlayerReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContractResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContractResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContractID.Set {
			e.FieldStart("contract_id")
			s.ContractID.Encode(e)
		}
	}
	{
		if s.Contract.Set {
			e.FieldStart("contract")
			s.Contract.Encode(e)
		}
	}
	{
		if s.AcceptedAt.Set {
			e.FieldStart("accepted_at")
			s.AcceptedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfContractResponse = [4]string{
	0: "contract_id",
	1: "contract",
	2: "accepted_at",
	3: "expires_at",
}

// Decode decodes ContractResponse from json.
func (s *ContractResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contract_id":
			if err := func() error {
				s.ContractID.Reset()
				if err := s.ContractID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_id\"")
			}
		case "contract":
			if err := func() error {
				s.Contract.Reset()
				if err := s.Contract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract\"")
			}
		case "accepted_at":
			if err := func() error {
				s.AcceptedAt.Reset()
				if err := s.AcceptedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accepted_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContractResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateQuestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateQuestRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quest_type")
		s.QuestType.Encode(e)
	}
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("template_id")
		json.EncodeUUID(e, s.TemplateID)
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateQuestRequest = [4]string{
	0: "quest_type",
	1: "player_id",
	2: "template_id",
	3: "parameters",
}

// Decode decodes CreateQuestRequest from json.
func (s *CreateQuestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateQuestRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.QuestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_type\"")
			}
		case "player_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "template_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = nil
				var elem CreateQuestRequestParameters
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parameters = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateQuestRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateQuestRequest) {
					name = jsonFieldsNameOfCreateQuestRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateQuestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateQuestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateQuestRequestParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateQuestRequestParameters) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateQuestRequestParameters = [0]string{}

// Decode decodes CreateQuestRequestParameters from json.
func (s *CreateQuestRequestParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateQuestRequestParameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateQuestRequestParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateQuestRequestParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateQuestRequestParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberActionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberActionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action_type")
		s.ActionType.Encode(e)
	}
	{
		if s.TargetNodeID.Set {
			e.FieldStart("target_node_id")
			s.TargetNodeID.Encode(e)
		}
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberActionRequest = [3]string{
	0: "action_type",
	1: "target_node_id",
	2: "parameters",
}

// Decode decodes CyberActionRequest from json.
func (s *CyberActionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "target_node_id":
			if err := func() error {
				s.TargetNodeID.Reset()
				if err := s.TargetNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_node_id\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = nil
				var elem CyberActionRequestParameters
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parameters = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberActionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCyberActionRequest) {
					name = jsonFieldsNameOfCyberActionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberActionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CyberActionRequestActionType as json.
func (s CyberActionRequestActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CyberActionRequestActionType from json.
func (s *CyberActionRequestActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionRequestActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CyberActionRequestActionType(v) {
	case CyberActionRequestActionTypeMove:
		*s = CyberActionRequestActionTypeMove
	case CyberActionRequestActionTypeHack:
		*s = CyberActionRequestActionTypeHack
	case CyberActionRequestActionTypeDefend:
		*s = CyberActionRequestActionTypeDefend
	case CyberActionRequestActionTypeExtractData:
		*s = CyberActionRequestActionTypeExtractData
	case CyberActionRequestActionTypeCombat:
		*s = CyberActionRequestActionTypeCombat
	default:
		*s = CyberActionRequestActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CyberActionRequestActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionRequestActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberActionRequestParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberActionRequestParameters) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCyberActionRequestParameters = [0]string{}

// Decode decodes CyberActionRequestParameters from json.
func (s *CyberActionRequestParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionRequestParameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CyberActionRequestParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberActionRequestParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionRequestParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberActionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberActionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ActionSuccess.Set {
			e.FieldStart("action_success")
			s.ActionSuccess.Encode(e)
		}
	}
	{
		if s.ActionResult != nil {
			e.FieldStart("action_result")
			s.ActionResult.Encode(e)
		}
	}
	{
		if s.SessionState != nil {
			e.FieldStart("session_state")
			s.SessionState.Encode(e)
		}
	}
	{
		if s.IceEncountered.Set {
			e.FieldStart("ice_encountered")
			s.IceEncountered.Encode(e)
		}
	}
	{
		if s.DataExtracted.Set {
			e.FieldStart("data_extracted")
			s.DataExtracted.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberActionResponse = [5]string{
	0: "action_success",
	1: "action_result",
	2: "session_state",
	3: "ice_encountered",
	4: "data_extracted",
}

// Decode decodes CyberActionResponse from json.
func (s *CyberActionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_success":
			if err := func() error {
				s.ActionSuccess.Reset()
				if err := s.ActionSuccess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_success\"")
			}
		case "action_result":
			if err := func() error {
				s.ActionResult = nil
				var elem CyberActionResponseActionResult
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ActionResult = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_result\"")
			}
		case "session_state":
			if err := func() error {
				s.SessionState = nil
				var elem CyberActionResponseSessionState
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.SessionState = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_state\"")
			}
		case "ice_encountered":
			if err := func() error {
				s.IceEncountered.Reset()
				if err := s.IceEncountered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ice_encountered\"")
			}
		case "data_extracted":
			if err := func() error {
				s.DataExtracted.Reset()
				if err := s.DataExtracted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_extracted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberActionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberActionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberActionResponseActionResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberActionResponseActionResult) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCyberActionResponseActionResult = [0]string{}

// Decode decodes CyberActionResponseActionResult from json.
func (s *CyberActionResponseActionResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionResponseActionResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CyberActionResponseActionResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberActionResponseActionResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionResponseActionResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberActionResponseSessionState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberActionResponseSessionState) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCyberActionResponseSessionState = [0]string{}

// Decode decodes CyberActionResponseSessionState from json.
func (s *CyberActionResponseSessionState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberActionResponseSessionState to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CyberActionResponseSessionState")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberActionResponseSessionState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberActionResponseSessionState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CyberDifficulty as json.
func (s CyberDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CyberDifficulty from json.
func (s *CyberDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CyberDifficulty(v) {
	case CyberDifficultyBeginner:
		*s = CyberDifficultyBeginner
	case CyberDifficultyIntermediate:
		*s = CyberDifficultyIntermediate
	case CyberDifficultyAdvanced:
		*s = CyberDifficultyAdvanced
	case CyberDifficultyExpert:
		*s = CyberDifficultyExpert
	case CyberDifficultyLegendary:
		*s = CyberDifficultyLegendary
	default:
		*s = CyberDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CyberDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberExitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberExitResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.TotalDataExtracted.Set {
			e.FieldStart("total_data_extracted")
			s.TotalDataExtracted.Encode(e)
		}
	}
	{
		if s.TimeSpent.Set {
			e.FieldStart("time_spent")
			s.TimeSpent.Encode(e)
		}
	}
	{
		if s.PsychologicalImpact.Set {
			e.FieldStart("psychological_impact")
			s.PsychologicalImpact.Encode(e)
		}
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberExitResponse = [6]string{
	0: "session_id",
	1: "success",
	2: "total_data_extracted",
	3: "time_spent",
	4: "psychological_impact",
	5: "rewards",
}

// Decode decodes CyberExitResponse from json.
func (s *CyberExitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberExitResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "total_data_extracted":
			if err := func() error {
				s.TotalDataExtracted.Reset()
				if err := s.TotalDataExtracted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_data_extracted\"")
			}
		case "time_spent":
			if err := func() error {
				s.TimeSpent.Reset()
				if err := s.TimeSpent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_spent\"")
			}
		case "psychological_impact":
			if err := func() error {
				s.PsychologicalImpact.Reset()
				if err := s.PsychologicalImpact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"psychological_impact\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberExitResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberExitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberExitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberMission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberMission) encodeFields(e *jx.Encoder) {
	{
		if s.MissionID.Set {
			e.FieldStart("mission_id")
			s.MissionID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
	{
		if s.EstimatedDuration.Set {
			e.FieldStart("estimated_duration")
			s.EstimatedDuration.Encode(e)
		}
	}
	{
		if s.PotentialRewards.Set {
			e.FieldStart("potential_rewards")
			s.PotentialRewards.Encode(e)
		}
	}
	{
		if s.RequiredLevel.Set {
			e.FieldStart("required_level")
			s.RequiredLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberMission = [7]string{
	0: "mission_id",
	1: "title",
	2: "description",
	3: "difficulty",
	4: "estimated_duration",
	5: "potential_rewards",
	6: "required_level",
}

// Decode decodes CyberMission from json.
func (s *CyberMission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberMission to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mission_id":
			if err := func() error {
				s.MissionID.Reset()
				if err := s.MissionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mission_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "estimated_duration":
			if err := func() error {
				s.EstimatedDuration.Reset()
				if err := s.EstimatedDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_duration\"")
			}
		case "potential_rewards":
			if err := func() error {
				s.PotentialRewards.Reset()
				if err := s.PotentialRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"potential_rewards\"")
			}
		case "required_level":
			if err := func() error {
				s.RequiredLevel.Reset()
				if err := s.RequiredLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberMission")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberMission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberMission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberMissionListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberMissionListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Missions != nil {
			e.FieldStart("missions")
			e.ArrStart()
			for _, elem := range s.Missions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PlayerLevel.Set {
			e.FieldStart("player_level")
			s.PlayerLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberMissionListResponse = [2]string{
	0: "missions",
	1: "player_level",
}

// Decode decodes CyberMissionListResponse from json.
func (s *CyberMissionListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberMissionListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "missions":
			if err := func() error {
				s.Missions = make([]CyberMission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CyberMission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Missions = append(s.Missions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missions\"")
			}
		case "player_level":
			if err := func() error {
				s.PlayerLevel.Reset()
				if err := s.PlayerLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberMissionListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberMissionListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberMissionListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberRewards) encodeFields(e *jx.Encoder) {
	{
		if s.DataFragments.Set {
			e.FieldStart("data_fragments")
			s.DataFragments.Encode(e)
		}
	}
	{
		if s.SoftwareUpgrades != nil {
			e.FieldStart("software_upgrades")
			e.ArrStart()
			for _, elem := range s.SoftwareUpgrades {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReputationBoost.Set {
			e.FieldStart("reputation_boost")
			s.ReputationBoost.Encode(e)
		}
	}
}

var jsonFieldsNameOfCyberRewards = [3]string{
	0: "data_fragments",
	1: "software_upgrades",
	2: "reputation_boost",
}

// Decode decodes CyberRewards from json.
func (s *CyberRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_fragments":
			if err := func() error {
				s.DataFragments.Reset()
				if err := s.DataFragments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_fragments\"")
			}
		case "software_upgrades":
			if err := func() error {
				s.SoftwareUpgrades = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SoftwareUpgrades = append(s.SoftwareUpgrades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"software_upgrades\"")
			}
		case "reputation_boost":
			if err := func() error {
				s.ReputationBoost.Reset()
				if err := s.ReputationBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_boost\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberSessionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberSessionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.PlayerID.Set {
			e.FieldStart("player_id")
			s.PlayerID.Encode(e)
		}
	}
	{
		if s.Mission.Set {
			e.FieldStart("mission")
			s.Mission.Encode(e)
		}
	}
	{
		if s.CyberspaceMap != nil {
			e.FieldStart("cyberspace_map")
			s.CyberspaceMap.Encode(e)
		}
	}
	{
		if s.SessionStartTime.Set {
			e.FieldStart("session_start_time")
			s.SessionStartTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCyberSessionResponse = [5]string{
	0: "session_id",
	1: "player_id",
	2: "mission",
	3: "cyberspace_map",
	4: "session_start_time",
}

// Decode decodes CyberSessionResponse from json.
func (s *CyberSessionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberSessionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "player_id":
			if err := func() error {
				s.PlayerID.Reset()
				if err := s.PlayerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "mission":
			if err := func() error {
				s.Mission.Reset()
				if err := s.Mission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mission\"")
			}
		case "cyberspace_map":
			if err := func() error {
				s.CyberspaceMap = nil
				var elem CyberSessionResponseCyberspaceMap
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CyberspaceMap = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberspace_map\"")
			}
		case "session_start_time":
			if err := func() error {
				s.SessionStartTime.Reset()
				if err := s.SessionStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_start_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CyberSessionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberSessionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberSessionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CyberSessionResponseCyberspaceMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CyberSessionResponseCyberspaceMap) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCyberSessionResponseCyberspaceMap = [0]string{}

// Decode decodes CyberSessionResponseCyberspaceMap from json.
func (s *CyberSessionResponseCyberspaceMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CyberSessionResponseCyberspaceMap to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CyberSessionResponseCyberspaceMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CyberSessionResponseCyberspaceMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CyberSessionResponseCyberspaceMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclareWarRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclareWarRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacker_guild_id")
		json.EncodeUUID(e, s.AttackerGuildID)
	}
	{
		e.FieldStart("defender_guild_id")
		json.EncodeUUID(e, s.DefenderGuildID)
	}
	{
		e.FieldStart("territories")
		e.ArrStart()
		for _, elem := range s.Territories {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.WarDurationHours.Set {
			e.FieldStart("war_duration_hours")
			s.WarDurationHours.Encode(e)
		}
	}
	{
		if s.WarType.Set {
			e.FieldStart("war_type")
			s.WarType.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeclareWarRequest = [5]string{
	0: "attacker_guild_id",
	1: "defender_guild_id",
	2: "territories",
	3: "war_duration_hours",
	4: "war_type",
}

// Decode decodes DeclareWarRequest from json.
func (s *DeclareWarRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareWarRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_guild_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AttackerGuildID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_guild_id\"")
			}
		case "defender_guild_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DefenderGuildID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_guild_id\"")
			}
		case "territories":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Territories = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Territories = append(s.Territories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories\"")
			}
		case "war_duration_hours":
			if err := func() error {
				s.WarDurationHours.Reset()
				if err := s.WarDurationHours.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"war_duration_hours\"")
			}
		case "war_type":
			if err := func() error {
				s.WarType.Reset()
				if err := s.WarType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"war_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeclareWarRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclareWarRequest) {
					name = jsonFieldsNameOfDeclareWarRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclareWarRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareWarRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeclareWarRequestWarType as json.
func (s DeclareWarRequestWarType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeclareWarRequestWarType from json.
func (s *DeclareWarRequestWarType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareWarRequestWarType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeclareWarRequestWarType(v) {
	case DeclareWarRequestWarTypeTerritorial:
		*s = DeclareWarRequestWarTypeTerritorial
	case DeclareWarRequestWarTypeResource:
		*s = DeclareWarRequestWarTypeResource
	case DeclareWarRequestWarTypeRevenge:
		*s = DeclareWarRequestWarTypeRevenge
	default:
		*s = DeclareWarRequestWarType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeclareWarRequestWarType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareWarRequestWarType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterCyberSpaceRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterCyberSpaceRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("mission_id")
		json.EncodeUUID(e, s.MissionID)
	}
	{
		if s.DeckConfiguration != nil {
			e.FieldStart("deck_configuration")
			s.DeckConfiguration.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterCyberSpaceRequest = [3]string{
	0: "player_id",
	1: "mission_id",
	2: "deck_configuration",
}

// Decode decodes EnterCyberSpaceRequest from json.
func (s *EnterCyberSpaceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterCyberSpaceRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "mission_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.MissionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mission_id\"")
			}
		case "deck_configuration":
			if err := func() error {
				s.DeckConfiguration = nil
				var elem EnterCyberSpaceRequestDeckConfiguration
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.DeckConfiguration = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deck_configuration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterCyberSpaceRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterCyberSpaceRequest) {
					name = jsonFieldsNameOfEnterCyberSpaceRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterCyberSpaceRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterCyberSpaceRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterCyberSpaceRequestDeckConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterCyberSpaceRequestDeckConfiguration) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEnterCyberSpaceRequestDeckConfiguration = [0]string{}

// Decode decodes EnterCyberSpaceRequestDeckConfiguration from json.
func (s *EnterCyberSpaceRequestDeckConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterCyberSpaceRequestDeckConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EnterCyberSpaceRequestDeckConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterCyberSpaceRequestDeckConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterCyberSpaceRequestDeckConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuildInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuildInfo) encodeFields(e *jx.Encoder) {
	{
		if s.GuildID.Set {
			e.FieldStart("guild_id")
			s.GuildID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
}

var jsonFieldsNameOfGuildInfo = [3]string{
	0: "guild_id",
	1: "name",
	2: "level",
}

// Decode decodes GuildInfo from json.
func (s *GuildInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuildInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "guild_id":
			if err := func() error {
				s.GuildID.Reset()
				if err := s.GuildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guild_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuildInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuildInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuildInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuildWarListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuildWarListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Wars != nil {
			e.FieldStart("wars")
			e.ArrStart()
			for _, elem := range s.Wars {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfGuildWarListResponse = [2]string{
	0: "wars",
	1: "total_count",
}

// Decode decodes GuildWarListResponse from json.
func (s *GuildWarListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuildWarListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wars":
			if err := func() error {
				s.Wars = make([]GuildWarSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GuildWarSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Wars = append(s.Wars, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wars\"")
			}
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuildWarListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuildWarListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuildWarListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuildWarResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuildWarResponse) encodeFields(e *jx.Encoder) {
	{
		if s.WarID.Set {
			e.FieldStart("war_id")
			s.WarID.Encode(e)
		}
	}
	{
		if s.AttackerGuild.Set {
			e.FieldStart("attacker_guild")
			s.AttackerGuild.Encode(e)
		}
	}
	{
		if s.DefenderGuild.Set {
			e.FieldStart("defender_guild")
			s.DefenderGuild.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Territories != nil {
			e.FieldStart("territories")
			e.ArrStart()
			for _, elem := range s.Territories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndsAt.Set {
			e.FieldStart("ends_at")
			s.EndsAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGuildWarResponse = [8]string{
	0: "war_id",
	1: "attacker_guild",
	2: "defender_guild",
	3: "status",
	4: "territories",
	5: "statistics",
	6: "started_at",
	7: "ends_at",
}

// Decode decodes GuildWarResponse from json.
func (s *GuildWarResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuildWarResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "war_id":
			if err := func() error {
				s.WarID.Reset()
				if err := s.WarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"war_id\"")
			}
		case "attacker_guild":
			if err := func() error {
				s.AttackerGuild.Reset()
				if err := s.AttackerGuild.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_guild\"")
			}
		case "defender_guild":
			if err := func() error {
				s.DefenderGuild.Reset()
				if err := s.DefenderGuild.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_guild\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "territories":
			if err := func() error {
				s.Territories = make([]WarTerritory, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WarTerritory
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Territories = append(s.Territories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "ends_at":
			if err := func() error {
				s.EndsAt.Reset()
				if err := s.EndsAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ends_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuildWarResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuildWarResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuildWarResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuildWarSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuildWarSummary) encodeFields(e *jx.Encoder) {
	{
		if s.WarID.Set {
			e.FieldStart("war_id")
			s.WarID.Encode(e)
		}
	}
	{
		if s.AttackerGuildID.Set {
			e.FieldStart("attacker_guild_id")
			s.AttackerGuildID.Encode(e)
		}
	}
	{
		if s.DefenderGuildID.Set {
			e.FieldStart("defender_guild_id")
			s.DefenderGuildID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TerritoriesClaimed.Set {
			e.FieldStart("territories_claimed")
			s.TerritoriesClaimed.Encode(e)
		}
	}
	{
		if s.Casualties.Set {
			e.FieldStart("casualties")
			s.Casualties.Encode(e)
		}
	}
	{
		if s.DurationHours.Set {
			e.FieldStart("duration_hours")
			s.DurationHours.Encode(e)
		}
	}
}

var jsonFieldsNameOfGuildWarSummary = [7]string{
	0: "war_id",
	1: "attacker_guild_id",
	2: "defender_guild_id",
	3: "status",
	4: "territories_claimed",
	5: "casualties",
	6: "duration_hours",
}

// Decode decodes GuildWarSummary from json.
func (s *GuildWarSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuildWarSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "war_id":
			if err := func() error {
				s.WarID.Reset()
				if err := s.WarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"war_id\"")
			}
		case "attacker_guild_id":
			if err := func() error {
				s.AttackerGuildID.Reset()
				if err := s.AttackerGuildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_guild_id\"")
			}
		case "defender_guild_id":
			if err := func() error {
				s.DefenderGuildID.Reset()
				if err := s.DefenderGuildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_guild_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "territories_claimed":
			if err := func() error {
				s.TerritoriesClaimed.Reset()
				if err := s.TerritoriesClaimed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories_claimed\"")
			}
		case "casualties":
			if err := func() error {
				s.Casualties.Reset()
				if err := s.Casualties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"casualties\"")
			}
		case "duration_hours":
			if err := func() error {
				s.DurationHours.Reset()
				if err := s.DurationHours.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_hours\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuildWarSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuildWarSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuildWarSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveQuests.Set {
			e.FieldStart("active_quests")
			s.ActiveQuests.Encode(e)
		}
	}
	{
		if s.ActiveWars.Set {
			e.FieldStart("active_wars")
			s.ActiveWars.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [6]string{
	0: "status",
	1: "timestamp",
	2: "version",
	3: "uptime_seconds",
	4: "active_quests",
	5: "active_wars",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_quests":
			if err := func() error {
				s.ActiveQuests.Reset()
				if err := s.ActiveQuests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_quests\"")
			}
		case "active_wars":
			if err := func() error {
				s.ActiveWars.Reset()
				if err := s.ActiveWars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_wars\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	case HealthResponseStatusDegraded:
		*s = HealthResponseStatusDegraded
	case HealthResponseStatusUnhealthy:
		*s = HealthResponseStatusUnhealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Intrigue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Intrigue) encodeFields(e *jx.Encoder) {
	{
		if s.IntrigueID.Set {
			e.FieldStart("intrigue_id")
			s.IntrigueID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.InvolvedFactions != nil {
			e.FieldStart("involved_factions")
			e.ArrStart()
			for _, elem := range s.InvolvedFactions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PlayerRole.Set {
			e.FieldStart("player_role")
			s.PlayerRole.Encode(e)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progress_percentage")
			s.ProgressPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntrigue = [6]string{
	0: "intrigue_id",
	1: "title",
	2: "description",
	3: "involved_factions",
	4: "player_role",
	5: "progress_percentage",
}

// Decode decodes Intrigue from json.
func (s *Intrigue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Intrigue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "intrigue_id":
			if err := func() error {
				s.IntrigueID.Reset()
				if err := s.IntrigueID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrigue_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "involved_factions":
			if err := func() error {
				s.InvolvedFactions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.InvolvedFactions = append(s.InvolvedFactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"involved_factions\"")
			}
		case "player_role":
			if err := func() error {
				s.PlayerRole.Reset()
				if err := s.PlayerRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_role\"")
			}
		case "progress_percentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Intrigue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Intrigue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Intrigue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntrigueListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntrigueListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Intrigues != nil {
			e.FieldStart("intrigues")
			e.ArrStart()
			for _, elem := range s.Intrigues {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIntrigueListResponse = [1]string{
	0: "intrigues",
}

// Decode decodes IntrigueListResponse from json.
func (s *IntrigueListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntrigueListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "intrigues":
			if err := func() error {
				s.Intrigues = make([]Intrigue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Intrigue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Intrigues = append(s.Intrigues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrigues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntrigueListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntrigueListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntrigueListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntrigueResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntrigueResponse) encodeFields(e *jx.Encoder) {
	{
		if s.IntrigueID.Set {
			e.FieldStart("intrigue_id")
			s.IntrigueID.Encode(e)
		}
	}
	{
		if s.Intrigue.Set {
			e.FieldStart("intrigue")
			s.Intrigue.Encode(e)
		}
	}
	{
		if s.FirstDecision.Set {
			e.FieldStart("first_decision")
			s.FirstDecision.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntrigueResponse = [3]string{
	0: "intrigue_id",
	1: "intrigue",
	2: "first_decision",
}

// Decode decodes IntrigueResponse from json.
func (s *IntrigueResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntrigueResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "intrigue_id":
			if err := func() error {
				s.IntrigueID.Reset()
				if err := s.IntrigueID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrigue_id\"")
			}
		case "intrigue":
			if err := func() error {
				s.Intrigue.Reset()
				if err := s.Intrigue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrigue\"")
			}
		case "first_decision":
			if err := func() error {
				s.FirstDecision.Reset()
				if err := s.FirstDecision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_decision\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntrigueResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntrigueResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntrigueResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntrigueResponseFirstDecision) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntrigueResponseFirstDecision) encodeFields(e *jx.Encoder) {
	{
		if s.Question.Set {
			e.FieldStart("question")
			s.Question.Encode(e)
		}
	}
	{
		if s.Choices != nil {
			e.FieldStart("choices")
			e.ArrStart()
			for _, elem := range s.Choices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIntrigueResponseFirstDecision = [2]string{
	0: "question",
	1: "choices",
}

// Decode decodes IntrigueResponseFirstDecision from json.
func (s *IntrigueResponseFirstDecision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntrigueResponseFirstDecision to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "question":
			if err := func() error {
				s.Question.Reset()
				if err := s.Question.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question\"")
			}
		case "choices":
			if err := func() error {
				s.Choices = make([]IntrigueResponseFirstDecisionChoicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IntrigueResponseFirstDecisionChoicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Choices = append(s.Choices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"choices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntrigueResponseFirstDecision")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntrigueResponseFirstDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntrigueResponseFirstDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntrigueResponseFirstDecisionChoicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntrigueResponseFirstDecisionChoicesItem) encodeFields(e *jx.Encoder) {
	{
		if s.ChoiceID.Set {
			e.FieldStart("choice_id")
			s.ChoiceID.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Consequences.Set {
			e.FieldStart("consequences")
			s.Consequences.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntrigueResponseFirstDecisionChoicesItem = [3]string{
	0: "choice_id",
	1: "text",
	2: "consequences",
}

// Decode decodes IntrigueResponseFirstDecisionChoicesItem from json.
func (s *IntrigueResponseFirstDecisionChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntrigueResponseFirstDecisionChoicesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "choice_id":
			if err := func() error {
				s.ChoiceID.Reset()
				if err := s.ChoiceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"choice_id\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "consequences":
			if err := func() error {
				s.Consequences.Reset()
				if err := s.Consequences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consequences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntrigueResponseFirstDecisionChoicesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntrigueResponseFirstDecisionChoicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntrigueResponseFirstDecisionChoicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectiveResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectiveResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectiveID.Set {
			e.FieldStart("objective_id")
			s.ObjectiveID.Encode(e)
		}
	}
	{
		if s.Completed.Set {
			e.FieldStart("completed")
			s.Completed.Encode(e)
		}
	}
	{
		if s.NewProgress.Set {
			e.FieldStart("new_progress")
			s.NewProgress.Encode(e)
		}
	}
	{
		if s.RewardsGranted.Set {
			e.FieldStart("rewards_granted")
			s.RewardsGranted.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectiveResponse = [4]string{
	0: "objective_id",
	1: "completed",
	2: "new_progress",
	3: "rewards_granted",
}

// Decode decodes ObjectiveResponse from json.
func (s *ObjectiveResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectiveResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "objective_id":
			if err := func() error {
				s.ObjectiveID.Reset()
				if err := s.ObjectiveID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_id\"")
			}
		case "completed":
			if err := func() error {
				s.Completed.Reset()
				if err := s.Completed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		case "new_progress":
			if err := func() error {
				s.NewProgress.Reset()
				if err := s.NewProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_progress\"")
			}
		case "rewards_granted":
			if err := func() error {
				s.RewardsGranted.Reset()
				if err := s.RewardsGranted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards_granted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectiveResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectiveResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectiveResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContractCompletionResponseFactionReputation as json.
func (o OptContractCompletionResponseFactionReputation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContractCompletionResponseFactionReputation from json.
func (o *OptContractCompletionResponseFactionReputation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContractCompletionResponseFactionReputation to nil")
	}
	o.Set = true
	o.Value = make(ContractCompletionResponseFactionReputation)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContractCompletionResponseFactionReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContractCompletionResponseFactionReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContractListResponsePlayerReputation as json.
func (o OptContractListResponsePlayerReputation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContractListResponsePlayerReputation from json.
func (o *OptContractListResponsePlayerReputation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContractListResponsePlayerReputation to nil")
	}
	o.Set = true
	o.Value = make(ContractListResponsePlayerReputation)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContractListResponsePlayerReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContractListResponsePlayerReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CyberDifficulty as json.
func (o OptCyberDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CyberDifficulty from json.
func (o *OptCyberDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCyberDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCyberDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCyberDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CyberMission as json.
func (o OptCyberMission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CyberMission from json.
func (o *OptCyberMission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCyberMission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCyberMission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCyberMission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CyberRewards as json.
func (o OptCyberRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CyberRewards from json.
func (o *OptCyberRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCyberRewards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCyberRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCyberRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DeclareWarRequestWarType as json.
func (o OptDeclareWarRequestWarType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DeclareWarRequestWarType from json.
func (o *OptDeclareWarRequestWarType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeclareWarRequestWarType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeclareWarRequestWarType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeclareWarRequestWarType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GuildInfo as json.
func (o OptGuildInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GuildInfo from json.
func (o *OptGuildInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGuildInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGuildInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGuildInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (o OptHealthResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HealthResponseStatus from json.
func (o *OptHealthResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Intrigue as json.
func (o OptIntrigue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Intrigue from json.
func (o *OptIntrigue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIntrigue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIntrigue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIntrigue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntrigueResponseFirstDecision as json.
func (o OptIntrigueResponseFirstDecision) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IntrigueResponseFirstDecision from json.
func (o *OptIntrigueResponseFirstDecision) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIntrigueResponseFirstDecision to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIntrigueResponseFirstDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIntrigueResponseFirstDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestCompletionResponseReputationChanges as json.
func (o OptQuestCompletionResponseReputationChanges) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QuestCompletionResponseReputationChanges from json.
func (o *OptQuestCompletionResponseReputationChanges) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestCompletionResponseReputationChanges to nil")
	}
	o.Set = true
	o.Value = make(QuestCompletionResponseReputationChanges)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestCompletionResponseReputationChanges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestCompletionResponseReputationChanges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestObjectiveType as json.
func (o OptQuestObjectiveType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes QuestObjectiveType from json.
func (o *OptQuestObjectiveType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestObjectiveType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestObjectiveType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestObjectiveType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestResponseProgress as json.
func (o OptQuestResponseProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QuestResponseProgress from json.
func (o *OptQuestResponseProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestResponseProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestResponseProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestResponseProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestRewards as json.
func (o OptQuestRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QuestRewards from json.
func (o *OptQuestRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestRewards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestRewardsReputation as json.
func (o OptQuestRewardsReputation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QuestRewardsReputation from json.
func (o *OptQuestRewardsReputation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestRewardsReputation to nil")
	}
	o.Set = true
	o.Value = make(QuestRewardsReputation)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestRewardsReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestRewardsReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestStatus as json.
func (o OptQuestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes QuestStatus from json.
func (o *OptQuestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestType as json.
func (o OptQuestType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes QuestType from json.
func (o *OptQuestType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuestType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipReputationTier as json.
func (o OptRelationshipReputationTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RelationshipReputationTier from json.
func (o *OptRelationshipReputationTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipReputationTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipReputationTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipReputationTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipsResponseRelationships as json.
func (o OptRelationshipsResponseRelationships) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipsResponseRelationships from json.
func (o *OptRelationshipsResponseRelationships) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipsResponseRelationships to nil")
	}
	o.Set = true
	o.Value = make(RelationshipsResponseRelationships)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipsResponseRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipsResponseRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationContract as json.
func (o OptReputationContract) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReputationContract from json.
func (o *OptReputationContract) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationContract to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationContract) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationContract) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationContractDifficulty as json.
func (o OptReputationContractDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReputationContractDifficulty from json.
func (o *OptReputationContractDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationContractDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationContractDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationContractDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WarStatistics as json.
func (o OptWarStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WarStatistics from json.
func (o *OptWarStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWarStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWarStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWarStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WarStatus as json.
func (o OptWarStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WarStatus from json.
func (o *OptWarStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWarStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWarStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWarStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestCompletionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestCompletionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QuestID.Set {
			e.FieldStart("quest_id")
			s.QuestID.Encode(e)
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.RewardsGranted.Set {
			e.FieldStart("rewards_granted")
			s.RewardsGranted.Encode(e)
		}
	}
	{
		if s.ReputationChanges.Set {
			e.FieldStart("reputation_changes")
			s.ReputationChanges.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestCompletionResponse = [4]string{
	0: "quest_id",
	1: "success",
	2: "rewards_granted",
	3: "reputation_changes",
}

// Decode decodes QuestCompletionResponse from json.
func (s *QuestCompletionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestCompletionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_id":
			if err := func() error {
				s.QuestID.Reset()
				if err := s.QuestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_id\"")
			}
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "rewards_granted":
			if err := func() error {
				s.RewardsGranted.Reset()
				if err := s.RewardsGranted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards_granted\"")
			}
		case "reputation_changes":
			if err := func() error {
				s.ReputationChanges.Reset()
				if err := s.ReputationChanges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_changes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestCompletionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestCompletionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestCompletionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s QuestCompletionResponseReputationChanges) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s QuestCompletionResponseReputationChanges) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes QuestCompletionResponseReputationChanges from json.
func (s *QuestCompletionResponseReputationChanges) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestCompletionResponseReputationChanges to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestCompletionResponseReputationChanges")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestCompletionResponseReputationChanges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestCompletionResponseReputationChanges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Quests != nil {
			e.FieldStart("quests")
			e.ArrStart()
			for _, elem := range s.Quests {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestListResponse = [2]string{
	0: "quests",
	1: "total_count",
}

// Decode decodes QuestListResponse from json.
func (s *QuestListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quests":
			if err := func() error {
				s.Quests = make([]QuestSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Quests = append(s.Quests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quests\"")
			}
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestObjective) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestObjective) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectiveID.Set {
			e.FieldStart("objective_id")
			s.ObjectiveID.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.TargetCount.Set {
			e.FieldStart("target_count")
			s.TargetCount.Encode(e)
		}
	}
	{
		if s.CurrentCount.Set {
			e.FieldStart("current_count")
			s.CurrentCount.Encode(e)
		}
	}
	{
		if s.Completed.Set {
			e.FieldStart("completed")
			s.Completed.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestObjective = [6]string{
	0: "objective_id",
	1: "description",
	2: "type",
	3: "target_count",
	4: "current_count",
	5: "completed",
}

// Decode decodes QuestObjective from json.
func (s *QuestObjective) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjective to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "objective_id":
			if err := func() error {
				s.ObjectiveID.Reset()
				if err := s.ObjectiveID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target_count":
			if err := func() error {
				s.TargetCount.Reset()
				if err := s.TargetCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_count\"")
			}
		case "current_count":
			if err := func() error {
				s.CurrentCount.Reset()
				if err := s.CurrentCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_count\"")
			}
		case "completed":
			if err := func() error {
				s.Completed.Reset()
				if err := s.Completed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestObjective")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestObjective) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjective) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestObjectiveType as json.
func (s QuestObjectiveType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestObjectiveType from json.
func (s *QuestObjectiveType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjectiveType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestObjectiveType(v) {
	case QuestObjectiveTypeKill:
		*s = QuestObjectiveTypeKill
	case QuestObjectiveTypeCollect:
		*s = QuestObjectiveTypeCollect
	case QuestObjectiveTypeDeliver:
		*s = QuestObjectiveTypeDeliver
	case QuestObjectiveTypeInteract:
		*s = QuestObjectiveTypeInteract
	case QuestObjectiveTypeReachLocation:
		*s = QuestObjectiveTypeReachLocation
	default:
		*s = QuestObjectiveType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestObjectiveType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjectiveType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestObjectivesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestObjectivesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QuestID.Set {
			e.FieldStart("quest_id")
			s.QuestID.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfQuestObjectivesResponse = [2]string{
	0: "quest_id",
	1: "objectives",
}

// Decode decodes QuestObjectivesResponse from json.
func (s *QuestObjectivesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestObjectivesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_id":
			if err := func() error {
				s.QuestID.Reset()
				if err := s.QuestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_id\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]QuestObjective, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestObjective
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestObjectivesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestObjectivesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestObjectivesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QuestID.Set {
			e.FieldStart("quest_id")
			s.QuestID.Encode(e)
		}
	}
	{
		if s.QuestType.Set {
			e.FieldStart("quest_type")
			s.QuestType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfQuestResponse = [11]string{
	0:  "quest_id",
	1:  "quest_type",
	2:  "title",
	3:  "description",
	4:  "status",
	5:  "objectives",
	6:  "rewards",
	7:  "progress",
	8:  "time_limit",
	9:  "created_at",
	10: "expires_at",
}

// Decode decodes QuestResponse from json.
func (s *QuestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_id":
			if err := func() error {
				s.QuestID.Reset()
				if err := s.QuestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_id\"")
			}
		case "quest_type":
			if err := func() error {
				s.QuestType.Reset()
				if err := s.QuestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]QuestObjective, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QuestObjective
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestResponseProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestResponseProgress) encodeFields(e *jx.Encoder) {
	{
		if s.CompletedObjectives.Set {
			e.FieldStart("completed_objectives")
			s.CompletedObjectives.Encode(e)
		}
	}
	{
		if s.TotalObjectives.Set {
			e.FieldStart("total_objectives")
			s.TotalObjectives.Encode(e)
		}
	}
	{
		if s.Percentage.Set {
			e.FieldStart("percentage")
			s.Percentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestResponseProgress = [3]string{
	0: "completed_objectives",
	1: "total_objectives",
	2: "percentage",
}

// Decode decodes QuestResponseProgress from json.
func (s *QuestResponseProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestResponseProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completed_objectives":
			if err := func() error {
				s.CompletedObjectives.Reset()
				if err := s.CompletedObjectives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_objectives\"")
			}
		case "total_objectives":
			if err := func() error {
				s.TotalObjectives.Reset()
				if err := s.TotalObjectives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_objectives\"")
			}
		case "percentage":
			if err := func() error {
				s.Percentage.Reset()
				if err := s.Percentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestResponseProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestResponseProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestResponseProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestRewards) encodeFields(e *jx.Encoder) {
	{
		if s.Experience.Set {
			e.FieldStart("experience")
			s.Experience.Encode(e)
		}
	}
	{
		if s.Credits.Set {
			e.FieldStart("credits")
			s.Credits.Encode(e)
		}
	}
	{
		if s.Reputation.Set {
			e.FieldStart("reputation")
			s.Reputation.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfQuestRewards = [4]string{
	0: "experience",
	1: "credits",
	2: "reputation",
	3: "items",
}

// Decode decodes QuestRewards from json.
func (s *QuestRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experience":
			if err := func() error {
				s.Experience.Reset()
				if err := s.Experience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience\"")
			}
		case "credits":
			if err := func() error {
				s.Credits.Reset()
				if err := s.Credits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credits\"")
			}
		case "reputation":
			if err := func() error {
				s.Reputation.Reset()
				if err := s.Reputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s QuestRewardsReputation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s QuestRewardsReputation) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes QuestRewardsReputation from json.
func (s *QuestRewardsReputation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestRewardsReputation to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestRewardsReputation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestRewardsReputation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestRewardsReputation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestStatus as json.
func (s QuestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestStatus from json.
func (s *QuestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestStatus(v) {
	case QuestStatusActive:
		*s = QuestStatusActive
	case QuestStatusCompleted:
		*s = QuestStatusCompleted
	case QuestStatusFailed:
		*s = QuestStatusFailed
	case QuestStatusCancelled:
		*s = QuestStatusCancelled
	default:
		*s = QuestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QuestSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QuestSummary) encodeFields(e *jx.Encoder) {
	{
		if s.QuestID.Set {
			e.FieldStart("quest_id")
			s.QuestID.Encode(e)
		}
	}
	{
		if s.QuestType.Set {
			e.FieldStart("quest_type")
			s.QuestType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progress_percentage")
			s.ProgressPercentage.Encode(e)
		}
	}
	{
		if s.TimeRemaining.Set {
			e.FieldStart("time_remaining")
			s.TimeRemaining.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuestSummary = [6]string{
	0: "quest_id",
	1: "quest_type",
	2: "title",
	3: "status",
	4: "progress_percentage",
	5: "time_remaining",
}

// Decode decodes QuestSummary from json.
func (s *QuestSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quest_id":
			if err := func() error {
				s.QuestID.Reset()
				if err := s.QuestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_id\"")
			}
		case "quest_type":
			if err := func() error {
				s.QuestType.Reset()
				if err := s.QuestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quest_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "progress_percentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "time_remaining":
			if err := func() error {
				s.TimeRemaining.Reset()
				if err := s.TimeRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_remaining\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QuestSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QuestSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QuestType as json.
func (s QuestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QuestType from json.
func (s *QuestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QuestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QuestType(v) {
	case QuestTypeGuildWar:
		*s = QuestTypeGuildWar
	case QuestTypeCyberSpaceMission:
		*s = QuestTypeCyberSpaceMission
	case QuestTypeSocialIntrigue:
		*s = QuestTypeSocialIntrigue
	case QuestTypeReputationContract:
		*s = QuestTypeReputationContract
	default:
		*s = QuestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QuestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QuestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Relationship) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Relationship) encodeFields(e *jx.Encoder) {
	{
		if s.FactionName.Set {
			e.FieldStart("faction_name")
			s.FactionName.Encode(e)
		}
	}
	{
		if s.ReputationLevel.Set {
			e.FieldStart("reputation_level")
			s.ReputationLevel.Encode(e)
		}
	}
	{
		if s.ReputationTier.Set {
			e.FieldStart("reputation_tier")
			s.ReputationTier.Encode(e)
		}
	}
	{
		if s.InfluencePoints.Set {
			e.FieldStart("influence_points")
			s.InfluencePoints.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationship = [4]string{
	0: "faction_name",
	1: "reputation_level",
	2: "reputation_tier",
	3: "influence_points",
}

// Decode decodes Relationship from json.
func (s *Relationship) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Relationship to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "faction_name":
			if err := func() error {
				s.FactionName.Reset()
				if err := s.FactionName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_name\"")
			}
		case "reputation_level":
			if err := func() error {
				s.ReputationLevel.Reset()
				if err := s.ReputationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_level\"")
			}
		case "reputation_tier":
			if err := func() error {
				s.ReputationTier.Reset()
				if err := s.ReputationTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_tier\"")
			}
		case "influence_points":
			if err := func() error {
				s.InfluencePoints.Reset()
				if err := s.InfluencePoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"influence_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Relationship")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Relationship) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Relationship) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipReputationTier as json.
func (s RelationshipReputationTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipReputationTier from json.
func (s *RelationshipReputationTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipReputationTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipReputationTier(v) {
	case RelationshipReputationTierHated:
		*s = RelationshipReputationTierHated
	case RelationshipReputationTierDisliked:
		*s = RelationshipReputationTierDisliked
	case RelationshipReputationTierNeutral:
		*s = RelationshipReputationTierNeutral
	case RelationshipReputationTierLiked:
		*s = RelationshipReputationTierLiked
	case RelationshipReputationTierTrusted:
		*s = RelationshipReputationTierTrusted
	case RelationshipReputationTierAllied:
		*s = RelationshipReputationTierAllied
	default:
		*s = RelationshipReputationTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipReputationTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipReputationTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PlayerID.Set {
			e.FieldStart("player_id")
			s.PlayerID.Encode(e)
		}
	}
	{
		if s.FactionName.Set {
			e.FieldStart("faction_name")
			s.FactionName.Encode(e)
		}
	}
	{
		if s.OldReputation.Set {
			e.FieldStart("old_reputation")
			s.OldReputation.Encode(e)
		}
	}
	{
		if s.NewReputation.Set {
			e.FieldStart("new_reputation")
			s.NewReputation.Encode(e)
		}
	}
	{
		if s.NewTier.Set {
			e.FieldStart("new_tier")
			s.NewTier.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipResponse = [5]string{
	0: "player_id",
	1: "faction_name",
	2: "old_reputation",
	3: "new_reputation",
	4: "new_tier",
}

// Decode decodes RelationshipResponse from json.
func (s *RelationshipResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			if err := func() error {
				s.PlayerID.Reset()
				if err := s.PlayerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "faction_name":
			if err := func() error {
				s.FactionName.Reset()
				if err := s.FactionName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_name\"")
			}
		case "old_reputation":
			if err := func() error {
				s.OldReputation.Reset()
				if err := s.OldReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_reputation\"")
			}
		case "new_reputation":
			if err := func() error {
				s.NewReputation.Reset()
				if err := s.NewReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_reputation\"")
			}
		case "new_tier":
			if err := func() error {
				s.NewTier.Reset()
				if err := s.NewTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_tier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PlayerID.Set {
			e.FieldStart("player_id")
			s.PlayerID.Encode(e)
		}
	}
	{
		if s.Relationships.Set {
			e.FieldStart("relationships")
			s.Relationships.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipsResponse = [2]string{
	0: "player_id",
	1: "relationships",
}

// Decode decodes RelationshipsResponse from json.
func (s *RelationshipsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			if err := func() error {
				s.PlayerID.Reset()
				if err := s.PlayerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "relationships":
			if err := func() error {
				s.Relationships.Reset()
				if err := s.Relationships.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationships\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RelationshipsResponseRelationships) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RelationshipsResponseRelationships) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes RelationshipsResponseRelationships from json.
func (s *RelationshipsResponseRelationships) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipsResponseRelationships to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem Relationship
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipsResponseRelationships")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipsResponseRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipsResponseRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationContract) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationContract) encodeFields(e *jx.Encoder) {
	{
		if s.ContractID.Set {
			e.FieldStart("contract_id")
			s.ContractID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Faction.Set {
			e.FieldStart("faction")
			s.Faction.Encode(e)
		}
	}
	{
		if s.RequiredReputation.Set {
			e.FieldStart("required_reputation")
			s.RequiredReputation.Encode(e)
		}
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.RewardReputation.Set {
			e.FieldStart("reward_reputation")
			s.RewardReputation.Encode(e)
		}
	}
	{
		if s.RewardCredits.Set {
			e.FieldStart("reward_credits")
			s.RewardCredits.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationContract = [9]string{
	0: "contract_id",
	1: "title",
	2: "description",
	3: "faction",
	4: "required_reputation",
	5: "time_limit",
	6: "reward_reputation",
	7: "reward_credits",
	8: "difficulty",
}

// Decode decodes ReputationContract from json.
func (s *ReputationContract) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationContract to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contract_id":
			if err := func() error {
				s.ContractID.Reset()
				if err := s.ContractID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "faction":
			if err := func() error {
				s.Faction.Reset()
				if err := s.Faction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction\"")
			}
		case "required_reputation":
			if err := func() error {
				s.RequiredReputation.Reset()
				if err := s.RequiredReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_reputation\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		case "reward_reputation":
			if err := func() error {
				s.RewardReputation.Reset()
				if err := s.RewardReputation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward_reputation\"")
			}
		case "reward_credits":
			if err := func() error {
				s.RewardCredits.Reset()
				if err := s.RewardCredits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward_credits\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationContract")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationContract) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationContract) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationContractDifficulty as json.
func (s ReputationContractDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReputationContractDifficulty from json.
func (s *ReputationContractDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationContractDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReputationContractDifficulty(v) {
	case ReputationContractDifficultyEasy:
		*s = ReputationContractDifficultyEasy
	case ReputationContractDifficultyMedium:
		*s = ReputationContractDifficultyMedium
	case ReputationContractDifficultyHard:
		*s = ReputationContractDifficultyHard
	case ReputationContractDifficultyExtreme:
		*s = ReputationContractDifficultyExtreme
	default:
		*s = ReputationContractDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReputationContractDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationContractDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIntrigueRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIntrigueRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("intrigue_template_id")
		json.EncodeUUID(e, s.IntrigueTemplateID)
	}
	{
		if s.InitialChoice.Set {
			e.FieldStart("initial_choice")
			s.InitialChoice.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartIntrigueRequest = [3]string{
	0: "player_id",
	1: "intrigue_template_id",
	2: "initial_choice",
}

// Decode decodes StartIntrigueRequest from json.
func (s *StartIntrigueRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIntrigueRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "intrigue_template_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.IntrigueTemplateID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intrigue_template_id\"")
			}
		case "initial_choice":
			if err := func() error {
				s.InitialChoice.Reset()
				if err := s.InitialChoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_choice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIntrigueRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIntrigueRequest) {
					name = jsonFieldsNameOfStartIntrigueRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIntrigueRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIntrigueRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SurrenderWarRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SurrenderWarRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("surrender_reason")
		s.SurrenderReason.Encode(e)
	}
}

var jsonFieldsNameOfSurrenderWarRequest = [1]string{
	0: "surrender_reason",
}

// Decode decodes SurrenderWarRequest from json.
func (s *SurrenderWarRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SurrenderWarRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "surrender_reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SurrenderReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"surrender_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SurrenderWarRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSurrenderWarRequest) {
					name = jsonFieldsNameOfSurrenderWarRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SurrenderWarRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SurrenderWarRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SurrenderWarRequestSurrenderReason as json.
func (s SurrenderWarRequestSurrenderReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SurrenderWarRequestSurrenderReason from json.
func (s *SurrenderWarRequestSurrenderReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SurrenderWarRequestSurrenderReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SurrenderWarRequestSurrenderReason(v) {
	case SurrenderWarRequestSurrenderReasonUnwinnable:
		*s = SurrenderWarRequestSurrenderReasonUnwinnable
	case SurrenderWarRequestSurrenderReasonTimeUp:
		*s = SurrenderWarRequestSurrenderReasonTimeUp
	case SurrenderWarRequestSurrenderReasonLeadershipDecision:
		*s = SurrenderWarRequestSurrenderReasonLeadershipDecision
	case SurrenderWarRequestSurrenderReasonInternalConflict:
		*s = SurrenderWarRequestSurrenderReasonInternalConflict
	default:
		*s = SurrenderWarRequestSurrenderReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SurrenderWarRequestSurrenderReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SurrenderWarRequestSurrenderReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelemetryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelemetryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Metric.Set {
			e.FieldStart("metric")
			s.Metric.Encode(e)
		}
	}
	{
		if s.Timeframe.Set {
			e.FieldStart("timeframe")
			s.Timeframe.Encode(e)
		}
	}
	{
		if s.DataPoints != nil {
			e.FieldStart("data_points")
			e.ArrStart()
			for _, elem := range s.DataPoints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Average.Set {
			e.FieldStart("average")
			s.Average.Encode(e)
		}
	}
	{
		if s.Peak.Set {
			e.FieldStart("peak")
			s.Peak.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelemetryResponse = [6]string{
	0: "metric",
	1: "timeframe",
	2: "data_points",
	3: "average",
	4: "peak",
	5: "total",
}

// Decode decodes TelemetryResponse from json.
func (s *TelemetryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelemetryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			if err := func() error {
				s.Metric.Reset()
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "timeframe":
			if err := func() error {
				s.Timeframe.Reset()
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "data_points":
			if err := func() error {
				s.DataPoints = make([]TelemetryResponseDataPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TelemetryResponseDataPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DataPoints = append(s.DataPoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_points\"")
			}
		case "average":
			if err := func() error {
				s.Average.Reset()
				if err := s.Average.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average\"")
			}
		case "peak":
			if err := func() error {
				s.Peak.Reset()
				if err := s.Peak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peak\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelemetryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelemetryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelemetryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelemetryResponseDataPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelemetryResponseDataPointsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelemetryResponseDataPointsItem = [2]string{
	0: "timestamp",
	1: "value",
}

// Decode decodes TelemetryResponseDataPointsItem from json.
func (s *TelemetryResponseDataPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelemetryResponseDataPointsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelemetryResponseDataPointsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelemetryResponseDataPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelemetryResponseDataPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerritoryClaimResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerritoryClaimResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TerritoryID.Set {
			e.FieldStart("territory_id")
			s.TerritoryID.Encode(e)
		}
	}
	{
		if s.ClaimedByGuildID.Set {
			e.FieldStart("claimed_by_guild_id")
			s.ClaimedByGuildID.Encode(e)
		}
	}
	{
		if s.PreviousController.Set {
			e.FieldStart("previous_controller")
			s.PreviousController.Encode(e)
		}
	}
	{
		if s.ClaimSuccessful.Set {
			e.FieldStart("claim_successful")
			s.ClaimSuccessful.Encode(e)
		}
	}
	{
		if s.NewControlPercentage.Set {
			e.FieldStart("new_control_percentage")
			s.NewControlPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerritoryClaimResponse = [5]string{
	0: "territory_id",
	1: "claimed_by_guild_id",
	2: "previous_controller",
	3: "claim_successful",
	4: "new_control_percentage",
}

// Decode decodes TerritoryClaimResponse from json.
func (s *TerritoryClaimResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerritoryClaimResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "territory_id":
			if err := func() error {
				s.TerritoryID.Reset()
				if err := s.TerritoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territory_id\"")
			}
		case "claimed_by_guild_id":
			if err := func() error {
				s.ClaimedByGuildID.Reset()
				if err := s.ClaimedByGuildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_by_guild_id\"")
			}
		case "previous_controller":
			if err := func() error {
				s.PreviousController.Reset()
				if err := s.PreviousController.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_controller\"")
			}
		case "claim_successful":
			if err := func() error {
				s.ClaimSuccessful.Reset()
				if err := s.ClaimSuccessful.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claim_successful\"")
			}
		case "new_control_percentage":
			if err := func() error {
				s.NewControlPercentage.Reset()
				if err := s.NewControlPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_control_percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerritoryClaimResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerritoryClaimResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerritoryClaimResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateQuestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateQuestRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Progress != nil {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateQuestRequest = [3]string{
	0: "status",
	1: "progress",
	2: "metadata",
}

// Decode decodes UpdateQuestRequest from json.
func (s *UpdateQuestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuestRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "progress":
			if err := func() error {
				s.Progress = nil
				var elem UpdateQuestRequestProgress
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Progress = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem UpdateQuestRequestMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuestRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateQuestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateQuestRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateQuestRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateQuestRequestMetadata = [0]string{}

// Decode decodes UpdateQuestRequestMetadata from json.
func (s *UpdateQuestRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuestRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuestRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateQuestRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuestRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateQuestRequestProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateQuestRequestProgress) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateQuestRequestProgress = [0]string{}

// Decode decodes UpdateQuestRequestProgress from json.
func (s *UpdateQuestRequestProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateQuestRequestProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateQuestRequestProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateQuestRequestProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateQuestRequestProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRelationshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRelationshipRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		json.EncodeUUID(e, s.PlayerID)
	}
	{
		e.FieldStart("faction_name")
		e.Str(s.FactionName)
	}
	{
		e.FieldStart("reputation_change")
		e.Int(s.ReputationChange)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRelationshipRequest = [4]string{
	0: "player_id",
	1: "faction_name",
	2: "reputation_change",
	3: "reason",
}

// Decode decodes UpdateRelationshipRequest from json.
func (s *UpdateRelationshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "faction_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FactionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_name\"")
			}
		case "reputation_change":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ReputationChange = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_change\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRelationshipRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRelationshipRequest) {
					name = jsonFieldsNameOfUpdateRelationshipRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRelationshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateWarRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateWarRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.NewTerritories != nil {
			e.FieldStart("new_territories")
			e.ArrStart()
			for _, elem := range s.NewTerritories {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CeasefireRequested.Set {
			e.FieldStart("ceasefire_requested")
			s.CeasefireRequested.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateWarRequest = [3]string{
	0: "status",
	1: "new_territories",
	2: "ceasefire_requested",
}

// Decode decodes UpdateWarRequest from json.
func (s *UpdateWarRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWarRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "new_territories":
			if err := func() error {
				s.NewTerritories = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.NewTerritories = append(s.NewTerritories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_territories\"")
			}
		case "ceasefire_requested":
			if err := func() error {
				s.CeasefireRequested.Reset()
				if err := s.CeasefireRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ceasefire_requested\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateWarRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWarRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWarRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WarStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WarStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.AttackerCasualties.Set {
			e.FieldStart("attacker_casualties")
			s.AttackerCasualties.Encode(e)
		}
	}
	{
		if s.DefenderCasualties.Set {
			e.FieldStart("defender_casualties")
			s.DefenderCasualties.Encode(e)
		}
	}
	{
		if s.TerritoriesCaptured.Set {
			e.FieldStart("territories_captured")
			s.TerritoriesCaptured.Encode(e)
		}
	}
	{
		if s.TerritoriesLost.Set {
			e.FieldStart("territories_lost")
			s.TerritoriesLost.Encode(e)
		}
	}
	{
		if s.TotalBattles.Set {
			e.FieldStart("total_battles")
			s.TotalBattles.Encode(e)
		}
	}
}

var jsonFieldsNameOfWarStatistics = [5]string{
	0: "attacker_casualties",
	1: "defender_casualties",
	2: "territories_captured",
	3: "territories_lost",
	4: "total_battles",
}

// Decode decodes WarStatistics from json.
func (s *WarStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WarStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacker_casualties":
			if err := func() error {
				s.AttackerCasualties.Reset()
				if err := s.AttackerCasualties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacker_casualties\"")
			}
		case "defender_casualties":
			if err := func() error {
				s.DefenderCasualties.Reset()
				if err := s.DefenderCasualties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defender_casualties\"")
			}
		case "territories_captured":
			if err := func() error {
				s.TerritoriesCaptured.Reset()
				if err := s.TerritoriesCaptured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories_captured\"")
			}
		case "territories_lost":
			if err := func() error {
				s.TerritoriesLost.Reset()
				if err := s.TerritoriesLost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories_lost\"")
			}
		case "total_battles":
			if err := func() error {
				s.TotalBattles.Reset()
				if err := s.TotalBattles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_battles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WarStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WarStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WarStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WarStatus as json.
func (s WarStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WarStatus from json.
func (s *WarStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WarStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WarStatus(v) {
	case WarStatusDeclared:
		*s = WarStatusDeclared
	case WarStatusActive:
		*s = WarStatusActive
	case WarStatusPaused:
		*s = WarStatusPaused
	case WarStatusCompleted:
		*s = WarStatusCompleted
	case WarStatusSurrendered:
		*s = WarStatusSurrendered
	default:
		*s = WarStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WarStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WarStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WarTerritoriesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WarTerritoriesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.WarID.Set {
			e.FieldStart("war_id")
			s.WarID.Encode(e)
		}
	}
	{
		if s.Territories != nil {
			e.FieldStart("territories")
			e.ArrStart()
			for _, elem := range s.Territories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWarTerritoriesResponse = [2]string{
	0: "war_id",
	1: "territories",
}

// Decode decodes WarTerritoriesResponse from json.
func (s *WarTerritoriesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WarTerritoriesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "war_id":
			if err := func() error {
				s.WarID.Reset()
				if err := s.WarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"war_id\"")
			}
		case "territories":
			if err := func() error {
				s.Territories = make([]WarTerritory, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WarTerritory
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Territories = append(s.Territories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WarTerritoriesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WarTerritoriesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WarTerritoriesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WarTerritory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WarTerritory) encodeFields(e *jx.Encoder) {
	{
		if s.TerritoryID.Set {
			e.FieldStart("territory_id")
			s.TerritoryID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ControllingGuildID.Set {
			e.FieldStart("controlling_guild_id")
			s.ControllingGuildID.Encode(e)
		}
	}
	{
		if s.Contested.Set {
			e.FieldStart("contested")
			s.Contested.Encode(e)
		}
	}
	{
		if s.CaptureProgress.Set {
			e.FieldStart("capture_progress")
			s.CaptureProgress.Encode(e)
		}
	}
}

var jsonFieldsNameOfWarTerritory = [5]string{
	0: "territory_id",
	1: "name",
	2: "controlling_guild_id",
	3: "contested",
	4: "capture_progress",
}

// Decode decodes WarTerritory from json.
func (s *WarTerritory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WarTerritory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "territory_id":
			if err := func() error {
				s.TerritoryID.Reset()
				if err := s.TerritoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"territory_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "controlling_guild_id":
			if err := func() error {
				s.ControllingGuildID.Reset()
				if err := s.ControllingGuildID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controlling_guild_id\"")
			}
		case "contested":
			if err := func() error {
				s.Contested.Reset()
				if err := s.Contested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contested\"")
			}
		case "capture_progress":
			if err := func() error {
				s.CaptureProgress.Reset()
				if err := s.CaptureProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capture_progress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WarTerritory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WarTerritory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WarTerritory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
