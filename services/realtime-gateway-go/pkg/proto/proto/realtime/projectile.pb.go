// Issue: #PROJECTILE_OPTIMIZATION
// Projectile Service - Optimized Protocol Buffers for Real-Time Projectile Simulation
// Performance: Coordinate quantization, spatial culling, server-side validation
// Target: >5000 projectiles/sec, <10ms processing, 60% smaller than JSON

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: proto/realtime/projectile.proto

package projectile

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Projectile type (for simulation)
type ProjectileSpawn_ProjectileType int32

const (
	ProjectileSpawn_BULLET  ProjectileSpawn_ProjectileType = 0
	ProjectileSpawn_ROCKET  ProjectileSpawn_ProjectileType = 1
	ProjectileSpawn_GRENADE ProjectileSpawn_ProjectileType = 2
	ProjectileSpawn_LASER   ProjectileSpawn_ProjectileType = 3
	ProjectileSpawn_PLASMA  ProjectileSpawn_ProjectileType = 4
)

// Enum value maps for ProjectileSpawn_ProjectileType.
var (
	ProjectileSpawn_ProjectileType_name = map[int32]string{
		0: "BULLET",
		1: "ROCKET",
		2: "GRENADE",
		3: "LASER",
		4: "PLASMA",
	}
	ProjectileSpawn_ProjectileType_value = map[string]int32{
		"BULLET":  0,
		"ROCKET":  1,
		"GRENADE": 2,
		"LASER":   3,
		"PLASMA":  4,
	}
)

func (x ProjectileSpawn_ProjectileType) Enum() *ProjectileSpawn_ProjectileType {
	p := new(ProjectileSpawn_ProjectileType)
	*p = x
	return p
}

func (x ProjectileSpawn_ProjectileType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectileSpawn_ProjectileType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_realtime_projectile_proto_enumTypes[0].Descriptor()
}

func (ProjectileSpawn_ProjectileType) Type() protoreflect.EnumType {
	return &file_proto_realtime_projectile_proto_enumTypes[0]
}

func (x ProjectileSpawn_ProjectileType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectileSpawn_ProjectileType.Descriptor instead.
func (ProjectileSpawn_ProjectileType) EnumDescriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{1, 0}
}

// Hit type (for anti-cheat)
type ProjectileHit_HitType int32

const (
	ProjectileHit_MISS     ProjectileHit_HitType = 0
	ProjectileHit_BODY     ProjectileHit_HitType = 1
	ProjectileHit_HEAD     ProjectileHit_HitType = 2 // Headshot multiplier
	ProjectileHit_CRITICAL ProjectileHit_HitType = 3 // Critical hit
)

// Enum value maps for ProjectileHit_HitType.
var (
	ProjectileHit_HitType_name = map[int32]string{
		0: "MISS",
		1: "BODY",
		2: "HEAD",
		3: "CRITICAL",
	}
	ProjectileHit_HitType_value = map[string]int32{
		"MISS":     0,
		"BODY":     1,
		"HEAD":     2,
		"CRITICAL": 3,
	}
)

func (x ProjectileHit_HitType) Enum() *ProjectileHit_HitType {
	p := new(ProjectileHit_HitType)
	*p = x
	return p
}

func (x ProjectileHit_HitType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectileHit_HitType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_realtime_projectile_proto_enumTypes[1].Descriptor()
}

func (ProjectileHit_HitType) Type() protoreflect.EnumType {
	return &file_proto_realtime_projectile_proto_enumTypes[1]
}

func (x ProjectileHit_HitType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectileHit_HitType.Descriptor instead.
func (ProjectileHit_HitType) EnumDescriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{3, 0}
}

// Destroy reason
type ProjectileDestroy_DestroyReason int32

const (
	ProjectileDestroy_TIMEOUT       ProjectileDestroy_DestroyReason = 0
	ProjectileDestroy_HIT_TARGET    ProjectileDestroy_DestroyReason = 1
	ProjectileDestroy_HIT_TERRAIN   ProjectileDestroy_DestroyReason = 2
	ProjectileDestroy_OUT_OF_BOUNDS ProjectileDestroy_DestroyReason = 3
)

// Enum value maps for ProjectileDestroy_DestroyReason.
var (
	ProjectileDestroy_DestroyReason_name = map[int32]string{
		0: "TIMEOUT",
		1: "HIT_TARGET",
		2: "HIT_TERRAIN",
		3: "OUT_OF_BOUNDS",
	}
	ProjectileDestroy_DestroyReason_value = map[string]int32{
		"TIMEOUT":       0,
		"HIT_TARGET":    1,
		"HIT_TERRAIN":   2,
		"OUT_OF_BOUNDS": 3,
	}
)

func (x ProjectileDestroy_DestroyReason) Enum() *ProjectileDestroy_DestroyReason {
	p := new(ProjectileDestroy_DestroyReason)
	*p = x
	return p
}

func (x ProjectileDestroy_DestroyReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectileDestroy_DestroyReason) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_realtime_projectile_proto_enumTypes[2].Descriptor()
}

func (ProjectileDestroy_DestroyReason) Type() protoreflect.EnumType {
	return &file_proto_realtime_projectile_proto_enumTypes[2]
}

func (x ProjectileDestroy_DestroyReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectileDestroy_DestroyReason.Descriptor instead.
func (ProjectileDestroy_DestroyReason) EnumDescriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{4, 0}
}

// If invalid, reason
type ProjectileValidationResult_InvalidReason int32

const (
	ProjectileValidationResult_VALID             ProjectileValidationResult_InvalidReason = 0
	ProjectileValidationResult_RATE_LIMIT        ProjectileValidationResult_InvalidReason = 1 // Shooting too fast
	ProjectileValidationResult_INVALID_WEAPON    ProjectileValidationResult_InvalidReason = 2 // Weapon not equipped
	ProjectileValidationResult_OUT_OF_AMMO       ProjectileValidationResult_InvalidReason = 3 // No ammo
	ProjectileValidationResult_INVALID_DIRECTION ProjectileValidationResult_InvalidReason = 4 // Impossible aim
	ProjectileValidationResult_COOLDOWN          ProjectileValidationResult_InvalidReason = 5 // Weapon on cooldown
)

// Enum value maps for ProjectileValidationResult_InvalidReason.
var (
	ProjectileValidationResult_InvalidReason_name = map[int32]string{
		0: "VALID",
		1: "RATE_LIMIT",
		2: "INVALID_WEAPON",
		3: "OUT_OF_AMMO",
		4: "INVALID_DIRECTION",
		5: "COOLDOWN",
	}
	ProjectileValidationResult_InvalidReason_value = map[string]int32{
		"VALID":             0,
		"RATE_LIMIT":        1,
		"INVALID_WEAPON":    2,
		"OUT_OF_AMMO":       3,
		"INVALID_DIRECTION": 4,
		"COOLDOWN":          5,
	}
)

func (x ProjectileValidationResult_InvalidReason) Enum() *ProjectileValidationResult_InvalidReason {
	p := new(ProjectileValidationResult_InvalidReason)
	*p = x
	return p
}

func (x ProjectileValidationResult_InvalidReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectileValidationResult_InvalidReason) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_realtime_projectile_proto_enumTypes[3].Descriptor()
}

func (ProjectileValidationResult_InvalidReason) Type() protoreflect.EnumType {
	return &file_proto_realtime_projectile_proto_enumTypes[3]
}

func (x ProjectileValidationResult_InvalidReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectileValidationResult_InvalidReason.Descriptor instead.
func (ProjectileValidationResult_InvalidReason) EnumDescriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{6, 0}
}

// Vector3Quantized - Quantized 3D vector (50% smaller than float32)
type Vector3Quantized struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	X             int32                  `protobuf:"zigzag32,1,opt,name=x,proto3" json:"x,omitempty"` // * 100 for 0.01m precision
	Y             int32                  `protobuf:"zigzag32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z             int32                  `protobuf:"zigzag32,3,opt,name=z,proto3" json:"z,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Vector3Quantized) Reset() {
	*x = Vector3Quantized{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Vector3Quantized) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Vector3Quantized) ProtoMessage() {}

func (x *Vector3Quantized) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Vector3Quantized.ProtoReflect.Descriptor instead.
func (*Vector3Quantized) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{0}
}

func (x *Vector3Quantized) GetX() int32 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *Vector3Quantized) GetY() int32 {
	if x != nil {
		return x.Y
	}
	return 0
}

func (x *Vector3Quantized) GetZ() int32 {
	if x != nil {
		return x.Z
	}
	return 0
}

// ProjectileSpawn - Client shoots projectile
// Client-side prediction + server-side validation
type ProjectileSpawn struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Player who fired
	PlayerId uint64 `protobuf:"fixed64,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"` // 8 bytes
	// Client tick (for lag compensation)
	ClientTick uint32 `protobuf:"varint,2,opt,name=client_tick,json=clientTick,proto3" json:"client_tick,omitempty"`
	// Weapon ID (for validation)
	WeaponId uint32 `protobuf:"varint,3,opt,name=weapon_id,json=weaponId,proto3" json:"weapon_id,omitempty"` // 4 bytes
	// Spawn position (quantized)
	Origin *Vector3Quantized `protobuf:"bytes,4,opt,name=origin,proto3" json:"origin,omitempty"` // 12 bytes (varint encoded: ~6 bytes)
	// Direction (quantized unit vector)
	Direction *Vector3Quantized              `protobuf:"bytes,5,opt,name=direction,proto3" json:"direction,omitempty"`                                                        // 12 bytes (varint: ~6 bytes)
	Type      ProjectileSpawn_ProjectileType `protobuf:"varint,6,opt,name=type,proto3,enum=necp.realtime.projectile.v1.ProjectileSpawn_ProjectileType" json:"type,omitempty"` // 1 byte
	// Client-side projectile ID (for prediction)
	ClientProjectileId uint32 `protobuf:"varint,7,opt,name=client_projectile_id,json=clientProjectileId,proto3" json:"client_projectile_id,omitempty"`
	// Sequence number (packet loss detection)
	Sequence      uint32 `protobuf:"varint,8,opt,name=sequence,proto3" json:"sequence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectileSpawn) Reset() {
	*x = ProjectileSpawn{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileSpawn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileSpawn) ProtoMessage() {}

func (x *ProjectileSpawn) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileSpawn.ProtoReflect.Descriptor instead.
func (*ProjectileSpawn) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{1}
}

func (x *ProjectileSpawn) GetPlayerId() uint64 {
	if x != nil {
		return x.PlayerId
	}
	return 0
}

func (x *ProjectileSpawn) GetClientTick() uint32 {
	if x != nil {
		return x.ClientTick
	}
	return 0
}

func (x *ProjectileSpawn) GetWeaponId() uint32 {
	if x != nil {
		return x.WeaponId
	}
	return 0
}

func (x *ProjectileSpawn) GetOrigin() *Vector3Quantized {
	if x != nil {
		return x.Origin
	}
	return nil
}

func (x *ProjectileSpawn) GetDirection() *Vector3Quantized {
	if x != nil {
		return x.Direction
	}
	return nil
}

func (x *ProjectileSpawn) GetType() ProjectileSpawn_ProjectileType {
	if x != nil {
		return x.Type
	}
	return ProjectileSpawn_BULLET
}

func (x *ProjectileSpawn) GetClientProjectileId() uint32 {
	if x != nil {
		return x.ClientProjectileId
	}
	return 0
}

func (x *ProjectileSpawn) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

// ProjectileState - Server authoritative projectile state
// Sent to ALL players in zone (spatial culling applied)
type ProjectileState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server projectile ID (authoritative)
	ProjectileId uint64 `protobuf:"fixed64,1,opt,name=projectile_id,json=projectileId,proto3" json:"projectile_id,omitempty"` // 8 bytes
	// Owner
	OwnerId uint64 `protobuf:"fixed64,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"` // 8 bytes
	// Current position (quantized)
	Position *Vector3Quantized `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"` // ~6 bytes
	// Current velocity (quantized)
	Velocity *Vector3Quantized `protobuf:"bytes,4,opt,name=velocity,proto3" json:"velocity,omitempty"` // ~6 bytes
	// Server tick
	ServerTick uint32 `protobuf:"varint,5,opt,name=server_tick,json=serverTick,proto3" json:"server_tick,omitempty"`
	// Time to live (milliseconds remaining)
	TtlMs uint32 `protobuf:"varint,6,opt,name=ttl_ms,json=ttlMs,proto3" json:"ttl_ms,omitempty"`
	// Projectile type
	Type          uint32 `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"` // 1 byte
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectileState) Reset() {
	*x = ProjectileState{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileState) ProtoMessage() {}

func (x *ProjectileState) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileState.ProtoReflect.Descriptor instead.
func (*ProjectileState) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{2}
}

func (x *ProjectileState) GetProjectileId() uint64 {
	if x != nil {
		return x.ProjectileId
	}
	return 0
}

func (x *ProjectileState) GetOwnerId() uint64 {
	if x != nil {
		return x.OwnerId
	}
	return 0
}

func (x *ProjectileState) GetPosition() *Vector3Quantized {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *ProjectileState) GetVelocity() *Vector3Quantized {
	if x != nil {
		return x.Velocity
	}
	return nil
}

func (x *ProjectileState) GetServerTick() uint32 {
	if x != nil {
		return x.ServerTick
	}
	return 0
}

func (x *ProjectileState) GetTtlMs() uint32 {
	if x != nil {
		return x.TtlMs
	}
	return 0
}

func (x *ProjectileState) GetType() uint32 {
	if x != nil {
		return x.Type
	}
	return 0
}

// ProjectileHit - Server validates and broadcasts hit
type ProjectileHit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Projectile that hit
	ProjectileId uint64 `protobuf:"fixed64,1,opt,name=projectile_id,json=projectileId,proto3" json:"projectile_id,omitempty"`
	// Target that was hit
	TargetId uint64 `protobuf:"fixed64,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"` // player_id or npc_id
	// Hit position (quantized)
	HitPosition *Vector3Quantized `protobuf:"bytes,3,opt,name=hit_position,json=hitPosition,proto3" json:"hit_position,omitempty"`
	// Hit normal (for effects)
	HitNormal *Vector3Quantized `protobuf:"bytes,4,opt,name=hit_normal,json=hitNormal,proto3" json:"hit_normal,omitempty"`
	// Damage dealt (server-calculated)
	Damage  uint32                `protobuf:"varint,5,opt,name=damage,proto3" json:"damage,omitempty"`
	HitType ProjectileHit_HitType `protobuf:"varint,6,opt,name=hit_type,json=hitType,proto3,enum=necp.realtime.projectile.v1.ProjectileHit_HitType" json:"hit_type,omitempty"`
	// Server tick
	ServerTick    uint32 `protobuf:"varint,7,opt,name=server_tick,json=serverTick,proto3" json:"server_tick,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectileHit) Reset() {
	*x = ProjectileHit{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileHit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileHit) ProtoMessage() {}

func (x *ProjectileHit) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileHit.ProtoReflect.Descriptor instead.
func (*ProjectileHit) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{3}
}

func (x *ProjectileHit) GetProjectileId() uint64 {
	if x != nil {
		return x.ProjectileId
	}
	return 0
}

func (x *ProjectileHit) GetTargetId() uint64 {
	if x != nil {
		return x.TargetId
	}
	return 0
}

func (x *ProjectileHit) GetHitPosition() *Vector3Quantized {
	if x != nil {
		return x.HitPosition
	}
	return nil
}

func (x *ProjectileHit) GetHitNormal() *Vector3Quantized {
	if x != nil {
		return x.HitNormal
	}
	return nil
}

func (x *ProjectileHit) GetDamage() uint32 {
	if x != nil {
		return x.Damage
	}
	return 0
}

func (x *ProjectileHit) GetHitType() ProjectileHit_HitType {
	if x != nil {
		return x.HitType
	}
	return ProjectileHit_MISS
}

func (x *ProjectileHit) GetServerTick() uint32 {
	if x != nil {
		return x.ServerTick
	}
	return 0
}

// ProjectileDestroy - Server notifies projectile destruction
type ProjectileDestroy struct {
	state        protoimpl.MessageState          `protogen:"open.v1"`
	ProjectileId uint64                          `protobuf:"fixed64,1,opt,name=projectile_id,json=projectileId,proto3" json:"projectile_id,omitempty"`
	Reason       ProjectileDestroy_DestroyReason `protobuf:"varint,2,opt,name=reason,proto3,enum=necp.realtime.projectile.v1.ProjectileDestroy_DestroyReason" json:"reason,omitempty"`
	// Final position (for effects)
	Position      *Vector3Quantized `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectileDestroy) Reset() {
	*x = ProjectileDestroy{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileDestroy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileDestroy) ProtoMessage() {}

func (x *ProjectileDestroy) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileDestroy.ProtoReflect.Descriptor instead.
func (*ProjectileDestroy) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{4}
}

func (x *ProjectileDestroy) GetProjectileId() uint64 {
	if x != nil {
		return x.ProjectileId
	}
	return 0
}

func (x *ProjectileDestroy) GetReason() ProjectileDestroy_DestroyReason {
	if x != nil {
		return x.Reason
	}
	return ProjectileDestroy_TIMEOUT
}

func (x *ProjectileDestroy) GetPosition() *Vector3Quantized {
	if x != nil {
		return x.Position
	}
	return nil
}

// ProjectileBatch - Multiple projectiles in one UDP packet
// Reduces syscalls by 95%+, critical for >5000 projectiles/sec
type ProjectileBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server tick
	ServerTick uint32 `protobuf:"varint,1,opt,name=server_tick,json=serverTick,proto3" json:"server_tick,omitempty"`
	// Spatial zone ID (for interest management)
	ZoneId uint32 `protobuf:"varint,2,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	// All active projectiles in zone
	Projectiles []*ProjectileState `protobuf:"bytes,3,rep,name=projectiles,proto3" json:"projectiles,omitempty"` // Only players in this zone receive
	// New hits this tick
	Hits []*ProjectileHit `protobuf:"bytes,4,rep,name=hits,proto3" json:"hits,omitempty"`
	// Destroyed projectiles
	Destroys      []*ProjectileDestroy `protobuf:"bytes,5,rep,name=destroys,proto3" json:"destroys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectileBatch) Reset() {
	*x = ProjectileBatch{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileBatch) ProtoMessage() {}

func (x *ProjectileBatch) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileBatch.ProtoReflect.Descriptor instead.
func (*ProjectileBatch) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{5}
}

func (x *ProjectileBatch) GetServerTick() uint32 {
	if x != nil {
		return x.ServerTick
	}
	return 0
}

func (x *ProjectileBatch) GetZoneId() uint32 {
	if x != nil {
		return x.ZoneId
	}
	return 0
}

func (x *ProjectileBatch) GetProjectiles() []*ProjectileState {
	if x != nil {
		return x.Projectiles
	}
	return nil
}

func (x *ProjectileBatch) GetHits() []*ProjectileHit {
	if x != nil {
		return x.Hits
	}
	return nil
}

func (x *ProjectileBatch) GetDestroys() []*ProjectileDestroy {
	if x != nil {
		return x.Destroys
	}
	return nil
}

// ProjectileValidationResult - Server validates projectile spawn
type ProjectileValidationResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client projectile ID (for matching)
	ClientProjectileId uint32 `protobuf:"varint,1,opt,name=client_projectile_id,json=clientProjectileId,proto3" json:"client_projectile_id,omitempty"`
	Valid              bool   `protobuf:"varint,2,opt,name=valid,proto3" json:"valid,omitempty"`
	// If valid, server projectile ID
	ServerProjectileId uint64                                   `protobuf:"fixed64,3,opt,name=server_projectile_id,json=serverProjectileId,proto3" json:"server_projectile_id,omitempty"`
	Reason             ProjectileValidationResult_InvalidReason `protobuf:"varint,4,opt,name=reason,proto3,enum=necp.realtime.projectile.v1.ProjectileValidationResult_InvalidReason" json:"reason,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ProjectileValidationResult) Reset() {
	*x = ProjectileValidationResult{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectileValidationResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectileValidationResult) ProtoMessage() {}

func (x *ProjectileValidationResult) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectileValidationResult.ProtoReflect.Descriptor instead.
func (*ProjectileValidationResult) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{6}
}

func (x *ProjectileValidationResult) GetClientProjectileId() uint32 {
	if x != nil {
		return x.ClientProjectileId
	}
	return 0
}

func (x *ProjectileValidationResult) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ProjectileValidationResult) GetServerProjectileId() uint64 {
	if x != nil {
		return x.ServerProjectileId
	}
	return 0
}

func (x *ProjectileValidationResult) GetReason() ProjectileValidationResult_InvalidReason {
	if x != nil {
		return x.Reason
	}
	return ProjectileValidationResult_VALID
}

type ClientProjectileMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Message:
	//
	//	*ClientProjectileMessage_Spawn
	Message       isClientProjectileMessage_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientProjectileMessage) Reset() {
	*x = ClientProjectileMessage{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientProjectileMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientProjectileMessage) ProtoMessage() {}

func (x *ClientProjectileMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientProjectileMessage.ProtoReflect.Descriptor instead.
func (*ClientProjectileMessage) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{7}
}

func (x *ClientProjectileMessage) GetMessage() isClientProjectileMessage_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *ClientProjectileMessage) GetSpawn() *ProjectileSpawn {
	if x != nil {
		if x, ok := x.Message.(*ClientProjectileMessage_Spawn); ok {
			return x.Spawn
		}
	}
	return nil
}

type isClientProjectileMessage_Message interface {
	isClientProjectileMessage_Message()
}

type ClientProjectileMessage_Spawn struct {
	Spawn *ProjectileSpawn `protobuf:"bytes,1,opt,name=spawn,proto3,oneof"` // Future: grenades, rockets with special physics
}

func (*ClientProjectileMessage_Spawn) isClientProjectileMessage_Message() {}

type ServerProjectileMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Message:
	//
	//	*ServerProjectileMessage_Batch
	//	*ServerProjectileMessage_Validation
	//	*ServerProjectileMessage_Hit
	Message       isServerProjectileMessage_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerProjectileMessage) Reset() {
	*x = ServerProjectileMessage{}
	mi := &file_proto_realtime_projectile_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerProjectileMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerProjectileMessage) ProtoMessage() {}

func (x *ServerProjectileMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_realtime_projectile_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerProjectileMessage.ProtoReflect.Descriptor instead.
func (*ServerProjectileMessage) Descriptor() ([]byte, []int) {
	return file_proto_realtime_projectile_proto_rawDescGZIP(), []int{8}
}

func (x *ServerProjectileMessage) GetMessage() isServerProjectileMessage_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *ServerProjectileMessage) GetBatch() *ProjectileBatch {
	if x != nil {
		if x, ok := x.Message.(*ServerProjectileMessage_Batch); ok {
			return x.Batch
		}
	}
	return nil
}

func (x *ServerProjectileMessage) GetValidation() *ProjectileValidationResult {
	if x != nil {
		if x, ok := x.Message.(*ServerProjectileMessage_Validation); ok {
			return x.Validation
		}
	}
	return nil
}

func (x *ServerProjectileMessage) GetHit() *ProjectileHit {
	if x != nil {
		if x, ok := x.Message.(*ServerProjectileMessage_Hit); ok {
			return x.Hit
		}
	}
	return nil
}

type isServerProjectileMessage_Message interface {
	isServerProjectileMessage_Message()
}

type ServerProjectileMessage_Batch struct {
	Batch *ProjectileBatch `protobuf:"bytes,1,opt,name=batch,proto3,oneof"` // Most common (every tick)
}

type ServerProjectileMessage_Validation struct {
	Validation *ProjectileValidationResult `protobuf:"bytes,2,opt,name=validation,proto3,oneof"` // Spawn confirmation
}

type ServerProjectileMessage_Hit struct {
	Hit *ProjectileHit `protobuf:"bytes,3,opt,name=hit,proto3,oneof"` // Individual hit (redundant)
}

func (*ServerProjectileMessage_Batch) isServerProjectileMessage_Message() {}

func (*ServerProjectileMessage_Validation) isServerProjectileMessage_Message() {}

func (*ServerProjectileMessage_Hit) isServerProjectileMessage_Message() {}

var File_proto_realtime_projectile_proto protoreflect.FileDescriptor

const file_proto_realtime_projectile_proto_rawDesc = "" +
	"\n" +
	"\x1fproto/realtime/projectile.proto\x12\x1bnecp.realtime.projectile.v1\"<\n" +
	"\x10Vector3Quantized\x12\f\n" +
	"\x01x\x18\x01 \x01(\x11R\x01x\x12\f\n" +
	"\x01y\x18\x02 \x01(\x11R\x01y\x12\f\n" +
	"\x01z\x18\x03 \x01(\x11R\x01z\"\xed\x03\n" +
	"\x0fProjectileSpawn\x12\x1b\n" +
	"\tplayer_id\x18\x01 \x01(\x06R\bplayerId\x12\x1f\n" +
	"\vclient_tick\x18\x02 \x01(\rR\n" +
	"clientTick\x12\x1b\n" +
	"\tweapon_id\x18\x03 \x01(\rR\bweaponId\x12E\n" +
	"\x06origin\x18\x04 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\x06origin\x12K\n" +
	"\tdirection\x18\x05 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\tdirection\x12O\n" +
	"\x04type\x18\x06 \x01(\x0e2;.necp.realtime.projectile.v1.ProjectileSpawn.ProjectileTypeR\x04type\x120\n" +
	"\x14client_projectile_id\x18\a \x01(\rR\x12clientProjectileId\x12\x1a\n" +
	"\bsequence\x18\b \x01(\rR\bsequence\"L\n" +
	"\x0eProjectileType\x12\n" +
	"\n" +
	"\x06BULLET\x10\x00\x12\n" +
	"\n" +
	"\x06ROCKET\x10\x01\x12\v\n" +
	"\aGRENADE\x10\x02\x12\t\n" +
	"\x05LASER\x10\x03\x12\n" +
	"\n" +
	"\x06PLASMA\x10\x04\"\xb3\x02\n" +
	"\x0fProjectileState\x12#\n" +
	"\rprojectile_id\x18\x01 \x01(\x06R\fprojectileId\x12\x19\n" +
	"\bowner_id\x18\x02 \x01(\x06R\aownerId\x12I\n" +
	"\bposition\x18\x03 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\bposition\x12I\n" +
	"\bvelocity\x18\x04 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\bvelocity\x12\x1f\n" +
	"\vserver_tick\x18\x05 \x01(\rR\n" +
	"serverTick\x12\x15\n" +
	"\x06ttl_ms\x18\x06 \x01(\rR\x05ttlMs\x12\x12\n" +
	"\x04type\x18\a \x01(\rR\x04type\"\xb0\x03\n" +
	"\rProjectileHit\x12#\n" +
	"\rprojectile_id\x18\x01 \x01(\x06R\fprojectileId\x12\x1b\n" +
	"\ttarget_id\x18\x02 \x01(\x06R\btargetId\x12P\n" +
	"\fhit_position\x18\x03 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\vhitPosition\x12L\n" +
	"\n" +
	"hit_normal\x18\x04 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\thitNormal\x12\x16\n" +
	"\x06damage\x18\x05 \x01(\rR\x06damage\x12M\n" +
	"\bhit_type\x18\x06 \x01(\x0e22.necp.realtime.projectile.v1.ProjectileHit.HitTypeR\ahitType\x12\x1f\n" +
	"\vserver_tick\x18\a \x01(\rR\n" +
	"serverTick\"5\n" +
	"\aHitType\x12\b\n" +
	"\x04MISS\x10\x00\x12\b\n" +
	"\x04BODY\x10\x01\x12\b\n" +
	"\x04HEAD\x10\x02\x12\f\n" +
	"\bCRITICAL\x10\x03\"\xab\x02\n" +
	"\x11ProjectileDestroy\x12#\n" +
	"\rprojectile_id\x18\x01 \x01(\x06R\fprojectileId\x12T\n" +
	"\x06reason\x18\x02 \x01(\x0e2<.necp.realtime.projectile.v1.ProjectileDestroy.DestroyReasonR\x06reason\x12I\n" +
	"\bposition\x18\x03 \x01(\v2-.necp.realtime.projectile.v1.Vector3QuantizedR\bposition\"P\n" +
	"\rDestroyReason\x12\v\n" +
	"\aTIMEOUT\x10\x00\x12\x0e\n" +
	"\n" +
	"HIT_TARGET\x10\x01\x12\x0f\n" +
	"\vHIT_TERRAIN\x10\x02\x12\x11\n" +
	"\rOUT_OF_BOUNDS\x10\x03\"\xa7\x02\n" +
	"\x0fProjectileBatch\x12\x1f\n" +
	"\vserver_tick\x18\x01 \x01(\rR\n" +
	"serverTick\x12\x17\n" +
	"\azone_id\x18\x02 \x01(\rR\x06zoneId\x12N\n" +
	"\vprojectiles\x18\x03 \x03(\v2,.necp.realtime.projectile.v1.ProjectileStateR\vprojectiles\x12>\n" +
	"\x04hits\x18\x04 \x03(\v2*.necp.realtime.projectile.v1.ProjectileHitR\x04hits\x12J\n" +
	"\bdestroys\x18\x05 \x03(\v2..necp.realtime.projectile.v1.ProjectileDestroyR\bdestroys\"\xeb\x02\n" +
	"\x1aProjectileValidationResult\x120\n" +
	"\x14client_projectile_id\x18\x01 \x01(\rR\x12clientProjectileId\x12\x14\n" +
	"\x05valid\x18\x02 \x01(\bR\x05valid\x120\n" +
	"\x14server_projectile_id\x18\x03 \x01(\x06R\x12serverProjectileId\x12]\n" +
	"\x06reason\x18\x04 \x01(\x0e2E.necp.realtime.projectile.v1.ProjectileValidationResult.InvalidReasonR\x06reason\"t\n" +
	"\rInvalidReason\x12\t\n" +
	"\x05VALID\x10\x00\x12\x0e\n" +
	"\n" +
	"RATE_LIMIT\x10\x01\x12\x12\n" +
	"\x0eINVALID_WEAPON\x10\x02\x12\x0f\n" +
	"\vOUT_OF_AMMO\x10\x03\x12\x15\n" +
	"\x11INVALID_DIRECTION\x10\x04\x12\f\n" +
	"\bCOOLDOWN\x10\x05\"j\n" +
	"\x17ClientProjectileMessage\x12D\n" +
	"\x05spawn\x18\x01 \x01(\v2,.necp.realtime.projectile.v1.ProjectileSpawnH\x00R\x05spawnB\t\n" +
	"\amessage\"\x85\x02\n" +
	"\x17ServerProjectileMessage\x12D\n" +
	"\x05batch\x18\x01 \x01(\v2,.necp.realtime.projectile.v1.ProjectileBatchH\x00R\x05batch\x12Y\n" +
	"\n" +
	"validation\x18\x02 \x01(\v27.necp.realtime.projectile.v1.ProjectileValidationResultH\x00R\n" +
	"validation\x12>\n" +
	"\x03hit\x18\x03 \x01(\v2*.necp.realtime.projectile.v1.ProjectileHitH\x00R\x03hitB\t\n" +
	"\amessageBAZ?github.com/gc-lover/necpgame-monorepo/proto/realtime/projectileb\x06proto3"

var (
	file_proto_realtime_projectile_proto_rawDescOnce sync.Once
	file_proto_realtime_projectile_proto_rawDescData []byte
)

func file_proto_realtime_projectile_proto_rawDescGZIP() []byte {
	file_proto_realtime_projectile_proto_rawDescOnce.Do(func() {
		file_proto_realtime_projectile_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_realtime_projectile_proto_rawDesc), len(file_proto_realtime_projectile_proto_rawDesc)))
	})
	return file_proto_realtime_projectile_proto_rawDescData
}

var file_proto_realtime_projectile_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_proto_realtime_projectile_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_proto_realtime_projectile_proto_goTypes = []any{
	(ProjectileSpawn_ProjectileType)(0),           // 0: necp.realtime.projectile.v1.ProjectileSpawn.ProjectileType
	(ProjectileHit_HitType)(0),                    // 1: necp.realtime.projectile.v1.ProjectileHit.HitType
	(ProjectileDestroy_DestroyReason)(0),          // 2: necp.realtime.projectile.v1.ProjectileDestroy.DestroyReason
	(ProjectileValidationResult_InvalidReason)(0), // 3: necp.realtime.projectile.v1.ProjectileValidationResult.InvalidReason
	(*Vector3Quantized)(nil),                      // 4: necp.realtime.projectile.v1.Vector3Quantized
	(*ProjectileSpawn)(nil),                       // 5: necp.realtime.projectile.v1.ProjectileSpawn
	(*ProjectileState)(nil),                       // 6: necp.realtime.projectile.v1.ProjectileState
	(*ProjectileHit)(nil),                         // 7: necp.realtime.projectile.v1.ProjectileHit
	(*ProjectileDestroy)(nil),                     // 8: necp.realtime.projectile.v1.ProjectileDestroy
	(*ProjectileBatch)(nil),                       // 9: necp.realtime.projectile.v1.ProjectileBatch
	(*ProjectileValidationResult)(nil),            // 10: necp.realtime.projectile.v1.ProjectileValidationResult
	(*ClientProjectileMessage)(nil),               // 11: necp.realtime.projectile.v1.ClientProjectileMessage
	(*ServerProjectileMessage)(nil),               // 12: necp.realtime.projectile.v1.ServerProjectileMessage
}
var file_proto_realtime_projectile_proto_depIdxs = []int32{
	4,  // 0: necp.realtime.projectile.v1.ProjectileSpawn.origin:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	4,  // 1: necp.realtime.projectile.v1.ProjectileSpawn.direction:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	0,  // 2: necp.realtime.projectile.v1.ProjectileSpawn.type:type_name -> necp.realtime.projectile.v1.ProjectileSpawn.ProjectileType
	4,  // 3: necp.realtime.projectile.v1.ProjectileState.position:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	4,  // 4: necp.realtime.projectile.v1.ProjectileState.velocity:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	4,  // 5: necp.realtime.projectile.v1.ProjectileHit.hit_position:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	4,  // 6: necp.realtime.projectile.v1.ProjectileHit.hit_normal:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	1,  // 7: necp.realtime.projectile.v1.ProjectileHit.hit_type:type_name -> necp.realtime.projectile.v1.ProjectileHit.HitType
	2,  // 8: necp.realtime.projectile.v1.ProjectileDestroy.reason:type_name -> necp.realtime.projectile.v1.ProjectileDestroy.DestroyReason
	4,  // 9: necp.realtime.projectile.v1.ProjectileDestroy.position:type_name -> necp.realtime.projectile.v1.Vector3Quantized
	6,  // 10: necp.realtime.projectile.v1.ProjectileBatch.projectiles:type_name -> necp.realtime.projectile.v1.ProjectileState
	7,  // 11: necp.realtime.projectile.v1.ProjectileBatch.hits:type_name -> necp.realtime.projectile.v1.ProjectileHit
	8,  // 12: necp.realtime.projectile.v1.ProjectileBatch.destroys:type_name -> necp.realtime.projectile.v1.ProjectileDestroy
	3,  // 13: necp.realtime.projectile.v1.ProjectileValidationResult.reason:type_name -> necp.realtime.projectile.v1.ProjectileValidationResult.InvalidReason
	5,  // 14: necp.realtime.projectile.v1.ClientProjectileMessage.spawn:type_name -> necp.realtime.projectile.v1.ProjectileSpawn
	9,  // 15: necp.realtime.projectile.v1.ServerProjectileMessage.batch:type_name -> necp.realtime.projectile.v1.ProjectileBatch
	10, // 16: necp.realtime.projectile.v1.ServerProjectileMessage.validation:type_name -> necp.realtime.projectile.v1.ProjectileValidationResult
	7,  // 17: necp.realtime.projectile.v1.ServerProjectileMessage.hit:type_name -> necp.realtime.projectile.v1.ProjectileHit
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_proto_realtime_projectile_proto_init() }
func file_proto_realtime_projectile_proto_init() {
	if File_proto_realtime_projectile_proto != nil {
		return
	}
	file_proto_realtime_projectile_proto_msgTypes[7].OneofWrappers = []any{
		(*ClientProjectileMessage_Spawn)(nil),
	}
	file_proto_realtime_projectile_proto_msgTypes[8].OneofWrappers = []any{
		(*ServerProjectileMessage_Batch)(nil),
		(*ServerProjectileMessage_Validation)(nil),
		(*ServerProjectileMessage_Hit)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_realtime_projectile_proto_rawDesc), len(file_proto_realtime_projectile_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_realtime_projectile_proto_goTypes,
		DependencyIndexes: file_proto_realtime_projectile_proto_depIdxs,
		EnumInfos:         file_proto_realtime_projectile_proto_enumTypes,
		MessageInfos:      file_proto_realtime_projectile_proto_msgTypes,
	}.Build()
	File_proto_realtime_projectile_proto = out.File
	file_proto_realtime_projectile_proto_goTypes = nil
	file_proto_realtime_projectile_proto_depIdxs = nil
}
