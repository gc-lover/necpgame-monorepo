// Code generated by NECPGAME Network agent. Adaptive tick rate system for performance optimization.
// PERFORMANCE: Dynamic tick rate adjustment based on player count (20-128 Hz)
// Issue: Network optimization for realtime-gateway-service-go

package service

import (
	"context"
	"sync"
	"time"

	"go.opentelemetry.io/otel/metric"
	"go.uber.org/zap"
)

// TickRateConfig holds adaptive tick rate configuration
type TickRateConfig struct {
	// Base tick rates for different player count ranges
	BaseTickRates map[string]time.Duration

	// Performance thresholds
	MaxPlayersPerTick int
	TargetLatency     time.Duration
	MinTickRate       time.Duration
	MaxTickRate       time.Duration

	// Adaptive parameters
	AdjustmentInterval time.Duration
	LatencyThreshold   time.Duration
	PlayerCountStep    int

	Logger *zap.Logger
	Meter  metric.Meter
}

// AdaptiveTickRate manages dynamic tick rate adjustment
type AdaptiveTickRate struct {
	config TickRateConfig

	// Current state
	currentTickRate time.Duration
	currentPlayerCount int
	lastAdjustment  time.Time

	// Metrics tracking
	averageLatency   time.Duration
	tickCount        int64
	totalLatency     time.Duration

	// Control
	ticker           *time.Ticker
	stopCh          chan struct{}
	mu              sync.RWMutex

	// Metrics
	tickRateGauge     metric.Int64Gauge
	playerCountGauge  metric.Int64Gauge
	averageLatencyGauge metric.Int64Gauge
}

// NewAdaptiveTickRate creates a new adaptive tick rate manager
func NewAdaptiveTickRate(config TickRateConfig) *AdaptiveTickRate {
	if config.BaseTickRates == nil {
		// Default tick rates based on player count ranges
		config.BaseTickRates = map[string]time.Duration{
			"0-50":   8 * time.Millisecond,   // 128 Hz
			"51-100": 10 * time.Millisecond,  // 100 Hz
			"101-200": 16 * time.Millisecond, // 62.5 Hz
			"201-500": 20 * time.Millisecond, // 50 Hz
			"500+":   33 * time.Millisecond,  // 30 Hz
		}
	}

	if config.AdjustmentInterval == 0 {
		config.AdjustmentInterval = 30 * time.Second
	}

	if config.LatencyThreshold == 0 {
		config.LatencyThreshold = 50 * time.Millisecond
	}

	if config.PlayerCountStep == 0 {
		config.PlayerCountStep = 10
	}

	if config.MinTickRate == 0 {
		config.MinTickRate = 50 * time.Millisecond // 20 Hz minimum
	}

	if config.MaxTickRate == 0 {
		config.MaxTickRate = 8 * time.Millisecond // 128 Hz maximum
	}

	return &AdaptiveTickRate{
		config:           config,
		currentTickRate:  16 * time.Millisecond, // Start with 60 Hz
		currentPlayerCount: 0,
		lastAdjustment:   time.Now(),
		stopCh:          make(chan struct{}),
	}
}

// Start begins the adaptive tick rate management
func (atr *AdaptiveTickRate) Start(ctx context.Context) error {
	atr.config.Logger.Info("starting adaptive tick rate manager")

	// Initialize metrics
	var err error
	atr.tickRateGauge, err = atr.config.Meter.Int64Gauge(
		"adaptive_tick_rate_current",
		metric.WithDescription("Current tick rate in milliseconds"),
	)
	if err != nil {
		return err
	}

	atr.playerCountGauge, err = atr.config.Meter.Int64Gauge(
		"adaptive_tick_rate_player_count",
		metric.WithDescription("Current player count for tick rate calculation"),
	)
	if err != nil {
		return err
	}

	atr.averageLatencyGauge, err = atr.config.Meter.Int64Gauge(
		"adaptive_tick_rate_avg_latency",
		metric.WithDescription("Average tick latency in milliseconds"),
	)
	if err != nil {
		return err
	}

	// Start adjustment ticker
	atr.ticker = time.NewTicker(atr.config.AdjustmentInterval)
	go atr.adjustmentLoop(ctx)

	atr.config.Logger.Info("adaptive tick rate manager started")
	return nil
}

// Stop stops the adaptive tick rate management
func (atr *AdaptiveTickRate) Stop(ctx context.Context) error {
	atr.config.Logger.Info("stopping adaptive tick rate manager")

	close(atr.stopCh)
	if atr.ticker != nil {
		atr.ticker.Stop()
	}

	atr.config.Logger.Info("adaptive tick rate manager stopped")
	return nil
}

// GetCurrentTickRate returns the current tick rate
func (atr *AdaptiveTickRate) GetCurrentTickRate() time.Duration {
	atr.mu.RLock()
	defer atr.mu.RUnlock()
	return atr.currentTickRate
}

// UpdatePlayerCount updates the current player count for tick rate calculation
func (atr *AdaptiveTickRate) UpdatePlayerCount(count int) {
	atr.mu.Lock()
	oldCount := atr.currentPlayerCount
	atr.currentPlayerCount = count
	atr.mu.Unlock()

	// Update metrics
	atr.playerCountGauge.Set(int64(count))

	// Trigger immediate adjustment if player count changed significantly
	if abs(oldCount-count) >= atr.config.PlayerCountStep {
		go atr.adjustTickRate()
	}
}

// RecordTickLatency records the latency of a tick operation
func (atr *AdaptiveTickRate) RecordTickLatency(latency time.Duration) {
	atr.mu.Lock()
	atr.tickCount++
	atr.totalLatency += latency
	atr.averageLatency = atr.totalLatency / time.Duration(atr.tickCount)
	atr.mu.Unlock()

	// Update metrics
	atr.averageLatencyGauge.Set(int64(atr.averageLatency.Milliseconds()))
}

// adjustmentLoop runs periodic tick rate adjustments
func (atr *AdaptiveTickRate) adjustmentLoop(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case <-atr.stopCh:
			return
		case <-atr.ticker.C:
			atr.adjustTickRate()
		}
	}
}

// adjustTickRate calculates and applies optimal tick rate
func (atr *AdaptiveTickRate) adjustTickRate() {
	atr.mu.Lock()
	defer atr.mu.Unlock()

	playerCount := atr.currentPlayerCount
	currentLatency := atr.averageLatency

	// Calculate target tick rate based on player count
	targetTickRate := atr.calculateTargetTickRate(playerCount)

	// Adjust for latency if it's too high
	if currentLatency > atr.config.LatencyThreshold {
		// Increase tick rate (reduce frequency) to reduce load
		targetTickRate = atr.increaseTickRate(targetTickRate)
	} else if currentLatency < atr.config.LatencyThreshold/2 && playerCount < 100 {
		// Decrease tick rate (increase frequency) for better responsiveness
		targetTickRate = atr.decreaseTickRate(targetTickRate)
	}

	// Apply bounds
	if targetTickRate < atr.config.MaxTickRate {
		targetTickRate = atr.config.MaxTickRate
	}
	if targetTickRate > atr.config.MinTickRate {
		targetTickRate = atr.config.MinTickRate
	}

	// Update tick rate if changed
	if targetTickRate != atr.currentTickRate {
		oldRate := atr.currentTickRate
		atr.currentTickRate = targetTickRate
		atr.lastAdjustment = time.Now()

		// Update metrics
		atr.tickRateGauge.Set(int64(targetTickRate.Milliseconds()))

		atr.config.Logger.Info("tick rate adjusted",
			zap.Duration("old_rate", oldRate),
			zap.Duration("new_rate", targetTickRate),
			zap.Int("player_count", playerCount),
			zap.Duration("avg_latency", currentLatency))
	}
}

// calculateTargetTickRate calculates the optimal tick rate for a given player count
func (atr *AdaptiveTickRate) calculateTargetTickRate(playerCount int) time.Duration {
	switch {
	case playerCount <= 50:
		return atr.config.BaseTickRates["0-50"]
	case playerCount <= 100:
		return atr.config.BaseTickRates["51-100"]
	case playerCount <= 200:
		return atr.config.BaseTickRates["101-200"]
	case playerCount <= 500:
		return atr.config.BaseTickRates["201-500"]
	default:
		return atr.config.BaseTickRates["500+"]
	}
}

// increaseTickRate increases the tick rate (reduces frequency) to reduce server load
func (atr *AdaptiveTickRate) increaseTickRate(current time.Duration) time.Duration {
	// Increase by 25% to reduce frequency
	newRate := time.Duration(float64(current) * 1.25)

	// Round to nearest 5ms for cleaner values
	ms := newRate.Milliseconds()
	rounded := (ms + 2) / 5 * 5 // Round to nearest 5ms

	return time.Duration(rounded) * time.Millisecond
}

// decreaseTickRate decreases the tick rate (increases frequency) for better responsiveness
func (atr *AdaptiveTickRate) decreaseTickRate(current time.Duration) time.Duration {
	// Decrease by 20% to increase frequency
	newRate := time.Duration(float64(current) * 0.8)

	// Round to nearest 5ms
	ms := newRate.Milliseconds()
	rounded := (ms + 2) / 5 * 5

	return time.Duration(rounded) * time.Millisecond
}

// GetStats returns current tick rate statistics
func (atr *AdaptiveTickRate) GetStats() map[string]interface{} {
	atr.mu.RLock()
	defer atr.mu.RUnlock()

	return map[string]interface{}{
		"current_tick_rate_ms": atr.currentTickRate.Milliseconds(),
		"current_player_count": atr.currentPlayerCount,
		"average_latency_ms":   atr.averageLatency.Milliseconds(),
		"tick_count":          atr.tickCount,
		"last_adjustment":     atr.lastAdjustment,
		"target_frequency_hz": 1000.0 / float64(atr.currentTickRate.Milliseconds()),
	}
}

// abs returns the absolute value of an integer
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}





