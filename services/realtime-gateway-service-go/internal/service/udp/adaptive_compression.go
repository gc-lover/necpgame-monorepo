// Code generated by NECPGAME Network agent. Adaptive compression for real-time data.
// PERFORMANCE: Adaptive algorithm selection (LZ4 for real-time, Zstandard for bulk)
// Issue: #2117
package udp

import (
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/klauspost/compress/zstd"
	"github.com/pierrec/lz4/v4"
	"go.uber.org/zap"
)

// CompressionAlgorithm represents available compression algorithms
type CompressionAlgorithm uint8

const (
	CompressionNone CompressionAlgorithm = iota
	CompressionDelta
	CompressionLZ4
	CompressionZstd
	CompressionAdaptive
)

// NetworkCondition represents current network conditions
type NetworkCondition struct {
	BandwidthMbps    float64 // Available bandwidth in Mbps
	LatencyMs       int     // Network latency in milliseconds
	PacketLossRate  float64 // Packet loss rate (0.0-1.0)
	LastUpdated     time.Time
}

// AdaptiveCompressor handles adaptive compression algorithm selection
type AdaptiveCompressor struct {
	// Current compression algorithm per client
	clientAlgorithms map[string]CompressionAlgorithm // clientAddr -> algorithm
	mu               sync.RWMutex

	// Network condition monitoring
	networkConditions map[string]*NetworkCondition // clientAddr -> condition
	conditionMu       sync.RWMutex

	// Compression statistics
	stats struct {
		mu                    sync.RWMutex
		totalCompressed       int64
		totalOriginal         int64
		algorithmUsage        map[CompressionAlgorithm]int64
		compressionRatios     map[CompressionAlgorithm]float64
		algorithmSwitches     int64
	}

	// Configuration
	config AdaptiveCompressionConfig
	logger *zap.Logger

	// Zstandard encoder/decoder with dictionary
	zstdEncoder *zstd.Encoder
	zstdDecoder *zstd.Decoder
	zstdDict    []byte
}

// AdaptiveCompressionConfig holds configuration for adaptive compression
type AdaptiveCompressionConfig struct {
	// Algorithm selection thresholds
	HighBandwidthThresholdMbps float64 // Use Zstd above this
	LowLatencyThresholdMs      int     // Use LZ4 below this
	HighPacketLossThreshold    float64 // Disable compression above this

	// Dictionary compression
	EnableDictionary bool
	DictionarySize   int

	// Adaptation interval
	AdaptationInterval time.Duration

	Logger *zap.Logger
}

// DefaultAdaptiveCompressionConfig returns default configuration
func DefaultAdaptiveCompressionConfig() AdaptiveCompressionConfig {
	return AdaptiveCompressionConfig{
		HighBandwidthThresholdMbps: 10.0,
		LowLatencyThresholdMs:      50,
		HighPacketLossThreshold:    0.05,
		EnableDictionary:          true,
		DictionarySize:            8192,
		AdaptationInterval:         30 * time.Second,
	}
}

// NewAdaptiveCompressor creates a new adaptive compressor
func NewAdaptiveCompressor(config AdaptiveCompressionConfig) (*AdaptiveCompressor, error) {
	if config.Logger == nil {
		config.Logger = zap.NewNop()
	}

	ac := &AdaptiveCompressor{
		clientAlgorithms: make(map[string]CompressionAlgorithm),
		networkConditions: make(map[string]*NetworkCondition),
		config:            config,
		logger:           config.Logger,
	}

	ac.stats.algorithmUsage = make(map[CompressionAlgorithm]int64)
	ac.stats.compressionRatios = make(map[CompressionAlgorithm]float64)

	// Initialize Zstandard encoder/decoder
	if config.EnableDictionary {
		// Build dictionary from sample game packets (simplified)
		ac.zstdDict = make([]byte, config.DictionarySize)
		// In production, build from actual game packet samples

		var err error
		ac.zstdEncoder, err = zstd.NewWriter(nil, zstd.WithEncoderDict(ac.zstdDict))
		if err != nil {
			return nil, errors.Wrap(err, "failed to create zstd encoder")
		}

		ac.zstdDecoder, err = zstd.NewReader(nil, zstd.WithDecoderDicts(ac.zstdDict))
		if err != nil {
			return nil, errors.Wrap(err, "failed to create zstd decoder")
		}
	} else {
		var err error
		ac.zstdEncoder, err = zstd.NewWriter(nil)
		if err != nil {
			return nil, errors.Wrap(err, "failed to create zstd encoder")
		}

		ac.zstdDecoder, err = zstd.NewReader(nil)
		if err != nil {
			return nil, errors.Wrap(err, "failed to create zstd decoder")
		}
	}

	return ac, nil
}

// Compress adaptively compresses data based on network conditions
func (ac *AdaptiveCompressor) Compress(clientAddr string, data []byte, isRealtime bool) ([]byte, CompressionAlgorithm, error) {
	ac.mu.RLock()
	algorithm, exists := ac.clientAlgorithms[clientAddr]
	ac.mu.RUnlock()

	// Select initial algorithm if not exists
	if !exists {
		algorithm = ac.selectInitialAlgorithm(clientAddr, isRealtime)
		ac.mu.Lock()
		ac.clientAlgorithms[clientAddr] = algorithm
		ac.mu.Unlock()
	}

	// Adapt algorithm based on network conditions
	condition := ac.getNetworkCondition(clientAddr)
	newAlgorithm := ac.adaptAlgorithm(algorithm, condition, isRealtime, len(data))

	if newAlgorithm != algorithm {
		ac.mu.Lock()
		ac.clientAlgorithms[clientAddr] = newAlgorithm
		ac.mu.Unlock()
		ac.stats.mu.Lock()
		ac.stats.algorithmSwitches++
		ac.stats.mu.Unlock()
		algorithm = newAlgorithm
	}

	// Compress using selected algorithm
	compressed, err := ac.compressWithAlgorithm(data, algorithm)
	if err != nil {
		return nil, CompressionNone, errors.Wrap(err, "compression failed")
	}

	// Update statistics
	ac.updateStats(algorithm, len(data), len(compressed))

	return compressed, algorithm, nil
}

// Decompress decompresses data using the algorithm used for compression
func (ac *AdaptiveCompressor) Decompress(clientAddr string, compressed []byte, algorithm CompressionAlgorithm) ([]byte, error) {
	return ac.decompressWithAlgorithm(compressed, algorithm)
}

// selectInitialAlgorithm selects initial compression algorithm
func (ac *AdaptiveCompressor) selectInitialAlgorithm(clientAddr string, isRealtime bool) CompressionAlgorithm {
	if isRealtime {
		// LZ4 for real-time data (low latency)
		return CompressionLZ4
	}
	// Zstd for bulk data (better compression ratio)
	return CompressionZstd
}

// adaptAlgorithm adapts compression algorithm based on network conditions
func (ac *AdaptiveCompressor) adaptAlgorithm(current CompressionAlgorithm, condition *NetworkCondition, isRealtime bool, dataSize int) CompressionAlgorithm {
	if condition == nil {
		return current
	}

	// High packet loss - disable compression
	if condition.PacketLossRate > ac.config.HighPacketLossThreshold {
		return CompressionNone
	}

	// Real-time data - prefer LZ4 for low latency
	if isRealtime {
		if condition.LatencyMs < ac.config.LowLatencyThresholdMs {
			return CompressionLZ4
		}
		// High latency - use delta compression only
		return CompressionDelta
	}

	// Bulk data - prefer Zstd for better ratio
	if condition.BandwidthMbps > ac.config.HighBandwidthThresholdMbps {
		return CompressionZstd
	}

	// Low bandwidth - use LZ4 (faster, less CPU)
	return CompressionLZ4
}

// compressWithAlgorithm compresses data using specified algorithm
func (ac *AdaptiveCompressor) compressWithAlgorithm(data []byte, algorithm CompressionAlgorithm) ([]byte, error) {
	switch algorithm {
	case CompressionNone:
		return data, nil
	case CompressionLZ4:
		compressed := make([]byte, lz4.CompressBlockBound(len(data)))
		n, err := lz4.CompressBlock(data, compressed, nil)
		if err != nil {
			return nil, errors.Wrap(err, "lz4 compression failed")
		}
		return compressed[:n], nil
	case CompressionZstd:
		return ac.zstdEncoder.EncodeAll(data, nil), nil
	case CompressionDelta:
		// Delta compression is handled separately by DeltaCompressor
		return data, nil
	default:
		return data, nil
	}
}

// decompressWithAlgorithm decompresses data using specified algorithm
func (ac *AdaptiveCompressor) decompressWithAlgorithm(compressed []byte, algorithm CompressionAlgorithm) ([]byte, error) {
	switch algorithm {
	case CompressionNone:
		return compressed, nil
	case CompressionLZ4:
		decompressed := make([]byte, len(compressed)*4) // Estimate
		n, err := lz4.UncompressBlock(compressed, decompressed)
		if err != nil {
			return nil, errors.Wrap(err, "lz4 decompression failed")
		}
		return decompressed[:n], nil
	case CompressionZstd:
		return ac.zstdDecoder.DecodeAll(compressed, nil)
	case CompressionDelta:
		return compressed, nil
	default:
		return compressed, nil
	}
}

// UpdateNetworkCondition updates network condition for a client
func (ac *AdaptiveCompressor) UpdateNetworkCondition(clientAddr string, condition *NetworkCondition) {
	ac.conditionMu.Lock()
	defer ac.conditionMu.Unlock()
	condition.LastUpdated = time.Now()
	ac.networkConditions[clientAddr] = condition
}

// getNetworkCondition gets current network condition for a client
func (ac *AdaptiveCompressor) getNetworkCondition(clientAddr string) *NetworkCondition {
	ac.conditionMu.RLock()
	defer ac.conditionMu.RUnlock()
	return ac.networkConditions[clientAddr]
}

// updateStats updates compression statistics
func (ac *AdaptiveCompressor) updateStats(algorithm CompressionAlgorithm, originalSize, compressedSize int) {
	ac.stats.mu.Lock()
	defer ac.stats.mu.Unlock()

	ac.stats.totalOriginal += int64(originalSize)
	ac.stats.totalCompressed += int64(compressedSize)
	ac.stats.algorithmUsage[algorithm]++

	if originalSize > 0 {
		ratio := float64(compressedSize) / float64(originalSize)
		// Update running average
		if ac.stats.compressionRatios[algorithm] == 0 {
			ac.stats.compressionRatios[algorithm] = ratio
		} else {
			ac.stats.compressionRatios[algorithm] = (ac.stats.compressionRatios[algorithm] + ratio) / 2
		}
	}
}

// GetStats returns compression statistics
func (ac *AdaptiveCompressor) GetStats() map[string]interface{} {
	ac.stats.mu.RLock()
	defer ac.stats.mu.RUnlock()

	return map[string]interface{}{
		"total_original":      ac.stats.totalOriginal,
		"total_compressed":    ac.stats.totalCompressed,
		"overall_ratio":       float64(ac.stats.totalCompressed) / float64(ac.stats.totalOriginal),
		"algorithm_usage":     ac.stats.algorithmUsage,
		"compression_ratios": ac.stats.compressionRatios,
		"algorithm_switches":  ac.stats.algorithmSwitches,
	}
}

// RemoveClient removes client from adaptive compressor
func (ac *AdaptiveCompressor) RemoveClient(clientAddr string) {
	ac.mu.Lock()
	delete(ac.clientAlgorithms, clientAddr)
	ac.mu.Unlock()

	ac.conditionMu.Lock()
	delete(ac.networkConditions, clientAddr)
	ac.conditionMu.Unlock()
}

// Close closes the adaptive compressor
func (ac *AdaptiveCompressor) Close() error {
	if ac.zstdEncoder != nil {
		ac.zstdEncoder.Close()
	}
	if ac.zstdDecoder != nil {
		ac.zstdDecoder.Close()
	}
	return nil
}
