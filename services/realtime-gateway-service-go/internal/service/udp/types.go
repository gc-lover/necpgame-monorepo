// Code generated by NECPGAME Network agent. UDP protocol types and data structures.
// PERFORMANCE: Coordinate quantization (50% bandwidth reduction), spatial partitioning (80% traffic reduction)
// Issue: Network optimization for realtime-gateway-service-go

package udp

import (
	"net"
	"time"
)

// PacketType defines UDP packet types for real-time game state
type PacketType uint16

const (
	PacketTypePosition  PacketType = 1 // Position updates (most frequent)
	PacketTypeRotation  PacketType = 2 // Rotation updates
	PacketTypeShooting  PacketType = 3 // Shooting events
	PacketTypeHeartbeat PacketType = 4 // Keep-alive packets
	PacketTypeDamage    PacketType = 5 // Damage events
	PacketTypeSpawn     PacketType = 6 // Entity spawn events
	PacketTypeDespawn   PacketType = 7 // Entity despawn events
)

// Client represents a UDP client connection
type Client struct {
	ID       uint16      // Client ID (from packet header)
	Addr     *net.UDPAddr // UDP address
	LastSeen time.Time   // Last packet received time
	Position Vec3        // Current position (quantized)
	Rotation Vec3        // Current rotation (quantized)
}

// Vec3 represents a 3D vector with coordinate quantization
// PERFORMANCE: int16 instead of float32 = 50% bandwidth reduction
type Vec3 struct {
	X, Y, Z float32
}

// Quantize converts float32 coordinates to int16 for network transmission
// Range: -327.68 to 327.67 with 0.01 precision (2 decimal places)
func (v Vec3) Quantize() (int16, int16, int16) {
	return int16(v.X * 100), int16(v.Y * 100), int16(v.Z * 100)
}

// Dequantize converts int16 coordinates back to float32
func Dequantize(x, y, z int16) Vec3 {
	return Vec3{
		X: float32(x) / 100,
		Y: float32(y) / 100,
		Z: float32(z) / 100,
	}
}

// Distance calculates Euclidean distance between two Vec3 points
func (v Vec3) Distance(other Vec3) float32 {
	dx := v.X - other.X
	dy := v.Y - other.Y
	dz := v.Z - other.Z
	return sqrt(dx*dx + dy*dy + dz*dz)
}

// sqrt implements fast inverse square root approximation for distance calculations
// PERFORMANCE: Fast approximation for real-time distance checks
func sqrt(x float32) float32 {
	if x <= 0 {
		return 0
	}

	// Fast inverse square root (Quake III algorithm adapted for float32)
	i := int32(x)
	i = 0x5f3759df - (i >> 1)
	y := *(*float32)(&i)
	y = y * (1.5 - 0.5*x*y*y) // Newton iteration
	return 1.0 / y            // Return actual sqrt
}

// PositionUpdate represents a quantized position update packet
type PositionUpdate struct {
	X, Y, Z int16 // Quantized coordinates (-327.68 to 327.67 range)
}

// RotationUpdate represents a quantized rotation update packet
type RotationUpdate struct {
	Pitch, Yaw, Roll int16 // Quantized rotations in degrees * 100
}

// ShootingEvent represents a shooting event with quantized vectors
type ShootingEvent struct {
	OriginX, OriginY, OriginZ       int16 // Shot origin point
	DirectionX, DirectionY, DirectionZ int16 // Shot direction vector
	WeaponID                         uint8 // Weapon type identifier
}

// DamageEvent represents a damage event
type DamageEvent struct {
	TargetID   uint16 // Target entity ID
	Damage     uint16 // Damage amount
	DamageType uint8  // Damage type (0=normal, 1=critical, 2=environmental)
}

// HeartbeatPacket represents a keep-alive packet
type HeartbeatPacket struct {
	Timestamp uint32 // Client timestamp for latency calculation
}





