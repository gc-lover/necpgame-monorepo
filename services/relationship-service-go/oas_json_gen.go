// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ContractTerms) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContractTerms) encodeFields(e *jx.Encoder) {
	{
		if s.DurationDays.Set {
			e.FieldStart("duration_days")
			s.DurationDays.Encode(e)
		}
	}
	{
		if s.PaymentAmount.Set {
			e.FieldStart("payment_amount")
			s.PaymentAmount.Encode(e)
		}
	}
	{
		if s.PaymentSchedule.Set {
			e.FieldStart("payment_schedule")
			s.PaymentSchedule.Encode(e)
		}
	}
}

var jsonFieldsNameOfContractTerms = [3]string{
	0: "duration_days",
	1: "payment_amount",
	2: "payment_schedule",
}

// Decode decodes ContractTerms from json.
func (s *ContractTerms) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractTerms to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_days":
			if err := func() error {
				s.DurationDays.Reset()
				if err := s.DurationDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_days\"")
			}
		case "payment_amount":
			if err := func() error {
				s.PaymentAmount.Reset()
				if err := s.PaymentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_amount\"")
			}
		case "payment_schedule":
			if err := func() error {
				s.PaymentSchedule.Reset()
				if err := s.PaymentSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_schedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContractTerms")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContractTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContractTermsPaymentSchedule as json.
func (s ContractTermsPaymentSchedule) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContractTermsPaymentSchedule from json.
func (s *ContractTermsPaymentSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContractTermsPaymentSchedule to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContractTermsPaymentSchedule(v) {
	case ContractTermsPaymentScheduleWeekly:
		*s = ContractTermsPaymentScheduleWeekly
	case ContractTermsPaymentScheduleMonthly:
		*s = ContractTermsPaymentScheduleMonthly
	case ContractTermsPaymentScheduleCompletion:
		*s = ContractTermsPaymentScheduleCompletion
	default:
		*s = ContractTermsPaymentSchedule(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContractTermsPaymentSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContractTermsPaymentSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRelationshipBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRelationshipBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRelationshipBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes CreateRelationshipBadRequest from json.
func (s *CreateRelationshipBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRelationshipBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CreateRelationshipBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRelationshipBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateRelationshipBadRequest) {
					name = jsonFieldsNameOfCreateRelationshipBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRelationshipBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRelationshipBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRelationshipBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRelationshipBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateRelationshipBadRequestDetails = [0]string{}

// Decode decodes CreateRelationshipBadRequestDetails from json.
func (s *CreateRelationshipBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRelationshipBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateRelationshipBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRelationshipBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRelationshipBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRelationshipConflictApplicationJSON as json.
func (s CreateRelationshipConflictApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes CreateRelationshipConflictApplicationJSON from json.
func (s *CreateRelationshipConflictApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRelationshipConflictApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateRelationshipConflictApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRelationshipConflictApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRelationshipConflictApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRelationshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRelationshipRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.InitialLevel.Set {
			e.FieldStart("initial_level")
			s.InitialLevel.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IsPublic.Set {
			e.FieldStart("is_public")
			s.IsPublic.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRelationshipRequest = [5]string{
	0: "target_id",
	1: "type",
	2: "initial_level",
	3: "description",
	4: "is_public",
}

// Decode decodes CreateRelationshipRequest from json.
func (s *CreateRelationshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRelationshipRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "initial_level":
			if err := func() error {
				s.InitialLevel.Reset()
				if err := s.InitialLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "is_public":
			if err := func() error {
				s.IsPublic.Reset()
				if err := s.IsPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_public\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRelationshipRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateRelationshipRequest) {
					name = jsonFieldsNameOfCreateRelationshipRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRelationshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRelationshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRelationshipRequestType as json.
func (s CreateRelationshipRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateRelationshipRequestType from json.
func (s *CreateRelationshipRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRelationshipRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateRelationshipRequestType(v) {
	case CreateRelationshipRequestTypeFriendship:
		*s = CreateRelationshipRequestTypeFriendship
	case CreateRelationshipRequestTypeRomance:
		*s = CreateRelationshipRequestTypeRomance
	case CreateRelationshipRequestTypeRivalry:
		*s = CreateRelationshipRequestTypeRivalry
	case CreateRelationshipRequestTypeMentorship:
		*s = CreateRelationshipRequestTypeMentorship
	case CreateRelationshipRequestTypeBusiness:
		*s = CreateRelationshipRequestTypeBusiness
	case CreateRelationshipRequestTypeEnmity:
		*s = CreateRelationshipRequestTypeEnmity
	default:
		*s = CreateRelationshipRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRelationshipRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRelationshipRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclareRivalryBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclareRivalryBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeclareRivalryBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes DeclareRivalryBadRequest from json.
func (s *DeclareRivalryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareRivalryBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem DeclareRivalryBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeclareRivalryBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclareRivalryBadRequest) {
					name = jsonFieldsNameOfDeclareRivalryBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclareRivalryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareRivalryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclareRivalryBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclareRivalryBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDeclareRivalryBadRequestDetails = [0]string{}

// Decode decodes DeclareRivalryBadRequestDetails from json.
func (s *DeclareRivalryBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareRivalryBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DeclareRivalryBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclareRivalryBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareRivalryBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclareRivalryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclareRivalryRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		if s.InitialIntensity.Set {
			e.FieldStart("initial_intensity")
			s.InitialIntensity.Encode(e)
		}
	}
	{
		if s.IsPublic.Set {
			e.FieldStart("is_public")
			s.IsPublic.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeclareRivalryRequest = [4]string{
	0: "target_id",
	1: "reason",
	2: "initial_intensity",
	3: "is_public",
}

// Decode decodes DeclareRivalryRequest from json.
func (s *DeclareRivalryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareRivalryRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "initial_intensity":
			if err := func() error {
				s.InitialIntensity.Reset()
				if err := s.InitialIntensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_intensity\"")
			}
		case "is_public":
			if err := func() error {
				s.IsPublic.Reset()
				if err := s.IsPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_public\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeclareRivalryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclareRivalryRequest) {
					name = jsonFieldsNameOfDeclareRivalryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclareRivalryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareRivalryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeclareRivalryRequestInitialIntensity as json.
func (s DeclareRivalryRequestInitialIntensity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeclareRivalryRequestInitialIntensity from json.
func (s *DeclareRivalryRequestInitialIntensity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclareRivalryRequestInitialIntensity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeclareRivalryRequestInitialIntensity(v) {
	case DeclareRivalryRequestInitialIntensityMinor:
		*s = DeclareRivalryRequestInitialIntensityMinor
	case DeclareRivalryRequestInitialIntensityModerate:
		*s = DeclareRivalryRequestInitialIntensityModerate
	case DeclareRivalryRequestInitialIntensityMajor:
		*s = DeclareRivalryRequestInitialIntensityMajor
	case DeclareRivalryRequestInitialIntensityDeadly:
		*s = DeclareRivalryRequestInitialIntensityDeadly
	default:
		*s = DeclareRivalryRequestInitialIntensity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeclareRivalryRequestInitialIntensity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclareRivalryRequestInitialIntensity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendRequestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendRequestResponse) encodeFields(e *jx.Encoder) {
	{
		if s.FriendshipID.Set {
			e.FieldStart("friendship_id")
			s.FriendshipID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RequestedAt.Set {
			e.FieldStart("requested_at")
			s.RequestedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendRequestResponse = [4]string{
	0: "friendship_id",
	1: "status",
	2: "requested_at",
	3: "message",
}

// Decode decodes FriendRequestResponse from json.
func (s *FriendRequestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendRequestResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friendship_id":
			if err := func() error {
				s.FriendshipID.Reset()
				if err := s.FriendshipID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendship_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_at":
			if err := func() error {
				s.RequestedAt.Reset()
				if err := s.RequestedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_at\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendRequestResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendRequestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendRequestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendRequestResponseStatus as json.
func (s FriendRequestResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FriendRequestResponseStatus from json.
func (s *FriendRequestResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendRequestResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FriendRequestResponseStatus(v) {
	case FriendRequestResponseStatusPending:
		*s = FriendRequestResponseStatusPending
	case FriendRequestResponseStatusAccepted:
		*s = FriendRequestResponseStatusAccepted
	case FriendRequestResponseStatusDeclined:
		*s = FriendRequestResponseStatusDeclined
	default:
		*s = FriendRequestResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendRequestResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendRequestResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendshipResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendshipResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("user_id")
		json.EncodeUUID(e, s.UserID)
	}
	{
		e.FieldStart("friend_id")
		json.EncodeUUID(e, s.FriendID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.RequestedAt.Set {
			e.FieldStart("requested_at")
			s.RequestedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AcceptedAt.Set {
			e.FieldStart("accepted_at")
			s.AcceptedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BlockedAt.Set {
			e.FieldStart("blocked_at")
			s.BlockedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FriendshipLevel.Set {
			e.FieldStart("friendship_level")
			s.FriendshipLevel.Encode(e)
		}
	}
	{
		if s.SharedExperiences.Set {
			e.FieldStart("shared_experiences")
			s.SharedExperiences.Encode(e)
		}
	}
	{
		if s.FriendProfile.Set {
			e.FieldStart("friend_profile")
			s.FriendProfile.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendshipResponse = [12]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "user_id",
	4:  "friend_id",
	5:  "status",
	6:  "requested_at",
	7:  "accepted_at",
	8:  "blocked_at",
	9:  "friendship_level",
	10: "shared_experiences",
	11: "friend_profile",
}

// Decode decodes FriendshipResponse from json.
func (s *FriendshipResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendshipResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "friend_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.FriendID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friend_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_at":
			if err := func() error {
				s.RequestedAt.Reset()
				if err := s.RequestedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_at\"")
			}
		case "accepted_at":
			if err := func() error {
				s.AcceptedAt.Reset()
				if err := s.AcceptedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accepted_at\"")
			}
		case "blocked_at":
			if err := func() error {
				s.BlockedAt.Reset()
				if err := s.BlockedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_at\"")
			}
		case "friendship_level":
			if err := func() error {
				s.FriendshipLevel.Reset()
				if err := s.FriendshipLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendship_level\"")
			}
		case "shared_experiences":
			if err := func() error {
				s.SharedExperiences.Reset()
				if err := s.SharedExperiences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared_experiences\"")
			}
		case "friend_profile":
			if err := func() error {
				s.FriendProfile.Reset()
				if err := s.FriendProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friend_profile\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendshipResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFriendshipResponse) {
					name = jsonFieldsNameOfFriendshipResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FriendshipResponseFriendProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FriendshipResponseFriendProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfFriendshipResponseFriendProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes FriendshipResponseFriendProfile from json.
func (s *FriendshipResponseFriendProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendshipResponseFriendProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FriendshipResponseFriendProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFriendshipResponseFriendProfile) {
					name = jsonFieldsNameOfFriendshipResponseFriendProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FriendshipResponseFriendProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendshipResponseFriendProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendshipResponseStatus as json.
func (s FriendshipResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FriendshipResponseStatus from json.
func (s *FriendshipResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FriendshipResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FriendshipResponseStatus(v) {
	case FriendshipResponseStatusPending:
		*s = FriendshipResponseStatusPending
	case FriendshipResponseStatusAccepted:
		*s = FriendshipResponseStatusAccepted
	case FriendshipResponseStatusBlocked:
		*s = FriendshipResponseStatusBlocked
	default:
		*s = FriendshipResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FriendshipResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FriendshipResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMentorshipRelationshipsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMentorshipRelationshipsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfGetMentorshipRelationshipsOK = [4]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes GetMentorshipRelationshipsOK from json.
func (s *GetMentorshipRelationshipsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMentorshipRelationshipsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]MentorshipResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MentorshipResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMentorshipRelationshipsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetMentorshipRelationshipsOK) {
					name = jsonFieldsNameOfGetMentorshipRelationshipsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMentorshipRelationshipsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMentorshipRelationshipsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMentorshipRelationshipsUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMentorshipRelationshipsUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMentorshipRelationshipsUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetMentorshipRelationshipsUnauthorized from json.
func (s *GetMentorshipRelationshipsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMentorshipRelationshipsUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetMentorshipRelationshipsUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMentorshipRelationshipsUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetMentorshipRelationshipsUnauthorized) {
					name = jsonFieldsNameOfGetMentorshipRelationshipsUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMentorshipRelationshipsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMentorshipRelationshipsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMentorshipRelationshipsUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMentorshipRelationshipsUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetMentorshipRelationshipsUnauthorizedDetails = [0]string{}

// Decode decodes GetMentorshipRelationshipsUnauthorizedDetails from json.
func (s *GetMentorshipRelationshipsUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMentorshipRelationshipsUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetMentorshipRelationshipsUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMentorshipRelationshipsUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMentorshipRelationshipsUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRelationshipNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRelationshipNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRelationshipNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetRelationshipNotFound from json.
func (s *GetRelationshipNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRelationshipNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetRelationshipNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRelationshipNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRelationshipNotFound) {
					name = jsonFieldsNameOfGetRelationshipNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRelationshipNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRelationshipNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRelationshipNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRelationshipNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRelationshipNotFoundDetails = [0]string{}

// Decode decodes GetRelationshipNotFoundDetails from json.
func (s *GetRelationshipNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRelationshipNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRelationshipNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRelationshipNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRelationshipNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetReputationHistoryNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetReputationHistoryNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetReputationHistoryNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetReputationHistoryNotFound from json.
func (s *GetReputationHistoryNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReputationHistoryNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetReputationHistoryNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetReputationHistoryNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetReputationHistoryNotFound) {
					name = jsonFieldsNameOfGetReputationHistoryNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReputationHistoryNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReputationHistoryNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetReputationHistoryNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetReputationHistoryNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetReputationHistoryNotFoundDetails = [0]string{}

// Decode decodes GetReputationHistoryNotFoundDetails from json.
func (s *GetReputationHistoryNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReputationHistoryNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetReputationHistoryNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReputationHistoryNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReputationHistoryNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetReputationHistoryOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetReputationHistoryOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfGetReputationHistoryOK = [4]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes GetReputationHistoryOK from json.
func (s *GetReputationHistoryOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReputationHistoryOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]ReputationEventResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReputationEventResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetReputationHistoryOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetReputationHistoryOK) {
					name = jsonFieldsNameOfGetReputationHistoryOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReputationHistoryOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReputationHistoryOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRomanticRelationshipsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRomanticRelationshipsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Relationships != nil {
			e.FieldStart("relationships")
			e.ArrStart()
			for _, elem := range s.Relationships {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetRomanticRelationshipsOK = [1]string{
	0: "relationships",
}

// Decode decodes GetRomanticRelationshipsOK from json.
func (s *GetRomanticRelationshipsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRomanticRelationshipsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "relationships":
			if err := func() error {
				s.Relationships = make([]RomanticRelationshipResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RomanticRelationshipResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Relationships = append(s.Relationships, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationships\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRomanticRelationshipsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRomanticRelationshipsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRomanticRelationshipsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRomanticRelationshipsUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRomanticRelationshipsUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRomanticRelationshipsUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetRomanticRelationshipsUnauthorized from json.
func (s *GetRomanticRelationshipsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRomanticRelationshipsUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetRomanticRelationshipsUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRomanticRelationshipsUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRomanticRelationshipsUnauthorized) {
					name = jsonFieldsNameOfGetRomanticRelationshipsUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRomanticRelationshipsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRomanticRelationshipsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRomanticRelationshipsUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRomanticRelationshipsUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRomanticRelationshipsUnauthorizedDetails = [0]string{}

// Decode decodes GetRomanticRelationshipsUnauthorizedDetails from json.
func (s *GetRomanticRelationshipsUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRomanticRelationshipsUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRomanticRelationshipsUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRomanticRelationshipsUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRomanticRelationshipsUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSocialConnectionsNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSocialConnectionsNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSocialConnectionsNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetSocialConnectionsNotFound from json.
func (s *GetSocialConnectionsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSocialConnectionsNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetSocialConnectionsNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSocialConnectionsNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSocialConnectionsNotFound) {
					name = jsonFieldsNameOfGetSocialConnectionsNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSocialConnectionsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSocialConnectionsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSocialConnectionsNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSocialConnectionsNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetSocialConnectionsNotFoundDetails = [0]string{}

// Decode decodes GetSocialConnectionsNotFoundDetails from json.
func (s *GetSocialConnectionsNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSocialConnectionsNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetSocialConnectionsNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSocialConnectionsNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSocialConnectionsNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSocialInfluenceNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSocialInfluenceNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSocialInfluenceNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetSocialInfluenceNotFound from json.
func (s *GetSocialInfluenceNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSocialInfluenceNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetSocialInfluenceNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSocialInfluenceNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSocialInfluenceNotFound) {
					name = jsonFieldsNameOfGetSocialInfluenceNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSocialInfluenceNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSocialInfluenceNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSocialInfluenceNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSocialInfluenceNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetSocialInfluenceNotFoundDetails = [0]string{}

// Decode decodes GetSocialInfluenceNotFoundDetails from json.
func (s *GetSocialInfluenceNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSocialInfluenceNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetSocialInfluenceNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSocialInfluenceNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSocialInfluenceNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserFriendshipsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserFriendshipsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfGetUserFriendshipsOK = [4]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes GetUserFriendshipsOK from json.
func (s *GetUserFriendshipsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserFriendshipsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]FriendshipResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FriendshipResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserFriendshipsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserFriendshipsOK) {
					name = jsonFieldsNameOfGetUserFriendshipsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserFriendshipsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserFriendshipsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserFriendshipsUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserFriendshipsUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserFriendshipsUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetUserFriendshipsUnauthorized from json.
func (s *GetUserFriendshipsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserFriendshipsUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetUserFriendshipsUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserFriendshipsUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserFriendshipsUnauthorized) {
					name = jsonFieldsNameOfGetUserFriendshipsUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserFriendshipsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserFriendshipsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserFriendshipsUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserFriendshipsUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetUserFriendshipsUnauthorizedDetails = [0]string{}

// Decode decodes GetUserFriendshipsUnauthorizedDetails from json.
func (s *GetUserFriendshipsUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserFriendshipsUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetUserFriendshipsUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserFriendshipsUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserFriendshipsUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRelationshipsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRelationshipsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfGetUserRelationshipsOK = [4]string{
	0: "items",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes GetUserRelationshipsOK from json.
func (s *GetUserRelationshipsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRelationshipsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]RelationshipResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RelationshipResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRelationshipsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserRelationshipsOK) {
					name = jsonFieldsNameOfGetUserRelationshipsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRelationshipsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRelationshipsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRelationshipsUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRelationshipsUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserRelationshipsUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetUserRelationshipsUnauthorized from json.
func (s *GetUserRelationshipsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRelationshipsUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetUserRelationshipsUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRelationshipsUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserRelationshipsUnauthorized) {
					name = jsonFieldsNameOfGetUserRelationshipsUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRelationshipsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRelationshipsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRelationshipsUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRelationshipsUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetUserRelationshipsUnauthorizedDetails = [0]string{}

// Decode decodes GetUserRelationshipsUnauthorizedDetails from json.
func (s *GetUserRelationshipsUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRelationshipsUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRelationshipsUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRelationshipsUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRelationshipsUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserReputationNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserReputationNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserReputationNotFound = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetUserReputationNotFound from json.
func (s *GetUserReputationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserReputationNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetUserReputationNotFoundDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserReputationNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserReputationNotFound) {
					name = jsonFieldsNameOfGetUserReputationNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserReputationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserReputationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserReputationNotFoundDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserReputationNotFoundDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetUserReputationNotFoundDetails = [0]string{}

// Decode decodes GetUserReputationNotFoundDetails from json.
func (s *GetUserReputationNotFoundDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserReputationNotFoundDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetUserReputationNotFoundDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserReputationNotFoundDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserReputationNotFoundDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRivalriesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRivalriesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Rivalries != nil {
			e.FieldStart("rivalries")
			e.ArrStart()
			for _, elem := range s.Rivalries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetUserRivalriesOK = [1]string{
	0: "rivalries",
}

// Decode decodes GetUserRivalriesOK from json.
func (s *GetUserRivalriesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRivalriesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rivalries":
			if err := func() error {
				s.Rivalries = make([]RivalryResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RivalryResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rivalries = append(s.Rivalries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rivalries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRivalriesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRivalriesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRivalriesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRivalriesUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRivalriesUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserRivalriesUnauthorized = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes GetUserRivalriesUnauthorized from json.
func (s *GetUserRivalriesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRivalriesUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem GetUserRivalriesUnauthorizedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRivalriesUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserRivalriesUnauthorized) {
					name = jsonFieldsNameOfGetUserRivalriesUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRivalriesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRivalriesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserRivalriesUnauthorizedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserRivalriesUnauthorizedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetUserRivalriesUnauthorizedDetails = [0]string{}

// Decode decodes GetUserRivalriesUnauthorizedDetails from json.
func (s *GetUserRivalriesUnauthorizedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserRivalriesUnauthorizedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetUserRivalriesUnauthorizedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserRivalriesUnauthorizedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserRivalriesUnauthorizedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateMentorshipBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateMentorshipBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateMentorshipBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes InitiateMentorshipBadRequest from json.
func (s *InitiateMentorshipBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateMentorshipBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem InitiateMentorshipBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateMentorshipBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateMentorshipBadRequest) {
					name = jsonFieldsNameOfInitiateMentorshipBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateMentorshipBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateMentorshipBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateMentorshipBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateMentorshipBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitiateMentorshipBadRequestDetails = [0]string{}

// Decode decodes InitiateMentorshipBadRequestDetails from json.
func (s *InitiateMentorshipBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateMentorshipBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitiateMentorshipBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateMentorshipBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateMentorshipBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateMentorshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateMentorshipRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("skills_to_teach")
		e.ArrStart()
		for _, elem := range s.SkillsToTeach {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ContractTerms.Set {
			e.FieldStart("contract_terms")
			s.ContractTerms.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateMentorshipRequest = [3]string{
	0: "target_id",
	1: "skills_to_teach",
	2: "contract_terms",
}

// Decode decodes InitiateMentorshipRequest from json.
func (s *InitiateMentorshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateMentorshipRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "skills_to_teach":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.SkillsToTeach = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SkillsToTeach = append(s.SkillsToTeach, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skills_to_teach\"")
			}
		case "contract_terms":
			if err := func() error {
				s.ContractTerms.Reset()
				if err := s.ContractTerms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_terms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateMentorshipRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateMentorshipRequest) {
					name = jsonFieldsNameOfInitiateMentorshipRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateMentorshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateMentorshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateMentorshipRequestContractTerms) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateMentorshipRequestContractTerms) encodeFields(e *jx.Encoder) {
	{
		if s.DurationDays.Set {
			e.FieldStart("duration_days")
			s.DurationDays.Encode(e)
		}
	}
	{
		if s.PaymentAmount.Set {
			e.FieldStart("payment_amount")
			s.PaymentAmount.Encode(e)
		}
	}
	{
		if s.PaymentSchedule.Set {
			e.FieldStart("payment_schedule")
			s.PaymentSchedule.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateMentorshipRequestContractTerms = [3]string{
	0: "duration_days",
	1: "payment_amount",
	2: "payment_schedule",
}

// Decode decodes InitiateMentorshipRequestContractTerms from json.
func (s *InitiateMentorshipRequestContractTerms) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateMentorshipRequestContractTerms to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_days":
			if err := func() error {
				s.DurationDays.Reset()
				if err := s.DurationDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_days\"")
			}
		case "payment_amount":
			if err := func() error {
				s.PaymentAmount.Reset()
				if err := s.PaymentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_amount\"")
			}
		case "payment_schedule":
			if err := func() error {
				s.PaymentSchedule.Reset()
				if err := s.PaymentSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_schedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateMentorshipRequestContractTerms")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateMentorshipRequestContractTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateMentorshipRequestContractTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateMentorshipRequestContractTermsPaymentSchedule as json.
func (s InitiateMentorshipRequestContractTermsPaymentSchedule) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateMentorshipRequestContractTermsPaymentSchedule from json.
func (s *InitiateMentorshipRequestContractTermsPaymentSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateMentorshipRequestContractTermsPaymentSchedule to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateMentorshipRequestContractTermsPaymentSchedule(v) {
	case InitiateMentorshipRequestContractTermsPaymentScheduleWeekly:
		*s = InitiateMentorshipRequestContractTermsPaymentScheduleWeekly
	case InitiateMentorshipRequestContractTermsPaymentScheduleMonthly:
		*s = InitiateMentorshipRequestContractTermsPaymentScheduleMonthly
	case InitiateMentorshipRequestContractTermsPaymentScheduleCompletion:
		*s = InitiateMentorshipRequestContractTermsPaymentScheduleCompletion
	default:
		*s = InitiateMentorshipRequestContractTermsPaymentSchedule(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateMentorshipRequestContractTermsPaymentSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateMentorshipRequestContractTermsPaymentSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipProgressResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ProgressID.Set {
			e.FieldStart("progress_id")
			s.ProgressID.Encode(e)
		}
	}
	{
		if s.MentorshipID.Set {
			e.FieldStart("mentorship_id")
			s.MentorshipID.Encode(e)
		}
	}
	{
		if s.RecordedAt.Set {
			e.FieldStart("recorded_at")
			s.RecordedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProgressType.Set {
			e.FieldStart("progress_type")
			s.ProgressType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.SkillImprovements != nil {
			e.FieldStart("skill_improvements")
			e.ArrStart()
			for _, elem := range s.SkillImprovements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMentorshipProgressResponse = [6]string{
	0: "progress_id",
	1: "mentorship_id",
	2: "recorded_at",
	3: "progress_type",
	4: "description",
	5: "skill_improvements",
}

// Decode decodes MentorshipProgressResponse from json.
func (s *MentorshipProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipProgressResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "progress_id":
			if err := func() error {
				s.ProgressID.Reset()
				if err := s.ProgressID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_id\"")
			}
		case "mentorship_id":
			if err := func() error {
				s.MentorshipID.Reset()
				if err := s.MentorshipID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentorship_id\"")
			}
		case "recorded_at":
			if err := func() error {
				s.RecordedAt.Reset()
				if err := s.RecordedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recorded_at\"")
			}
		case "progress_type":
			if err := func() error {
				s.ProgressType.Reset()
				if err := s.ProgressType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "skill_improvements":
			if err := func() error {
				s.SkillImprovements = make([]MentorshipProgressResponseSkillImprovementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MentorshipProgressResponseSkillImprovementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SkillImprovements = append(s.SkillImprovements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_improvements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipProgressResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipProgressResponseProgressType as json.
func (s MentorshipProgressResponseProgressType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MentorshipProgressResponseProgressType from json.
func (s *MentorshipProgressResponseProgressType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipProgressResponseProgressType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MentorshipProgressResponseProgressType(v) {
	case MentorshipProgressResponseProgressTypeLessonCompleted:
		*s = MentorshipProgressResponseProgressTypeLessonCompleted
	case MentorshipProgressResponseProgressTypeSkillImproved:
		*s = MentorshipProgressResponseProgressTypeSkillImproved
	case MentorshipProgressResponseProgressTypeMilestoneAchieved:
		*s = MentorshipProgressResponseProgressTypeMilestoneAchieved
	case MentorshipProgressResponseProgressTypeIssueResolved:
		*s = MentorshipProgressResponseProgressTypeIssueResolved
	default:
		*s = MentorshipProgressResponseProgressType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MentorshipProgressResponseProgressType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipProgressResponseProgressType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipProgressResponseSkillImprovementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipProgressResponseSkillImprovementsItem) encodeFields(e *jx.Encoder) {
	{
		if s.SkillName.Set {
			e.FieldStart("skill_name")
			s.SkillName.Encode(e)
		}
	}
	{
		if s.ImprovementPercent.Set {
			e.FieldStart("improvement_percent")
			s.ImprovementPercent.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipProgressResponseSkillImprovementsItem = [2]string{
	0: "skill_name",
	1: "improvement_percent",
}

// Decode decodes MentorshipProgressResponseSkillImprovementsItem from json.
func (s *MentorshipProgressResponseSkillImprovementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipProgressResponseSkillImprovementsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill_name":
			if err := func() error {
				s.SkillName.Reset()
				if err := s.SkillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_name\"")
			}
		case "improvement_percent":
			if err := func() error {
				s.ImprovementPercent.Reset()
				if err := s.ImprovementPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"improvement_percent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipProgressResponseSkillImprovementsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipProgressResponseSkillImprovementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipProgressResponseSkillImprovementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("mentor_id")
		json.EncodeUUID(e, s.MentorID)
	}
	{
		e.FieldStart("mentee_id")
		json.EncodeUUID(e, s.MenteeID)
	}
	{
		e.FieldStart("contract_terms")
		s.ContractTerms.Encode(e)
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipResponse = [17]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "mentor_id",
	13: "mentee_id",
	14: "contract_terms",
	15: "progress",
	16: "status",
}

// Decode decodes MentorshipResponse from json.
func (s *MentorshipResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]MentorshipResponseFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MentorshipResponseFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "mentor_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.MentorID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentor_id\"")
			}
		case "mentee_id":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.MenteeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentee_id\"")
			}
		case "contract_terms":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ContractTerms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_terms\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b01110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMentorshipResponse) {
					name = jsonFieldsNameOfMentorshipResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipResponseContractTerms) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipResponseContractTerms) encodeFields(e *jx.Encoder) {
	{
		if s.DurationDays.Set {
			e.FieldStart("duration_days")
			s.DurationDays.Encode(e)
		}
	}
	{
		if s.SkillsToTeach != nil {
			e.FieldStart("skills_to_teach")
			e.ArrStart()
			for _, elem := range s.SkillsToTeach {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PaymentTerms.Set {
			e.FieldStart("payment_terms")
			s.PaymentTerms.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipResponseContractTerms = [3]string{
	0: "duration_days",
	1: "skills_to_teach",
	2: "payment_terms",
}

// Decode decodes MentorshipResponseContractTerms from json.
func (s *MentorshipResponseContractTerms) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseContractTerms to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_days":
			if err := func() error {
				s.DurationDays.Reset()
				if err := s.DurationDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_days\"")
			}
		case "skills_to_teach":
			if err := func() error {
				s.SkillsToTeach = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SkillsToTeach = append(s.SkillsToTeach, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skills_to_teach\"")
			}
		case "payment_terms":
			if err := func() error {
				s.PaymentTerms.Reset()
				if err := s.PaymentTerms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_terms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipResponseContractTerms")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipResponseContractTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseContractTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipResponseContractTermsPaymentTerms) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipResponseContractTermsPaymentTerms) encodeFields(e *jx.Encoder) {
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Schedule.Set {
			e.FieldStart("schedule")
			s.Schedule.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipResponseContractTermsPaymentTerms = [3]string{
	0: "currency",
	1: "amount",
	2: "schedule",
}

// Decode decodes MentorshipResponseContractTermsPaymentTerms from json.
func (s *MentorshipResponseContractTermsPaymentTerms) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseContractTermsPaymentTerms to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "schedule":
			if err := func() error {
				s.Schedule.Reset()
				if err := s.Schedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipResponseContractTermsPaymentTerms")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipResponseContractTermsPaymentTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseContractTermsPaymentTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseContractTermsPaymentTermsSchedule as json.
func (s MentorshipResponseContractTermsPaymentTermsSchedule) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MentorshipResponseContractTermsPaymentTermsSchedule from json.
func (s *MentorshipResponseContractTermsPaymentTermsSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseContractTermsPaymentTermsSchedule to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MentorshipResponseContractTermsPaymentTermsSchedule(v) {
	case MentorshipResponseContractTermsPaymentTermsScheduleWeekly:
		*s = MentorshipResponseContractTermsPaymentTermsScheduleWeekly
	case MentorshipResponseContractTermsPaymentTermsScheduleMonthly:
		*s = MentorshipResponseContractTermsPaymentTermsScheduleMonthly
	case MentorshipResponseContractTermsPaymentTermsScheduleCompletion:
		*s = MentorshipResponseContractTermsPaymentTermsScheduleCompletion
	default:
		*s = MentorshipResponseContractTermsPaymentTermsSchedule(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MentorshipResponseContractTermsPaymentTermsSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseContractTermsPaymentTermsSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseFlagsItem as json.
func (s MentorshipResponseFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MentorshipResponseFlagsItem from json.
func (s *MentorshipResponseFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MentorshipResponseFlagsItem(v) {
	case MentorshipResponseFlagsItemExclusive:
		*s = MentorshipResponseFlagsItemExclusive
	case MentorshipResponseFlagsItemPublic:
		*s = MentorshipResponseFlagsItemPublic
	case MentorshipResponseFlagsItemSecret:
		*s = MentorshipResponseFlagsItemSecret
	case MentorshipResponseFlagsItemTemporary:
		*s = MentorshipResponseFlagsItemTemporary
	default:
		*s = MentorshipResponseFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MentorshipResponseFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipResponseProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipResponseProgress) encodeFields(e *jx.Encoder) {
	{
		if s.LessonsCompleted.Set {
			e.FieldStart("lessons_completed")
			s.LessonsCompleted.Encode(e)
		}
	}
	{
		if s.SkillsImproved != nil {
			e.FieldStart("skills_improved")
			e.ArrStart()
			for _, elem := range s.SkillsImproved {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SatisfactionRating.Set {
			e.FieldStart("satisfaction_rating")
			s.SatisfactionRating.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipResponseProgress = [3]string{
	0: "lessons_completed",
	1: "skills_improved",
	2: "satisfaction_rating",
}

// Decode decodes MentorshipResponseProgress from json.
func (s *MentorshipResponseProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lessons_completed":
			if err := func() error {
				s.LessonsCompleted.Reset()
				if err := s.LessonsCompleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lessons_completed\"")
			}
		case "skills_improved":
			if err := func() error {
				s.SkillsImproved = make([]MentorshipResponseProgressSkillsImprovedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MentorshipResponseProgressSkillsImprovedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SkillsImproved = append(s.SkillsImproved, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skills_improved\"")
			}
		case "satisfaction_rating":
			if err := func() error {
				s.SatisfactionRating.Reset()
				if err := s.SatisfactionRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"satisfaction_rating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipResponseProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipResponseProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MentorshipResponseProgressSkillsImprovedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MentorshipResponseProgressSkillsImprovedItem) encodeFields(e *jx.Encoder) {
	{
		if s.SkillName.Set {
			e.FieldStart("skill_name")
			s.SkillName.Encode(e)
		}
	}
	{
		if s.ImprovementPercent.Set {
			e.FieldStart("improvement_percent")
			s.ImprovementPercent.Encode(e)
		}
	}
}

var jsonFieldsNameOfMentorshipResponseProgressSkillsImprovedItem = [2]string{
	0: "skill_name",
	1: "improvement_percent",
}

// Decode decodes MentorshipResponseProgressSkillsImprovedItem from json.
func (s *MentorshipResponseProgressSkillsImprovedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseProgressSkillsImprovedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill_name":
			if err := func() error {
				s.SkillName.Reset()
				if err := s.SkillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_name\"")
			}
		case "improvement_percent":
			if err := func() error {
				s.ImprovementPercent.Reset()
				if err := s.ImprovementPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"improvement_percent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MentorshipResponseProgressSkillsImprovedItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MentorshipResponseProgressSkillsImprovedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseProgressSkillsImprovedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseStatus as json.
func (s MentorshipResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MentorshipResponseStatus from json.
func (s *MentorshipResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MentorshipResponseStatus(v) {
	case MentorshipResponseStatusActive:
		*s = MentorshipResponseStatusActive
	case MentorshipResponseStatusCompleted:
		*s = MentorshipResponseStatusCompleted
	case MentorshipResponseStatusTerminated:
		*s = MentorshipResponseStatusTerminated
	case MentorshipResponseStatusPaused:
		*s = MentorshipResponseStatusPaused
	default:
		*s = MentorshipResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MentorshipResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseType as json.
func (s MentorshipResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MentorshipResponseType from json.
func (s *MentorshipResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MentorshipResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MentorshipResponseType(v) {
	case MentorshipResponseTypeFriendship:
		*s = MentorshipResponseTypeFriendship
	case MentorshipResponseTypeRomance:
		*s = MentorshipResponseTypeRomance
	case MentorshipResponseTypeRivalry:
		*s = MentorshipResponseTypeRivalry
	case MentorshipResponseTypeMentorship:
		*s = MentorshipResponseTypeMentorship
	case MentorshipResponseTypeBusiness:
		*s = MentorshipResponseTypeBusiness
	case MentorshipResponseTypeEnmity:
		*s = MentorshipResponseTypeEnmity
	default:
		*s = MentorshipResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MentorshipResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MentorshipResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContractTerms as json.
func (o OptContractTerms) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContractTerms from json.
func (o *OptContractTerms) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContractTerms to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContractTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContractTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContractTermsPaymentSchedule as json.
func (o OptContractTermsPaymentSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ContractTermsPaymentSchedule from json.
func (o *OptContractTermsPaymentSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContractTermsPaymentSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContractTermsPaymentSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContractTermsPaymentSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DeclareRivalryRequestInitialIntensity as json.
func (o OptDeclareRivalryRequestInitialIntensity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DeclareRivalryRequestInitialIntensity from json.
func (o *OptDeclareRivalryRequestInitialIntensity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeclareRivalryRequestInitialIntensity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeclareRivalryRequestInitialIntensity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeclareRivalryRequestInitialIntensity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendRequestResponseStatus as json.
func (o OptFriendRequestResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FriendRequestResponseStatus from json.
func (o *OptFriendRequestResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendRequestResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendRequestResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendRequestResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FriendshipResponseFriendProfile as json.
func (o OptFriendshipResponseFriendProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FriendshipResponseFriendProfile from json.
func (o *OptFriendshipResponseFriendProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFriendshipResponseFriendProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFriendshipResponseFriendProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFriendshipResponseFriendProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateMentorshipRequestContractTerms as json.
func (o OptInitiateMentorshipRequestContractTerms) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InitiateMentorshipRequestContractTerms from json.
func (o *OptInitiateMentorshipRequestContractTerms) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateMentorshipRequestContractTerms to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateMentorshipRequestContractTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateMentorshipRequestContractTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateMentorshipRequestContractTermsPaymentSchedule as json.
func (o OptInitiateMentorshipRequestContractTermsPaymentSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateMentorshipRequestContractTermsPaymentSchedule from json.
func (o *OptInitiateMentorshipRequestContractTermsPaymentSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateMentorshipRequestContractTermsPaymentSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateMentorshipRequestContractTermsPaymentSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateMentorshipRequestContractTermsPaymentSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipProgressResponseProgressType as json.
func (o OptMentorshipProgressResponseProgressType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MentorshipProgressResponseProgressType from json.
func (o *OptMentorshipProgressResponseProgressType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMentorshipProgressResponseProgressType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMentorshipProgressResponseProgressType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMentorshipProgressResponseProgressType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseContractTermsPaymentTerms as json.
func (o OptMentorshipResponseContractTermsPaymentTerms) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MentorshipResponseContractTermsPaymentTerms from json.
func (o *OptMentorshipResponseContractTermsPaymentTerms) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMentorshipResponseContractTermsPaymentTerms to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMentorshipResponseContractTermsPaymentTerms) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMentorshipResponseContractTermsPaymentTerms) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseContractTermsPaymentTermsSchedule as json.
func (o OptMentorshipResponseContractTermsPaymentTermsSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MentorshipResponseContractTermsPaymentTermsSchedule from json.
func (o *OptMentorshipResponseContractTermsPaymentTermsSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMentorshipResponseContractTermsPaymentTermsSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMentorshipResponseContractTermsPaymentTermsSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMentorshipResponseContractTermsPaymentTermsSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseProgress as json.
func (o OptMentorshipResponseProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MentorshipResponseProgress from json.
func (o *OptMentorshipResponseProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMentorshipResponseProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMentorshipResponseProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMentorshipResponseProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MentorshipResponseStatus as json.
func (o OptMentorshipResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MentorshipResponseStatus from json.
func (o *OptMentorshipResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMentorshipResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMentorshipResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMentorshipResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseCharacterProfile as json.
func (o OptRelationshipDetailResponseCharacterProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipDetailResponseCharacterProfile from json.
func (o *OptRelationshipDetailResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipDetailResponseCharacterProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipDetailResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipDetailResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseHistoryItemEventType as json.
func (o OptRelationshipDetailResponseHistoryItemEventType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RelationshipDetailResponseHistoryItemEventType from json.
func (o *OptRelationshipDetailResponseHistoryItemEventType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipDetailResponseHistoryItemEventType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipDetailResponseHistoryItemEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipDetailResponseHistoryItemEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseStatistics as json.
func (o OptRelationshipDetailResponseStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipDetailResponseStatistics from json.
func (o *OptRelationshipDetailResponseStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipDetailResponseStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipDetailResponseStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipDetailResponseStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseTargetProfile as json.
func (o OptRelationshipDetailResponseTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipDetailResponseTargetProfile from json.
func (o *OptRelationshipDetailResponseTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipDetailResponseTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipDetailResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipDetailResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipResponse as json.
func (o OptRelationshipResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipResponse from json.
func (o *OptRelationshipResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipResponseCharacterProfile as json.
func (o OptRelationshipResponseCharacterProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipResponseCharacterProfile from json.
func (o *OptRelationshipResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipResponseCharacterProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipResponseTargetProfile as json.
func (o OptRelationshipResponseTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RelationshipResponseTargetProfile from json.
func (o *OptRelationshipResponseTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRelationshipResponseTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRelationshipResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRelationshipResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationCategory as json.
func (o OptReputationCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReputationCategory from json.
func (o *OptReputationCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationCategoryTrend as json.
func (o OptReputationCategoryTrend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReputationCategoryTrend from json.
func (o *OptReputationCategoryTrend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationCategoryTrend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationCategoryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationCategoryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseCategory as json.
func (o OptReputationEventResponseCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReputationEventResponseCategory from json.
func (o *OptReputationEventResponseCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationEventResponseCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationEventResponseCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationEventResponseCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseEvidenceItemEventType as json.
func (o OptReputationEventResponseEvidenceItemEventType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReputationEventResponseEvidenceItemEventType from json.
func (o *OptReputationEventResponseEvidenceItemEventType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationEventResponseEvidenceItemEventType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationEventResponseEvidenceItemEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationEventResponseEvidenceItemEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseSubjectProfile as json.
func (o OptReputationEventResponseSubjectProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReputationEventResponseSubjectProfile from json.
func (o *OptReputationEventResponseSubjectProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationEventResponseSubjectProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationEventResponseSubjectProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationEventResponseSubjectProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseTargetProfile as json.
func (o OptReputationEventResponseTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReputationEventResponseTargetProfile from json.
func (o *OptReputationEventResponseTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReputationEventResponseTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReputationEventResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReputationEventResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseCharacterProfile as json.
func (o OptRivalryResponseCharacterProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RivalryResponseCharacterProfile from json.
func (o *OptRivalryResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRivalryResponseCharacterProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRivalryResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRivalryResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseRivalryIntensity as json.
func (o OptRivalryResponseRivalryIntensity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RivalryResponseRivalryIntensity from json.
func (o *OptRivalryResponseRivalryIntensity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRivalryResponseRivalryIntensity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRivalryResponseRivalryIntensity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRivalryResponseRivalryIntensity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseTargetProfile as json.
func (o OptRivalryResponseTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RivalryResponseTargetProfile from json.
func (o *OptRivalryResponseTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRivalryResponseTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRivalryResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRivalryResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalRequestPrivacyLevel as json.
func (o OptRomanticProposalRequestPrivacyLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RomanticProposalRequestPrivacyLevel from json.
func (o *OptRomanticProposalRequestPrivacyLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticProposalRequestPrivacyLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticProposalRequestPrivacyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticProposalRequestPrivacyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalResponseProposalType as json.
func (o OptRomanticProposalResponseProposalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RomanticProposalResponseProposalType from json.
func (o *OptRomanticProposalResponseProposalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticProposalResponseProposalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticProposalResponseProposalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticProposalResponseProposalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalResponseStatus as json.
func (o OptRomanticProposalResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RomanticProposalResponseStatus from json.
func (o *OptRomanticProposalResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticProposalResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticProposalResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticProposalResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseCharacterProfile as json.
func (o OptRomanticRelationshipResponseCharacterProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RomanticRelationshipResponseCharacterProfile from json.
func (o *OptRomanticRelationshipResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticRelationshipResponseCharacterProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticRelationshipResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticRelationshipResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseEngagementDetails as json.
func (o OptRomanticRelationshipResponseEngagementDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RomanticRelationshipResponseEngagementDetails from json.
func (o *OptRomanticRelationshipResponseEngagementDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticRelationshipResponseEngagementDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticRelationshipResponseEngagementDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticRelationshipResponseEngagementDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponsePrivacyLevel as json.
func (o OptRomanticRelationshipResponsePrivacyLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RomanticRelationshipResponsePrivacyLevel from json.
func (o *OptRomanticRelationshipResponsePrivacyLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticRelationshipResponsePrivacyLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticRelationshipResponsePrivacyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticRelationshipResponsePrivacyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseRomanticStatus as json.
func (o OptRomanticRelationshipResponseRomanticStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RomanticRelationshipResponseRomanticStatus from json.
func (o *OptRomanticRelationshipResponseRomanticStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticRelationshipResponseRomanticStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticRelationshipResponseRomanticStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticRelationshipResponseRomanticStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseTargetProfile as json.
func (o OptRomanticRelationshipResponseTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RomanticRelationshipResponseTargetProfile from json.
func (o *OptRomanticRelationshipResponseTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRomanticRelationshipResponseTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRomanticRelationshipResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRomanticRelationshipResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRelationshipsOKRelationshipsItemCharacterProfile as json.
func (o OptSearchRelationshipsOKRelationshipsItemCharacterProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchRelationshipsOKRelationshipsItemCharacterProfile from json.
func (o *OptSearchRelationshipsOKRelationshipsItemCharacterProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchRelationshipsOKRelationshipsItemCharacterProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchRelationshipsOKRelationshipsItemCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchRelationshipsOKRelationshipsItemCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRelationshipsOKRelationshipsItemTargetProfile as json.
func (o OptSearchRelationshipsOKRelationshipsItemTargetProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchRelationshipsOKRelationshipsItemTargetProfile from json.
func (o *OptSearchRelationshipsOKRelationshipsItemTargetProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchRelationshipsOKRelationshipsItemTargetProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchRelationshipsOKRelationshipsItemTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchRelationshipsOKRelationshipsItemTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SocialInfluenceResponseInfluenceFactors as json.
func (o OptSocialInfluenceResponseInfluenceFactors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SocialInfluenceResponseInfluenceFactors from json.
func (o *OptSocialInfluenceResponseInfluenceFactors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSocialInfluenceResponseInfluenceFactors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSocialInfluenceResponseInfluenceFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSocialInfluenceResponseInfluenceFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SocialNetworkResponseConnectionsItemCharacter as json.
func (o OptSocialNetworkResponseConnectionsItemCharacter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SocialNetworkResponseConnectionsItemCharacter from json.
func (o *OptSocialNetworkResponseConnectionsItemCharacter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSocialNetworkResponseConnectionsItemCharacter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSocialNetworkResponseConnectionsItemCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSocialNetworkResponseConnectionsItemCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SocialNetworkResponseNetworkStats as json.
func (o OptSocialNetworkResponseNetworkStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SocialNetworkResponseNetworkStats from json.
func (o *OptSocialNetworkResponseNetworkStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSocialNetworkResponseNetworkStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSocialNetworkResponseNetworkStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSocialNetworkResponseNetworkStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateMentorshipRequestStatus as json.
func (o OptUpdateMentorshipRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateMentorshipRequestStatus from json.
func (o *OptUpdateMentorshipRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateMentorshipRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateMentorshipRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateMentorshipRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReputationResponseCategories as json.
func (o OptUserReputationResponseCategories) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserReputationResponseCategories from json.
func (o *OptUserReputationResponseCategories) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReputationResponseCategories to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserReputationResponseCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserReputationResponseCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordMentorshipProgressForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordMentorshipProgressForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordMentorshipProgressForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RecordMentorshipProgressForbidden from json.
func (s *RecordMentorshipProgressForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordMentorshipProgressForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RecordMentorshipProgressForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordMentorshipProgressForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecordMentorshipProgressForbidden) {
					name = jsonFieldsNameOfRecordMentorshipProgressForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordMentorshipProgressForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordMentorshipProgressForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordMentorshipProgressForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordMentorshipProgressForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRecordMentorshipProgressForbiddenDetails = [0]string{}

// Decode decodes RecordMentorshipProgressForbiddenDetails from json.
func (s *RecordMentorshipProgressForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordMentorshipProgressForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RecordMentorshipProgressForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordMentorshipProgressForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordMentorshipProgressForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordProgressRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordProgressRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("progress_type")
		s.ProgressType.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.SkillImprovements != nil {
			e.FieldStart("skill_improvements")
			e.ArrStart()
			for _, elem := range s.SkillImprovements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LessonRating.Set {
			e.FieldStart("lesson_rating")
			s.LessonRating.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordProgressRequest = [4]string{
	0: "progress_type",
	1: "description",
	2: "skill_improvements",
	3: "lesson_rating",
}

// Decode decodes RecordProgressRequest from json.
func (s *RecordProgressRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordProgressRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "progress_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ProgressType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "skill_improvements":
			if err := func() error {
				s.SkillImprovements = make([]RecordProgressRequestSkillImprovementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecordProgressRequestSkillImprovementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SkillImprovements = append(s.SkillImprovements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_improvements\"")
			}
		case "lesson_rating":
			if err := func() error {
				s.LessonRating.Reset()
				if err := s.LessonRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lesson_rating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordProgressRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecordProgressRequest) {
					name = jsonFieldsNameOfRecordProgressRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordProgressRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordProgressRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordProgressRequestProgressType as json.
func (s RecordProgressRequestProgressType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordProgressRequestProgressType from json.
func (s *RecordProgressRequestProgressType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordProgressRequestProgressType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordProgressRequestProgressType(v) {
	case RecordProgressRequestProgressTypeLessonCompleted:
		*s = RecordProgressRequestProgressTypeLessonCompleted
	case RecordProgressRequestProgressTypeSkillImproved:
		*s = RecordProgressRequestProgressTypeSkillImproved
	case RecordProgressRequestProgressTypeMilestoneAchieved:
		*s = RecordProgressRequestProgressTypeMilestoneAchieved
	case RecordProgressRequestProgressTypeIssueResolved:
		*s = RecordProgressRequestProgressTypeIssueResolved
	default:
		*s = RecordProgressRequestProgressType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordProgressRequestProgressType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordProgressRequestProgressType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordProgressRequestSkillImprovementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordProgressRequestSkillImprovementsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("skill_name")
		e.Str(s.SkillName)
	}
	{
		e.FieldStart("improvement_percent")
		e.Int(s.ImprovementPercent)
	}
}

var jsonFieldsNameOfRecordProgressRequestSkillImprovementsItem = [2]string{
	0: "skill_name",
	1: "improvement_percent",
}

// Decode decodes RecordProgressRequestSkillImprovementsItem from json.
func (s *RecordProgressRequestSkillImprovementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordProgressRequestSkillImprovementsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SkillName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_name\"")
			}
		case "improvement_percent":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ImprovementPercent = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"improvement_percent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordProgressRequestSkillImprovementsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecordProgressRequestSkillImprovementsItem) {
					name = jsonFieldsNameOfRecordProgressRequestSkillImprovementsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordProgressRequestSkillImprovementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordProgressRequestSkillImprovementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordReputationEventBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordReputationEventBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordReputationEventBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RecordReputationEventBadRequest from json.
func (s *RecordReputationEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordReputationEventBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RecordReputationEventBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordReputationEventBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecordReputationEventBadRequest) {
					name = jsonFieldsNameOfRecordReputationEventBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordReputationEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordReputationEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordReputationEventBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordReputationEventBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRecordReputationEventBadRequestDetails = [0]string{}

// Decode decodes RecordReputationEventBadRequestDetails from json.
func (s *RecordReputationEventBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordReputationEventBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RecordReputationEventBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordReputationEventBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordReputationEventBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordReputationEventRequest as json.
func (s RecordReputationEventRequest) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RecordReputationEventRequest from json.
func (s *RecordReputationEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordReputationEventRequest to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecordReputationEventRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordReputationEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordReputationEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipBatchHealthCheckMultiStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipBatchHealthCheckMultiStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipBatchHealthCheckMultiStatus = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes RelationshipBatchHealthCheckMultiStatus from json.
func (s *RelationshipBatchHealthCheckMultiStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipBatchHealthCheckMultiStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipBatchHealthCheckMultiStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipBatchHealthCheckMultiStatus) {
					name = jsonFieldsNameOfRelationshipBatchHealthCheckMultiStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipBatchHealthCheckMultiStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipBatchHealthCheckMultiStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipBatchHealthCheckMultiStatusStatus as json.
func (s RelationshipBatchHealthCheckMultiStatusStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipBatchHealthCheckMultiStatusStatus from json.
func (s *RelationshipBatchHealthCheckMultiStatusStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipBatchHealthCheckMultiStatusStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipBatchHealthCheckMultiStatusStatus(v) {
	case RelationshipBatchHealthCheckMultiStatusStatusHealthy:
		*s = RelationshipBatchHealthCheckMultiStatusStatusHealthy
	case RelationshipBatchHealthCheckMultiStatusStatusDegraded:
		*s = RelationshipBatchHealthCheckMultiStatusStatusDegraded
	case RelationshipBatchHealthCheckMultiStatusStatusUnhealthy:
		*s = RelationshipBatchHealthCheckMultiStatusStatusUnhealthy
	default:
		*s = RelationshipBatchHealthCheckMultiStatusStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipBatchHealthCheckMultiStatusStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipBatchHealthCheckMultiStatusStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipBatchHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipBatchHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipBatchHealthCheckOK = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes RelationshipBatchHealthCheckOK from json.
func (s *RelationshipBatchHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipBatchHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipBatchHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipBatchHealthCheckOK) {
					name = jsonFieldsNameOfRelationshipBatchHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipBatchHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipBatchHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipBatchHealthCheckOKStatus as json.
func (s RelationshipBatchHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipBatchHealthCheckOKStatus from json.
func (s *RelationshipBatchHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipBatchHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipBatchHealthCheckOKStatus(v) {
	case RelationshipBatchHealthCheckOKStatusHealthy:
		*s = RelationshipBatchHealthCheckOKStatusHealthy
	case RelationshipBatchHealthCheckOKStatusDegraded:
		*s = RelationshipBatchHealthCheckOKStatusDegraded
	case RelationshipBatchHealthCheckOKStatusUnhealthy:
		*s = RelationshipBatchHealthCheckOKStatusUnhealthy
	default:
		*s = RelationshipBatchHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipBatchHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipBatchHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipDetailResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipDetailResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacterProfile.Set {
			e.FieldStart("character_profile")
			s.CharacterProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
	{
		if s.IsMutual.Set {
			e.FieldStart("is_mutual")
			s.IsMutual.Encode(e)
		}
	}
	{
		if s.History != nil {
			e.FieldStart("history")
			e.ArrStart()
			for _, elem := range s.History {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipDetailResponse = [17]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "character_profile",
	13: "target_profile",
	14: "is_mutual",
	15: "history",
	16: "statistics",
}

// Decode decodes RelationshipDetailResponse from json.
func (s *RelationshipDetailResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]RelationshipDetailResponseFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RelationshipDetailResponseFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "character_profile":
			if err := func() error {
				s.CharacterProfile.Reset()
				if err := s.CharacterProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		case "is_mutual":
			if err := func() error {
				s.IsMutual.Reset()
				if err := s.IsMutual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mutual\"")
			}
		case "history":
			if err := func() error {
				s.History = make([]RelationshipDetailResponseHistoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RelationshipDetailResponseHistoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipDetailResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipDetailResponse) {
					name = jsonFieldsNameOfRelationshipDetailResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipDetailResponseCharacterProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipDetailResponseCharacterProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipDetailResponseCharacterProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RelationshipDetailResponseCharacterProfile from json.
func (s *RelationshipDetailResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseCharacterProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipDetailResponseCharacterProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipDetailResponseCharacterProfile) {
					name = jsonFieldsNameOfRelationshipDetailResponseCharacterProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipDetailResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseFlagsItem as json.
func (s RelationshipDetailResponseFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipDetailResponseFlagsItem from json.
func (s *RelationshipDetailResponseFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipDetailResponseFlagsItem(v) {
	case RelationshipDetailResponseFlagsItemExclusive:
		*s = RelationshipDetailResponseFlagsItemExclusive
	case RelationshipDetailResponseFlagsItemPublic:
		*s = RelationshipDetailResponseFlagsItemPublic
	case RelationshipDetailResponseFlagsItemSecret:
		*s = RelationshipDetailResponseFlagsItemSecret
	case RelationshipDetailResponseFlagsItemTemporary:
		*s = RelationshipDetailResponseFlagsItemTemporary
	default:
		*s = RelationshipDetailResponseFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipDetailResponseFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipDetailResponseHistoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipDetailResponseHistoryItem) encodeFields(e *jx.Encoder) {
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.LevelChange.Set {
			e.FieldStart("level_change")
			s.LevelChange.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipDetailResponseHistoryItem = [4]string{
	0: "event_type",
	1: "timestamp",
	2: "description",
	3: "level_change",
}

// Decode decodes RelationshipDetailResponseHistoryItem from json.
func (s *RelationshipDetailResponseHistoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseHistoryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "level_change":
			if err := func() error {
				s.LevelChange.Reset()
				if err := s.LevelChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level_change\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipDetailResponseHistoryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipDetailResponseHistoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseHistoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseHistoryItemEventType as json.
func (s RelationshipDetailResponseHistoryItemEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipDetailResponseHistoryItemEventType from json.
func (s *RelationshipDetailResponseHistoryItemEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseHistoryItemEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipDetailResponseHistoryItemEventType(v) {
	case RelationshipDetailResponseHistoryItemEventTypeCreated:
		*s = RelationshipDetailResponseHistoryItemEventTypeCreated
	case RelationshipDetailResponseHistoryItemEventTypeLevelChanged:
		*s = RelationshipDetailResponseHistoryItemEventTypeLevelChanged
	case RelationshipDetailResponseHistoryItemEventTypeInteraction:
		*s = RelationshipDetailResponseHistoryItemEventTypeInteraction
	case RelationshipDetailResponseHistoryItemEventTypeTerminated:
		*s = RelationshipDetailResponseHistoryItemEventTypeTerminated
	default:
		*s = RelationshipDetailResponseHistoryItemEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipDetailResponseHistoryItemEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseHistoryItemEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipDetailResponseStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipDetailResponseStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.TotalInteractions.Set {
			e.FieldStart("total_interactions")
			s.TotalInteractions.Encode(e)
		}
	}
	{
		if s.AverageLevel.Set {
			e.FieldStart("average_level")
			s.AverageLevel.Encode(e)
		}
	}
	{
		if s.RelationshipDurationDays.Set {
			e.FieldStart("relationship_duration_days")
			s.RelationshipDurationDays.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipDetailResponseStatistics = [3]string{
	0: "total_interactions",
	1: "average_level",
	2: "relationship_duration_days",
}

// Decode decodes RelationshipDetailResponseStatistics from json.
func (s *RelationshipDetailResponseStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_interactions":
			if err := func() error {
				s.TotalInteractions.Reset()
				if err := s.TotalInteractions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_interactions\"")
			}
		case "average_level":
			if err := func() error {
				s.AverageLevel.Reset()
				if err := s.AverageLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_level\"")
			}
		case "relationship_duration_days":
			if err := func() error {
				s.RelationshipDurationDays.Reset()
				if err := s.RelationshipDurationDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_duration_days\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipDetailResponseStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipDetailResponseStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipDetailResponseTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipDetailResponseTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipDetailResponseTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RelationshipDetailResponseTargetProfile from json.
func (s *RelationshipDetailResponseTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipDetailResponseTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipDetailResponseTargetProfile) {
					name = jsonFieldsNameOfRelationshipDetailResponseTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipDetailResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipDetailResponseType as json.
func (s RelationshipDetailResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipDetailResponseType from json.
func (s *RelationshipDetailResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipDetailResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipDetailResponseType(v) {
	case RelationshipDetailResponseTypeFriendship:
		*s = RelationshipDetailResponseTypeFriendship
	case RelationshipDetailResponseTypeRomance:
		*s = RelationshipDetailResponseTypeRomance
	case RelationshipDetailResponseTypeRivalry:
		*s = RelationshipDetailResponseTypeRivalry
	case RelationshipDetailResponseTypeMentorship:
		*s = RelationshipDetailResponseTypeMentorship
	case RelationshipDetailResponseTypeBusiness:
		*s = RelationshipDetailResponseTypeBusiness
	case RelationshipDetailResponseTypeEnmity:
		*s = RelationshipDetailResponseTypeEnmity
	default:
		*s = RelationshipDetailResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipDetailResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipDetailResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipHealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipHealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipHealthCheckOK = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes RelationshipHealthCheckOK from json.
func (s *RelationshipHealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipHealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipHealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipHealthCheckOK) {
					name = jsonFieldsNameOfRelationshipHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipHealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipHealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipHealthCheckOKStatus as json.
func (s RelationshipHealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipHealthCheckOKStatus from json.
func (s *RelationshipHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipHealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipHealthCheckOKStatus(v) {
	case RelationshipHealthCheckOKStatusHealthy:
		*s = RelationshipHealthCheckOKStatusHealthy
	case RelationshipHealthCheckOKStatusDegraded:
		*s = RelationshipHealthCheckOKStatusDegraded
	case RelationshipHealthCheckOKStatusUnhealthy:
		*s = RelationshipHealthCheckOKStatusUnhealthy
	default:
		*s = RelationshipHealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipHealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipHealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipHealthCheckServiceUnavailable = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes RelationshipHealthCheckServiceUnavailable from json.
func (s *RelationshipHealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipHealthCheckServiceUnavailable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipHealthCheckServiceUnavailable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipHealthCheckServiceUnavailable) {
					name = jsonFieldsNameOfRelationshipHealthCheckServiceUnavailable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipHealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipHealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipHealthCheckServiceUnavailableStatus as json.
func (s RelationshipHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipHealthCheckServiceUnavailableStatus from json.
func (s *RelationshipHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipHealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipHealthCheckServiceUnavailableStatus(v) {
	case RelationshipHealthCheckServiceUnavailableStatusHealthy:
		*s = RelationshipHealthCheckServiceUnavailableStatusHealthy
	case RelationshipHealthCheckServiceUnavailableStatusDegraded:
		*s = RelationshipHealthCheckServiceUnavailableStatusDegraded
	case RelationshipHealthCheckServiceUnavailableStatusUnhealthy:
		*s = RelationshipHealthCheckServiceUnavailableStatusUnhealthy
	default:
		*s = RelationshipHealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacterProfile.Set {
			e.FieldStart("character_profile")
			s.CharacterProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
	{
		if s.IsMutual.Set {
			e.FieldStart("is_mutual")
			s.IsMutual.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipResponse = [15]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "character_profile",
	13: "target_profile",
	14: "is_mutual",
}

// Decode decodes RelationshipResponse from json.
func (s *RelationshipResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]RelationshipResponseFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RelationshipResponseFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "character_profile":
			if err := func() error {
				s.CharacterProfile.Reset()
				if err := s.CharacterProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		case "is_mutual":
			if err := func() error {
				s.IsMutual.Reset()
				if err := s.IsMutual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mutual\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipResponse) {
					name = jsonFieldsNameOfRelationshipResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipResponseCharacterProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipResponseCharacterProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipResponseCharacterProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RelationshipResponseCharacterProfile from json.
func (s *RelationshipResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponseCharacterProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipResponseCharacterProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipResponseCharacterProfile) {
					name = jsonFieldsNameOfRelationshipResponseCharacterProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipResponseFlagsItem as json.
func (s RelationshipResponseFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipResponseFlagsItem from json.
func (s *RelationshipResponseFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponseFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipResponseFlagsItem(v) {
	case RelationshipResponseFlagsItemExclusive:
		*s = RelationshipResponseFlagsItemExclusive
	case RelationshipResponseFlagsItemPublic:
		*s = RelationshipResponseFlagsItemPublic
	case RelationshipResponseFlagsItemSecret:
		*s = RelationshipResponseFlagsItemSecret
	case RelationshipResponseFlagsItemTemporary:
		*s = RelationshipResponseFlagsItemTemporary
	default:
		*s = RelationshipResponseFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipResponseFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponseFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RelationshipResponseTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RelationshipResponseTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelationshipResponseTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RelationshipResponseTargetProfile from json.
func (s *RelationshipResponseTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponseTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RelationshipResponseTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelationshipResponseTargetProfile) {
					name = jsonFieldsNameOfRelationshipResponseTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RelationshipResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RelationshipResponseType as json.
func (s RelationshipResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RelationshipResponseType from json.
func (s *RelationshipResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RelationshipResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RelationshipResponseType(v) {
	case RelationshipResponseTypeFriendship:
		*s = RelationshipResponseTypeFriendship
	case RelationshipResponseTypeRomance:
		*s = RelationshipResponseTypeRomance
	case RelationshipResponseTypeRivalry:
		*s = RelationshipResponseTypeRivalry
	case RelationshipResponseTypeMentorship:
		*s = RelationshipResponseTypeMentorship
	case RelationshipResponseTypeBusiness:
		*s = RelationshipResponseTypeBusiness
	case RelationshipResponseTypeEnmity:
		*s = RelationshipResponseTypeEnmity
	default:
		*s = RelationshipResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RelationshipResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RelationshipResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveFriendshipForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveFriendshipForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemoveFriendshipForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RemoveFriendshipForbidden from json.
func (s *RemoveFriendshipForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveFriendshipForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RemoveFriendshipForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveFriendshipForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveFriendshipForbidden) {
					name = jsonFieldsNameOfRemoveFriendshipForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveFriendshipForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveFriendshipForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveFriendshipForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveFriendshipForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemoveFriendshipForbiddenDetails = [0]string{}

// Decode decodes RemoveFriendshipForbiddenDetails from json.
func (s *RemoveFriendshipForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveFriendshipForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemoveFriendshipForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveFriendshipForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveFriendshipForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationCategory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationCategory) encodeFields(e *jx.Encoder) {
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.EvidenceCount.Set {
			e.FieldStart("evidence_count")
			s.EvidenceCount.Encode(e)
		}
	}
	{
		if s.Trend.Set {
			e.FieldStart("trend")
			s.Trend.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationCategory = [3]string{
	0: "score",
	1: "evidence_count",
	2: "trend",
}

// Decode decodes ReputationCategory from json.
func (s *ReputationCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationCategory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "evidence_count":
			if err := func() error {
				s.EvidenceCount.Reset()
				if err := s.EvidenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_count\"")
			}
		case "trend":
			if err := func() error {
				s.Trend.Reset()
				if err := s.Trend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationCategory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationCategoryTrend as json.
func (s ReputationCategoryTrend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReputationCategoryTrend from json.
func (s *ReputationCategoryTrend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationCategoryTrend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReputationCategoryTrend(v) {
	case ReputationCategoryTrendImproving:
		*s = ReputationCategoryTrendImproving
	case ReputationCategoryTrendStable:
		*s = ReputationCategoryTrendStable
	case ReputationCategoryTrendDeclining:
		*s = ReputationCategoryTrendDeclining
	default:
		*s = ReputationCategoryTrend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReputationCategoryTrend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationCategoryTrend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationEventResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("subject_id")
		json.EncodeUUID(e, s.SubjectID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.EvidenceCount.Set {
			e.FieldStart("evidence_count")
			s.EvidenceCount.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IsPublic.Set {
			e.FieldStart("is_public")
			s.IsPublic.Encode(e)
		}
	}
	{
		if s.Evidence != nil {
			e.FieldStart("evidence")
			e.ArrStart()
			for _, elem := range s.Evidence {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubjectProfile.Set {
			e.FieldStart("subject_profile")
			s.SubjectProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationEventResponse = [13]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "subject_id",
	4:  "target_id",
	5:  "score",
	6:  "category",
	7:  "evidence_count",
	8:  "last_updated_at",
	9:  "is_public",
	10: "evidence",
	11: "subject_profile",
	12: "target_profile",
}

// Decode decodes ReputationEventResponse from json.
func (s *ReputationEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "subject_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "evidence_count":
			if err := func() error {
				s.EvidenceCount.Reset()
				if err := s.EvidenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_count\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "is_public":
			if err := func() error {
				s.IsPublic.Reset()
				if err := s.IsPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_public\"")
			}
		case "evidence":
			if err := func() error {
				s.Evidence = make([]ReputationEventResponseEvidenceItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReputationEventResponseEvidenceItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Evidence = append(s.Evidence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		case "subject_profile":
			if err := func() error {
				s.SubjectProfile.Reset()
				if err := s.SubjectProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationEventResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReputationEventResponse) {
					name = jsonFieldsNameOfReputationEventResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseCategory as json.
func (s ReputationEventResponseCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReputationEventResponseCategory from json.
func (s *ReputationEventResponseCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponseCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReputationEventResponseCategory(v) {
	case ReputationEventResponseCategoryTrading:
		*s = ReputationEventResponseCategoryTrading
	case ReputationEventResponseCategoryCombat:
		*s = ReputationEventResponseCategoryCombat
	case ReputationEventResponseCategorySocial:
		*s = ReputationEventResponseCategorySocial
	case ReputationEventResponseCategoryLeadership:
		*s = ReputationEventResponseCategoryLeadership
	case ReputationEventResponseCategoryCraftsmanship:
		*s = ReputationEventResponseCategoryCraftsmanship
	case ReputationEventResponseCategoryReliability:
		*s = ReputationEventResponseCategoryReliability
	case ReputationEventResponseCategoryGenerosity:
		*s = ReputationEventResponseCategoryGenerosity
	case ReputationEventResponseCategoryCombatSkill:
		*s = ReputationEventResponseCategoryCombatSkill
	default:
		*s = ReputationEventResponseCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReputationEventResponseCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponseCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationEventResponseEvidenceItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationEventResponseEvidenceItem) encodeFields(e *jx.Encoder) {
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
	{
		if s.Points.Set {
			e.FieldStart("points")
			s.Points.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationEventResponseEvidenceItem = [4]string{
	0: "event_type",
	1: "points",
	2: "timestamp",
	3: "description",
}

// Decode decodes ReputationEventResponseEvidenceItem from json.
func (s *ReputationEventResponseEvidenceItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponseEvidenceItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "points":
			if err := func() error {
				s.Points.Reset()
				if err := s.Points.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationEventResponseEvidenceItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationEventResponseEvidenceItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponseEvidenceItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReputationEventResponseEvidenceItemEventType as json.
func (s ReputationEventResponseEvidenceItemEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReputationEventResponseEvidenceItemEventType from json.
func (s *ReputationEventResponseEvidenceItemEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponseEvidenceItemEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReputationEventResponseEvidenceItemEventType(v) {
	case ReputationEventResponseEvidenceItemEventTypeTradeCompleted:
		*s = ReputationEventResponseEvidenceItemEventTypeTradeCompleted
	case ReputationEventResponseEvidenceItemEventTypeCombatAssist:
		*s = ReputationEventResponseEvidenceItemEventTypeCombatAssist
	case ReputationEventResponseEvidenceItemEventTypeGuildHelp:
		*s = ReputationEventResponseEvidenceItemEventTypeGuildHelp
	case ReputationEventResponseEvidenceItemEventTypeQuestShared:
		*s = ReputationEventResponseEvidenceItemEventTypeQuestShared
	default:
		*s = ReputationEventResponseEvidenceItemEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReputationEventResponseEvidenceItemEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponseEvidenceItemEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationEventResponseSubjectProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationEventResponseSubjectProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationEventResponseSubjectProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes ReputationEventResponseSubjectProfile from json.
func (s *ReputationEventResponseSubjectProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponseSubjectProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationEventResponseSubjectProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReputationEventResponseSubjectProfile) {
					name = jsonFieldsNameOfReputationEventResponseSubjectProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationEventResponseSubjectProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponseSubjectProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReputationEventResponseTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReputationEventResponseTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfReputationEventResponseTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes ReputationEventResponseTargetProfile from json.
func (s *ReputationEventResponseTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReputationEventResponseTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReputationEventResponseTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReputationEventResponseTargetProfile) {
					name = jsonFieldsNameOfReputationEventResponseTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReputationEventResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReputationEventResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RespondToFriendRequestForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RespondToFriendRequestForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfRespondToFriendRequestForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RespondToFriendRequestForbidden from json.
func (s *RespondToFriendRequestForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RespondToFriendRequestForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem RespondToFriendRequestForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RespondToFriendRequestForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRespondToFriendRequestForbidden) {
					name = jsonFieldsNameOfRespondToFriendRequestForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RespondToFriendRequestForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RespondToFriendRequestForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RespondToFriendRequestForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RespondToFriendRequestForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRespondToFriendRequestForbiddenDetails = [0]string{}

// Decode decodes RespondToFriendRequestForbiddenDetails from json.
func (s *RespondToFriendRequestForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RespondToFriendRequestForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RespondToFriendRequestForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RespondToFriendRequestForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RespondToFriendRequestForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RivalryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RivalryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacterProfile.Set {
			e.FieldStart("character_profile")
			s.CharacterProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
	{
		if s.IsMutual.Set {
			e.FieldStart("is_mutual")
			s.IsMutual.Encode(e)
		}
	}
	{
		if s.RivalryIntensity.Set {
			e.FieldStart("rivalry_intensity")
			s.RivalryIntensity.Encode(e)
		}
	}
	{
		if s.RivalryReason.Set {
			e.FieldStart("rivalry_reason")
			s.RivalryReason.Encode(e)
		}
	}
	{
		if s.ActiveConflicts.Set {
			e.FieldStart("active_conflicts")
			s.ActiveConflicts.Encode(e)
		}
	}
	{
		if s.LastConflictAt.Set {
			e.FieldStart("last_conflict_at")
			s.LastConflictAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRivalryResponse = [19]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "character_profile",
	13: "target_profile",
	14: "is_mutual",
	15: "rivalry_intensity",
	16: "rivalry_reason",
	17: "active_conflicts",
	18: "last_conflict_at",
}

// Decode decodes RivalryResponse from json.
func (s *RivalryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]RivalryResponseFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RivalryResponseFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "character_profile":
			if err := func() error {
				s.CharacterProfile.Reset()
				if err := s.CharacterProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		case "is_mutual":
			if err := func() error {
				s.IsMutual.Reset()
				if err := s.IsMutual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mutual\"")
			}
		case "rivalry_intensity":
			if err := func() error {
				s.RivalryIntensity.Reset()
				if err := s.RivalryIntensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rivalry_intensity\"")
			}
		case "rivalry_reason":
			if err := func() error {
				s.RivalryReason.Reset()
				if err := s.RivalryReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rivalry_reason\"")
			}
		case "active_conflicts":
			if err := func() error {
				s.ActiveConflicts.Reset()
				if err := s.ActiveConflicts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_conflicts\"")
			}
		case "last_conflict_at":
			if err := func() error {
				s.LastConflictAt.Reset()
				if err := s.LastConflictAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_conflict_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RivalryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRivalryResponse) {
					name = jsonFieldsNameOfRivalryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RivalryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RivalryResponseCharacterProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RivalryResponseCharacterProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRivalryResponseCharacterProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RivalryResponseCharacterProfile from json.
func (s *RivalryResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponseCharacterProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RivalryResponseCharacterProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRivalryResponseCharacterProfile) {
					name = jsonFieldsNameOfRivalryResponseCharacterProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RivalryResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseFlagsItem as json.
func (s RivalryResponseFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RivalryResponseFlagsItem from json.
func (s *RivalryResponseFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponseFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RivalryResponseFlagsItem(v) {
	case RivalryResponseFlagsItemExclusive:
		*s = RivalryResponseFlagsItemExclusive
	case RivalryResponseFlagsItemPublic:
		*s = RivalryResponseFlagsItemPublic
	case RivalryResponseFlagsItemSecret:
		*s = RivalryResponseFlagsItemSecret
	case RivalryResponseFlagsItemTemporary:
		*s = RivalryResponseFlagsItemTemporary
	default:
		*s = RivalryResponseFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RivalryResponseFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponseFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseRivalryIntensity as json.
func (s RivalryResponseRivalryIntensity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RivalryResponseRivalryIntensity from json.
func (s *RivalryResponseRivalryIntensity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponseRivalryIntensity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RivalryResponseRivalryIntensity(v) {
	case RivalryResponseRivalryIntensityMinor:
		*s = RivalryResponseRivalryIntensityMinor
	case RivalryResponseRivalryIntensityModerate:
		*s = RivalryResponseRivalryIntensityModerate
	case RivalryResponseRivalryIntensityMajor:
		*s = RivalryResponseRivalryIntensityMajor
	case RivalryResponseRivalryIntensityDeadly:
		*s = RivalryResponseRivalryIntensityDeadly
	default:
		*s = RivalryResponseRivalryIntensity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RivalryResponseRivalryIntensity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponseRivalryIntensity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RivalryResponseTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RivalryResponseTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRivalryResponseTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RivalryResponseTargetProfile from json.
func (s *RivalryResponseTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponseTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RivalryResponseTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRivalryResponseTargetProfile) {
					name = jsonFieldsNameOfRivalryResponseTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RivalryResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RivalryResponseType as json.
func (s RivalryResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RivalryResponseType from json.
func (s *RivalryResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RivalryResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RivalryResponseType(v) {
	case RivalryResponseTypeFriendship:
		*s = RivalryResponseTypeFriendship
	case RivalryResponseTypeRomance:
		*s = RivalryResponseTypeRomance
	case RivalryResponseTypeRivalry:
		*s = RivalryResponseTypeRivalry
	case RivalryResponseTypeMentorship:
		*s = RivalryResponseTypeMentorship
	case RivalryResponseTypeBusiness:
		*s = RivalryResponseTypeBusiness
	case RivalryResponseTypeEnmity:
		*s = RivalryResponseTypeEnmity
	default:
		*s = RivalryResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RivalryResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RivalryResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticProposalRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticProposalRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("proposal_type")
		s.ProposalType.Encode(e)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.PrivacyLevel.Set {
			e.FieldStart("privacy_level")
			s.PrivacyLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticProposalRequest = [4]string{
	0: "target_id",
	1: "proposal_type",
	2: "message",
	3: "privacy_level",
}

// Decode decodes RomanticProposalRequest from json.
func (s *RomanticProposalRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "proposal_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ProposalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proposal_type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "privacy_level":
			if err := func() error {
				s.PrivacyLevel.Reset()
				if err := s.PrivacyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticProposalRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRomanticProposalRequest) {
					name = jsonFieldsNameOfRomanticProposalRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticProposalRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalRequestPrivacyLevel as json.
func (s RomanticProposalRequestPrivacyLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticProposalRequestPrivacyLevel from json.
func (s *RomanticProposalRequestPrivacyLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalRequestPrivacyLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticProposalRequestPrivacyLevel(v) {
	case RomanticProposalRequestPrivacyLevelPrivate:
		*s = RomanticProposalRequestPrivacyLevelPrivate
	case RomanticProposalRequestPrivacyLevelFriends:
		*s = RomanticProposalRequestPrivacyLevelFriends
	case RomanticProposalRequestPrivacyLevelPublic:
		*s = RomanticProposalRequestPrivacyLevelPublic
	default:
		*s = RomanticProposalRequestPrivacyLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticProposalRequestPrivacyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalRequestPrivacyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalRequestProposalType as json.
func (s RomanticProposalRequestProposalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticProposalRequestProposalType from json.
func (s *RomanticProposalRequestProposalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalRequestProposalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticProposalRequestProposalType(v) {
	case RomanticProposalRequestProposalTypeDate:
		*s = RomanticProposalRequestProposalTypeDate
	case RomanticProposalRequestProposalTypeRelationship:
		*s = RomanticProposalRequestProposalTypeRelationship
	case RomanticProposalRequestProposalTypeEngagement:
		*s = RomanticProposalRequestProposalTypeEngagement
	case RomanticProposalRequestProposalTypeMarriage:
		*s = RomanticProposalRequestProposalTypeMarriage
	default:
		*s = RomanticProposalRequestProposalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticProposalRequestProposalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalRequestProposalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticProposalResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticProposalResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ProposalID.Set {
			e.FieldStart("proposal_id")
			s.ProposalID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProposalType.Set {
			e.FieldStart("proposal_type")
			s.ProposalType.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticProposalResponse = [4]string{
	0: "proposal_id",
	1: "status",
	2: "expires_at",
	3: "proposal_type",
}

// Decode decodes RomanticProposalResponse from json.
func (s *RomanticProposalResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proposal_id":
			if err := func() error {
				s.ProposalID.Reset()
				if err := s.ProposalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proposal_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "proposal_type":
			if err := func() error {
				s.ProposalType.Reset()
				if err := s.ProposalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proposal_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticProposalResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticProposalResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalResponseProposalType as json.
func (s RomanticProposalResponseProposalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticProposalResponseProposalType from json.
func (s *RomanticProposalResponseProposalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalResponseProposalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticProposalResponseProposalType(v) {
	case RomanticProposalResponseProposalTypeDate:
		*s = RomanticProposalResponseProposalTypeDate
	case RomanticProposalResponseProposalTypeRelationship:
		*s = RomanticProposalResponseProposalTypeRelationship
	case RomanticProposalResponseProposalTypeEngagement:
		*s = RomanticProposalResponseProposalTypeEngagement
	case RomanticProposalResponseProposalTypeMarriage:
		*s = RomanticProposalResponseProposalTypeMarriage
	default:
		*s = RomanticProposalResponseProposalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticProposalResponseProposalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalResponseProposalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticProposalResponseStatus as json.
func (s RomanticProposalResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticProposalResponseStatus from json.
func (s *RomanticProposalResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticProposalResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticProposalResponseStatus(v) {
	case RomanticProposalResponseStatusPending:
		*s = RomanticProposalResponseStatusPending
	case RomanticProposalResponseStatusAccepted:
		*s = RomanticProposalResponseStatusAccepted
	case RomanticProposalResponseStatusDeclined:
		*s = RomanticProposalResponseStatusDeclined
	default:
		*s = RomanticProposalResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticProposalResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticProposalResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticRelationshipResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticRelationshipResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacterProfile.Set {
			e.FieldStart("character_profile")
			s.CharacterProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
	{
		if s.IsMutual.Set {
			e.FieldStart("is_mutual")
			s.IsMutual.Encode(e)
		}
	}
	{
		if s.RomanticStatus.Set {
			e.FieldStart("romantic_status")
			s.RomanticStatus.Encode(e)
		}
	}
	{
		if s.PrivacyLevel.Set {
			e.FieldStart("privacy_level")
			s.PrivacyLevel.Encode(e)
		}
	}
	{
		if s.Anniversary.Set {
			e.FieldStart("anniversary")
			s.Anniversary.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EngagementDetails.Set {
			e.FieldStart("engagement_details")
			s.EngagementDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticRelationshipResponse = [19]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "character_profile",
	13: "target_profile",
	14: "is_mutual",
	15: "romantic_status",
	16: "privacy_level",
	17: "anniversary",
	18: "engagement_details",
}

// Decode decodes RomanticRelationshipResponse from json.
func (s *RomanticRelationshipResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]RomanticRelationshipResponseFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RomanticRelationshipResponseFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "character_profile":
			if err := func() error {
				s.CharacterProfile.Reset()
				if err := s.CharacterProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		case "is_mutual":
			if err := func() error {
				s.IsMutual.Reset()
				if err := s.IsMutual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mutual\"")
			}
		case "romantic_status":
			if err := func() error {
				s.RomanticStatus.Reset()
				if err := s.RomanticStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"romantic_status\"")
			}
		case "privacy_level":
			if err := func() error {
				s.PrivacyLevel.Reset()
				if err := s.PrivacyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy_level\"")
			}
		case "anniversary":
			if err := func() error {
				s.Anniversary.Reset()
				if err := s.Anniversary.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anniversary\"")
			}
		case "engagement_details":
			if err := func() error {
				s.EngagementDetails.Reset()
				if err := s.EngagementDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"engagement_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticRelationshipResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRomanticRelationshipResponse) {
					name = jsonFieldsNameOfRomanticRelationshipResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticRelationshipResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticRelationshipResponseCharacterProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticRelationshipResponseCharacterProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticRelationshipResponseCharacterProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RomanticRelationshipResponseCharacterProfile from json.
func (s *RomanticRelationshipResponseCharacterProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseCharacterProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticRelationshipResponseCharacterProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRomanticRelationshipResponseCharacterProfile) {
					name = jsonFieldsNameOfRomanticRelationshipResponseCharacterProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticRelationshipResponseCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticRelationshipResponseEngagementDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticRelationshipResponseEngagementDetails) encodeFields(e *jx.Encoder) {
	{
		if s.RingItemID.Set {
			e.FieldStart("ring_item_id")
			s.RingItemID.Encode(e)
		}
	}
	{
		if s.ProposalDate.Set {
			e.FieldStart("proposal_date")
			s.ProposalDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProposalMessage.Set {
			e.FieldStart("proposal_message")
			s.ProposalMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticRelationshipResponseEngagementDetails = [3]string{
	0: "ring_item_id",
	1: "proposal_date",
	2: "proposal_message",
}

// Decode decodes RomanticRelationshipResponseEngagementDetails from json.
func (s *RomanticRelationshipResponseEngagementDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseEngagementDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ring_item_id":
			if err := func() error {
				s.RingItemID.Reset()
				if err := s.RingItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring_item_id\"")
			}
		case "proposal_date":
			if err := func() error {
				s.ProposalDate.Reset()
				if err := s.ProposalDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proposal_date\"")
			}
		case "proposal_message":
			if err := func() error {
				s.ProposalMessage.Reset()
				if err := s.ProposalMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proposal_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticRelationshipResponseEngagementDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticRelationshipResponseEngagementDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseEngagementDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseFlagsItem as json.
func (s RomanticRelationshipResponseFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticRelationshipResponseFlagsItem from json.
func (s *RomanticRelationshipResponseFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticRelationshipResponseFlagsItem(v) {
	case RomanticRelationshipResponseFlagsItemExclusive:
		*s = RomanticRelationshipResponseFlagsItemExclusive
	case RomanticRelationshipResponseFlagsItemPublic:
		*s = RomanticRelationshipResponseFlagsItemPublic
	case RomanticRelationshipResponseFlagsItemSecret:
		*s = RomanticRelationshipResponseFlagsItemSecret
	case RomanticRelationshipResponseFlagsItemTemporary:
		*s = RomanticRelationshipResponseFlagsItemTemporary
	default:
		*s = RomanticRelationshipResponseFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticRelationshipResponseFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponsePrivacyLevel as json.
func (s RomanticRelationshipResponsePrivacyLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticRelationshipResponsePrivacyLevel from json.
func (s *RomanticRelationshipResponsePrivacyLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponsePrivacyLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticRelationshipResponsePrivacyLevel(v) {
	case RomanticRelationshipResponsePrivacyLevelPrivate:
		*s = RomanticRelationshipResponsePrivacyLevelPrivate
	case RomanticRelationshipResponsePrivacyLevelFriends:
		*s = RomanticRelationshipResponsePrivacyLevelFriends
	case RomanticRelationshipResponsePrivacyLevelPublic:
		*s = RomanticRelationshipResponsePrivacyLevelPublic
	default:
		*s = RomanticRelationshipResponsePrivacyLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticRelationshipResponsePrivacyLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponsePrivacyLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseRomanticStatus as json.
func (s RomanticRelationshipResponseRomanticStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticRelationshipResponseRomanticStatus from json.
func (s *RomanticRelationshipResponseRomanticStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseRomanticStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticRelationshipResponseRomanticStatus(v) {
	case RomanticRelationshipResponseRomanticStatusDating:
		*s = RomanticRelationshipResponseRomanticStatusDating
	case RomanticRelationshipResponseRomanticStatusEngaged:
		*s = RomanticRelationshipResponseRomanticStatusEngaged
	case RomanticRelationshipResponseRomanticStatusMarried:
		*s = RomanticRelationshipResponseRomanticStatusMarried
	case RomanticRelationshipResponseRomanticStatusSeparated:
		*s = RomanticRelationshipResponseRomanticStatusSeparated
	case RomanticRelationshipResponseRomanticStatusDivorced:
		*s = RomanticRelationshipResponseRomanticStatusDivorced
	default:
		*s = RomanticRelationshipResponseRomanticStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticRelationshipResponseRomanticStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseRomanticStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RomanticRelationshipResponseTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RomanticRelationshipResponseTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRomanticRelationshipResponseTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes RomanticRelationshipResponseTargetProfile from json.
func (s *RomanticRelationshipResponseTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RomanticRelationshipResponseTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRomanticRelationshipResponseTargetProfile) {
					name = jsonFieldsNameOfRomanticRelationshipResponseTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RomanticRelationshipResponseTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RomanticRelationshipResponseType as json.
func (s RomanticRelationshipResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RomanticRelationshipResponseType from json.
func (s *RomanticRelationshipResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RomanticRelationshipResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RomanticRelationshipResponseType(v) {
	case RomanticRelationshipResponseTypeFriendship:
		*s = RomanticRelationshipResponseTypeFriendship
	case RomanticRelationshipResponseTypeRomance:
		*s = RomanticRelationshipResponseTypeRomance
	case RomanticRelationshipResponseTypeRivalry:
		*s = RomanticRelationshipResponseTypeRivalry
	case RomanticRelationshipResponseTypeMentorship:
		*s = RomanticRelationshipResponseTypeMentorship
	case RomanticRelationshipResponseTypeBusiness:
		*s = RomanticRelationshipResponseTypeBusiness
	case RomanticRelationshipResponseTypeEnmity:
		*s = RomanticRelationshipResponseTypeEnmity
	default:
		*s = RomanticRelationshipResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RomanticRelationshipResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RomanticRelationshipResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRelationshipsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRelationshipsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Relationships != nil {
			e.FieldStart("relationships")
			e.ArrStart()
			for _, elem := range s.Relationships {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchRelationshipsOK = [1]string{
	0: "relationships",
}

// Decode decodes SearchRelationshipsOK from json.
func (s *SearchRelationshipsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "relationships":
			if err := func() error {
				s.Relationships = make([]SearchRelationshipsOKRelationshipsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchRelationshipsOKRelationshipsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Relationships = append(s.Relationships, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationships\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRelationshipsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRelationshipsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRelationshipsOKRelationshipsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("character_id")
		json.EncodeUUID(e, s.CharacterID)
	}
	{
		e.FieldStart("target_id")
		json.EncodeUUID(e, s.TargetID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.EstablishedAt.Set {
			e.FieldStart("established_at")
			s.EstablishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastInteractionAt.Set {
			e.FieldStart("last_interaction_at")
			s.LastInteractionAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InteractionCount.Set {
			e.FieldStart("interaction_count")
			s.InteractionCount.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacterProfile.Set {
			e.FieldStart("character_profile")
			s.CharacterProfile.Encode(e)
		}
	}
	{
		if s.TargetProfile.Set {
			e.FieldStart("target_profile")
			s.TargetProfile.Encode(e)
		}
	}
	{
		if s.IsMutual.Set {
			e.FieldStart("is_mutual")
			s.IsMutual.Encode(e)
		}
	}
	{
		if s.SearchScore.Set {
			e.FieldStart("search_score")
			s.SearchScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchRelationshipsOKRelationshipsItem = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "character_id",
	4:  "target_id",
	5:  "type",
	6:  "level",
	7:  "description",
	8:  "established_at",
	9:  "last_interaction_at",
	10: "interaction_count",
	11: "flags",
	12: "character_profile",
	13: "target_profile",
	14: "is_mutual",
	15: "search_score",
}

// Decode decodes SearchRelationshipsOKRelationshipsItem from json.
func (s *SearchRelationshipsOKRelationshipsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOKRelationshipsItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.CharacterID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "target_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TargetID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "established_at":
			if err := func() error {
				s.EstablishedAt.Reset()
				if err := s.EstablishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"established_at\"")
			}
		case "last_interaction_at":
			if err := func() error {
				s.LastInteractionAt.Reset()
				if err := s.LastInteractionAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_interaction_at\"")
			}
		case "interaction_count":
			if err := func() error {
				s.InteractionCount.Reset()
				if err := s.InteractionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interaction_count\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]SearchRelationshipsOKRelationshipsItemFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchRelationshipsOKRelationshipsItemFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "character_profile":
			if err := func() error {
				s.CharacterProfile.Reset()
				if err := s.CharacterProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_profile\"")
			}
		case "target_profile":
			if err := func() error {
				s.TargetProfile.Reset()
				if err := s.TargetProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_profile\"")
			}
		case "is_mutual":
			if err := func() error {
				s.IsMutual.Reset()
				if err := s.IsMutual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mutual\"")
			}
		case "search_score":
			if err := func() error {
				s.SearchScore.Reset()
				if err := s.SearchScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRelationshipsOKRelationshipsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchRelationshipsOKRelationshipsItem) {
					name = jsonFieldsNameOfSearchRelationshipsOKRelationshipsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOKRelationshipsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItemCharacterProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRelationshipsOKRelationshipsItemCharacterProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemCharacterProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes SearchRelationshipsOKRelationshipsItemCharacterProfile from json.
func (s *SearchRelationshipsOKRelationshipsItemCharacterProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOKRelationshipsItemCharacterProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRelationshipsOKRelationshipsItemCharacterProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemCharacterProfile) {
					name = jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemCharacterProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItemCharacterProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOKRelationshipsItemCharacterProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRelationshipsOKRelationshipsItemFlagsItem as json.
func (s SearchRelationshipsOKRelationshipsItemFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchRelationshipsOKRelationshipsItemFlagsItem from json.
func (s *SearchRelationshipsOKRelationshipsItemFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOKRelationshipsItemFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchRelationshipsOKRelationshipsItemFlagsItem(v) {
	case SearchRelationshipsOKRelationshipsItemFlagsItemExclusive:
		*s = SearchRelationshipsOKRelationshipsItemFlagsItemExclusive
	case SearchRelationshipsOKRelationshipsItemFlagsItemPublic:
		*s = SearchRelationshipsOKRelationshipsItemFlagsItemPublic
	case SearchRelationshipsOKRelationshipsItemFlagsItemSecret:
		*s = SearchRelationshipsOKRelationshipsItemFlagsItemSecret
	case SearchRelationshipsOKRelationshipsItemFlagsItemTemporary:
		*s = SearchRelationshipsOKRelationshipsItemFlagsItemTemporary
	default:
		*s = SearchRelationshipsOKRelationshipsItemFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchRelationshipsOKRelationshipsItemFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOKRelationshipsItemFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItemTargetProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchRelationshipsOKRelationshipsItemTargetProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemTargetProfile = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes SearchRelationshipsOKRelationshipsItemTargetProfile from json.
func (s *SearchRelationshipsOKRelationshipsItemTargetProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOKRelationshipsItemTargetProfile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchRelationshipsOKRelationshipsItemTargetProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemTargetProfile) {
					name = jsonFieldsNameOfSearchRelationshipsOKRelationshipsItemTargetProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchRelationshipsOKRelationshipsItemTargetProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOKRelationshipsItemTargetProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchRelationshipsOKRelationshipsItemType as json.
func (s SearchRelationshipsOKRelationshipsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchRelationshipsOKRelationshipsItemType from json.
func (s *SearchRelationshipsOKRelationshipsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchRelationshipsOKRelationshipsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchRelationshipsOKRelationshipsItemType(v) {
	case SearchRelationshipsOKRelationshipsItemTypeFriendship:
		*s = SearchRelationshipsOKRelationshipsItemTypeFriendship
	case SearchRelationshipsOKRelationshipsItemTypeRomance:
		*s = SearchRelationshipsOKRelationshipsItemTypeRomance
	case SearchRelationshipsOKRelationshipsItemTypeRivalry:
		*s = SearchRelationshipsOKRelationshipsItemTypeRivalry
	case SearchRelationshipsOKRelationshipsItemTypeMentorship:
		*s = SearchRelationshipsOKRelationshipsItemTypeMentorship
	case SearchRelationshipsOKRelationshipsItemTypeBusiness:
		*s = SearchRelationshipsOKRelationshipsItemTypeBusiness
	case SearchRelationshipsOKRelationshipsItemTypeEnmity:
		*s = SearchRelationshipsOKRelationshipsItemTypeEnmity
	default:
		*s = SearchRelationshipsOKRelationshipsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchRelationshipsOKRelationshipsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchRelationshipsOKRelationshipsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendRomanticProposalBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendRomanticProposalBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendRomanticProposalBadRequest = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes SendRomanticProposalBadRequest from json.
func (s *SendRomanticProposalBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendRomanticProposalBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem SendRomanticProposalBadRequestDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendRomanticProposalBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendRomanticProposalBadRequest) {
					name = jsonFieldsNameOfSendRomanticProposalBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendRomanticProposalBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendRomanticProposalBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendRomanticProposalBadRequestDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendRomanticProposalBadRequestDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSendRomanticProposalBadRequestDetails = [0]string{}

// Decode decodes SendRomanticProposalBadRequestDetails from json.
func (s *SendRomanticProposalBadRequestDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendRomanticProposalBadRequestDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SendRomanticProposalBadRequestDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendRomanticProposalBadRequestDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendRomanticProposalBadRequestDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialInfluenceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialInfluenceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.InfluenceScore.Set {
			e.FieldStart("influence_score")
			s.InfluenceScore.Encode(e)
		}
	}
	{
		if s.InfluenceFactors.Set {
			e.FieldStart("influence_factors")
			s.InfluenceFactors.Encode(e)
		}
	}
	{
		if s.InfluenceRank.Set {
			e.FieldStart("influence_rank")
			s.InfluenceRank.Encode(e)
		}
	}
	{
		if s.Percentile.Set {
			e.FieldStart("percentile")
			s.Percentile.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialInfluenceResponse = [5]string{
	0: "user_id",
	1: "influence_score",
	2: "influence_factors",
	3: "influence_rank",
	4: "percentile",
}

// Decode decodes SocialInfluenceResponse from json.
func (s *SocialInfluenceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialInfluenceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "influence_score":
			if err := func() error {
				s.InfluenceScore.Reset()
				if err := s.InfluenceScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"influence_score\"")
			}
		case "influence_factors":
			if err := func() error {
				s.InfluenceFactors.Reset()
				if err := s.InfluenceFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"influence_factors\"")
			}
		case "influence_rank":
			if err := func() error {
				s.InfluenceRank.Reset()
				if err := s.InfluenceRank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"influence_rank\"")
			}
		case "percentile":
			if err := func() error {
				s.Percentile.Reset()
				if err := s.Percentile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentile\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialInfluenceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialInfluenceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialInfluenceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialInfluenceResponseInfluenceFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialInfluenceResponseInfluenceFactors) encodeFields(e *jx.Encoder) {
	{
		if s.ReputationWeight.Set {
			e.FieldStart("reputation_weight")
			s.ReputationWeight.Encode(e)
		}
	}
	{
		if s.NetworkSizeWeight.Set {
			e.FieldStart("network_size_weight")
			s.NetworkSizeWeight.Encode(e)
		}
	}
	{
		if s.RelationshipQualityWeight.Set {
			e.FieldStart("relationship_quality_weight")
			s.RelationshipQualityWeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialInfluenceResponseInfluenceFactors = [3]string{
	0: "reputation_weight",
	1: "network_size_weight",
	2: "relationship_quality_weight",
}

// Decode decodes SocialInfluenceResponseInfluenceFactors from json.
func (s *SocialInfluenceResponseInfluenceFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialInfluenceResponseInfluenceFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reputation_weight":
			if err := func() error {
				s.ReputationWeight.Reset()
				if err := s.ReputationWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_weight\"")
			}
		case "network_size_weight":
			if err := func() error {
				s.NetworkSizeWeight.Reset()
				if err := s.NetworkSizeWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_size_weight\"")
			}
		case "relationship_quality_weight":
			if err := func() error {
				s.RelationshipQualityWeight.Reset()
				if err := s.RelationshipQualityWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_quality_weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialInfluenceResponseInfluenceFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialInfluenceResponseInfluenceFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialInfluenceResponseInfluenceFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialNetworkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialNetworkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.Connections != nil {
			e.FieldStart("connections")
			e.ArrStart()
			for _, elem := range s.Connections {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NetworkStats.Set {
			e.FieldStart("network_stats")
			s.NetworkStats.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialNetworkResponse = [3]string{
	0: "user_id",
	1: "connections",
	2: "network_stats",
}

// Decode decodes SocialNetworkResponse from json.
func (s *SocialNetworkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialNetworkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "connections":
			if err := func() error {
				s.Connections = make([]SocialNetworkResponseConnectionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SocialNetworkResponseConnectionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Connections = append(s.Connections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connections\"")
			}
		case "network_stats":
			if err := func() error {
				s.NetworkStats.Reset()
				if err := s.NetworkStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialNetworkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialNetworkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialNetworkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialNetworkResponseConnectionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialNetworkResponseConnectionsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Character.Set {
			e.FieldStart("character")
			s.Character.Encode(e)
		}
	}
	{
		if s.Relationship.Set {
			e.FieldStart("relationship")
			s.Relationship.Encode(e)
		}
	}
	{
		if s.ConnectionPath != nil {
			e.FieldStart("connection_path")
			e.ArrStart()
			for _, elem := range s.ConnectionPath {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSocialNetworkResponseConnectionsItem = [3]string{
	0: "character",
	1: "relationship",
	2: "connection_path",
}

// Decode decodes SocialNetworkResponseConnectionsItem from json.
func (s *SocialNetworkResponseConnectionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialNetworkResponseConnectionsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character":
			if err := func() error {
				s.Character.Reset()
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		case "relationship":
			if err := func() error {
				s.Relationship.Reset()
				if err := s.Relationship.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship\"")
			}
		case "connection_path":
			if err := func() error {
				s.ConnectionPath = make([]SocialNetworkResponseConnectionsItemConnectionPathItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SocialNetworkResponseConnectionsItemConnectionPathItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConnectionPath = append(s.ConnectionPath, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialNetworkResponseConnectionsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialNetworkResponseConnectionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialNetworkResponseConnectionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialNetworkResponseConnectionsItemCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialNetworkResponseConnectionsItemCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.PreferredLanguage.Set {
			e.FieldStart("preferred_language")
			s.PreferredLanguage.Encode(e)
		}
	}
	{
		if s.IsOnline.Set {
			e.FieldStart("is_online")
			s.IsOnline.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReputationScore.Set {
			e.FieldStart("reputation_score")
			s.ReputationScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialNetworkResponseConnectionsItemCharacter = [16]string{
	0:  "id",
	1:  "created_at",
	2:  "updated_at",
	3:  "created_by",
	4:  "updated_by",
	5:  "username",
	6:  "display_name",
	7:  "email",
	8:  "avatar_url",
	9:  "bio",
	10: "country",
	11: "timezone",
	12: "preferred_language",
	13: "is_online",
	14: "last_seen_at",
	15: "reputation_score",
}

// Decode decodes SocialNetworkResponseConnectionsItemCharacter from json.
func (s *SocialNetworkResponseConnectionsItemCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialNetworkResponseConnectionsItemCharacter to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "preferred_language":
			if err := func() error {
				s.PreferredLanguage.Reset()
				if err := s.PreferredLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_language\"")
			}
		case "is_online":
			if err := func() error {
				s.IsOnline.Reset()
				if err := s.IsOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_online\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "reputation_score":
			if err := func() error {
				s.ReputationScore.Reset()
				if err := s.ReputationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialNetworkResponseConnectionsItemCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSocialNetworkResponseConnectionsItemCharacter) {
					name = jsonFieldsNameOfSocialNetworkResponseConnectionsItemCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialNetworkResponseConnectionsItemCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialNetworkResponseConnectionsItemCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialNetworkResponseConnectionsItemConnectionPathItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialNetworkResponseConnectionsItemConnectionPathItem) encodeFields(e *jx.Encoder) {
	{
		if s.CharacterID.Set {
			e.FieldStart("character_id")
			s.CharacterID.Encode(e)
		}
	}
	{
		if s.RelationshipType.Set {
			e.FieldStart("relationship_type")
			s.RelationshipType.Encode(e)
		}
	}
	{
		if s.RelationshipLevel.Set {
			e.FieldStart("relationship_level")
			s.RelationshipLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialNetworkResponseConnectionsItemConnectionPathItem = [3]string{
	0: "character_id",
	1: "relationship_type",
	2: "relationship_level",
}

// Decode decodes SocialNetworkResponseConnectionsItemConnectionPathItem from json.
func (s *SocialNetworkResponseConnectionsItemConnectionPathItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialNetworkResponseConnectionsItemConnectionPathItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_id":
			if err := func() error {
				s.CharacterID.Reset()
				if err := s.CharacterID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "relationship_type":
			if err := func() error {
				s.RelationshipType.Reset()
				if err := s.RelationshipType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_type\"")
			}
		case "relationship_level":
			if err := func() error {
				s.RelationshipLevel.Reset()
				if err := s.RelationshipLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationship_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialNetworkResponseConnectionsItemConnectionPathItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialNetworkResponseConnectionsItemConnectionPathItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialNetworkResponseConnectionsItemConnectionPathItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SocialNetworkResponseNetworkStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SocialNetworkResponseNetworkStats) encodeFields(e *jx.Encoder) {
	{
		if s.TotalConnections.Set {
			e.FieldStart("total_connections")
			s.TotalConnections.Encode(e)
		}
	}
	{
		if s.AverageRelationshipLevel.Set {
			e.FieldStart("average_relationship_level")
			s.AverageRelationshipLevel.Encode(e)
		}
	}
	{
		if s.NetworkDensity.Set {
			e.FieldStart("network_density")
			s.NetworkDensity.Encode(e)
		}
	}
}

var jsonFieldsNameOfSocialNetworkResponseNetworkStats = [3]string{
	0: "total_connections",
	1: "average_relationship_level",
	2: "network_density",
}

// Decode decodes SocialNetworkResponseNetworkStats from json.
func (s *SocialNetworkResponseNetworkStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SocialNetworkResponseNetworkStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_connections":
			if err := func() error {
				s.TotalConnections.Reset()
				if err := s.TotalConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_connections\"")
			}
		case "average_relationship_level":
			if err := func() error {
				s.AverageRelationshipLevel.Reset()
				if err := s.AverageRelationshipLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_relationship_level\"")
			}
		case "network_density":
			if err := func() error {
				s.NetworkDensity.Reset()
				if err := s.NetworkDensity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_density\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SocialNetworkResponseNetworkStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SocialNetworkResponseNetworkStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SocialNetworkResponseNetworkStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerminateRelationshipForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerminateRelationshipForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerminateRelationshipForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes TerminateRelationshipForbidden from json.
func (s *TerminateRelationshipForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerminateRelationshipForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem TerminateRelationshipForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerminateRelationshipForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTerminateRelationshipForbidden) {
					name = jsonFieldsNameOfTerminateRelationshipForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerminateRelationshipForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerminateRelationshipForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerminateRelationshipForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerminateRelationshipForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTerminateRelationshipForbiddenDetails = [0]string{}

// Decode decodes TerminateRelationshipForbiddenDetails from json.
func (s *TerminateRelationshipForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerminateRelationshipForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TerminateRelationshipForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerminateRelationshipForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerminateRelationshipForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateMentorshipForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateMentorshipForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateMentorshipForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateMentorshipForbidden from json.
func (s *UpdateMentorshipForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateMentorshipForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateMentorshipForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateMentorshipForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateMentorshipForbidden) {
					name = jsonFieldsNameOfUpdateMentorshipForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateMentorshipForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateMentorshipForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateMentorshipForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateMentorshipForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateMentorshipForbiddenDetails = [0]string{}

// Decode decodes UpdateMentorshipForbiddenDetails from json.
func (s *UpdateMentorshipForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateMentorshipForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateMentorshipForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateMentorshipForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateMentorshipForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateMentorshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateMentorshipRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ContractTerms.Set {
			e.FieldStart("contract_terms")
			s.ContractTerms.Encode(e)
		}
	}
	{
		if s.ProgressNotes.Set {
			e.FieldStart("progress_notes")
			s.ProgressNotes.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateMentorshipRequest = [3]string{
	0: "status",
	1: "contract_terms",
	2: "progress_notes",
}

// Decode decodes UpdateMentorshipRequest from json.
func (s *UpdateMentorshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateMentorshipRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "contract_terms":
			if err := func() error {
				s.ContractTerms.Reset()
				if err := s.ContractTerms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract_terms\"")
			}
		case "progress_notes":
			if err := func() error {
				s.ProgressNotes.Reset()
				if err := s.ProgressNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateMentorshipRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateMentorshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateMentorshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateMentorshipRequestStatus as json.
func (s UpdateMentorshipRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateMentorshipRequestStatus from json.
func (s *UpdateMentorshipRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateMentorshipRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateMentorshipRequestStatus(v) {
	case UpdateMentorshipRequestStatusActive:
		*s = UpdateMentorshipRequestStatusActive
	case UpdateMentorshipRequestStatusCompleted:
		*s = UpdateMentorshipRequestStatusCompleted
	case UpdateMentorshipRequestStatusTerminated:
		*s = UpdateMentorshipRequestStatusTerminated
	case UpdateMentorshipRequestStatusPaused:
		*s = UpdateMentorshipRequestStatusPaused
	default:
		*s = UpdateMentorshipRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateMentorshipRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateMentorshipRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRelationshipForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRelationshipForbidden) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRelationshipForbidden = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes UpdateRelationshipForbidden from json.
func (s *UpdateRelationshipForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipForbidden to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem UpdateRelationshipForbiddenDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRelationshipForbidden")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRelationshipForbidden) {
					name = jsonFieldsNameOfUpdateRelationshipForbidden[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRelationshipForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRelationshipForbiddenDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRelationshipForbiddenDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateRelationshipForbiddenDetails = [0]string{}

// Decode decodes UpdateRelationshipForbiddenDetails from json.
func (s *UpdateRelationshipForbiddenDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipForbiddenDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRelationshipForbiddenDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRelationshipForbiddenDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipForbiddenDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRelationshipRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRelationshipRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateRelationshipRequest = [3]string{
	0: "level",
	1: "description",
	2: "flags",
}

// Decode decodes UpdateRelationshipRequest from json.
func (s *UpdateRelationshipRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]UpdateRelationshipRequestFlagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateRelationshipRequestFlagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRelationshipRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRelationshipRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRelationshipRequestFlagsItem as json.
func (s UpdateRelationshipRequestFlagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRelationshipRequestFlagsItem from json.
func (s *UpdateRelationshipRequestFlagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRelationshipRequestFlagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRelationshipRequestFlagsItem(v) {
	case UpdateRelationshipRequestFlagsItemExclusive:
		*s = UpdateRelationshipRequestFlagsItemExclusive
	case UpdateRelationshipRequestFlagsItemPublic:
		*s = UpdateRelationshipRequestFlagsItemPublic
	case UpdateRelationshipRequestFlagsItemSecret:
		*s = UpdateRelationshipRequestFlagsItemSecret
	case UpdateRelationshipRequestFlagsItemTemporary:
		*s = UpdateRelationshipRequestFlagsItemTemporary
	default:
		*s = UpdateRelationshipRequestFlagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRelationshipRequestFlagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRelationshipRequestFlagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserReputationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserReputationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.OverallScore.Set {
			e.FieldStart("overall_score")
			s.OverallScore.Encode(e)
		}
	}
	{
		if s.Categories.Set {
			e.FieldStart("categories")
			s.Categories.Encode(e)
		}
	}
	{
		if s.EvidenceCount.Set {
			e.FieldStart("evidence_count")
			s.EvidenceCount.Encode(e)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserReputationResponse = [5]string{
	0: "user_id",
	1: "overall_score",
	2: "categories",
	3: "evidence_count",
	4: "last_updated",
}

// Decode decodes UserReputationResponse from json.
func (s *UserReputationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReputationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "overall_score":
			if err := func() error {
				s.OverallScore.Reset()
				if err := s.OverallScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overall_score\"")
			}
		case "categories":
			if err := func() error {
				s.Categories.Reset()
				if err := s.Categories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "evidence_count":
			if err := func() error {
				s.EvidenceCount.Reset()
				if err := s.EvidenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence_count\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserReputationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserReputationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReputationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserReputationResponseCategories) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserReputationResponseCategories) encodeFields(e *jx.Encoder) {
	{
		if s.Trading.Set {
			e.FieldStart("trading")
			s.Trading.Encode(e)
		}
	}
	{
		if s.Combat.Set {
			e.FieldStart("combat")
			s.Combat.Encode(e)
		}
	}
	{
		if s.Social.Set {
			e.FieldStart("social")
			s.Social.Encode(e)
		}
	}
	{
		if s.Leadership.Set {
			e.FieldStart("leadership")
			s.Leadership.Encode(e)
		}
	}
	{
		if s.Craftsmanship.Set {
			e.FieldStart("craftsmanship")
			s.Craftsmanship.Encode(e)
		}
	}
	{
		if s.Reliability.Set {
			e.FieldStart("reliability")
			s.Reliability.Encode(e)
		}
	}
	{
		if s.Generosity.Set {
			e.FieldStart("generosity")
			s.Generosity.Encode(e)
		}
	}
	{
		if s.CombatSkill.Set {
			e.FieldStart("combat_skill")
			s.CombatSkill.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserReputationResponseCategories = [8]string{
	0: "trading",
	1: "combat",
	2: "social",
	3: "leadership",
	4: "craftsmanship",
	5: "reliability",
	6: "generosity",
	7: "combat_skill",
}

// Decode decodes UserReputationResponseCategories from json.
func (s *UserReputationResponseCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReputationResponseCategories to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trading":
			if err := func() error {
				s.Trading.Reset()
				if err := s.Trading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trading\"")
			}
		case "combat":
			if err := func() error {
				s.Combat.Reset()
				if err := s.Combat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat\"")
			}
		case "social":
			if err := func() error {
				s.Social.Reset()
				if err := s.Social.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"social\"")
			}
		case "leadership":
			if err := func() error {
				s.Leadership.Reset()
				if err := s.Leadership.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leadership\"")
			}
		case "craftsmanship":
			if err := func() error {
				s.Craftsmanship.Reset()
				if err := s.Craftsmanship.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craftsmanship\"")
			}
		case "reliability":
			if err := func() error {
				s.Reliability.Reset()
				if err := s.Reliability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reliability\"")
			}
		case "generosity":
			if err := func() error {
				s.Generosity.Reset()
				if err := s.Generosity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generosity\"")
			}
		case "combat_skill":
			if err := func() error {
				s.CombatSkill.Reset()
				if err := s.CombatSkill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"combat_skill\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserReputationResponseCategories")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserReputationResponseCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReputationResponseCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
