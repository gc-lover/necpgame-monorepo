// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// GetMentorshipRelationshipsParams is parameters of getMentorshipRelationships operation.
type GetMentorshipRelationshipsParams struct {
	// Filter by mentorship role.
	Role OptGetMentorshipRelationshipsRole `json:",omitempty,omitzero"`
	// Filter by mentorship status.
	Status OptGetMentorshipRelationshipsStatus `json:",omitempty,omitzero"`
	// Number of relationships to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetMentorshipRelationshipsParams(packed middleware.Parameters) (params GetMentorshipRelationshipsParams) {
	{
		key := middleware.ParameterKey{
			Name: "role",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Role = v.(OptGetMentorshipRelationshipsRole)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetMentorshipRelationshipsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetMentorshipRelationshipsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetMentorshipRelationshipsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: role.
	{
		val := GetMentorshipRelationshipsRole("both")
		params.Role.SetTo(val)
	}
	// Decode query: role.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal GetMentorshipRelationshipsRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = GetMentorshipRelationshipsRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Role.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "role",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: status.
	{
		val := GetMentorshipRelationshipsStatus("active")
		params.Status.SetTo(val)
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetMentorshipRelationshipsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetMentorshipRelationshipsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           50,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRelationshipParams is parameters of getRelationship operation.
type GetRelationshipParams struct {
	RelationshipId uuid.UUID
}

func unpackGetRelationshipParams(packed middleware.Parameters) (params GetRelationshipParams) {
	{
		key := middleware.ParameterKey{
			Name: "relationshipId",
			In:   "path",
		}
		params.RelationshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetRelationshipParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRelationshipParams, _ error) {
	// Decode path: relationshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "relationshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.RelationshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "relationshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetReputationHistoryParams is parameters of getReputationHistory operation.
type GetReputationHistoryParams struct {
	UserId uuid.UUID
	// Filter by reputation category.
	Category OptGetReputationHistoryCategory `json:",omitempty,omitzero"`
	// Number of history entries to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetReputationHistoryParams(packed middleware.Parameters) (params GetReputationHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "category",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Category = v.(OptGetReputationHistoryCategory)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetReputationHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetReputationHistoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: userId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: category.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCategoryVal GetReputationHistoryCategory
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCategoryVal = GetReputationHistoryCategory(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Category.SetTo(paramsDotCategoryVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Category.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "category",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRomanticRelationshipsParams is parameters of getRomanticRelationships operation.
type GetRomanticRelationshipsParams struct {
	// Filter by romantic status.
	Status OptGetRomanticRelationshipsStatus `json:",omitempty,omitzero"`
	// Privacy level of relationships to show.
	PrivacyLevel OptGetRomanticRelationshipsPrivacyLevel `json:",omitempty,omitzero"`
}

func unpackGetRomanticRelationshipsParams(packed middleware.Parameters) (params GetRomanticRelationshipsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetRomanticRelationshipsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "privacy_level",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PrivacyLevel = v.(OptGetRomanticRelationshipsPrivacyLevel)
		}
	}
	return params
}

func decodeGetRomanticRelationshipsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetRomanticRelationshipsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: status.
	{
		val := GetRomanticRelationshipsStatus("dating")
		params.Status.SetTo(val)
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetRomanticRelationshipsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetRomanticRelationshipsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: privacy_level.
	{
		val := GetRomanticRelationshipsPrivacyLevel("private")
		params.PrivacyLevel.SetTo(val)
	}
	// Decode query: privacy_level.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "privacy_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrivacyLevelVal GetRomanticRelationshipsPrivacyLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrivacyLevelVal = GetRomanticRelationshipsPrivacyLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.PrivacyLevel.SetTo(paramsDotPrivacyLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.PrivacyLevel.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "privacy_level",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSocialConnectionsParams is parameters of getSocialConnections operation.
type GetSocialConnectionsParams struct {
	UserId uuid.UUID
	// Connection depth to traverse.
	Depth OptInt `json:",omitempty,omitzero"`
	// Types of relationships to include.
	RelationshipTypes []GetSocialConnectionsRelationshipTypesItem `json:",omitempty"`
	// Maximum connections to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackGetSocialConnectionsParams(packed middleware.Parameters) (params GetSocialConnectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "depth",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Depth = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "relationship_types",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.RelationshipTypes = v.([]GetSocialConnectionsRelationshipTypesItem)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeGetSocialConnectionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSocialConnectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: userId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: depth.
	{
		val := int(2)
		params.Depth.SetTo(val)
	}
	// Decode query: depth.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "depth",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDepthVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotDepthVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Depth.SetTo(paramsDotDepthVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Depth.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           3,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "depth",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: relationship_types.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "relationship_types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotRelationshipTypesVal GetSocialConnectionsRelationshipTypesItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRelationshipTypesVal = GetSocialConnectionsRelationshipTypesItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.RelationshipTypes = append(params.RelationshipTypes, paramsDotRelationshipTypesVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.RelationshipTypes {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "relationship_types",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           200,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSocialInfluenceParams is parameters of getSocialInfluence operation.
type GetSocialInfluenceParams struct {
	UserId uuid.UUID
}

func unpackGetSocialInfluenceParams(packed middleware.Parameters) (params GetSocialInfluenceParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetSocialInfluenceParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSocialInfluenceParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUserFriendshipsParams is parameters of getUserFriendships operation.
type GetUserFriendshipsParams struct {
	// Friendship status filter.
	Status OptGetUserFriendshipsStatus `json:",omitempty,omitzero"`
	// Number of friendships to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetUserFriendshipsParams(packed middleware.Parameters) (params GetUserFriendshipsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetUserFriendshipsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetUserFriendshipsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetUserFriendshipsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: status.
	{
		val := GetUserFriendshipsStatus("accepted")
		params.Status.SetTo(val)
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetUserFriendshipsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetUserFriendshipsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUserRelationshipsParams is parameters of getUserRelationships operation.
type GetUserRelationshipsParams struct {
	// Filter by relationship type.
	Type OptGetUserRelationshipsType `json:",omitempty,omitzero"`
	// Minimum relationship level.
	LevelMin OptInt `json:",omitempty,omitzero"`
	// Maximum relationship level.
	LevelMax OptInt `json:",omitempty,omitzero"`
	// Filter by relationship status.
	Status OptGetUserRelationshipsStatus `json:",omitempty,omitzero"`
	// Number of relationships to return.
	Limit OptInt `json:",omitempty,omitzero"`
	// Pagination offset.
	Offset OptInt `json:",omitempty,omitzero"`
}

func unpackGetUserRelationshipsParams(packed middleware.Parameters) (params GetUserRelationshipsParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptGetUserRelationshipsType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "level_min",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LevelMin = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "level_max",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LevelMax = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptGetUserRelationshipsStatus)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt)
		}
	}
	return params
}

func decodeGetUserRelationshipsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetUserRelationshipsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal GetUserRelationshipsType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = GetUserRelationshipsType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Type.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: level_min.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "level_min",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLevelMinVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLevelMinVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LevelMin.SetTo(paramsDotLevelMinVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.LevelMin.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           -10,
							MaxSet:        true,
							Max:           10,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "level_min",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: level_max.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "level_max",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLevelMaxVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLevelMaxVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LevelMax.SetTo(paramsDotLevelMaxVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.LevelMax.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           -10,
							MaxSet:        true,
							Max:           10,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "level_max",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal GetUserRelationshipsStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = GetUserRelationshipsStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Status.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(50)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: offset.
	{
		val := int(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUserReputationParams is parameters of getUserReputation operation.
type GetUserReputationParams struct {
	UserId uuid.UUID
}

func unpackGetUserReputationParams(packed middleware.Parameters) (params GetUserReputationParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetUserReputationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUserReputationParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUserRivalriesParams is parameters of getUserRivalries operation.
type GetUserRivalriesParams struct {
	// Filter by rivalry intensity.
	Intensity OptGetUserRivalriesIntensity `json:",omitempty,omitzero"`
	// Only active rivalries.
	Active OptBool `json:",omitempty,omitzero"`
}

func unpackGetUserRivalriesParams(packed middleware.Parameters) (params GetUserRivalriesParams) {
	{
		key := middleware.ParameterKey{
			Name: "intensity",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Intensity = v.(OptGetUserRivalriesIntensity)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "active",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Active = v.(OptBool)
		}
	}
	return params
}

func decodeGetUserRivalriesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetUserRivalriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: intensity.
	{
		val := GetUserRivalriesIntensity("moderate")
		params.Intensity.SetTo(val)
	}
	// Decode query: intensity.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "intensity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIntensityVal GetUserRivalriesIntensity
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIntensityVal = GetUserRivalriesIntensity(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Intensity.SetTo(paramsDotIntensityVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Intensity.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "intensity",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: active.
	{
		val := bool(true)
		params.Active.SetTo(val)
	}
	// Decode query: active.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "active",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotActiveVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotActiveVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Active.SetTo(paramsDotActiveVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "active",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RecordMentorshipProgressParams is parameters of recordMentorshipProgress operation.
type RecordMentorshipProgressParams struct {
	MentorshipId uuid.UUID
}

func unpackRecordMentorshipProgressParams(packed middleware.Parameters) (params RecordMentorshipProgressParams) {
	{
		key := middleware.ParameterKey{
			Name: "mentorshipId",
			In:   "path",
		}
		params.MentorshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeRecordMentorshipProgressParams(args [1]string, argsEscaped bool, r *http.Request) (params RecordMentorshipProgressParams, _ error) {
	// Decode path: mentorshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "mentorshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.MentorshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mentorshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RelationshipHealthCheckParams is parameters of relationshipHealthCheck operation.
type RelationshipHealthCheckParams struct {
	AcceptEncoding OptRelationshipHealthCheckAcceptEncoding `json:",omitempty,omitzero"`
}

func unpackRelationshipHealthCheckParams(packed middleware.Parameters) (params RelationshipHealthCheckParams) {
	{
		key := middleware.ParameterKey{
			Name: "Accept-Encoding",
			In:   "header",
		}
		if v, ok := packed[key]; ok {
			params.AcceptEncoding = v.(OptRelationshipHealthCheckAcceptEncoding)
		}
	}
	return params
}

func decodeRelationshipHealthCheckParams(args [0]string, argsEscaped bool, r *http.Request) (params RelationshipHealthCheckParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: Accept-Encoding.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAcceptEncodingVal RelationshipHealthCheckAcceptEncoding
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAcceptEncodingVal = RelationshipHealthCheckAcceptEncoding(c)
					return nil
				}(); err != nil {
					return err
				}
				params.AcceptEncoding.SetTo(paramsDotAcceptEncodingVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.AcceptEncoding.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "Accept-Encoding",
			In:   "header",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveFriendshipParams is parameters of removeFriendship operation.
type RemoveFriendshipParams struct {
	FriendshipId uuid.UUID
}

func unpackRemoveFriendshipParams(packed middleware.Parameters) (params RemoveFriendshipParams) {
	{
		key := middleware.ParameterKey{
			Name: "friendshipId",
			In:   "path",
		}
		params.FriendshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeRemoveFriendshipParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveFriendshipParams, _ error) {
	// Decode path: friendshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "friendshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.FriendshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "friendshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RespondToFriendRequestParams is parameters of respondToFriendRequest operation.
type RespondToFriendRequestParams struct {
	FriendshipId uuid.UUID
}

func unpackRespondToFriendRequestParams(packed middleware.Parameters) (params RespondToFriendRequestParams) {
	{
		key := middleware.ParameterKey{
			Name: "friendshipId",
			In:   "path",
		}
		params.FriendshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeRespondToFriendRequestParams(args [1]string, argsEscaped bool, r *http.Request) (params RespondToFriendRequestParams, _ error) {
	// Decode path: friendshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "friendshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.FriendshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "friendshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchRelationshipsParams is parameters of searchRelationships operation.
type SearchRelationshipsParams struct {
	// Character to search relationships for.
	CharacterID uuid.UUID
	// Relationship type filter.
	Type OptSearchRelationshipsType `json:",omitempty,omitzero"`
	// Minimum relationship level.
	MinLevel OptInt `json:",omitempty,omitzero"`
	// Only mutual relationships.
	Mutual OptBool `json:",omitempty,omitzero"`
	// Number of results to return.
	Limit OptInt `json:",omitempty,omitzero"`
}

func unpackSearchRelationshipsParams(packed middleware.Parameters) (params SearchRelationshipsParams) {
	{
		key := middleware.ParameterKey{
			Name: "character_id",
			In:   "query",
		}
		params.CharacterID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptSearchRelationshipsType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "min_level",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MinLevel = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mutual",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mutual = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeSearchRelationshipsParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchRelationshipsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: character_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "character_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.CharacterID = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "character_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal SearchRelationshipsType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = SearchRelationshipsType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Type.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: min_level.
	{
		val := int(1)
		params.MinLevel.SetTo(val)
	}
	// Decode query: min_level.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMinLevelVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotMinLevelVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MinLevel.SetTo(paramsDotMinLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.MinLevel.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           -10,
							MaxSet:        true,
							Max:           10,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "min_level",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: mutual.
	{
		val := bool(true)
		params.Mutual.SetTo(val)
	}
	// Decode query: mutual.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mutual",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMutualVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotMutualVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mutual.SetTo(paramsDotMutualVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mutual",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        true,
							Max:           50,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
							Pattern:       nil,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TerminateRelationshipParams is parameters of terminateRelationship operation.
type TerminateRelationshipParams struct {
	RelationshipId uuid.UUID
	// Reason for termination.
	Reason OptString `json:",omitempty,omitzero"`
}

func unpackTerminateRelationshipParams(packed middleware.Parameters) (params TerminateRelationshipParams) {
	{
		key := middleware.ParameterKey{
			Name: "relationshipId",
			In:   "path",
		}
		params.RelationshipId = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "reason",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reason = v.(OptString)
		}
	}
	return params
}

func decodeTerminateRelationshipParams(args [1]string, argsEscaped bool, r *http.Request) (params TerminateRelationshipParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: relationshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "relationshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.RelationshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "relationshipId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reason.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reason",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReasonVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReasonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reason.SetTo(paramsDotReasonVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Reason.Get(); ok {
					if err := func() error {
						if err := (validate.String{
							MinLength:     0,
							MinLengthSet:  false,
							MaxLength:     200,
							MaxLengthSet:  true,
							Email:         false,
							Hostname:      false,
							Regex:         nil,
							MinNumeric:    0,
							MinNumericSet: false,
							MaxNumeric:    0,
							MaxNumericSet: false,
						}).Validate(string(value)); err != nil {
							return errors.Wrap(err, "string")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reason",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateMentorshipParams is parameters of updateMentorship operation.
type UpdateMentorshipParams struct {
	MentorshipId uuid.UUID
}

func unpackUpdateMentorshipParams(packed middleware.Parameters) (params UpdateMentorshipParams) {
	{
		key := middleware.ParameterKey{
			Name: "mentorshipId",
			In:   "path",
		}
		params.MentorshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeUpdateMentorshipParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateMentorshipParams, _ error) {
	// Decode path: mentorshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "mentorshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.MentorshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mentorshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateRelationshipParams is parameters of updateRelationship operation.
type UpdateRelationshipParams struct {
	RelationshipId uuid.UUID
}

func unpackUpdateRelationshipParams(packed middleware.Parameters) (params UpdateRelationshipParams) {
	{
		key := middleware.ParameterKey{
			Name: "relationshipId",
			In:   "path",
		}
		params.RelationshipId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeUpdateRelationshipParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateRelationshipParams, _ error) {
	// Decode path: relationshipId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "relationshipId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.RelationshipId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "relationshipId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
