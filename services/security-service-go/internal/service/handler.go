// Code generated by NECPGAME backend agent. Enterprise-grade Security service handlers.
// PERFORMANCE: Optimized request handling with context timeouts and security validations
// Issue: #2208 - Security Service for Authentication and Authorization

package service

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"go.uber.org/zap"

	api "necpgame/services/security-service-go/pkg/api"
)

// Handler implements the generated API handler interface
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Handler struct {
	service *SecurityService
	logger  *zap.Logger
}

// NewHandler creates new optimized handler
func NewHandler(svc *SecurityService) *Handler {
	return &Handler{
		service: svc,
		logger:  svc.logger,
	}
}

// RegisterUser handles user registration
// PERFORMANCE: Context timeout prevents slow registration operations
func (h *Handler) RegisterUser(ctx context.Context, req *api.RegisterUserRequest) (api.RegisterUserRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Processing user registration",
		zap.String("email", req.Email),
		zap.String("username", req.Username))

	user, err := h.service.Register(ctx, req.Email, req.Username, req.Password)
	if err != nil {
		h.logger.Error("User registration failed",
			zap.Error(err),
			zap.String("email", req.Email))
		return &api.RegisterUserBadRequest{
			Data: api.Error{
				Code:    "REGISTRATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.RegisterUserCreated{
		Data: &api.UserResponse{
			Id:        user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Status:    api.UserResponseStatus(user.Status),
			Role:      api.UserResponseRole(user.Role),
			CreatedAt: user.CreatedAt,
			IsActive:  user.IsActive,
			IsVerified: user.IsVerified,
		},
	}, nil
}

// LoginUser handles user authentication
// PERFORMANCE: High-throughput endpoint for user login operations
func (h *Handler) LoginUser(ctx context.Context, req *api.LoginUserRequest) (api.LoginUserRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	// Get client information
	userAgent := ctx.Value("user_agent").(string)
	ipAddress := ctx.Value("ip_address").(string)

	h.logger.Info("Processing user login",
		zap.String("identifier", req.Identifier))

	tokens, err := h.service.Login(ctx, req.Identifier, req.Password, userAgent, ipAddress)
	if err != nil {
		h.logger.Warn("User login failed",
			zap.Error(err),
			zap.String("identifier", req.Identifier))
		return &api.LoginUserUnauthorized{
			Data: api.Error{
				Code:    "LOGIN_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.LoginUserOK{
		Data: &api.LoginResponse{
			AccessToken:  tokens["access_token"],
			RefreshToken: tokens["refresh_token"],
			TokenType:    tokens["token_type"],
			ExpiresIn:    tokens["expires_in"],
		},
	}, nil
}

// LogoutUser handles user logout
func (h *Handler) LogoutUser(ctx context.Context, req *api.LogoutUserRequest) (api.LogoutUserRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Extract token from Authorization header
	authHeader := ctx.Value("authorization").(string)
	if authHeader == "" {
		return &api.LogoutUserUnauthorized{
			Data: api.Error{
				Code:    "MISSING_TOKEN",
				Message: "Authorization header required",
			},
		}, nil
	}

	token := strings.TrimPrefix(authHeader, "Bearer ")
	if token == authHeader {
		return &api.LogoutUserUnauthorized{
			Data: api.Error{
				Code:    "INVALID_TOKEN_FORMAT",
				Message: "Invalid token format",
			},
		}, nil
	}

	err := h.service.Logout(ctx, token)
	if err != nil {
		h.logger.Error("User logout failed", zap.Error(err))
		return &api.LogoutUserInternalServerError{
			Data: api.Error{
				Code:    "LOGOUT_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.LogoutUserOK{
		Data: &api.MessageResponse{
			Message: "Successfully logged out",
		},
	}, nil
}

// RefreshToken handles token refresh
func (h *Handler) RefreshToken(ctx context.Context, req *api.RefreshTokenRequest) (api.RefreshTokenRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	h.logger.Info("Processing token refresh")

	tokens, err := h.service.RefreshToken(ctx, req.RefreshToken)
	if err != nil {
		h.logger.Warn("Token refresh failed", zap.Error(err))
		return &api.RefreshTokenUnauthorized{
			Data: api.Error{
				Code:    "REFRESH_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.RefreshTokenOK{
		Data: &api.TokenRefreshResponse{
			AccessToken: tokens["access_token"],
			TokenType:   tokens["token_type"],
			ExpiresIn:   tokens["expires_in"],
		},
	}, nil
}

// ValidateToken handles token validation
// PERFORMANCE: Fast endpoint for token validation in request pipelines
func (h *Handler) ValidateToken(ctx context.Context, req *api.ValidateTokenRequest) (api.ValidateTokenRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	claims, err := h.service.ValidateToken(ctx, req.Token)
	if err != nil {
		return &api.ValidateTokenUnauthorized{
			Data: api.Error{
				Code:    "INVALID_TOKEN",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.ValidateTokenOK{
		Data: &api.TokenValidationResponse{
			Valid:    true,
			UserId:   claims.UserID,
			Username: claims.Username,
			Email:    claims.Email,
			Role:     claims.Role,
		},
	}, nil
}

// AuthorizeAction handles authorization checks
func (h *Handler) AuthorizeAction(ctx context.Context, req *api.AuthorizeActionRequest) (api.AuthorizeActionRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Extract user ID from context (set by middleware)
	userID := ctx.Value("user_id").(string)
	if userID == "" {
		return &api.AuthorizeActionUnauthorized{
			Data: api.Error{
				Code:    "MISSING_USER_ID",
				Message: "User ID not found in context",
			},
		}, nil
	}

	authorized, err := h.service.Authorize(ctx, userID, req.Resource, req.Action)
	if err != nil {
		h.logger.Error("Authorization check failed", zap.Error(err))
		return &api.AuthorizeActionInternalServerError{
			Data: api.Error{
				Code:    "AUTHORIZATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	if !authorized {
		return &api.AuthorizeActionForbidden{
			Data: api.Error{
				Code:    "INSUFFICIENT_PERMISSIONS",
				Message: "User does not have permission for this action",
			},
		}, nil
	}

	return &api.AuthorizeActionOK{
		Data: &api.AuthorizationResponse{
			Authorized: true,
			Resource:   req.Resource,
			Action:     req.Action,
		},
	}, nil
}

// GetUserProfile retrieves user profile information
func (h *Handler) GetUserProfile(ctx context.Context, params api.GetUserProfileParams) (api.GetUserProfileRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	userID := params.UserID

	// Check if user can access this profile
	currentUserID := ctx.Value("user_id").(string)
	if currentUserID != userID {
		// Check if current user has admin permissions
		authorized, err := h.service.Authorize(ctx, currentUserID, "users", "read")
		if err != nil || !authorized {
			return &api.GetUserProfileForbidden{
				Data: api.Error{
					Code:    "ACCESS_DENIED",
					Message: "Cannot access other user's profile",
				},
			}, nil
		}
	}

	user, err := h.service.getUserByID(ctx, userID)
	if err != nil {
		h.logger.Error("Failed to get user profile", zap.Error(err))
		return &api.GetUserProfileNotFound{
			Data: api.Error{
				Code:    "USER_NOT_FOUND",
				Message: "User not found",
			},
		}, nil
	}

	return &api.GetUserProfileOK{
		Data: &api.UserProfileResponse{
			Id:        user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Status:    api.UserProfileResponseStatus(user.Status),
			Role:      api.UserProfileResponseRole(user.Role),
			CreatedAt: user.CreatedAt,
			IsActive:  user.IsActive,
			IsVerified: user.IsVerified,
		},
	}, nil
}

// UpdateUserProfile updates user profile information
func (h *Handler) UpdateUserProfile(ctx context.Context, req *api.UpdateUserProfileRequest, params api.UpdateUserProfileParams) (api.UpdateUserProfileRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	userID := params.UserID

	// Check permissions
	currentUserID := ctx.Value("user_id").(string)
	if currentUserID != userID {
		authorized, err := h.service.Authorize(ctx, currentUserID, "users", "write")
		if err != nil || !authorized {
			return &api.UpdateUserProfileForbidden{
				Data: api.Error{
					Code:    "ACCESS_DENIED",
					Message: "Cannot update other user's profile",
				},
			}, nil
		}
	}

	// Update user profile in database
	// This is a simplified implementation
	updateFields := make(map[string]interface{})
	if req.Email != nil {
		updateFields["email"] = *req.Email
	}
	if req.Username != nil {
		updateFields["username"] = *req.Username
	}

	err := h.service.updateUserProfile(ctx, userID, updateFields)
	if err != nil {
		h.logger.Error("Failed to update user profile", zap.Error(err))
		return &api.UpdateUserProfileInternalServerError{
			Data: api.Error{
				Code:    "UPDATE_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.UpdateUserProfileOK{
		Data: &api.MessageResponse{
			Message: "Profile updated successfully",
		},
	}, nil
}

// Health check endpoint
func (h *Handler) HealthCheck(ctx context.Context) (api.HealthCheckRes, error) {
	return &api.HealthCheckOK{
		Data: &api.HealthResponse{
			Status:    api.HealthResponseStatusHealthy,
			Domain:    stringPtr("security-service"),
			Timestamp: time.Now(),
			Version:   stringPtr("1.0.0"),
		},
	}, nil
}

// Middleware helper functions

// AuthMiddleware validates JWT tokens and sets user context
func (h *Handler) AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
		if tokenString == authHeader {
			http.Error(w, "Invalid token format", http.StatusUnauthorized)
			return
		}

		claims, err := h.service.ValidateToken(r.Context(), tokenString)
		if err != nil {
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		// Set user context
		ctx := context.WithValue(r.Context(), "user_id", claims.UserID)
		ctx = context.WithValue(ctx, "user_role", claims.Role)
		ctx = context.WithValue(ctx, "username", claims.Username)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// RateLimitMiddleware applies rate limiting
func (h *Handler) RateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ip := getClientIP(r)

		if !h.service.checkRateLimit(ip, "ip") {
			http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// LoggingMiddleware logs all requests
func (h *Handler) LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Create response writer wrapper to capture status code
		rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		next.ServeHTTP(rw, r)

		duration := time.Since(start)
		h.logger.Info("Request completed",
			zap.String("method", r.Method),
			zap.String("path", r.URL.Path),
			zap.Int("status", rw.statusCode),
			zap.Duration("duration", duration),
			zap.String("ip", getClientIP(r)))
	})
}

// Helper types and functions

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func getClientIP(r *http.Request) string {
	// Check X-Forwarded-For header first
	xForwardedFor := r.Header.Get("X-Forwarded-For")
	if xForwardedFor != "" {
		// Take the first IP in case of multiple
		ips := strings.Split(xForwardedFor, ",")
		return strings.TrimSpace(ips[0])
	}

	// Check X-Real-IP header
	xRealIP := r.Header.Get("X-Real-IP")
	if xRealIP != "" {
		return xRealIP
	}

	// Fall back to RemoteAddr
	ip, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil {
		return r.RemoteAddr
	}
	return ip
}

func stringPtr(s string) *string {
	return &s
}

// Additional service methods needed by handlers

func (s *SecurityService) updateUserProfile(ctx context.Context, userID string, fields map[string]interface{}) error {
	// Simplified implementation - would need proper SQL building
	if email, ok := fields["email"].(string); ok {
		_, err := s.db.Exec(ctx, "UPDATE users SET email = $1, updated_at = $2 WHERE id = $3",
			email, time.Now().UTC(), userID)
		if err != nil {
			return err
		}
	}

	if username, ok := fields["username"].(string); ok {
		_, err := s.db.Exec(ctx, "UPDATE users SET username = $1, updated_at = $2 WHERE id = $3",
			username, time.Now().UTC(), userID)
		if err != nil {
			return err
		}
	}

	return nil
}