// Code generated by NECPGAME backend agent. Comprehensive security service tests.
// PERFORMANCE: Tests validate enterprise-grade security implementation

package service

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSecurityService_UserRegistration(t *testing.T) {
	// Skip integration tests in CI without database
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("successful registration", func(t *testing.T) {
		email := "test" + uuid.New().String()[:8] + "@example.com"
		username := "testuser" + uuid.New().String()[:8]

		user, err := svc.Register(ctx, email, username, "TestPassword123!")

		require.NoError(t, err)
		assert.NotEmpty(t, user.ID)
		assert.Equal(t, email, user.Email)
		assert.Equal(t, username, user.Username)
		assert.Equal(t, "active", user.Status)
		assert.Equal(t, "player", user.Role)
		assert.True(t, user.IsActive)
		assert.False(t, user.IsVerified)
	})

	t.Run("duplicate user registration", func(t *testing.T) {
		email := "duplicate" + uuid.New().String()[:8] + "@example.com"
		username := "dupuser" + uuid.New().String()[:8]

		// First registration
		_, err := svc.Register(ctx, email, username, "TestPassword123!")
		require.NoError(t, err)

		// Duplicate registration should fail
		_, err = svc.Register(ctx, email, username, "TestPassword123!")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "already exists")
	})

	t.Run("invalid registration data", func(t *testing.T) {
		testCases := []struct {
			name     string
			email    string
			username string
			password string
			wantErr  string
		}{
			{"empty email", "", "username", "password", "email, username, and password are required"},
			{"invalid email", "invalid-email", "username", "password", "invalid email format"},
			{"short password", "test@example.com", "username", "123", "password must be at least 8 characters"},
			{"empty username", "test@example.com", "", "password123", "email, username, and password are required"},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				_, err := svc.Register(ctx, tc.email, tc.username, tc.password)
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tc.wantErr)
			})
		}
	})
}

func TestSecurityService_UserLogin(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test user
	email := "login" + uuid.New().String()[:8] + "@example.com"
	username := "loginuser" + uuid.New().String()[:8]
	password := "LoginTest123!"

	_, err := svc.Register(ctx, email, username, password)
	require.NoError(t, err)

	t.Run("successful login", func(t *testing.T) {
		tokens, err := svc.Login(ctx, username, password, "test-agent", "127.0.0.1")

		require.NoError(t, err)
		assert.NotEmpty(t, tokens["access_token"])
		assert.NotEmpty(t, tokens["refresh_token"])
		assert.Equal(t, "Bearer", tokens["token_type"])
		assert.Equal(t, "900", tokens["expires_in"])
	})

	t.Run("invalid credentials", func(t *testing.T) {
		_, err := svc.Login(ctx, username, "wrongpassword", "test-agent", "127.0.0.1")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid credentials")
	})

	t.Run("nonexistent user", func(t *testing.T) {
		_, err := svc.Login(ctx, "nonexistentuser", "password", "test-agent", "127.0.0.1")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid credentials")
	})
}

func TestSecurityService_TokenValidation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create and login test user
	email := "token" + uuid.New().String()[:8] + "@example.com"
	username := "tokenuser" + uuid.New().String()[:8]
	password := "TokenTest123!"

	_, err := svc.Register(ctx, email, username, password)
	require.NoError(t, err)

	tokens, err := svc.Login(ctx, username, password, "test-agent", "127.0.0.1")
	require.NoError(t, err)

	t.Run("valid token", func(t *testing.T) {
		claims, err := svc.ValidateToken(ctx, tokens["access_token"].(string))

		require.NoError(t, err)
		assert.True(t, claims.Valid)
		assert.Equal(t, username, claims.Username)
		assert.Equal(t, email, claims.Email)
		assert.Equal(t, "player", claims.Role)
	})

	t.Run("invalid token", func(t *testing.T) {
		_, err := svc.ValidateToken(ctx, "invalid.jwt.token")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid token")
	})

	t.Run("expired token", func(t *testing.T) {
		// Create token with very short expiry for testing
		shortLivedClaims := getJWTClaims()
		defer putJWTClaims(shortLivedClaims)

		shortLivedClaims.UserID = "test-user"
		shortLivedClaims.Username = "testuser"
		shortLivedClaims.RegisteredClaims = jwt.RegisteredClaims{
			Issuer:    "test",
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(-time.Hour)), // Already expired
			IssuedAt:  jwt.NewNumericDate(time.Now().Add(-2 * time.Hour)),
		}

		shortToken := jwt.NewWithClaims(jwt.SigningMethodHS256, shortLivedClaims)
		shortTokenString, _ := shortToken.SignedString(svc.jwtSecret)

		_, err := svc.ValidateToken(ctx, shortTokenString)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid token")
	})
}

func TestSecurityService_Authorization(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test user
	email := "auth" + uuid.New().String()[:8] + "@example.com"
	username := "authuser" + uuid.New().String()[:8]
	password := "AuthTest123!"

	user, err := svc.Register(ctx, email, username, password)
	require.NoError(t, err)

	t.Run("player permissions", func(t *testing.T) {
		// Player should be able to read users
		allowed, err := svc.Authorize(ctx, user.ID, "users", "read")
		require.NoError(t, err)
		assert.True(t, allowed)

		// Player should be able to write games
		allowed, err = svc.Authorize(ctx, user.ID, "games", "write")
		require.NoError(t, err)
		assert.True(t, allowed)

		// Player should NOT be able to delete users
		allowed, err = svc.Authorize(ctx, user.ID, "users", "delete")
		require.NoError(t, err)
		assert.False(t, allowed)
	})

	t.Run("invalid user", func(t *testing.T) {
		_, err := svc.Authorize(ctx, "invalid-user-id", "users", "read")
		assert.Error(t, err)
	})
}

func TestSecurityService_RateLimiting(t *testing.T) {
	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("rate limit enforcement", func(t *testing.T) {
		ip := "192.168.1.100"

		// Should allow requests up to limit
		for i := 0; i < 100; i++ {
			allowed := svc.checkRateLimit(ip, "ip")
			assert.True(t, allowed, "Request %d should be allowed", i+1)
		}

		// Next request should be blocked
		allowed := svc.checkRateLimit(ip, "ip")
		assert.False(t, allowed, "Request should be rate limited")
	})
}

func TestSecurityService_PasswordSecurity(t *testing.T) {
	svc := setupTestService(t)
	defer svc.Shutdown(context.Background())

	t.Run("password hashing and verification", func(t *testing.T) {
		password := "MySecurePassword123!"

		// Hash password
		hashed, err := svc.hashPassword(password)
		require.NoError(t, err)
		assert.NotEmpty(t, hashed)
		assert.NotEqual(t, password, hashed)

		// Verify correct password
		assert.True(t, svc.verifyPassword(password, hashed))

		// Verify incorrect password
		assert.False(t, svc.verifyPassword("wrongpassword", hashed))
	})

	t.Run("password requirements", func(t *testing.T) {
		validPasswords := []string{
			"Password123!",
			"MySecurePass1",
			"Complex!Pass123",
		}

		invalidPasswords := []string{
			"12345678",     // No letters
			"password",     // No numbers/symbols
			"Pass",         // Too short
			"",             // Empty
		}

		for _, password := range validPasswords {
			_, err := svc.hashPassword(password)
			assert.NoError(t, err, "Password %s should be valid", password)
		}

		for _, password := range invalidPasswords {
			_, err := svc.hashPassword(password)
			assert.Error(t, err, "Password %s should be invalid", password)
		}
	})
}

// Test utilities

func setupTestService(t *testing.T) *SecurityService {
	// Use test database configuration
	config := Config{
		Logger:      zap.NewNop(),
		Tracer:      nil,
		Meter:       nil,
		DatabaseURL: "postgres://postgres:postgres@localhost:5432/necpgame_test?sslmode=disable",
		RedisURL:    "redis://localhost:6379/1", // Use DB 1 for tests
		JWTSecret:   "test-jwt-secret-key-for-testing-only",
	}

	svc, err := NewSecurityService(config)
	require.NoError(t, err)

	// Setup test database schema
	setupTestDatabase(t, svc)

	return svc
}

func setupTestDatabase(t *testing.T, svc *SecurityService) {
	// Create test tables if they don't exist
	_, err := svc.db.Exec(context.Background(), `
		CREATE TABLE IF NOT EXISTS users (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			email VARCHAR(255) UNIQUE,
			username VARCHAR(50) UNIQUE,
			password VARCHAR(255),
			status VARCHAR(20) DEFAULT 'active',
			role VARCHAR(20) DEFAULT 'player',
			is_active BOOLEAN DEFAULT true,
			is_verified BOOLEAN DEFAULT false,
			two_factor_enabled BOOLEAN DEFAULT false,
			login_attempts INTEGER DEFAULT 0,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			last_login_at TIMESTAMP WITH TIME ZONE
		);

		CREATE TABLE IF NOT EXISTS sessions (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			user_id UUID NOT NULL,
			token VARCHAR(500) UNIQUE,
			session_type VARCHAR(20) DEFAULT 'access',
			user_agent TEXT,
			ip_address INET,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			expires_at TIMESTAMP WITH TIME ZONE,
			last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			is_active BOOLEAN DEFAULT true
		);

		CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
		CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
		CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token);
		CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
	`)
	require.NoError(t, err)

	// Clean up test data
	_, err = svc.db.Exec(context.Background(), `
		DELETE FROM sessions WHERE token LIKE 'test%';
		DELETE FROM users WHERE email LIKE 'test%' OR username LIKE 'test%';
	`)
	require.NoError(t, err)
}

func BenchmarkSecurityService_Login(b *testing.B) {
	svc := setupTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test user
	email := "bench" + uuid.New().String()[:8] + "@example.com"
	username := "benchuser" + uuid.New().String()[:8]
	password := "BenchTest123!"

	_, err := svc.Register(ctx, email, username, password)
	require.NoError(b, err)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := svc.Login(ctx, username, password, "bench-agent", "127.0.0.1")
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkSecurityService_TokenValidation(b *testing.B) {
	svc := setupTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test user and get token
	email := "tokenbench" + uuid.New().String()[:8] + "@example.com"
	username := "tokenbenchuser" + uuid.New().String()[:8]
	password := "TokenBench123!"

	_, err := svc.Register(ctx, email, username, password)
	require.NoError(b, err)

	tokens, err := svc.Login(ctx, username, password, "bench-agent", "127.0.0.1")
	require.NoError(b, err)

	token := tokens["access_token"].(string)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := svc.ValidateToken(ctx, token)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkSecurityService_Authorization(b *testing.B) {
	svc := setupTestService(&testing.T{})
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test user
	email := "authbench" + uuid.New().String()[:8] + "@example.com"
	username := "authbenchuser" + uuid.New().String()[:8]
	password := "AuthBench123!"

	user, err := svc.Register(ctx, email, username, password)
	require.NoError(b, err)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := svc.Authorize(ctx, user.ID, "users", "read")
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}