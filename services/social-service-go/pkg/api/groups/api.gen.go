// SQL queries use prepared statements with placeholders (, , ?) for safety
// Package groups provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package groups

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for GroupStatus.
const (
	GroupStatusActive    GroupStatus = "active"
	GroupStatusCompleted GroupStatus = "completed"
	GroupStatusDisbanded GroupStatus = "disbanded"
)

// Defines values for GroupMemberRole.
const (
	Leader GroupMemberRole = "leader"
	Member GroupMemberRole = "member"
)

// Defines values for GroupTaskStatus.
const (
	GroupTaskStatusCompleted  GroupTaskStatus = "completed"
	GroupTaskStatusFailed     GroupTaskStatus = "failed"
	GroupTaskStatusInProgress GroupTaskStatus = "in_progress"
	GroupTaskStatusPending    GroupTaskStatus = "pending"
)

// Defines values for GroupTaskType.
const (
	Dungeon GroupTaskType = "dungeon"
	Order   GroupTaskType = "order"
	Quest   GroupTaskType = "quest"
	Raid    GroupTaskType = "raid"
)

// Defines values for SearchGroupsParamsStatus.
const (
	Active    SearchGroupsParamsStatus = "active"
	Completed SearchGroupsParamsStatus = "completed"
	Disbanded SearchGroupsParamsStatus = "disbanded"
)

// AddGroupMemberRequest defines model for AddGroupMemberRequest.
type AddGroupMemberRequest struct {
	// CharacterId ID персонажа для добавления в группу
	CharacterId openapi_types.UUID `json:"character_id"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	// Description Описание группы
	Description *string `json:"description,omitempty"`

	// MaxMembers Максимальное количество участников
	MaxMembers *int `json:"max_members,omitempty"`

	// Name Название группы
	Name string `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// Group defines model for Group.
type Group struct {
	// CreatedAt Дата создания группы
	CreatedAt time.Time `json:"created_at"`

	// Description Описание группы
	Description *string `json:"description,omitempty"`

	// DisbandedAt Дата роспуска группы
	DisbandedAt *time.Time `json:"disbanded_at"`

	// Id ID группы
	Id openapi_types.UUID `json:"id"`

	// LeaderId ID лидера группы
	LeaderId openapi_types.UUID `json:"leader_id"`

	// MaxMembers Максимальное количество участников
	MaxMembers int `json:"max_members"`

	// MemberCount Текущее количество участников
	MemberCount *int `json:"member_count,omitempty"`

	// Name Название группы
	Name string `json:"name"`

	// Status Статус группы
	Status GroupStatus `json:"status"`

	// UpdatedAt Дата обновления группы
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupStatus Статус группы
type GroupStatus string

// GroupMember defines model for GroupMember.
type GroupMember struct {
	// CharacterId ID персонажа
	CharacterId openapi_types.UUID `json:"character_id"`

	// CharacterName Имя персонажа
	CharacterName *string `json:"character_name,omitempty"`

	// JoinedAt Дата присоединения к группе
	JoinedAt time.Time `json:"joined_at"`

	// Role Роль в группе
	Role GroupMemberRole `json:"role"`
}

// GroupMemberRole Роль в группе
type GroupMemberRole string

// GroupTask defines model for GroupTask.
type GroupTask struct {
	// Description Описание задания
	Description *string `json:"description,omitempty"`

	// Id ID задания
	Id openapi_types.UUID `json:"id"`

	// Status Статус задания
	Status GroupTaskStatus `json:"status"`

	// Title Название задания
	Title *string `json:"title,omitempty"`

	// Type Тип задания
	Type GroupTaskType `json:"type"`
}

// GroupTaskStatus Статус задания
type GroupTaskStatus string

// GroupTaskType Тип задания
type GroupTaskType string

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Status Статус операции
	Status *string `json:"status,omitempty"`
}

// UpdateGroupRequest defines model for UpdateGroupRequest.
type UpdateGroupRequest struct {
	// Description Описание группы
	Description *string `json:"description,omitempty"`

	// Name Название группы
	Name *string `json:"name,omitempty"`
}

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// SearchGroupsParams defines parameters for SearchGroups.
type SearchGroupsParams struct {
	// Status Фильтр по статусу группы
	Status *SearchGroupsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// LeaderId Фильтр по лидеру группы
	LeaderId *openapi_types.UUID `form:"leader_id,omitempty" json:"leader_id,omitempty"`

	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchGroupsParamsStatus defines parameters for SearchGroups.
type SearchGroupsParamsStatus string

// GetGroupTasksParams defines parameters for GetGroupTasks.
type GetGroupTasksParams struct {
	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = CreateGroupRequest

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody = UpdateGroupRequest

// AddGroupMemberJSONRequestBody defines body for AddGroupMember for application/json ContentType.
type AddGroupMemberJSONRequestBody = AddGroupMemberRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Поиск групп
	// (GET /social/groups)
	SearchGroups(w http.ResponseWriter, r *http.Request, params SearchGroupsParams)
	// Создать группу
	// (POST /social/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Распустить группу
	// (DELETE /social/groups/{group_id})
	DisbandGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID)
	// Получить информацию о группе
	// (GET /social/groups/{group_id})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID)
	// Обновить информацию о группе
	// (PUT /social/groups/{group_id})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID)
	// Получить список участников группы
	// (GET /social/groups/{group_id}/members)
	GetGroupMembers(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID)
	// Добавить участника в группу
	// (POST /social/groups/{group_id}/members)
	AddGroupMember(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID)
	// Удалить участника из группы
	// (DELETE /social/groups/{group_id}/members/{member_id})
	RemoveGroupMember(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID, memberId openapi_types.UUID)
	// Получить список заданий группы
	// (GET /social/groups/{group_id}/tasks)
	GetGroupTasks(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID, params GetGroupTasksParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Поиск групп
// (GET /social/groups)
func (_ Unimplemented) SearchGroups(w http.ResponseWriter, r *http.Request, params SearchGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создать группу
// (POST /social/groups)
func (_ Unimplemented) CreateGroup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Распустить группу
// (DELETE /social/groups/{group_id})
func (_ Unimplemented) DisbandGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить информацию о группе
// (GET /social/groups/{group_id})
func (_ Unimplemented) GetGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновить информацию о группе
// (PUT /social/groups/{group_id})
func (_ Unimplemented) UpdateGroup(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список участников группы
// (GET /social/groups/{group_id}/members)
func (_ Unimplemented) GetGroupMembers(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Добавить участника в группу
// (POST /social/groups/{group_id}/members)
func (_ Unimplemented) AddGroupMember(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удалить участника из группы
// (DELETE /social/groups/{group_id}/members/{member_id})
func (_ Unimplemented) RemoveGroupMember(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID, memberId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список заданий группы
// (GET /social/groups/{group_id}/tasks)
func (_ Unimplemented) GetGroupTasks(w http.ResponseWriter, r *http.Request, groupId openapi_types.UUID, params GetGroupTasksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// SearchGroups operation middleware
func (siw *ServerInterfaceWrapper) SearchGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchGroupsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "leader_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "leader_id", r.URL.Query(), &params.LeaderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "leader_id", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchGroups(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DisbandGroup operation middleware
func (siw *ServerInterfaceWrapper) DisbandGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DisbandGroup(w, r, groupId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) GetGroupMembers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupMembers(w, r, groupId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddGroupMember operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMember(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMember(w, r, groupId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RemoveGroupMember operation middleware
func (siw *ServerInterfaceWrapper) RemoveGroupMember(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	// ------------- Path parameter "member_id" -------------
	var memberId openapi_types.UUID

	rawMemberID, _ := getPathParam(r, "member_id")
	err = runtime.BindStyledParameterWithOptions("simple", "member_id", rawMemberID, &memberId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "member_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveGroupMember(w, r, groupId, memberId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGroupTasks operation middleware
func (siw *ServerInterfaceWrapper) GetGroupTasks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId openapi_types.UUID

	rawGroupID, _ := getPathParam(r, "group_id")
	err = runtime.BindStyledParameterWithOptions("simple", "group_id", rawGroupID, &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupTasksParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupTasks(w, r, groupId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ServerOptions{})
}

type ServerOptions struct {
	BaseURL          string
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

type pathParamKey string

func setPathParam(r *http.Request, name, value string) *http.Request {
	return r.WithContext(context.WithValue(r.Context(), pathParamKey(name), value))
}

func getPathParam(r *http.Request, name string) (string, bool) {
	val, ok := r.Context().Value(pathParamKey(name)).(string)
	return val, ok
}

// HandlerWithOptions creates http.Handler with additional options using stdlib ServeMux.
func HandlerWithOptions(si ServerInterface, options ServerOptions) http.Handler {
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	mux := http.NewServeMux()
	base := options.BaseURL

	mux.Handle(base+"/social/groups", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			wrapper.SearchGroups(w, r)
		case http.MethodPost:
			wrapper.CreateGroup(w, r)
		default:
			http.NotFound(w, r)
			return
		}
	}))

	// /social/groups/{group_id}
	mux.Handle(base+"/social/groups/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !strings.HasPrefix(r.URL.Path, base+"/social/groups/") {
			http.NotFound(w, r)
			return
		}
		path := strings.TrimPrefix(r.URL.Path, base+"/social/groups/")
		if path == "" {
			http.NotFound(w, r)
			return
		}
		segments := strings.Split(path, "/")
		groupID := segments[0]
		r = setPathParam(r, "group_id", groupID)

		// /social/groups/{group_id}
		if len(segments) == 1 {
			switch r.Method {
			case http.MethodGet:
				wrapper.GetGroup(w, r)
			case http.MethodPut:
				wrapper.UpdateGroup(w, r)
			case http.MethodDelete:
				wrapper.DisbandGroup(w, r)
			default:
				http.NotFound(w, r)
			}
			return
		}

		// /social/groups/{group_id}/members
		if len(segments) >= 2 && segments[1] == "members" {
			if len(segments) == 2 {
				switch r.Method {
				case http.MethodGet:
					wrapper.GetGroupMembers(w, r)
				case http.MethodPost:
					wrapper.AddGroupMember(w, r)
				default:
					http.NotFound(w, r)
				}
				return
			}
			if len(segments) == 3 {
				r = setPathParam(r, "member_id", segments[2])
				if r.Method == http.MethodDelete {
					wrapper.RemoveGroupMember(w, r)
					return
				}
			}
			http.NotFound(w, r)
			return
		}

		// /social/groups/{group_id}/tasks
		if len(segments) == 2 && segments[1] == "tasks" {
			if r.Method == http.MethodGet {
				wrapper.GetGroupTasks(w, r)
				return
			}
			http.NotFound(w, r)
			return
		}

		http.NotFound(w, r)
	}))

	return mux
}

