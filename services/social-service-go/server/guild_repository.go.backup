package server

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/necpgame/social-service-go/models"
	"github.com/sirupsen/logrus"
)

type GuildRepository struct {
	db     *pgxpool.Pool
	logger *logrus.Logger
}

func NewGuildRepository(db *pgxpool.Pool) *GuildRepository {
	return &GuildRepository{
		db:     db,
		logger: GetLogger(),
	}
}

func (r *GuildRepository) Create(ctx context.Context, guild *models.Guild) error {
	query := `
		INSERT INTO social.guilds (
			id, name, tag, leader_id, level, experience, max_members,
			description, status, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
		)`

	_, err := r.db.Exec(ctx, query,
		guild.ID, guild.Name, guild.Tag, guild.LeaderID, guild.Level,
		guild.Experience, guild.MaxMembers, guild.Description, guild.Status,
		guild.CreatedAt, guild.UpdatedAt,
	)

	return err
}

func (r *GuildRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Guild, error) {
	var guild models.Guild

	query := `
		SELECT id, name, tag, leader_id, level, experience, max_members,
			description, status, created_at, updated_at
		FROM social.guilds
		WHERE id = $1 AND status != 'disbanded'`

	err := r.db.QueryRow(ctx, query, id).Scan(
		&guild.ID, &guild.Name, &guild.Tag, &guild.LeaderID, &guild.Level,
		&guild.Experience, &guild.MaxMembers, &guild.Description, &guild.Status,
		&guild.CreatedAt, &guild.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &guild, nil
}

func (r *GuildRepository) GetByName(ctx context.Context, name string) (*models.Guild, error) {
	var guild models.Guild

	query := `
		SELECT id, name, tag, leader_id, level, experience, max_members,
			description, status, created_at, updated_at
		FROM social.guilds
		WHERE name = $1 AND status != 'disbanded'`

	err := r.db.QueryRow(ctx, query, name).Scan(
		&guild.ID, &guild.Name, &guild.Tag, &guild.LeaderID, &guild.Level,
		&guild.Experience, &guild.MaxMembers, &guild.Description, &guild.Status,
		&guild.CreatedAt, &guild.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &guild, nil
}

func (r *GuildRepository) GetByTag(ctx context.Context, tag string) (*models.Guild, error) {
	var guild models.Guild

	query := `
		SELECT id, name, tag, leader_id, level, experience, max_members,
			description, status, created_at, updated_at
		FROM social.guilds
		WHERE tag = $1 AND status != 'disbanded'`

	err := r.db.QueryRow(ctx, query, tag).Scan(
		&guild.ID, &guild.Name, &guild.Tag, &guild.LeaderID, &guild.Level,
		&guild.Experience, &guild.MaxMembers, &guild.Description, &guild.Status,
		&guild.CreatedAt, &guild.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &guild, nil
}

func (r *GuildRepository) List(ctx context.Context, limit, offset int) ([]models.Guild, error) {
	query := `
		SELECT id, name, tag, leader_id, level, experience, max_members,
			description, status, created_at, updated_at
		FROM social.guilds
		WHERE status = 'active'
		ORDER BY level DESC, experience DESC
		LIMIT $1 OFFSET $2`

	rows, err := r.db.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var guilds []models.Guild
	for rows.Next() {
		var guild models.Guild
		err := rows.Scan(
			&guild.ID, &guild.Name, &guild.Tag, &guild.LeaderID, &guild.Level,
			&guild.Experience, &guild.MaxMembers, &guild.Description, &guild.Status,
			&guild.CreatedAt, &guild.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		guilds = append(guilds, guild)
	}

	return guilds, nil
}

func (r *GuildRepository) Count(ctx context.Context) (int, error) {
	var count int
	query := `SELECT COUNT(*) FROM social.guilds WHERE status = 'active'`
	err := r.db.QueryRow(ctx, query).Scan(&count)
	return count, err
}

func (r *GuildRepository) Update(ctx context.Context, guild *models.Guild) error {
	query := `
		UPDATE social.guilds
		SET name = $1, description = $2, updated_at = $3
		WHERE id = $4`

	_, err := r.db.Exec(ctx, query, guild.Name, guild.Description, guild.UpdatedAt, guild.ID)
	return err
}

func (r *GuildRepository) UpdateLevel(ctx context.Context, guildID uuid.UUID, level, experience int) error {
	query := `
		UPDATE social.guilds
		SET level = $1, experience = $2, updated_at = $3
		WHERE id = $4`

	_, err := r.db.Exec(ctx, query, level, experience, time.Now(), guildID)
	return err
}

func (r *GuildRepository) Disband(ctx context.Context, guildID uuid.UUID) error {
	query := `
		UPDATE social.guilds
		SET status = 'disbanded', updated_at = $1
		WHERE id = $2`

	_, err := r.db.Exec(ctx, query, time.Now(), guildID)
	return err
}

func (r *GuildRepository) AddMember(ctx context.Context, member *models.GuildMember) error {
	query := `
		INSERT INTO social.guild_members (
			id, guild_id, character_id, rank, status, contribution,
			joined_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
		)`

	_, err := r.db.Exec(ctx, query,
		member.ID, member.GuildID, member.CharacterID, member.Rank,
		member.Status, member.Contribution, member.JoinedAt, member.UpdatedAt,
	)

	return err
}

func (r *GuildRepository) GetMember(ctx context.Context, guildID, characterID uuid.UUID) (*models.GuildMember, error) {
	var member models.GuildMember

	query := `
		SELECT id, guild_id, character_id, rank, status, contribution,
			joined_at, updated_at
		FROM social.guild_members
		WHERE guild_id = $1 AND character_id = $2 AND status = 'active'`

	err := r.db.QueryRow(ctx, query, guildID, characterID).Scan(
		&member.ID, &member.GuildID, &member.CharacterID, &member.Rank,
		&member.Status, &member.Contribution, &member.JoinedAt, &member.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &member, nil
}

func (r *GuildRepository) GetMembers(ctx context.Context, guildID uuid.UUID, limit, offset int) ([]models.GuildMember, error) {
	query := `
		SELECT id, guild_id, character_id, rank, status, contribution,
			joined_at, updated_at
		FROM social.guild_members
		WHERE guild_id = $1 AND status = 'active'
		ORDER BY 
			CASE rank
				WHEN 'leader' THEN 1
				WHEN 'officer' THEN 2
				WHEN 'member' THEN 3
				WHEN 'recruit' THEN 4
			END,
			joined_at ASC
		LIMIT $2 OFFSET $3`

	rows, err := r.db.Query(ctx, query, guildID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var members []models.GuildMember
	for rows.Next() {
		var member models.GuildMember
		err := rows.Scan(
			&member.ID, &member.GuildID, &member.CharacterID, &member.Rank,
			&member.Status, &member.Contribution, &member.JoinedAt, &member.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		members = append(members, member)
	}

	return members, nil
}

func (r *GuildRepository) CountMembers(ctx context.Context, guildID uuid.UUID) (int, error) {
	var count int
	query := `SELECT COUNT(*) FROM social.guild_members WHERE guild_id = $1 AND status = 'active'`
	err := r.db.QueryRow(ctx, query, guildID).Scan(&count)
	return count, err
}

func (r *GuildRepository) UpdateMemberRank(ctx context.Context, guildID, characterID uuid.UUID, rank models.GuildRank) error {
	query := `
		UPDATE social.guild_members
		SET rank = $1, updated_at = $2
		WHERE guild_id = $3 AND character_id = $4 AND status = 'active'`

	_, err := r.db.Exec(ctx, query, rank, time.Now(), guildID, characterID)
	return err
}

func (r *GuildRepository) RemoveMember(ctx context.Context, guildID, characterID uuid.UUID) error {
	query := `
		UPDATE social.guild_members
		SET status = 'left', updated_at = $1
		WHERE guild_id = $2 AND character_id = $3`

	_, err := r.db.Exec(ctx, query, time.Now(), guildID, characterID)
	return err
}

func (r *GuildRepository) KickMember(ctx context.Context, guildID, characterID uuid.UUID) error {
	query := `
		UPDATE social.guild_members
		SET status = 'kicked', updated_at = $1
		WHERE guild_id = $2 AND character_id = $3`

	_, err := r.db.Exec(ctx, query, time.Now(), guildID, characterID)
	return err
}

func (r *GuildRepository) UpdateMemberContribution(ctx context.Context, guildID, characterID uuid.UUID, contribution int) error {
	query := `
		UPDATE social.guild_members
		SET contribution = contribution + $1, updated_at = $2
		WHERE guild_id = $3 AND character_id = $4 AND status = 'active'`

	_, err := r.db.Exec(ctx, query, contribution, time.Now(), guildID, characterID)
	return err
}

func (r *GuildRepository) CreateInvitation(ctx context.Context, invitation *models.GuildInvitation) error {
	query := `
		INSERT INTO social.guild_invitations (
			id, guild_id, character_id, invited_by, message, status,
			created_at, expires_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
		)`

	_, err := r.db.Exec(ctx, query,
		invitation.ID, invitation.GuildID, invitation.CharacterID,
		invitation.InvitedBy, invitation.Message, invitation.Status,
		invitation.CreatedAt, invitation.ExpiresAt,
	)

	return err
}

func (r *GuildRepository) GetInvitation(ctx context.Context, id uuid.UUID) (*models.GuildInvitation, error) {
	var invitation models.GuildInvitation

	query := `
		SELECT id, guild_id, character_id, invited_by, message, status,
			created_at, expires_at
		FROM social.guild_invitations
		WHERE id = $1 AND status = 'pending' AND expires_at > NOW()`

	err := r.db.QueryRow(ctx, query, id).Scan(
		&invitation.ID, &invitation.GuildID, &invitation.CharacterID,
		&invitation.InvitedBy, &invitation.Message, &invitation.Status,
		&invitation.CreatedAt, &invitation.ExpiresAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &invitation, nil
}

func (r *GuildRepository) GetInvitationsByCharacter(ctx context.Context, characterID uuid.UUID) ([]models.GuildInvitation, error) {
	query := `
		SELECT id, guild_id, character_id, invited_by, message, status,
			created_at, expires_at
		FROM social.guild_invitations
		WHERE character_id = $1 AND status = 'pending' AND expires_at > NOW()
		ORDER BY created_at DESC`

	rows, err := r.db.Query(ctx, query, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var invitations []models.GuildInvitation
	for rows.Next() {
		var invitation models.GuildInvitation
		err := rows.Scan(
			&invitation.ID, &invitation.GuildID, &invitation.CharacterID,
			&invitation.InvitedBy, &invitation.Message, &invitation.Status,
			&invitation.CreatedAt, &invitation.ExpiresAt,
		)
		if err != nil {
			return nil, err
		}
		invitations = append(invitations, invitation)
	}

	return invitations, nil
}

func (r *GuildRepository) AcceptInvitation(ctx context.Context, invitationID uuid.UUID) error {
	query := `
		UPDATE social.guild_invitations
		SET status = 'accepted'
		WHERE id = $1`

	_, err := r.db.Exec(ctx, query, invitationID)
	return err
}

func (r *GuildRepository) RejectInvitation(ctx context.Context, invitationID uuid.UUID) error {
	query := `
		UPDATE social.guild_invitations
		SET status = 'rejected'
		WHERE id = $1`

	_, err := r.db.Exec(ctx, query, invitationID)
	return err
}

func (r *GuildRepository) GetBank(ctx context.Context, guildID uuid.UUID) (*models.GuildBank, error) {
	var bank models.GuildBank
	var currencyJSON []byte
	var itemsJSON []byte

	query := `
		SELECT id, guild_id, currency, items, updated_at
		FROM social.guild_banks
		WHERE guild_id = $1`

	err := r.db.QueryRow(ctx, query, guildID).Scan(
		&bank.ID, &bank.GuildID, &currencyJSON, &itemsJSON, &bank.UpdatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if len(currencyJSON) > 0 {
		json.Unmarshal(currencyJSON, &bank.Currency)
	}
	if len(itemsJSON) > 0 {
		json.Unmarshal(itemsJSON, &bank.Items)
	}

	return &bank, nil
}

func (r *GuildRepository) CreateBank(ctx context.Context, bank *models.GuildBank) error {
	currencyJSON, _ := json.Marshal(bank.Currency)
	itemsJSON, _ := json.Marshal(bank.Items)

	query := `
		INSERT INTO social.guild_banks (
			id, guild_id, currency, items, updated_at
		) VALUES (
			$1, $2, $3, $4, $5
		)`

	_, err := r.db.Exec(ctx, query,
		bank.ID, bank.GuildID, currencyJSON, itemsJSON, bank.UpdatedAt,
	)

	return err
}

func (r *GuildRepository) UpdateBank(ctx context.Context, bank *models.GuildBank) error {
	currencyJSON, _ := json.Marshal(bank.Currency)
	itemsJSON, _ := json.Marshal(bank.Items)

	query := `
		UPDATE social.guild_banks
		SET currency = $1, items = $2, updated_at = $3
		WHERE guild_id = $4`

	_, err := r.db.Exec(ctx, query, currencyJSON, itemsJSON, time.Now(), bank.GuildID)
	return err
}

func (r *GuildRepository) GetRanks(ctx context.Context, guildID uuid.UUID) ([]models.GuildRankEntity, error) {
	query := `
		SELECT id, guild_id, name, permissions, "order", created_at
		FROM social.guild_ranks
		WHERE guild_id = $1
		ORDER BY "order" ASC`

	rows, err := r.db.Query(ctx, query, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var ranks []models.GuildRankEntity
	for rows.Next() {
		var rank models.GuildRankEntity
		var permissionsJSON []byte

		err := rows.Scan(
			&rank.ID, &rank.GuildID, &rank.Name, &permissionsJSON, &rank.Order, &rank.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		if len(permissionsJSON) > 0 {
			json.Unmarshal(permissionsJSON, &rank.Permissions)
		}

		ranks = append(ranks, rank)
	}

	return ranks, rows.Err()
}

func (r *GuildRepository) GetRankByID(ctx context.Context, rankID uuid.UUID) (*models.GuildRankEntity, error) {
	var rank models.GuildRankEntity
	var permissionsJSON []byte

	query := `
		SELECT id, guild_id, name, permissions, "order", created_at
		FROM social.guild_ranks
		WHERE id = $1`

	err := r.db.QueryRow(ctx, query, rankID).Scan(
		&rank.ID, &rank.GuildID, &rank.Name, &permissionsJSON, &rank.Order, &rank.CreatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if len(permissionsJSON) > 0 {
		json.Unmarshal(permissionsJSON, &rank.Permissions)
	}

	return &rank, nil
}

func (r *GuildRepository) CreateRank(ctx context.Context, rank *models.GuildRankEntity) error {
	permissionsJSON, _ := json.Marshal(rank.Permissions)

	query := `
		INSERT INTO social.guild_ranks (
			id, guild_id, name, permissions, "order", created_at
		) VALUES (
			$1, $2, $3, $4, $5, $6
		)`

	_, err := r.db.Exec(ctx, query,
		rank.ID, rank.GuildID, rank.Name, permissionsJSON, rank.Order, rank.CreatedAt,
	)

	return err
}

func (r *GuildRepository) UpdateRank(ctx context.Context, rank *models.GuildRankEntity) error {
	permissionsJSON, _ := json.Marshal(rank.Permissions)

	query := `
		UPDATE social.guild_ranks
		SET name = $1, permissions = $2, "order" = $3
		WHERE id = $4 AND guild_id = $5`

	_, err := r.db.Exec(ctx, query,
		rank.Name, permissionsJSON, rank.Order, rank.ID, rank.GuildID,
	)

	return err
}

func (r *GuildRepository) DeleteRank(ctx context.Context, guildID, rankID uuid.UUID) error {
	query := `
		DELETE FROM social.guild_ranks
		WHERE id = $1 AND guild_id = $2`

	_, err := r.db.Exec(ctx, query, rankID, guildID)
	return err
}

func (r *GuildRepository) CreateBankTransaction(ctx context.Context, transaction *models.GuildBankTransaction) error {
	itemsJSON, _ := json.Marshal(transaction.Items)

	query := `
		INSERT INTO social.guild_bank_transactions (
			id, guild_id, account_id, type, currency, items, created_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7
		)`

	_, err := r.db.Exec(ctx, query,
		transaction.ID, transaction.GuildID, transaction.AccountID,
		transaction.Type, transaction.Currency, itemsJSON, transaction.CreatedAt,
	)

	return err
}

func (r *GuildRepository) GetBankTransactions(ctx context.Context, guildID uuid.UUID, limit, offset int) ([]models.GuildBankTransaction, error) {
	query := `
		SELECT id, guild_id, account_id, type, currency, items, created_at
		FROM social.guild_bank_transactions
		WHERE guild_id = $1
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := r.db.Query(ctx, query, guildID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var transactions []models.GuildBankTransaction
	for rows.Next() {
		var transaction models.GuildBankTransaction
		var itemsJSON []byte

		err := rows.Scan(
			&transaction.ID, &transaction.GuildID, &transaction.AccountID,
			&transaction.Type, &transaction.Currency, &itemsJSON, &transaction.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		if len(itemsJSON) > 0 {
			json.Unmarshal(itemsJSON, &transaction.Items)
		}

		transactions = append(transactions, transaction)
	}

	return transactions, rows.Err()
}

func (r *GuildRepository) CountBankTransactions(ctx context.Context, guildID uuid.UUID) (int, error) {
	var count int
	query := `SELECT COUNT(*) FROM social.guild_bank_transactions WHERE guild_id = $1`

	err := r.db.QueryRow(ctx, query, guildID).Scan(&count)
	return count, err
}

