// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for StockIndexType.
const (
	StockIndexTypeGlobal   StockIndexType = "global"
	StockIndexTypeRegional StockIndexType = "regional"
	StockIndexTypeSector   StockIndexType = "sector"
)

// Defines values for StockIndexDetailedCalculationMethod.
const (
	EqualWeighted     StockIndexDetailedCalculationMethod = "equal_weighted"
	MarketCapWeighted StockIndexDetailedCalculationMethod = "market_cap_weighted"
	PriceWeighted     StockIndexDetailedCalculationMethod = "price_weighted"
)

// Defines values for StockIndexDetailedRebalanceFrequency.
const (
	Annual     StockIndexDetailedRebalanceFrequency = "annual"
	EventBased StockIndexDetailedRebalanceFrequency = "event_based"
	Monthly    StockIndexDetailedRebalanceFrequency = "monthly"
	Quarterly  StockIndexDetailedRebalanceFrequency = "quarterly"
	SemiAnnual StockIndexDetailedRebalanceFrequency = "semi_annual"
)

// Defines values for StockIndexDetailedType.
const (
	StockIndexDetailedTypeGlobal   StockIndexDetailedType = "global"
	StockIndexDetailedTypeRegional StockIndexDetailedType = "regional"
	StockIndexDetailedTypeSector   StockIndexDetailedType = "sector"
)

// Defines values for GetAllIndicesParamsType.
const (
	Global   GetAllIndicesParamsType = "global"
	Regional GetAllIndicesParamsType = "regional"
	Sector   GetAllIndicesParamsType = "sector"
)

// Defines values for GetIndexConstituentsParamsSortBy.
const (
	MarketCap   GetIndexConstituentsParamsSortBy = "market_cap"
	PriceChange GetIndexConstituentsParamsSortBy = "price_change"
	Weight      GetIndexConstituentsParamsSortBy = "weight"
)

// Defines values for GetIndexConstituentsParamsOrder.
const (
	Asc  GetIndexConstituentsParamsOrder = "asc"
	Desc GetIndexConstituentsParamsOrder = "desc"
)

// Defines values for GetIndexHistoryParamsInterval.
const (
	N15m GetIndexHistoryParamsInterval = "15m"
	N1d  GetIndexHistoryParamsInterval = "1d"
	N1h  GetIndexHistoryParamsInterval = "1h"
	N1m  GetIndexHistoryParamsInterval = "1m"
	N1w  GetIndexHistoryParamsInterval = "1w"
	N4h  GetIndexHistoryParamsInterval = "4h"
	N5m  GetIndexHistoryParamsInterval = "5m"
)

// Error defines model for Error.
type Error struct {
	// Code Код ошибки
	Code *string `json:"code"`

	// Details Дополнительные детали ошибки
	Details *map[string]interface{} `json:"details"`

	// Error Тип ошибки
	Error string `json:"error"`

	// Message Сообщение об ошибке
	Message string `json:"message"`
}

// IndexConstituent Акция в составе индекса
type IndexConstituent struct {
	// MarketCap Рыночная капитализация
	MarketCap float64 `json:"market_cap"`

	// Price Текущая цена акции
	Price float64 `json:"price"`

	// PriceChange24h Изменение цены за 24ч (абсолютное)
	PriceChange24h *float64 `json:"price_change_24h,omitempty"`

	// PriceChange24hPercent Изменение цены за 24ч (%)
	PriceChange24hPercent *float64 `json:"price_change_24h_percent,omitempty"`

	// SharesInIndex Количество акций в индексе
	SharesInIndex *int `json:"shares_in_index,omitempty"`

	// StockId ID акции
	StockId openapi_types.UUID `json:"stock_id"`

	// StockName Название корпорации
	StockName string `json:"stock_name"`

	// StockSymbol Тикер акции
	StockSymbol string `json:"stock_symbol"`

	// Weight Вес в индексе (%)
	Weight float64 `json:"weight"`
}

// IndexHistoryEntry Запись истории индекса
type IndexHistoryEntry struct {
	// Change Изменение с предыдущего периода (абсолютное)
	Change float64 `json:"change"`

	// ChangePercent Изменение с предыдущего периода (%)
	ChangePercent float64 `json:"change_percent"`

	// Timestamp Время записи
	Timestamp time.Time `json:"timestamp"`

	// Value Значение индекса
	Value float64 `json:"value"`

	// Volume Объем торгов акций в индексе
	Volume *float64 `json:"volume,omitempty"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// HasMore Есть ли еще элементы
	HasMore *bool `json:"has_more,omitempty"`

	// Items Список элементов
	Items []interface{} `json:"items"`

	// Limit Количество элементов на странице
	Limit *int `json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *int `json:"offset,omitempty"`

	// Total Общее количество элементов
	Total int `json:"total"`
}

// RebalanceResult Результат ребаланса индекса
type RebalanceResult struct {
	// AddedStocks Добавленные акции
	AddedStocks *[]struct {
		StockSymbol *string  `json:"stock_symbol,omitempty"`
		Weight      *float64 `json:"weight,omitempty"`
	} `json:"added_stocks,omitempty"`

	// DivisorAdjustment Корректировка divisor для непрерывности
	DivisorAdjustment *float64 `json:"divisor_adjustment,omitempty"`

	// EffectiveDate Дата вступления в силу
	EffectiveDate *time.Time `json:"effective_date,omitempty"`

	// ExecutedAt Время выполнения
	ExecutedAt *time.Time `json:"executed_at,omitempty"`

	// IndexCode Код индекса
	IndexCode *string `json:"index_code,omitempty"`

	// NewValue Значение после ребаланса
	NewValue *float64 `json:"new_value,omitempty"`

	// PreviousValue Значение до ребаланса
	PreviousValue *float64 `json:"previous_value,omitempty"`

	// RemovedStocks Удаленные акции
	RemovedStocks *[]struct {
		StockSymbol *string  `json:"stock_symbol,omitempty"`
		Weight      *float64 `json:"weight,omitempty"`
	} `json:"removed_stocks,omitempty"`

	// TotalChanges Общее количество изменений
	TotalChanges *int `json:"total_changes,omitempty"`

	// WeightChanges Изменения весов существующих акций
	WeightChanges *[]struct {
		Change      *float64 `json:"change,omitempty"`
		NewWeight   *float64 `json:"new_weight,omitempty"`
		OldWeight   *float64 `json:"old_weight,omitempty"`
		StockSymbol *string  `json:"stock_symbol,omitempty"`
	} `json:"weight_changes,omitempty"`
}

// StockIndex Фондовый индекс (краткая информация)
type StockIndex struct {
	// Change24h Изменение за 24 часа (абсолютное)
	Change24h float64 `json:"change_24h"`

	// Change24hPercent Изменение за 24 часа (%)
	Change24hPercent float64 `json:"change_24h_percent"`

	// Code Код индекса (CORP100, NC50, TECH, etc.)
	Code string `json:"code"`

	// ConstituentsCount Количество акций в индексе
	ConstituentsCount int `json:"constituents_count"`

	// CurrentValue Текущее значение индекса
	CurrentValue float64 `json:"current_value"`

	// Description Описание индекса
	Description *string `json:"description,omitempty"`

	// LastRebalance Дата последнего ребаланса
	LastRebalance *time.Time `json:"last_rebalance,omitempty"`

	// MarketCapTotal Общая капитализация акций в индексе
	MarketCapTotal *float64 `json:"market_cap_total,omitempty"`

	// Name Название индекса
	Name string `json:"name"`

	// Type Тип индекса:
	// - global: Глобальный (CORP100)
	// - regional: Региональный (NC50, ASIA25, EURO30)
	// - sector: Секторный (TECH, DEFENSE, ENERGY, MEDICAL, CYBER)
	Type StockIndexType `json:"type"`

	// UpdatedAt Время последнего обновления
	UpdatedAt time.Time `json:"updated_at"`
}

// StockIndexType Тип индекса:
// - global: Глобальный (CORP100)
// - regional: Региональный (NC50, ASIA25, EURO30)
// - sector: Секторный (TECH, DEFENSE, ENERGY, MEDICAL, CYBER)
type StockIndexType string

// StockIndexDetailed defines model for StockIndexDetailed.
type StockIndexDetailed struct {
	// AllTimeHigh Максимальное значение за все время
	AllTimeHigh *float64 `json:"all_time_high,omitempty"`

	// AllTimeLow Минимальное значение за все время
	AllTimeLow *float64 `json:"all_time_low,omitempty"`

	// BaseDate Базовая дата индекса
	BaseDate time.Time `json:"base_date"`

	// BaseValue Базовое значение индекса
	BaseValue float64 `json:"base_value"`

	// CalculationMethod Метод расчета:
	// - market_cap_weighted: По капитализации
	// - price_weighted: По цене (deprecated)
	// - equal_weighted: Равновзвешенный
	CalculationMethod StockIndexDetailedCalculationMethod `json:"calculation_method"`

	// Change24h Изменение за 24 часа (абсолютное)
	Change24h float64 `json:"change_24h"`

	// Change24hPercent Изменение за 24 часа (%)
	Change24hPercent float64 `json:"change_24h_percent"`

	// Change30dPercent Изменение за 30 дней (%)
	Change30dPercent *float64 `json:"change_30d_percent,omitempty"`

	// Change7dPercent Изменение за 7 дней (%)
	Change7dPercent *float64 `json:"change_7d_percent,omitempty"`

	// Code Код индекса (CORP100, NC50, TECH, etc.)
	Code string `json:"code"`

	// ConstituentsCount Количество акций в индексе
	ConstituentsCount int        `json:"constituents_count"`
	CreatedAt         *time.Time `json:"created_at,omitempty"`

	// CurrentValue Текущее значение индекса
	CurrentValue float64 `json:"current_value"`

	// Description Описание индекса
	Description *string `json:"description,omitempty"`

	// LastRebalance Дата последнего ребаланса
	LastRebalance *time.Time `json:"last_rebalance,omitempty"`

	// MarketCapTotal Общая капитализация акций в индексе
	MarketCapTotal *float64 `json:"market_cap_total,omitempty"`

	// Name Название индекса
	Name string `json:"name"`

	// NextRebalance Дата следующего ребаланса
	NextRebalance *time.Time `json:"next_rebalance,omitempty"`

	// RebalanceFrequency Частота ребаланса
	RebalanceFrequency StockIndexDetailedRebalanceFrequency `json:"rebalance_frequency"`

	// Type Тип индекса:
	// - global: Глобальный (CORP100)
	// - regional: Региональный (NC50, ASIA25, EURO30)
	// - sector: Секторный (TECH, DEFENSE, ENERGY, MEDICAL, CYBER)
	Type StockIndexDetailedType `json:"type"`

	// UpdatedAt Время последнего обновления
	UpdatedAt time.Time `json:"updated_at"`
}

// StockIndexDetailedCalculationMethod Метод расчета:
// - market_cap_weighted: По капитализации
// - price_weighted: По цене (deprecated)
// - equal_weighted: Равновзвешенный
type StockIndexDetailedCalculationMethod string

// StockIndexDetailedRebalanceFrequency Частота ребаланса
type StockIndexDetailedRebalanceFrequency string

// StockIndexDetailedType Тип индекса:
// - global: Глобальный (CORP100)
// - regional: Региональный (NC50, ASIA25, EURO30)
// - sector: Секторный (TECH, DEFENSE, ENERGY, MEDICAL, CYBER)
type StockIndexDetailedType string

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// RebalanceIndexJSONBody defines parameters for RebalanceIndex.
type RebalanceIndexJSONBody struct {
	// EffectiveDate Дата вступления в силу (опционально, default = now)
	EffectiveDate *time.Time `json:"effective_date,omitempty"`

	// MaxWeight Максимальный вес акции (%)
	MaxWeight *float64 `json:"max_weight,omitempty"`

	// Reason Причина ребаланса
	Reason *string `json:"reason,omitempty"`
}

// GetAllIndicesParams defines parameters for GetAllIndices.
type GetAllIndicesParams struct {
	// Type Фильтр по типу индекса
	Type *GetAllIndicesParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetAllIndicesParamsType defines parameters for GetAllIndices.
type GetAllIndicesParamsType string

// GetIndexConstituentsParams defines parameters for GetIndexConstituents.
type GetIndexConstituentsParams struct {
	// SortBy Поле для сортировки
	SortBy *GetIndexConstituentsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Order Порядок сортировки
	Order *GetIndexConstituentsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetIndexConstituentsParamsSortBy defines parameters for GetIndexConstituents.
type GetIndexConstituentsParamsSortBy string

// GetIndexConstituentsParamsOrder defines parameters for GetIndexConstituents.
type GetIndexConstituentsParamsOrder string

// GetIndexHistoryParams defines parameters for GetIndexHistory.
type GetIndexHistoryParams struct {
	// FromDate Начало периода (ISO 8601)
	FromDate *time.Time `form:"from_date,omitempty" json:"from_date,omitempty"`

	// ToDate Конец периода (ISO 8601)
	ToDate *time.Time `form:"to_date,omitempty" json:"to_date,omitempty"`

	// Interval Интервал агрегации
	Interval *GetIndexHistoryParamsInterval `form:"interval,omitempty" json:"interval,omitempty"`

	// Limit Количество элементов на странице
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Смещение для пагинации
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetIndexHistoryParamsInterval defines parameters for GetIndexHistory.
type GetIndexHistoryParamsInterval string

// RebalanceIndexJSONRequestBody defines body for RebalanceIndex for application/json ContentType.
type RebalanceIndexJSONRequestBody RebalanceIndexJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Выполнить ребаланс индекса
	// (POST /admin/indices/{code}/rebalance)
	RebalanceIndex(w http.ResponseWriter, r *http.Request, code string)
	// Получить список всех индексов
	// (GET /stocks/indices)
	GetAllIndices(w http.ResponseWriter, r *http.Request, params GetAllIndicesParams)
	// Получить данные индекса
	// (GET /stocks/indices/{code})
	GetIndex(w http.ResponseWriter, r *http.Request, code string)
	// Получить состав индекса
	// (GET /stocks/indices/{code}/constituents)
	GetIndexConstituents(w http.ResponseWriter, r *http.Request, code string, params GetIndexConstituentsParams)
	// Получить историю значений индекса
	// (GET /stocks/indices/{code}/history)
	GetIndexHistory(w http.ResponseWriter, r *http.Request, code string, params GetIndexHistoryParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Выполнить ребаланс индекса
// (POST /admin/indices/{code}/rebalance)
func (_ Unimplemented) RebalanceIndex(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список всех индексов
// (GET /stocks/indices)
func (_ Unimplemented) GetAllIndices(w http.ResponseWriter, r *http.Request, params GetAllIndicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить данные индекса
// (GET /stocks/indices/{code})
func (_ Unimplemented) GetIndex(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить состав индекса
// (GET /stocks/indices/{code}/constituents)
func (_ Unimplemented) GetIndexConstituents(w http.ResponseWriter, r *http.Request, code string, params GetIndexConstituentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить историю значений индекса
// (GET /stocks/indices/{code}/history)
func (_ Unimplemented) GetIndexHistory(w http.ResponseWriter, r *http.Request, code string, params GetIndexHistoryParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// RebalanceIndex operation middleware
func (siw *ServerInterfaceWrapper) RebalanceIndex(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithOptions("simple", "code", chi.URLParam(r, "code"), &code, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RebalanceIndex(w, r, code)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAllIndices operation middleware
func (siw *ServerInterfaceWrapper) GetAllIndices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllIndicesParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllIndices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIndex operation middleware
func (siw *ServerInterfaceWrapper) GetIndex(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithOptions("simple", "code", chi.URLParam(r, "code"), &code, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIndex(w, r, code)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIndexConstituents operation middleware
func (siw *ServerInterfaceWrapper) GetIndexConstituents(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithOptions("simple", "code", chi.URLParam(r, "code"), &code, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIndexConstituentsParams

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_by", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIndexConstituents(w, r, code, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIndexHistory operation middleware
func (siw *ServerInterfaceWrapper) GetIndexHistory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithOptions("simple", "code", chi.URLParam(r, "code"), &code, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIndexHistoryParams

	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from_date", Err: err})
		return
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to_date", Err: err})
		return
	}

	// ------------- Optional query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, false, "interval", r.URL.Query(), &params.Interval)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "interval", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIndexHistory(w, r, code, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/admin/indices/{code}/rebalance", wrapper.RebalanceIndex)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/stocks/indices", wrapper.GetAllIndices)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/stocks/indices/{code}", wrapper.GetIndex)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/stocks/indices/{code}/constituents", wrapper.GetIndexConstituents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/stocks/indices/{code}/history", wrapper.GetIndexHistory)
	})

	return r
}
