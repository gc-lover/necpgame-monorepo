
// Code generated by ogen, DO NOT EDIT.

package necpgame/services/technology-progression-service-go


import (
	 "bytes"
	 "context"
	 "encoding/base64"
	 "fmt"
	 "github.com/go-faster/errors"
	 "github.com/go-faster/jx"
	 "github.com/google/uuid"
	 "github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	 "github.com/ogen-go/ogen/json"
	 "github.com/ogen-go/ogen/middleware"
	 "github.com/ogen-go/ogen/ogenerrors"
	 "github.com/ogen-go/ogen/ogenregex"
	 "github.com/ogen-go/ogen/otelogen"
	 "github.com/ogen-go/ogen/uri"
	 "github.com/ogen-go/ogen/validate"
	 "github.com/shopspring/decimal"
	 "go.opentelemetry.io/otel"
	 "go.opentelemetry.io/otel/attribute"
	 "go.opentelemetry.io/otel/codes"
	 "go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	 "go.opentelemetry.io/otel/trace"
	 "go.uber.org/multierr"
	 "io"
	 "math"
	 "math/big"
	 "math/bits"
	 "mime"
	 "mime/multipart"
	 "net"
	 "net/http"
	 "net/netip"
	 "net/url"
	 "regexp"
	 "sort"
	 "strconv"
	 "strings"
	 "sync"
	 "time"
	
)



func decodeBatchHealthCheckResponse(resp *http.Response) (res *BatchHealthCheckOK, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response BatchHealthCheckOK
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &response, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}


func decodeCheckTechnologyAvailabilityResponse(resp *http.Response) (res *TechnologyAvailabilityResponse, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response TechnologyAvailabilityResponse
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &response, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}


func decodeGetAvailableTechnologiesResponse(resp *http.Response) (res *TechnologyListResponseHeaders, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response TechnologyListResponse
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			var wrapper TechnologyListResponseHeaders
			wrapper.Response = response
h := uri.NewHeaderDecoder(resp.Header)
// Parse "Cache-Control" header.
{
	cfg := uri.HeaderParameterDecodingConfig{
		Name:    "Cache-Control",
		Explode: false,
	}
	if err := func() error {
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
	var wrapperDotCacheControlVal string
	if err := func() error {
	val, err := d.DecodeValue()
	if err != nil {
		return err
	}

	c, err := conv.ToString(val)
	if err != nil {
		return err
	}

	wrapperDotCacheControlVal = c
	return nil
	}(); err != nil {
		return err
	}
	wrapper.CacheControl.SetTo(wrapperDotCacheControlVal)
	return nil
			}); err != nil {
				return err
			}
		} 
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "parse Cache-Control header")
	}
}
// Parse "ETag" header.
{
	cfg := uri.HeaderParameterDecodingConfig{
		Name:    "ETag",
		Explode: false,
	}
	if err := func() error {
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
	var wrapperDotETagVal string
	if err := func() error {
	val, err := d.DecodeValue()
	if err != nil {
		return err
	}

	c, err := conv.ToString(val)
	if err != nil {
		return err
	}

	wrapperDotETagVal = c
	return nil
	}(); err != nil {
		return err
	}
	wrapper.ETag.SetTo(wrapperDotETagVal)
	return nil
			}); err != nil {
				return err
			}
		} 
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "parse ETag header")
	}
}
			return &wrapper, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}


func decodeGetTechnologyNotificationsResponse(resp *http.Response) (res *TechnologyNotificationsResponse, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response TechnologyNotificationsResponse
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &response, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}


func decodeGetTechnologyTimelineResponse(resp *http.Response) (res *TechnologyTimelineResponse, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response TechnologyTimelineResponse
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &response, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}


func decodeTechnologyProgressionHealthCheckResponse(resp *http.Response) (res *HealthResponseHeaders, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response HealthResponse
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			var wrapper HealthResponseHeaders
			wrapper.Response = response
h := uri.NewHeaderDecoder(resp.Header)
// Parse "Cache-Control" header.
{
	cfg := uri.HeaderParameterDecodingConfig{
		Name:    "Cache-Control",
		Explode: false,
	}
	if err := func() error {
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
	var wrapperDotCacheControlVal string
	if err := func() error {
	val, err := d.DecodeValue()
	if err != nil {
		return err
	}

	c, err := conv.ToString(val)
	if err != nil {
		return err
	}

	wrapperDotCacheControlVal = c
	return nil
	}(); err != nil {
		return err
	}
	wrapper.CacheControl.SetTo(wrapperDotCacheControlVal)
	return nil
			}); err != nil {
				return err
			}
		} 
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "parse Cache-Control header")
	}
}
// Parse "Content-Encoding" header.
{
	cfg := uri.HeaderParameterDecodingConfig{
		Name:    "Content-Encoding",
		Explode: false,
	}
	if err := func() error {
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
	var wrapperDotContentEncodingVal TechnologyProgressionHealthCheckOKContentEncoding
	if err := func() error {
	val, err := d.DecodeValue()
	if err != nil {
		return err
	}

	c, err := conv.ToString(val)
	if err != nil {
		return err
	}

	wrapperDotContentEncodingVal = TechnologyProgressionHealthCheckOKContentEncoding(c)
	return nil
	}(); err != nil {
		return err
	}
	wrapper.ContentEncoding.SetTo(wrapperDotContentEncodingVal)
	return nil
			}); err != nil {
				return err
			}
			if err := func() error {
	if value, ok := wrapper.ContentEncoding.Get(); ok {
		if err := func() error {
	if err := value.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
			return err
		}
	}
	return nil
			}(); err != nil {
				return err
			}
		} 
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "parse Content-Encoding header")
	}
}
// Parse "ETag" header.
{
	cfg := uri.HeaderParameterDecodingConfig{
		Name:    "ETag",
		Explode: false,
	}
	if err := func() error {
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
	var wrapperDotETagVal string
	if err := func() error {
	val, err := d.DecodeValue()
	if err != nil {
		return err
	}

	c, err := conv.ToString(val)
	if err != nil {
		return err
	}

	wrapperDotETagVal = c
	return nil
	}(); err != nil {
		return err
	}
	wrapper.ETag.SetTo(wrapperDotETagVal)
	return nil
			}); err != nil {
				return err
			}
		} 
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "parse ETag header")
	}
}
			return &wrapper, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
	}
		// Convenient error response.
		defRes, err := func() (res *ErrorStatusCode, err error) {
	ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
	if err != nil {
		return res, errors.Wrap(err, "parse media type")
	}
	switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Error
			if err := func() error {
		if err := response.Decode(d); err != nil {
			return err
		}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body: buf,
					Err: err,
				}
				return res, err
			}
		// Validate response.
		if err := func() error {
	if err := response.Validate(); err != nil {
		return err
	}
	return nil
		}(); err != nil {
				return res, errors.Wrap(err, "validate")
		}
			return &ErrorStatusCode{
				StatusCode: resp.StatusCode,
				Response:   response,
			}, nil
	default:
		return res, validate.InvalidContentType(ct)
	}
		}()
		if err != nil {
			return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
		}
		return res, errors.Wrap(defRes, "error")
}



