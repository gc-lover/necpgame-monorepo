// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes CompleteTrialSessionBadRequest as json.
func (s *CompleteTrialSessionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteTrialSessionBadRequest from json.
func (s *CompleteTrialSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteTrialSessionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionConflict as json.
func (s *CompleteTrialSessionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteTrialSessionConflict from json.
func (s *CompleteTrialSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteTrialSessionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionInternalServerError as json.
func (s *CompleteTrialSessionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteTrialSessionInternalServerError from json.
func (s *CompleteTrialSessionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteTrialSessionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionNotFound as json.
func (s *CompleteTrialSessionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteTrialSessionNotFound from json.
func (s *CompleteTrialSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteTrialSessionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteTrialSessionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteTrialSessionOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		e.FieldStart("leaderboard_rank")
		e.Int(s.LeaderboardRank)
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompleteTrialSessionOK = [4]string{
	0: "session",
	1: "rewards",
	2: "leaderboard_rank",
	3: "validation_status",
}

// Decode decodes CompleteTrialSessionOK from json.
func (s *CompleteTrialSessionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "leaderboard_rank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.LeaderboardRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard_rank\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteTrialSessionOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteTrialSessionOK) {
					name = jsonFieldsNameOfCompleteTrialSessionOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionOKValidationStatus as json.
func (s CompleteTrialSessionOKValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CompleteTrialSessionOKValidationStatus from json.
func (s *CompleteTrialSessionOKValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionOKValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CompleteTrialSessionOKValidationStatus(v) {
	case CompleteTrialSessionOKValidationStatusPending:
		*s = CompleteTrialSessionOKValidationStatusPending
	case CompleteTrialSessionOKValidationStatusValid:
		*s = CompleteTrialSessionOKValidationStatusValid
	case CompleteTrialSessionOKValidationStatusInvalid:
		*s = CompleteTrialSessionOKValidationStatusInvalid
	default:
		*s = CompleteTrialSessionOKValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CompleteTrialSessionOKValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionOKValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteTrialSessionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteTrialSessionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completion_time")
		e.Int(s.CompletionTime)
	}
	{
		e.FieldStart("progress_percentage")
		e.Int(s.ProgressPercentage)
	}
	{
		if s.TelemetryData != nil {
			e.FieldStart("telemetry_data")
			s.TelemetryData.Encode(e)
		}
	}
	{
		if s.PartyMembers != nil {
			e.FieldStart("party_members")
			e.ArrStart()
			for _, elem := range s.PartyMembers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCompleteTrialSessionReq = [4]string{
	0: "completion_time",
	1: "progress_percentage",
	2: "telemetry_data",
	3: "party_members",
}

// Decode decodes CompleteTrialSessionReq from json.
func (s *CompleteTrialSessionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CompletionTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "progress_percentage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ProgressPercentage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "telemetry_data":
			if err := func() error {
				s.TelemetryData = nil
				var elem CompleteTrialSessionReqTelemetryData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TelemetryData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telemetry_data\"")
			}
		case "party_members":
			if err := func() error {
				s.PartyMembers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PartyMembers = append(s.PartyMembers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteTrialSessionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteTrialSessionReq) {
					name = jsonFieldsNameOfCompleteTrialSessionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteTrialSessionReqTelemetryData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteTrialSessionReqTelemetryData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCompleteTrialSessionReqTelemetryData = [0]string{}

// Decode decodes CompleteTrialSessionReqTelemetryData from json.
func (s *CompleteTrialSessionReqTelemetryData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionReqTelemetryData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CompleteTrialSessionReqTelemetryData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionReqTelemetryData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionReqTelemetryData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionUnauthorized as json.
func (s *CompleteTrialSessionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteTrialSessionUnauthorized from json.
func (s *CompleteTrialSessionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteTrialSessionUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteTrialSessionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteTrialSessionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteTrialSessionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTrialBadRequest as json.
func (s *CreateTrialBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTrialBadRequest from json.
func (s *CreateTrialBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTrialBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTrialBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTrialBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTrialBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTrialForbidden as json.
func (s *CreateTrialForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTrialForbidden from json.
func (s *CreateTrialForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTrialForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTrialForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTrialForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTrialForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTrialUnauthorized as json.
func (s *CreateTrialUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTrialUnauthorized from json.
func (s *CreateTrialUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTrialUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTrialUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTrialUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTrialUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (s ErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ErrorCode from json.
func (s *ErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ErrorCode(v) {
	case ErrorCodeVALIDATIONERROR:
		*s = ErrorCodeVALIDATIONERROR
	case ErrorCodeNOTFOUND:
		*s = ErrorCodeNOTFOUND
	case ErrorCodeUNAUTHORIZED:
		*s = ErrorCodeUNAUTHORIZED
	case ErrorCodeFORBIDDEN:
		*s = ErrorCodeFORBIDDEN
	case ErrorCodeINTERNALERROR:
		*s = ErrorCodeINTERNALERROR
	case ErrorCodeTIMEOUT:
		*s = ErrorCodeTIMEOUT
	default:
		*s = ErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHealthOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHealthOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.Metrics.Set {
			e.FieldStart("metrics")
			s.Metrics.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetHealthOK = [4]string{
	0: "status",
	1: "timestamp",
	2: "version",
	3: "metrics",
}

// Decode decodes GetHealthOK from json.
func (s *GetHealthOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics.Reset()
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHealthOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHealthOK) {
					name = jsonFieldsNameOfGetHealthOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHealthOKMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHealthOKMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveSessions.Set {
			e.FieldStart("active_sessions")
			s.ActiveSessions.Encode(e)
		}
	}
	{
		if s.TotalTrials.Set {
			e.FieldStart("total_trials")
			s.TotalTrials.Encode(e)
		}
	}
	{
		if s.AvgResponseTime.Set {
			e.FieldStart("avg_response_time")
			s.AvgResponseTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetHealthOKMetrics = [3]string{
	0: "active_sessions",
	1: "total_trials",
	2: "avg_response_time",
}

// Decode decodes GetHealthOKMetrics from json.
func (s *GetHealthOKMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthOKMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active_sessions":
			if err := func() error {
				s.ActiveSessions.Reset()
				if err := s.ActiveSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_sessions\"")
			}
		case "total_trials":
			if err := func() error {
				s.TotalTrials.Reset()
				if err := s.TotalTrials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_trials\"")
			}
		case "avg_response_time":
			if err := func() error {
				s.AvgResponseTime.Reset()
				if err := s.AvgResponseTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avg_response_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHealthOKMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthOKStatus as json.
func (s GetHealthOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetHealthOKStatus from json.
func (s *GetHealthOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetHealthOKStatus(v) {
	case GetHealthOKStatusHealthy:
		*s = GetHealthOKStatusHealthy
	case GetHealthOKStatusDegraded:
		*s = GetHealthOKStatusDegraded
	case GetHealthOKStatusUnhealthy:
		*s = GetHealthOKStatusUnhealthy
	default:
		*s = GetHealthOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetHealthOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordBadRequest as json.
func (s *GetPlayerPersonalRecordBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerPersonalRecordBadRequest from json.
func (s *GetPlayerPersonalRecordBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerPersonalRecordBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordInternalServerError as json.
func (s *GetPlayerPersonalRecordInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerPersonalRecordInternalServerError from json.
func (s *GetPlayerPersonalRecordInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerPersonalRecordInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordNotFound as json.
func (s *GetPlayerPersonalRecordNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerPersonalRecordNotFound from json.
func (s *GetPlayerPersonalRecordNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerPersonalRecordNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerPersonalRecordOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerPersonalRecordOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("personal_best")
		s.PersonalBest.Encode(e)
	}
	{
		e.FieldStart("current_rank")
		e.Int(s.CurrentRank)
	}
	{
		e.FieldStart("rank_history")
		e.ArrStart()
		for _, elem := range s.RankHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetPlayerPersonalRecordOK = [5]string{
	0: "player_id",
	1: "trial_id",
	2: "personal_best",
	3: "current_rank",
	4: "rank_history",
}

// Decode decodes GetPlayerPersonalRecordOK from json.
func (s *GetPlayerPersonalRecordOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "trial_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "personal_best":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PersonalBest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personal_best\"")
			}
		case "current_rank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CurrentRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_rank\"")
			}
		case "rank_history":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.RankHistory = make([]GetPlayerPersonalRecordOKRankHistoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetPlayerPersonalRecordOKRankHistoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RankHistory = append(s.RankHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerPersonalRecordOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerPersonalRecordOK) {
					name = jsonFieldsNameOfGetPlayerPersonalRecordOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerPersonalRecordOKPersonalBest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerPersonalRecordOKPersonalBest) encodeFields(e *jx.Encoder) {
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.AchievedAt.Set {
			e.FieldStart("achieved_at")
			s.AchievedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerPersonalRecordOKPersonalBest = [3]string{
	0: "completion_time",
	1: "achieved_at",
	2: "difficulty",
}

// Decode decodes GetPlayerPersonalRecordOKPersonalBest from json.
func (s *GetPlayerPersonalRecordOKPersonalBest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordOKPersonalBest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "achieved_at":
			if err := func() error {
				s.AchievedAt.Reset()
				if err := s.AchievedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achieved_at\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerPersonalRecordOKPersonalBest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordOKPersonalBest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordOKPersonalBest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordOKPersonalBestDifficulty as json.
func (s GetPlayerPersonalRecordOKPersonalBestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetPlayerPersonalRecordOKPersonalBestDifficulty from json.
func (s *GetPlayerPersonalRecordOKPersonalBestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordOKPersonalBestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetPlayerPersonalRecordOKPersonalBestDifficulty(v) {
	case GetPlayerPersonalRecordOKPersonalBestDifficultyNormal:
		*s = GetPlayerPersonalRecordOKPersonalBestDifficultyNormal
	case GetPlayerPersonalRecordOKPersonalBestDifficultyHeroic:
		*s = GetPlayerPersonalRecordOKPersonalBestDifficultyHeroic
	case GetPlayerPersonalRecordOKPersonalBestDifficultyMythic:
		*s = GetPlayerPersonalRecordOKPersonalBestDifficultyMythic
	case GetPlayerPersonalRecordOKPersonalBestDifficultyLegendary:
		*s = GetPlayerPersonalRecordOKPersonalBestDifficultyLegendary
	default:
		*s = GetPlayerPersonalRecordOKPersonalBestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPlayerPersonalRecordOKPersonalBestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordOKPersonalBestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerPersonalRecordOKRankHistoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerPersonalRecordOKRankHistoryItem) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPlayerPersonalRecordOKRankHistoryItem = [2]string{
	0: "date",
	1: "rank",
}

// Decode decodes GetPlayerPersonalRecordOKRankHistoryItem from json.
func (s *GetPlayerPersonalRecordOKRankHistoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordOKRankHistoryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerPersonalRecordOKRankHistoryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordOKRankHistoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordOKRankHistoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordTooManyRequests as json.
func (s *GetPlayerPersonalRecordTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerPersonalRecordTooManyRequests from json.
func (s *GetPlayerPersonalRecordTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerPersonalRecordTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerPersonalRecordTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerPersonalRecordTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerPersonalRecordTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialInternalServerError as json.
func (s *GetTrialInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialInternalServerError from json.
func (s *GetTrialInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialLeaderboardBadRequest as json.
func (s *GetTrialLeaderboardBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialLeaderboardBadRequest from json.
func (s *GetTrialLeaderboardBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialLeaderboardBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialLeaderboardBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialLeaderboardInternalServerError as json.
func (s *GetTrialLeaderboardInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialLeaderboardInternalServerError from json.
func (s *GetTrialLeaderboardInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialLeaderboardInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialLeaderboardInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialLeaderboardNotFound as json.
func (s *GetTrialLeaderboardNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialLeaderboardNotFound from json.
func (s *GetTrialLeaderboardNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialLeaderboardNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialLeaderboardNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTrialLeaderboardOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTrialLeaderboardOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("timeframe")
		s.Timeframe.Encode(e)
	}
	{
		e.FieldStart("entries")
		e.ArrStart()
		for _, elem := range s.Entries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_entries")
		e.Int(s.TotalEntries)
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGetTrialLeaderboardOK = [5]string{
	0: "trial_id",
	1: "timeframe",
	2: "entries",
	3: "total_entries",
	4: "last_updated",
}

// Decode decodes GetTrialLeaderboardOK from json.
func (s *GetTrialLeaderboardOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trial_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "timeframe":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "entries":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Entries = make([]LeaderboardEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeaderboardEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		case "total_entries":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalEntries = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_entries\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTrialLeaderboardOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTrialLeaderboardOK) {
					name = jsonFieldsNameOfGetTrialLeaderboardOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialLeaderboardOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialLeaderboardOKTimeframe as json.
func (s GetTrialLeaderboardOKTimeframe) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetTrialLeaderboardOKTimeframe from json.
func (s *GetTrialLeaderboardOKTimeframe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardOKTimeframe to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetTrialLeaderboardOKTimeframe(v) {
	case GetTrialLeaderboardOKTimeframeDaily:
		*s = GetTrialLeaderboardOKTimeframeDaily
	case GetTrialLeaderboardOKTimeframeWeekly:
		*s = GetTrialLeaderboardOKTimeframeWeekly
	case GetTrialLeaderboardOKTimeframeMonthly:
		*s = GetTrialLeaderboardOKTimeframeMonthly
	case GetTrialLeaderboardOKTimeframeAllTime:
		*s = GetTrialLeaderboardOKTimeframeAllTime
	case GetTrialLeaderboardOKTimeframeSeasonal:
		*s = GetTrialLeaderboardOKTimeframeSeasonal
	default:
		*s = GetTrialLeaderboardOKTimeframe(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTrialLeaderboardOKTimeframe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardOKTimeframe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialLeaderboardTooManyRequests as json.
func (s *GetTrialLeaderboardTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialLeaderboardTooManyRequests from json.
func (s *GetTrialLeaderboardTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialLeaderboardTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialLeaderboardTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialLeaderboardTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialLeaderboardTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialNotFound as json.
func (s *GetTrialNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialNotFound from json.
func (s *GetTrialNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsBadRequest as json.
func (s *GetTrialPerformanceAnalyticsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsBadRequest from json.
func (s *GetTrialPerformanceAnalyticsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialPerformanceAnalyticsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsForbidden as json.
func (s *GetTrialPerformanceAnalyticsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsForbidden from json.
func (s *GetTrialPerformanceAnalyticsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialPerformanceAnalyticsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsInternalServerError as json.
func (s *GetTrialPerformanceAnalyticsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsInternalServerError from json.
func (s *GetTrialPerformanceAnalyticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialPerformanceAnalyticsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsNotFound as json.
func (s *GetTrialPerformanceAnalyticsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsNotFound from json.
func (s *GetTrialPerformanceAnalyticsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialPerformanceAnalyticsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTrialPerformanceAnalyticsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTrialPerformanceAnalyticsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("timeframe")
		e.Str(s.Timeframe)
	}
	{
		e.FieldStart("metrics")
		s.Metrics.Encode(e)
	}
}

var jsonFieldsNameOfGetTrialPerformanceAnalyticsOK = [3]string{
	0: "trial_id",
	1: "timeframe",
	2: "metrics",
}

// Decode decodes GetTrialPerformanceAnalyticsOK from json.
func (s *GetTrialPerformanceAnalyticsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trial_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "timeframe":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Timeframe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "metrics":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTrialPerformanceAnalyticsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTrialPerformanceAnalyticsOK) {
					name = jsonFieldsNameOfGetTrialPerformanceAnalyticsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTrialPerformanceAnalyticsOKMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTrialPerformanceAnalyticsOKMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCompletions.Set {
			e.FieldStart("total_completions")
			s.TotalCompletions.Encode(e)
		}
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("average_completion_time")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.FastestTime.Set {
			e.FieldStart("fastest_time")
			s.FastestTime.Encode(e)
		}
	}
	{
		if s.SlowestTime.Set {
			e.FieldStart("slowest_time")
			s.SlowestTime.Encode(e)
		}
	}
	{
		if s.CompletionRate.Set {
			e.FieldStart("completion_rate")
			s.CompletionRate.Encode(e)
		}
	}
	{
		if s.DifficultyDistribution.Set {
			e.FieldStart("difficulty_distribution")
			s.DifficultyDistribution.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetTrialPerformanceAnalyticsOKMetrics = [6]string{
	0: "total_completions",
	1: "average_completion_time",
	2: "fastest_time",
	3: "slowest_time",
	4: "completion_rate",
	5: "difficulty_distribution",
}

// Decode decodes GetTrialPerformanceAnalyticsOKMetrics from json.
func (s *GetTrialPerformanceAnalyticsOKMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsOKMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_completions":
			if err := func() error {
				s.TotalCompletions.Reset()
				if err := s.TotalCompletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_completions\"")
			}
		case "average_completion_time":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_completion_time\"")
			}
		case "fastest_time":
			if err := func() error {
				s.FastestTime.Reset()
				if err := s.FastestTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fastest_time\"")
			}
		case "slowest_time":
			if err := func() error {
				s.SlowestTime.Reset()
				if err := s.SlowestTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slowest_time\"")
			}
		case "completion_rate":
			if err := func() error {
				s.CompletionRate.Reset()
				if err := s.CompletionRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_rate\"")
			}
		case "difficulty_distribution":
			if err := func() error {
				s.DifficultyDistribution.Reset()
				if err := s.DifficultyDistribution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_distribution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTrialPerformanceAnalyticsOKMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) encodeFields(e *jx.Encoder) {
	{
		if s.Normal.Set {
			e.FieldStart("normal")
			s.Normal.Encode(e)
		}
	}
	{
		if s.Heroic.Set {
			e.FieldStart("heroic")
			s.Heroic.Encode(e)
		}
	}
	{
		if s.Mythic.Set {
			e.FieldStart("mythic")
			s.Mythic.Encode(e)
		}
	}
	{
		if s.Legendary.Set {
			e.FieldStart("legendary")
			s.Legendary.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution = [4]string{
	0: "normal",
	1: "heroic",
	2: "mythic",
	3: "legendary",
}

// Decode decodes GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution from json.
func (s *GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "normal":
			if err := func() error {
				s.Normal.Reset()
				if err := s.Normal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normal\"")
			}
		case "heroic":
			if err := func() error {
				s.Heroic.Reset()
				if err := s.Heroic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heroic\"")
			}
		case "mythic":
			if err := func() error {
				s.Mythic.Reset()
				if err := s.Mythic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mythic\"")
			}
		case "legendary":
			if err := func() error {
				s.Legendary.Reset()
				if err := s.Legendary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legendary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsUnauthorized as json.
func (s *GetTrialPerformanceAnalyticsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsUnauthorized from json.
func (s *GetTrialPerformanceAnalyticsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTrialPerformanceAnalyticsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTrialPerformanceAnalyticsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTrialPerformanceAnalyticsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTrialPerformanceAnalyticsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		if s.PlayerName.Set {
			e.FieldStart("player_name")
			s.PlayerName.Encode(e)
		}
	}
	{
		e.FieldStart("completion_time")
		e.Int(s.CompletionTime)
	}
	{
		e.FieldStart("rank")
		e.Int(s.Rank)
	}
	{
		if s.RankChange.Set {
			e.FieldStart("rank_change")
			s.RankChange.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PartySize.Set {
			e.FieldStart("party_size")
			s.PartySize.Encode(e)
		}
	}
	{
		if s.TrialDifficulty.Set {
			e.FieldStart("trial_difficulty")
			s.TrialDifficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardEntry = [8]string{
	0: "player_id",
	1: "player_name",
	2: "completion_time",
	3: "rank",
	4: "rank_change",
	5: "completed_at",
	6: "party_size",
	7: "trial_difficulty",
}

// Decode decodes LeaderboardEntry from json.
func (s *LeaderboardEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "player_name":
			if err := func() error {
				s.PlayerName.Reset()
				if err := s.PlayerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_name\"")
			}
		case "completion_time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CompletionTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Rank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "rank_change":
			if err := func() error {
				s.RankChange.Reset()
				if err := s.RankChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_change\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "party_size":
			if err := func() error {
				s.PartySize.Reset()
				if err := s.PartySize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_size\"")
			}
		case "trial_difficulty":
			if err := func() error {
				s.TrialDifficulty.Reset()
				if err := s.TrialDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardEntry) {
					name = jsonFieldsNameOfLeaderboardEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardEntryTrialDifficulty as json.
func (s LeaderboardEntryTrialDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LeaderboardEntryTrialDifficulty from json.
func (s *LeaderboardEntryTrialDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardEntryTrialDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LeaderboardEntryTrialDifficulty(v) {
	case LeaderboardEntryTrialDifficultyNormal:
		*s = LeaderboardEntryTrialDifficultyNormal
	case LeaderboardEntryTrialDifficultyHeroic:
		*s = LeaderboardEntryTrialDifficultyHeroic
	case LeaderboardEntryTrialDifficultyMythic:
		*s = LeaderboardEntryTrialDifficultyMythic
	case LeaderboardEntryTrialDifficultyLegendary:
		*s = LeaderboardEntryTrialDifficultyLegendary
	default:
		*s = LeaderboardEntryTrialDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeaderboardEntryTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardEntryTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTrialsBadRequest as json.
func (s *ListTrialsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListTrialsBadRequest from json.
func (s *ListTrialsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTrialsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTrialsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTrialsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTrialsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTrialsInternalServerError as json.
func (s *ListTrialsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListTrialsInternalServerError from json.
func (s *ListTrialsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTrialsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTrialsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTrialsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTrialsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTrialsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTrialsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trials")
		e.ArrStart()
		for _, elem := range s.Trials {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfListTrialsOK = [4]string{
	0: "trials",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes ListTrialsOK from json.
func (s *ListTrialsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTrialsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trials":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Trials = make([]TimeTrial, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TimeTrial
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trials = append(s.Trials, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trials\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTrialsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListTrialsOK) {
					name = jsonFieldsNameOfListTrialsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTrialsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTrialsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteTrialSessionOKValidationStatus as json.
func (o OptCompleteTrialSessionOKValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CompleteTrialSessionOKValidationStatus from json.
func (o *OptCompleteTrialSessionOKValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompleteTrialSessionOKValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompleteTrialSessionOKValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompleteTrialSessionOKValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthOKMetrics as json.
func (o OptGetHealthOKMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetHealthOKMetrics from json.
func (o *OptGetHealthOKMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetHealthOKMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetHealthOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetHealthOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerPersonalRecordOKPersonalBestDifficulty as json.
func (o OptGetPlayerPersonalRecordOKPersonalBestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetPlayerPersonalRecordOKPersonalBestDifficulty from json.
func (o *OptGetPlayerPersonalRecordOKPersonalBestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPlayerPersonalRecordOKPersonalBestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPlayerPersonalRecordOKPersonalBestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPlayerPersonalRecordOKPersonalBestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution as json.
func (o OptGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution from json.
func (o *OptGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetTrialPerformanceAnalyticsOKMetricsDifficultyDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardEntryTrialDifficulty as json.
func (o OptLeaderboardEntryTrialDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LeaderboardEntryTrialDifficulty from json.
func (o *OptLeaderboardEntryTrialDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeaderboardEntryTrialDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeaderboardEntryTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeaderboardEntryTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardTiers as json.
func (o OptRewardTiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RewardTiers from json.
func (o *OptRewardTiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRewardTiers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRewardTiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRewardTiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardTiersCurrency as json.
func (o OptRewardTiersCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RewardTiersCurrency from json.
func (o *OptRewardTiersCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRewardTiersCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRewardTiersCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRewardTiersCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionReq as json.
func (o OptStartTrialSessionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StartTrialSessionReq from json.
func (o *OptStartTrialSessionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartTrialSessionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartTrialSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartTrialSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialRewards as json.
func (o OptTrialRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TrialRewards from json.
func (o *OptTrialRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialRewards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionValidationStatus as json.
func (o OptTrialSessionValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrialSessionValidationStatus from json.
func (o *OptTrialSessionValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialSessionValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialSessionValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialSessionValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationRules as json.
func (o OptValidationRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationRules from json.
func (o *OptValidationRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidationRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidationRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionBadRequest as json.
func (s *ReportSuspiciousSessionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReportSuspiciousSessionBadRequest from json.
func (s *ReportSuspiciousSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReportSuspiciousSessionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionConflict as json.
func (s *ReportSuspiciousSessionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReportSuspiciousSessionConflict from json.
func (s *ReportSuspiciousSessionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReportSuspiciousSessionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionInternalServerError as json.
func (s *ReportSuspiciousSessionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReportSuspiciousSessionInternalServerError from json.
func (s *ReportSuspiciousSessionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReportSuspiciousSessionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionNotFound as json.
func (s *ReportSuspiciousSessionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReportSuspiciousSessionNotFound from json.
func (s *ReportSuspiciousSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReportSuspiciousSessionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReportSuspiciousSessionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReportSuspiciousSessionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.Evidence != nil {
			e.FieldStart("evidence")
			e.ArrStart()
			for _, elem := range s.Evidence {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReportSuspiciousSessionReq = [3]string{
	0: "reason",
	1: "details",
	2: "evidence",
}

// Decode decodes ReportSuspiciousSessionReq from json.
func (s *ReportSuspiciousSessionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "evidence":
			if err := func() error {
				s.Evidence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Evidence = append(s.Evidence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReportSuspiciousSessionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReportSuspiciousSessionReq) {
					name = jsonFieldsNameOfReportSuspiciousSessionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionReqReason as json.
func (s ReportSuspiciousSessionReqReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReportSuspiciousSessionReqReason from json.
func (s *ReportSuspiciousSessionReqReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionReqReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReportSuspiciousSessionReqReason(v) {
	case ReportSuspiciousSessionReqReasonSpeedHack:
		*s = ReportSuspiciousSessionReqReasonSpeedHack
	case ReportSuspiciousSessionReqReasonRouteExploit:
		*s = ReportSuspiciousSessionReqReasonRouteExploit
	case ReportSuspiciousSessionReqReasonInvalidCompletion:
		*s = ReportSuspiciousSessionReqReasonInvalidCompletion
	case ReportSuspiciousSessionReqReasonOther:
		*s = ReportSuspiciousSessionReqReasonOther
	default:
		*s = ReportSuspiciousSessionReqReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReportSuspiciousSessionReqReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionReqReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportSuspiciousSessionTooManyRequests as json.
func (s *ReportSuspiciousSessionTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReportSuspiciousSessionTooManyRequests from json.
func (s *ReportSuspiciousSessionTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSuspiciousSessionTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReportSuspiciousSessionTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSuspiciousSessionTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSuspiciousSessionTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiers) encodeFields(e *jx.Encoder) {
	{
		if s.Experience.Set {
			e.FieldStart("experience")
			s.Experience.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRewardTiers = [4]string{
	0: "experience",
	1: "currency",
	2: "items",
	3: "achievements",
}

// Decode decodes RewardTiers from json.
func (s *RewardTiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experience":
			if err := func() error {
				s.Experience.Reset()
				if err := s.Experience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]RewardTiersItemsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RewardTiersItemsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiersCurrency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiersCurrency) encodeFields(e *jx.Encoder) {
	{
		if s.Gold.Set {
			e.FieldStart("gold")
			s.Gold.Encode(e)
		}
	}
	{
		if s.SeasonalTokens.Set {
			e.FieldStart("seasonal_tokens")
			s.SeasonalTokens.Encode(e)
		}
	}
}

var jsonFieldsNameOfRewardTiersCurrency = [2]string{
	0: "gold",
	1: "seasonal_tokens",
}

// Decode decodes RewardTiersCurrency from json.
func (s *RewardTiersCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiersCurrency to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gold":
			if err := func() error {
				s.Gold.Reset()
				if err := s.Gold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "seasonal_tokens":
			if err := func() error {
				s.SeasonalTokens.Reset()
				if err := s.SeasonalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonal_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiersCurrency")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiersCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiersCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiersItemsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiersItemsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfRewardTiersItemsItem = [2]string{
	0: "item_id",
	1: "quantity",
}

// Decode decodes RewardTiersItemsItem from json.
func (s *RewardTiersItemsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiersItemsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiersItemsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiersItemsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiersItemsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionBadRequest as json.
func (s *StartTrialSessionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartTrialSessionBadRequest from json.
func (s *StartTrialSessionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartTrialSessionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartTrialSessionCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartTrialSessionCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		e.FieldStart("server_time")
		json.EncodeDateTime(e, s.ServerTime)
	}
}

var jsonFieldsNameOfStartTrialSessionCreated = [2]string{
	0: "session",
	1: "server_time",
}

// Decode decodes StartTrialSessionCreated from json.
func (s *StartTrialSessionCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "server_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ServerTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartTrialSessionCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartTrialSessionCreated) {
					name = jsonFieldsNameOfStartTrialSessionCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionInternalServerError as json.
func (s *StartTrialSessionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartTrialSessionInternalServerError from json.
func (s *StartTrialSessionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartTrialSessionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionNotFound as json.
func (s *StartTrialSessionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartTrialSessionNotFound from json.
func (s *StartTrialSessionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartTrialSessionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartTrialSessionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartTrialSessionReq) encodeFields(e *jx.Encoder) {
	{
		if s.PartyID.Set {
			e.FieldStart("party_id")
			s.PartyID.Encode(e)
		}
	}
	{
		if s.CustomSettings != nil {
			e.FieldStart("custom_settings")
			s.CustomSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartTrialSessionReq = [2]string{
	0: "party_id",
	1: "custom_settings",
}

// Decode decodes StartTrialSessionReq from json.
func (s *StartTrialSessionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "party_id":
			if err := func() error {
				s.PartyID.Reset()
				if err := s.PartyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_id\"")
			}
		case "custom_settings":
			if err := func() error {
				s.CustomSettings = nil
				var elem StartTrialSessionReqCustomSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartTrialSessionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartTrialSessionReqCustomSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartTrialSessionReqCustomSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfStartTrialSessionReqCustomSettings = [0]string{}

// Decode decodes StartTrialSessionReqCustomSettings from json.
func (s *StartTrialSessionReqCustomSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionReqCustomSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode StartTrialSessionReqCustomSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionReqCustomSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionReqCustomSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionTooManyRequests as json.
func (s *StartTrialSessionTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartTrialSessionTooManyRequests from json.
func (s *StartTrialSessionTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartTrialSessionTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartTrialSessionUnauthorized as json.
func (s *StartTrialSessionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartTrialSessionUnauthorized from json.
func (s *StartTrialSessionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartTrialSessionUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartTrialSessionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartTrialSessionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartTrialSessionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResponse = [3]string{
	0: "success",
	1: "data",
	2: "metadata",
}

// Decode decodes SuccessResponse from json.
func (s *SuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem SuccessResponseData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem SuccessResponseMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessResponse) {
					name = jsonFieldsNameOfSuccessResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponseData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSuccessResponseData = [0]string{}

// Decode decodes SuccessResponseData from json.
func (s *SuccessResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponseMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponseMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSuccessResponseMetadata = [0]string{}

// Decode decodes SuccessResponseMetadata from json.
func (s *SuccessResponseMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponseMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponseMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponseMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponseMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeTrial) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeTrial) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("content_id")
		e.Str(s.ContentID)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.MinPlayers.Set {
			e.FieldStart("min_players")
			s.MinPlayers.Encode(e)
		}
	}
	{
		if s.MaxPlayers.Set {
			e.FieldStart("max_players")
			s.MaxPlayers.Encode(e)
		}
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
	{
		if s.ValidationRules.Set {
			e.FieldStart("validation_rules")
			s.ValidationRules.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTimeTrial = [14]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "type",
	4:  "content_id",
	5:  "difficulty",
	6:  "status",
	7:  "time_limit",
	8:  "min_players",
	9:  "max_players",
	10: "rewards",
	11: "validation_rules",
	12: "created_at",
	13: "updated_at",
}

// Decode decodes TimeTrial from json.
func (s *TimeTrial) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrial to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "content_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ContentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_id\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		case "min_players":
			if err := func() error {
				s.MinPlayers.Reset()
				if err := s.MinPlayers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_players\"")
			}
		case "max_players":
			if err := func() error {
				s.MaxPlayers.Reset()
				if err := s.MaxPlayers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_players\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "validation_rules":
			if err := func() error {
				s.ValidationRules.Reset()
				if err := s.ValidationRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_rules\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeTrial")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeTrial) {
					name = jsonFieldsNameOfTimeTrial[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeTrial) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrial) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialDifficulty as json.
func (s TimeTrialDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialDifficulty from json.
func (s *TimeTrialDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialDifficulty(v) {
	case TimeTrialDifficultyNormal:
		*s = TimeTrialDifficultyNormal
	case TimeTrialDifficultyHeroic:
		*s = TimeTrialDifficultyHeroic
	case TimeTrialDifficultyMythic:
		*s = TimeTrialDifficultyMythic
	case TimeTrialDifficultyLegendary:
		*s = TimeTrialDifficultyLegendary
	default:
		*s = TimeTrialDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialStatus as json.
func (s TimeTrialStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialStatus from json.
func (s *TimeTrialStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialStatus(v) {
	case TimeTrialStatusActive:
		*s = TimeTrialStatusActive
	case TimeTrialStatusInactive:
		*s = TimeTrialStatusInactive
	case TimeTrialStatusDeprecated:
		*s = TimeTrialStatusDeprecated
	default:
		*s = TimeTrialStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialType as json.
func (s TimeTrialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialType from json.
func (s *TimeTrialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialType(v) {
	case TimeTrialTypeSpeedrunRaid:
		*s = TimeTrialTypeSpeedrunRaid
	case TimeTrialTypeTimeAttackDungeon:
		*s = TimeTrialTypeTimeAttackDungeon
	case TimeTrialTypeWeeklyChallenge:
		*s = TimeTrialTypeWeeklyChallenge
	case TimeTrialTypeSeasonalTrial:
		*s = TimeTrialTypeSeasonalTrial
	default:
		*s = TimeTrialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialRewards) encodeFields(e *jx.Encoder) {
	{
		if s.BronzeTime.Set {
			e.FieldStart("bronze_time")
			s.BronzeTime.Encode(e)
		}
	}
	{
		if s.SilverTime.Set {
			e.FieldStart("silver_time")
			s.SilverTime.Encode(e)
		}
	}
	{
		if s.GoldTime.Set {
			e.FieldStart("gold_time")
			s.GoldTime.Encode(e)
		}
	}
	{
		if s.PlatinumTime.Set {
			e.FieldStart("platinum_time")
			s.PlatinumTime.Encode(e)
		}
	}
	{
		if s.BronzeRewards.Set {
			e.FieldStart("bronze_rewards")
			s.BronzeRewards.Encode(e)
		}
	}
	{
		if s.SilverRewards.Set {
			e.FieldStart("silver_rewards")
			s.SilverRewards.Encode(e)
		}
	}
	{
		if s.GoldRewards.Set {
			e.FieldStart("gold_rewards")
			s.GoldRewards.Encode(e)
		}
	}
	{
		if s.PlatinumRewards.Set {
			e.FieldStart("platinum_rewards")
			s.PlatinumRewards.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialRewards = [8]string{
	0: "bronze_time",
	1: "silver_time",
	2: "gold_time",
	3: "platinum_time",
	4: "bronze_rewards",
	5: "silver_rewards",
	6: "gold_rewards",
	7: "platinum_rewards",
}

// Decode decodes TrialRewards from json.
func (s *TrialRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bronze_time":
			if err := func() error {
				s.BronzeTime.Reset()
				if err := s.BronzeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bronze_time\"")
			}
		case "silver_time":
			if err := func() error {
				s.SilverTime.Reset()
				if err := s.SilverTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silver_time\"")
			}
		case "gold_time":
			if err := func() error {
				s.GoldTime.Reset()
				if err := s.GoldTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold_time\"")
			}
		case "platinum_time":
			if err := func() error {
				s.PlatinumTime.Reset()
				if err := s.PlatinumTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platinum_time\"")
			}
		case "bronze_rewards":
			if err := func() error {
				s.BronzeRewards.Reset()
				if err := s.BronzeRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bronze_rewards\"")
			}
		case "silver_rewards":
			if err := func() error {
				s.SilverRewards.Reset()
				if err := s.SilverRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silver_rewards\"")
			}
		case "gold_rewards":
			if err := func() error {
				s.GoldRewards.Reset()
				if err := s.GoldRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold_rewards\"")
			}
		case "platinum_rewards":
			if err := func() error {
				s.PlatinumRewards.Reset()
				if err := s.PlatinumRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platinum_rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialSession) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialSession) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		if s.PartyID.Set {
			e.FieldStart("party_id")
			s.PartyID.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progress_percentage")
			s.ProgressPercentage.Encode(e)
		}
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialSession = [11]string{
	0:  "id",
	1:  "trial_id",
	2:  "player_id",
	3:  "party_id",
	4:  "status",
	5:  "start_time",
	6:  "end_time",
	7:  "completion_time",
	8:  "progress_percentage",
	9:  "validation_status",
	10: "metadata",
}

// Decode decodes TrialSession from json.
func (s *TrialSession) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSession to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trial_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "player_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "party_id":
			if err := func() error {
				s.PartyID.Reset()
				if err := s.PartyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "progress_percentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem TrialSessionMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialSession")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialSession) {
					name = jsonFieldsNameOfTrialSession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialSessionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialSessionMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTrialSessionMetadata = [0]string{}

// Decode decodes TrialSessionMetadata from json.
func (s *TrialSessionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TrialSessionMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialSessionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionStatus as json.
func (s TrialSessionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrialSessionStatus from json.
func (s *TrialSessionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrialSessionStatus(v) {
	case TrialSessionStatusStarting:
		*s = TrialSessionStatusStarting
	case TrialSessionStatusActive:
		*s = TrialSessionStatusActive
	case TrialSessionStatusPaused:
		*s = TrialSessionStatusPaused
	case TrialSessionStatusCompleted:
		*s = TrialSessionStatusCompleted
	case TrialSessionStatusFailed:
		*s = TrialSessionStatusFailed
	case TrialSessionStatusInvalidated:
		*s = TrialSessionStatusInvalidated
	default:
		*s = TrialSessionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrialSessionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionValidationStatus as json.
func (s TrialSessionValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrialSessionValidationStatus from json.
func (s *TrialSessionValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrialSessionValidationStatus(v) {
	case TrialSessionValidationStatusPending:
		*s = TrialSessionValidationStatusPending
	case TrialSessionValidationStatusValid:
		*s = TrialSessionValidationStatusValid
	case TrialSessionValidationStatusInvalid:
		*s = TrialSessionValidationStatusInvalid
	case TrialSessionValidationStatusDisputed:
		*s = TrialSessionValidationStatusDisputed
	default:
		*s = TrialSessionValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrialSessionValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTrialBadRequest as json.
func (s *UpdateTrialBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTrialBadRequest from json.
func (s *UpdateTrialBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTrialBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTrialBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTrialBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTrialBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTrialForbidden as json.
func (s *UpdateTrialForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTrialForbidden from json.
func (s *UpdateTrialForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTrialForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTrialForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTrialForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTrialForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTrialInternalServerError as json.
func (s *UpdateTrialInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTrialInternalServerError from json.
func (s *UpdateTrialInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTrialInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTrialInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTrialInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTrialInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTrialNotFound as json.
func (s *UpdateTrialNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTrialNotFound from json.
func (s *UpdateTrialNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTrialNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTrialNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTrialNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTrialNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTrialUnauthorized as json.
func (s *UpdateTrialUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTrialUnauthorized from json.
func (s *UpdateTrialUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTrialUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTrialUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTrialUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTrialUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationRules) encodeFields(e *jx.Encoder) {
	{
		if s.AllowCheats.Set {
			e.FieldStart("allow_cheats")
			s.AllowCheats.Encode(e)
		}
	}
	{
		if s.ValidateRoute.Set {
			e.FieldStart("validate_route")
			s.ValidateRoute.Encode(e)
		}
	}
	{
		if s.MinCompletionPercentage.Set {
			e.FieldStart("min_completion_percentage")
			s.MinCompletionPercentage.Encode(e)
		}
	}
	{
		if s.AllowedModifiers != nil {
			e.FieldStart("allowed_modifiers")
			e.ArrStart()
			for _, elem := range s.AllowedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationRules = [4]string{
	0: "allow_cheats",
	1: "validate_route",
	2: "min_completion_percentage",
	3: "allowed_modifiers",
}

// Decode decodes ValidationRules from json.
func (s *ValidationRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationRules to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_cheats":
			if err := func() error {
				s.AllowCheats.Reset()
				if err := s.AllowCheats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_cheats\"")
			}
		case "validate_route":
			if err := func() error {
				s.ValidateRoute.Reset()
				if err := s.ValidateRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validate_route\"")
			}
		case "min_completion_percentage":
			if err := func() error {
				s.MinCompletionPercentage.Reset()
				if err := s.MinCompletionPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_completion_percentage\"")
			}
		case "allowed_modifiers":
			if err := func() error {
				s.AllowedModifiers = make([]ValidationRulesAllowedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationRulesAllowedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedModifiers = append(s.AllowedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationRulesAllowedModifiersItem as json.
func (s ValidationRulesAllowedModifiersItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValidationRulesAllowedModifiersItem from json.
func (s *ValidationRulesAllowedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationRulesAllowedModifiersItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValidationRulesAllowedModifiersItem(v) {
	case ValidationRulesAllowedModifiersItemSpeedBoost:
		*s = ValidationRulesAllowedModifiersItemSpeedBoost
	case ValidationRulesAllowedModifiersItemDamageMod:
		*s = ValidationRulesAllowedModifiersItemDamageMod
	case ValidationRulesAllowedModifiersItemHealthMod:
		*s = ValidationRulesAllowedModifiersItemHealthMod
	case ValidationRulesAllowedModifiersItemAbilityMod:
		*s = ValidationRulesAllowedModifiersItemAbilityMod
	default:
		*s = ValidationRulesAllowedModifiersItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationRulesAllowedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationRulesAllowedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
