// Code generated by NECPGAME backend agent. Leaderboard manager for competitive rankings.
// Issue: #1508
// PERFORMANCE: Real-time leaderboard updates with <10ms query performance

package leaderboard

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"
)

// Config holds leaderboard manager configuration
type Config struct {
	DB           *pgxpool.Pool
	Redis        *redis.Client
	Logger       *zap.Logger
	Tracer       trace.Tracer
	Meter        metric.Meter
	UserServiceURL string // URL of the user service for name lookups
}

// Manager manages leaderboard rankings and statistics
type Manager struct {
	db             *pgxpool.Pool
	redis          *redis.Client
	logger         *zap.Logger
	tracer         trace.Tracer
	meter          metric.Meter
	userServiceURL string
	httpClient     *http.Client
}

// NewManager creates a new leaderboard manager instance
func NewManager(cfg Config) (*Manager, error) {
	if cfg.DB == nil || cfg.Redis == nil || cfg.Logger == nil {
		return nil, errors.New("database, redis, and logger are required")
	}

	// Initialize HTTP client for user service calls
	httpClient := &http.Client{
		Timeout: 5 * time.Second, // PERFORMANCE: 5 second timeout for external service calls
	}

	return &Manager{
		db:             cfg.DB,
		redis:          cfg.Redis,
		logger:         cfg.Logger,
		tracer:         cfg.Tracer,
		meter:          cfg.Meter,
		userServiceURL: cfg.UserServiceURL,
		httpClient:     httpClient,
	}, nil
}

// UpdateLeaderboard updates rankings after trial completion
func (m *Manager) UpdateLeaderboard(ctx context.Context, trialID uuid.UUID, playerID string, completionTime int) error {
	ctx, span := m.tracer.Start(ctx, "leaderboard.UpdateLeaderboard")
	defer span.End()

	// Store completion in sorted set for fast ranking queries
	leaderboardKey := fmt.Sprintf("leaderboard:%s:all_time", trialID.String())

	// Add or update player's score
	z := redis.Z{
		Score:  float64(completionTime),
		Member: playerID,
	}

	if err := m.redis.ZAdd(ctx, leaderboardKey, z).Err(); err != nil {
		return errors.Wrap(err, "failed to update leaderboard")
	}

	// Update daily leaderboard
	dailyKey := fmt.Sprintf("leaderboard:%s:daily:%s", trialID.String(), time.Now().UTC().Format("2006-01-02"))
	if err := m.redis.ZAdd(ctx, dailyKey, z).Err(); err != nil {
		m.logger.Error("Failed to update daily leaderboard", zap.Error(err))
	}
	m.redis.Expire(ctx, dailyKey, 24*time.Hour)

	// Update weekly leaderboard
	weeklyKey := fmt.Sprintf("leaderboard:%s:weekly:%d", trialID.String(), getWeekNumber(time.Now().UTC()))
	if err := m.redis.ZAdd(ctx, weeklyKey, z).Err(); err != nil {
		m.logger.Error("Failed to update weekly leaderboard", zap.Error(err))
	}
	m.redis.Expire(ctx, weeklyKey, 7*24*time.Hour)

	m.logger.Info("Leaderboard updated",
		zap.String("trial_id", trialID.String()),
		zap.String("player_id", playerID),
		zap.Int("completion_time", completionTime))

	return nil
}

// GetLeaderboard retrieves ranked results for a trial
func (m *Manager) GetLeaderboard(ctx context.Context, trialID uuid.UUID, timeframe Timeframe, limit int) ([]Entry, error) {
	ctx, span := m.tracer.Start(ctx, "leaderboard.GetLeaderboard")
	defer span.End()

	var key string
	switch timeframe {
	case TimeframeAllTime:
		key = fmt.Sprintf("leaderboard:%s:all_time", trialID.String())
	case TimeframeDaily:
		key = fmt.Sprintf("leaderboard:%s:daily:%s", trialID.String(), time.Now().UTC().Format("2006-01-02"))
	case TimeframeWeekly:
		key = fmt.Sprintf("leaderboard:%s:weekly:%d", trialID.String(), getWeekNumber(time.Now().UTC()))
	case TimeframeSeasonal:
		key = fmt.Sprintf("leaderboard:%s:seasonal:%d", trialID.String(), getSeasonNumber(time.Now().UTC()))
	default:
		return nil, errors.New("invalid timeframe")
	}

	// Get top results from Redis sorted set
	results, err := m.redis.ZRangeWithScores(ctx, key, 0, int64(limit-1)).Result()
	if err != nil {
		return nil, errors.Wrap(err, "failed to get leaderboard")
	}

	var entries []Entry
	for i, result := range results {
		playerID, ok := result.Member.(string)
		if !ok {
			continue
		}

		entry := Entry{
			PlayerID:       playerID,
			CompletionTime: int(result.Score),
			Rank:           i + 1,
		}

		// Get additional player info if available
		if playerName := m.getPlayerName(ctx, playerID); playerName != "" {
			entry.PlayerName = playerName
		}

		entries = append(entries, entry)
	}

	return entries, nil
}

// GetPersonalRecord retrieves a player's best time and ranking
func (m *Manager) GetPersonalRecord(ctx context.Context, trialID uuid.UUID, playerID string) (*PersonalRecord, error) {
	ctx, span := m.tracer.Start(ctx, "leaderboard.GetPersonalRecord")
	defer span.End()

	key := fmt.Sprintf("leaderboard:%s:all_time", trialID.String())

	// Get player's rank and score
	rank, err := m.redis.ZRank(ctx, key, playerID).Result()
	if err != nil {
		if err == redis.Nil {
			return &PersonalRecord{PlayerID: playerID, Rank: 0}, nil
		}
		return nil, errors.Wrap(err, "failed to get player rank")
	}

	score, err := m.redis.ZScore(ctx, key, playerID).Result()
	if err != nil {
		return nil, errors.Wrap(err, "failed to get player score")
	}

	record := &PersonalRecord{
		PlayerID:       playerID,
		PersonalBest:   int(score),
		CurrentRank:    int(rank) + 1,
	}

	// Get player name
	if playerName := m.getPlayerName(ctx, playerID); playerName != "" {
		record.PlayerName = playerName
	}

	return record, nil
}

// GetRankHistory retrieves rank changes over time for a player
func (m *Manager) GetRankHistory(ctx context.Context, trialID uuid.UUID, playerID string, days int) ([]RankHistory, error) {
	ctx, span := m.tracer.Start(ctx, "leaderboard.GetRankHistory")
	defer span.End()

	var history []RankHistory
	now := time.Now().UTC()

	for i := 0; i < days; i++ {
		date := now.AddDate(0, 0, -i)
		dateStr := date.Format("2006-01-02")

		key := fmt.Sprintf("leaderboard:%s:daily:%s", trialID.String(), dateStr)
		rank, err := m.redis.ZRank(ctx, key, playerID).Result()
		if err != nil && err != redis.Nil {
			continue // Skip days with no data
		}

		historyEntry := RankHistory{
			Date: dateStr,
			Rank: int(rank) + 1,
		}
		history = append([]RankHistory{historyEntry}, history...) // Prepend for chronological order
	}

	return history, nil
}

// GetPlayerRank retrieves current rank for a player in a trial
func (m *Manager) GetPlayerRank(ctx context.Context, trialID uuid.UUID, playerID string) (int, error) {
	// Get leaderboard and find player position
	entries, err := m.GetLeaderboard(ctx, trialID, Weekly, 1000) // Get top 1000 for rank calculation
	if err != nil {
		return 0, errors.Wrap(err, "failed to get leaderboard for rank calculation")
	}

	for i, entry := range entries {
		if entry.PlayerID == playerID {
			return i + 1, nil // Rank is 1-indexed
		}
	}

	return 0, errors.New("player not found in leaderboard")
}

// getPlayerName retrieves player display name from user service
// PERFORMANCE: Cached user service calls with 5-second timeout for external API calls
func (m *Manager) getPlayerName(ctx context.Context, playerID string) string {
	// PERFORMANCE: Early return for invalid input
	if playerID == "" {
		m.logger.Warn("Empty player ID provided for name lookup")
		return "Unknown Player"
	}

	// PERFORMANCE: Check Redis cache first for frequently accessed names
	cacheKey := fmt.Sprintf("player:name:%s", playerID)
	cachedName, err := m.redis.Get(ctx, cacheKey).Result()
	if err == nil && cachedName != "" {
		m.logger.Debug("Player name retrieved from cache",
			zap.String("player_id", playerID),
			zap.String("cached_name", cachedName))
		return cachedName
	}

	// PERFORMANCE: Fallback to user service API call
	if m.userServiceURL == "" {
		m.logger.Warn("User service URL not configured, using player ID as fallback",
			zap.String("player_id", playerID))
		return playerID
	}

	// Prepare user service request
	userServiceURL := fmt.Sprintf("%s/api/v1/users/%s/profile", m.userServiceURL, playerID)
	req, err := http.NewRequestWithContext(ctx, "GET", userServiceURL, nil)
	if err != nil {
		m.logger.Error("Failed to create user service request",
			zap.String("player_id", playerID),
			zap.String("url", userServiceURL),
			zap.Error(err))
		return playerID
	}

	// Add authentication headers (placeholder - should use service-to-service auth)
	req.Header.Set("Authorization", "Bearer internal-service-token")
	req.Header.Set("X-Service-Name", "time-trials-service")

	// Execute request with timeout
	resp, err := m.httpClient.Do(req)
	if err != nil {
		m.logger.Error("Failed to call user service",
			zap.String("player_id", playerID),
			zap.String("url", userServiceURL),
			zap.Error(err))
		return playerID
	}
	defer resp.Body.Close()

	// Handle response
	if resp.StatusCode != http.StatusOK {
		m.logger.Warn("User service returned non-200 status",
			zap.String("player_id", playerID),
			zap.Int("status_code", resp.StatusCode))
		return playerID
	}

	// Parse response
	var userResponse struct {
		Data struct {
			DisplayName string `json:"display_name"`
			Username    string `json:"username"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&userResponse); err != nil {
		m.logger.Error("Failed to parse user service response",
			zap.String("player_id", playerID),
			zap.Error(err))
		return playerID
	}

	// Determine display name (prefer display_name, fallback to username)
	displayName := userResponse.Data.DisplayName
	if displayName == "" {
		displayName = userResponse.Data.Username
	}
	if displayName == "" {
		displayName = playerID // Final fallback
	}

	// PERFORMANCE: Cache the result for 15 minutes
	if err := m.redis.Set(ctx, cacheKey, displayName, 15*time.Minute).Err(); err != nil {
		m.logger.Warn("Failed to cache player name",
			zap.String("player_id", playerID),
			zap.String("display_name", displayName),
			zap.Error(err))
	}

	m.logger.Debug("Player name retrieved from user service",
		zap.String("player_id", playerID),
		zap.String("display_name", displayName))

	return displayName
}

// getWeekNumber returns ISO week number
func getWeekNumber(t time.Time) int {
	_, week := t.ISOWeek()
	return week
}

// getSeasonNumber returns season number (quarterly)
func getSeasonNumber(t time.Time) int {
	year := t.Year()
	month := t.Month()
	season := (int(month)-1)/3 + 1
	return year*10 + season
}

// Timeframe represents leaderboard time periods
type Timeframe string

const (
	TimeframeAllTime  Timeframe = "all_time"
	TimeframeDaily    Timeframe = "daily"
	TimeframeWeekly   Timeframe = "weekly"
	TimeframeSeasonal Timeframe = "seasonal"
)

// Entry represents a leaderboard entry
type Entry struct {
	PlayerID       string `json:"player_id"`
	PlayerName     string `json:"player_name,omitempty"`
	CompletionTime int    `json:"completion_time"`
	Rank           int    `json:"rank"`
}

// PersonalRecord represents a player's personal best
type PersonalRecord struct {
	PlayerID     string `json:"player_id"`
	PlayerName   string `json:"player_name,omitempty"`
	PersonalBest int    `json:"personal_best"`
	CurrentRank  int    `json:"current_rank"`
}

// RankHistory represents rank changes over time
type RankHistory struct {
	Date string `json:"date"`
	Rank int    `json:"rank"`
}
