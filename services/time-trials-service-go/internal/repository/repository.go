// Code generated by NECPGAME backend agent. Trial configuration repository.
// PERFORMANCE: Optimized for fast trial config retrieval (<10ms P99)

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"

	"necpgame/services/time-trials-service-go/internal/models"
)

// Repository handles database operations for time trials service
type Repository struct {
	pool   *pgxpool.Pool
	logger *zap.Logger
}

// NewRepository creates a new repository instance
func NewRepository(pool *pgxpool.Pool, logger *zap.Logger) *Repository {
	return &Repository{
		pool:   pool,
		logger: logger,
	}
}

// TrialConfigRecord represents trial configuration stored in database
type TrialConfigRecord struct {
	ID              string    `db:"id"`
	TrialID         string    `db:"trial_id"`
	Name            string    `db:"name"`
	Description     string    `db:"description"`
	ConfigData      string    `db:"config_data"` // JSON blob
	IsActive        bool      `db:"is_active"`
	CreatedAt       time.Time `db:"created_at"`
	UpdatedAt       time.Time `db:"updated_at"`
	CreatedBy       string    `db:"created_by"`
	RewardConfig    string    `db:"reward_config"` // JSON blob for reward configuration
}

// GetTrialRewardConfig retrieves trial reward configuration from database
func (r *Repository) GetTrialRewardConfig(ctx context.Context, trialID uuid.UUID) (*models.TrialRewardConfig, error) {
	// PERFORMANCE: Add timeout for database operations (50ms P99 target)
	dbCtx, cancel := context.WithTimeout(ctx, 50*time.Millisecond)
	defer cancel()

	query := `
		SELECT id, trial_id, name, description, reward_config, is_active, created_at, updated_at, created_by
		FROM time_trials.trial_configs
		WHERE trial_id = $1 AND is_active = true
		ORDER BY updated_at DESC
		LIMIT 1
	`

	var record TrialConfigRecord
	err := r.pool.QueryRow(dbCtx, query, trialID.String()).Scan(
		&record.ID,
		&record.TrialID,
		&record.Name,
		&record.Description,
		&record.RewardConfig,
		&record.IsActive,
		&record.CreatedAt,
		&record.UpdatedAt,
		&record.CreatedBy,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			r.logger.Warn("Trial configuration not found in database, using defaults",
				zap.String("trial_id", trialID.String()))
			// Return default configuration if not found in database
			return r.getDefaultTrialRewardConfig(), nil
		}
		r.logger.Error("Failed to retrieve trial configuration",
			zap.String("trial_id", trialID.String()),
			zap.Error(err))
		return nil, fmt.Errorf("failed to retrieve trial config: %w", err)
	}

	// Parse JSON config data
	config, err := r.parseTrialRewardConfigJSON(record.RewardConfig)
	if err != nil {
		r.logger.Error("Failed to parse trial configuration JSON",
			zap.String("trial_id", trialID.String()),
			zap.Error(err))
		return nil, fmt.Errorf("failed to parse trial config: %w", err)
	}

	r.logger.Debug("Retrieved trial configuration from database",
		zap.String("trial_id", trialID.String()),
		zap.String("config_name", record.Name))

	return config, nil
}

// parseTrialConfigJSON parses JSON configuration data into TrialConfig struct
func (r *Repository) parseTrialRewardConfigJSON(jsonData string) (*models.TrialRewardConfig, error) {
	var config models.TrialRewardConfig
	if err := json.Unmarshal([]byte(jsonData), &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal trial config JSON: %w", err)
	}
	return &config, nil
}

// getDefaultTrialConfig returns default trial configuration when database lookup fails
func (r *Repository) getDefaultTrialRewardConfig() *models.TrialRewardConfig {
	return &models.TrialRewardConfig{
		BronzeTime:  180000, // 3 minutes
		SilverTime:  150000, // 2.5 minutes
		GoldTime:    120000, // 2 minutes
		PlatinumTime: 90000, // 1.5 minutes
		BronzeRewards: models.RewardTiers{
			Experience: 100,
			Currency: models.CurrencyReward{
				Gold:           50,
				SeasonalTokens: 10,
			},
		},
		SilverRewards: models.RewardTiers{
			Experience: 150,
			Currency: models.CurrencyReward{
				Gold:           75,
				SeasonalTokens: 15,
			},
		},
		GoldRewards: models.RewardTiers{
			Experience: 200,
			Currency: models.CurrencyReward{
				Gold:           100,
				SeasonalTokens: 25,
			},
		},
		PlatinumRewards: models.RewardTiers{
			Experience: 300,
			Currency: models.CurrencyReward{
				Gold:           150,
				SeasonalTokens: 50,
			},
		},
	}
}

// CreateTrialConfig creates a new trial configuration in database
func (r *Repository) CreateTrialRewardConfig(ctx context.Context, trialID uuid.UUID, name, description string, config *models.TrialRewardConfig) (*TrialConfigRecord, error) {
	dbCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()

	// Serialize config to JSON
	configJSON, err := json.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal trial config: %w", err)
	}

	recordID := uuid.New().String()
	query := `
		INSERT INTO time_trials.trial_configs
		(id, trial_id, name, description, config_data, is_active, created_at, updated_at, created_by)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`

	_, err = r.pool.Exec(dbCtx, query,
		recordID,
		trialID.String(),
		name,
		description,
		string(configJSON),
		true,
		time.Now().UTC(),
		time.Now().UTC(),
		"system", // Default created_by
	)

	if err != nil {
		r.logger.Error("Failed to create trial configuration",
			zap.String("trial_id", trialID.String()),
			zap.Error(err))
		return nil, fmt.Errorf("failed to create trial config: %w", err)
	}

	record := &TrialConfigRecord{
		ID:         recordID,
		TrialID:    trialID.String(),
		Name:       name,
		Description: description,
		ConfigData: string(configJSON),
		IsActive:   true,
		CreatedAt:  time.Now().UTC(),
		UpdatedAt:  time.Now().UTC(),
		CreatedBy:  "system",
	}

	r.logger.Info("Created trial configuration",
		zap.String("trial_id", trialID.String()),
		zap.String("config_name", name))

	return record, nil
}

// UpdateTrialConfig updates existing trial configuration
func (r *Repository) UpdateTrialRewardConfig(ctx context.Context, configID string, config *models.TrialRewardConfig) error {
	dbCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()

	// Serialize config to JSON
	configJSON, err := json.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal trial config: %w", err)
	}

	query := `
		UPDATE time_trials.trial_configs
		SET config_data = $1, updated_at = $2
		WHERE id = $3 AND is_active = true
	`

	result, err := r.pool.Exec(dbCtx, query, string(configJSON), time.Now().UTC(), configID)
	if err != nil {
		r.logger.Error("Failed to update trial configuration",
			zap.String("config_id", configID),
			zap.Error(err))
		return fmt.Errorf("failed to update trial config: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("trial configuration not found: %s", configID)
	}

	r.logger.Info("Updated trial configuration",
		zap.String("config_id", configID))

	return nil
}

// ListTrialConfigs retrieves paginated list of trial configurations
func (r *Repository) ListTrialConfigs(ctx context.Context, limit, offset int) ([]*TrialConfigRecord, error) {
	dbCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()

	query := `
		SELECT id, trial_id, name, description, config_data, is_active, created_at, updated_at, created_by
		FROM time_trials.trial_configs
		WHERE is_active = true
		ORDER BY updated_at DESC
		LIMIT $1 OFFSET $2
	`

	rows, err := r.pool.Query(dbCtx, query, limit, offset)
	if err != nil {
		r.logger.Error("Failed to list trial configurations", zap.Error(err))
		return nil, fmt.Errorf("failed to list trial configs: %w", err)
	}
	defer rows.Close()

	var configs []*TrialConfigRecord
	for rows.Next() {
		var config TrialConfigRecord
		err := rows.Scan(
			&config.ID,
			&config.TrialID,
			&config.Name,
			&config.Description,
			&config.ConfigData,
			&config.IsActive,
			&config.CreatedAt,
			&config.UpdatedAt,
			&config.CreatedBy,
		)
		if err != nil {
			r.logger.Error("Failed to scan trial configuration row", zap.Error(err))
			continue
		}
		configs = append(configs, &config)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating trial configuration rows", zap.Error(err))
		return nil, fmt.Errorf("error iterating trial configs: %w", err)
	}

	return configs, nil
}