// Code generated by NECPGAME backend agent. Reward distributor for trial completions.
// Issue: #1508
// PERFORMANCE: Automated reward calculation and distribution

package reward

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/time-trials-service-go/internal/repository"
)

// Config holds reward distributor configuration
type Config struct {
	DB     *pgxpool.Pool
	Redis  *redis.Client
	Logger *zap.Logger
	Tracer trace.Tracer
	Meter  metric.Meter
	Repo   *repository.Repository
}

// Distributor manages reward calculation and distribution
type Distributor struct {
	db        *pgxpool.Pool
	redis     *redis.Client
	logger    *zap.Logger
	tracer    trace.Tracer
	meter     metric.Meter
	repo      *Repository
}

// NewDistributor creates a new reward distributor instance
func NewDistributor(cfg Config) (*Distributor, error) {
	if cfg.DB == nil || cfg.Redis == nil || cfg.Logger == nil || cfg.Repo == nil {
		return nil, errors.New("database, redis, logger, and repository are required")
	}

	return &Distributor{
		db:     cfg.DB,
		redis:  cfg.Redis,
		logger: cfg.Logger,
		tracer: cfg.Tracer,
		meter:  cfg.Meter,
		repo:   cfg.Repo,
	}, nil
}

// CalculateRewards determines rewards based on completion time and trial configuration
func (d *Distributor) CalculateRewards(ctx context.Context, trialID uuid.UUID, completionTime int, difficulty string) (*RewardPackage, error) {
	ctx, span := d.tracer.Start(ctx, "reward.CalculateRewards")
	defer span.End()

	// Get trial configuration
	trialConfig, err := d.getTrialConfig(ctx, trialID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get trial config")
	}

	package_ := &RewardPackage{
		TrialID:        trialID,
		CompletionTime: completionTime,
		Difficulty:     difficulty,
		Tier:           d.calculateTier(completionTime, trialConfig),
		Rewards:        RewardTiers{},
	}

	// Calculate rewards based on tier
	switch package_.Tier {
	case TierBronze:
		package_.Rewards = trialConfig.BronzeRewards
	case TierSilver:
		package_.Rewards = trialConfig.SilverRewards
	case TierGold:
		package_.Rewards = trialConfig.GoldRewards
	case TierPlatinum:
		package_.Rewards = trialConfig.PlatinumRewards
	}

	// Apply difficulty multipliers
	d.applyDifficultyMultiplier(package_, difficulty)

	return package_, nil
}

// DistributeRewards applies calculated rewards to player
func (d *Distributor) DistributeRewards(ctx context.Context, playerID string, package_ *RewardPackage) error {
	ctx, span := d.tracer.Start(ctx, "reward.DistributeRewards")
	defer span.End()

	d.logger.Info("Starting reward distribution",
		zap.String("player_id", playerID),
		zap.String("trial_id", package_.TrialID.String()),
		zap.String("tier", string(package_.Tier)),
		zap.Int("completion_time", package_.CompletionTime))

	// Distribute experience points
	if err := d.distributeExperience(ctx, playerID, package_.Rewards.Experience); err != nil {
		d.logger.Error("Failed to distribute experience", zap.Error(err))
		return errors.Wrap(err, "experience distribution failed")
	}

	// Distribute currency rewards
	if err := d.distributeCurrency(ctx, playerID, &package_.Rewards.Currency); err != nil {
		d.logger.Error("Failed to distribute currency", zap.Error(err))
		return errors.Wrap(err, "currency distribution failed")
	}

	// Distribute item rewards
	if err := d.distributeItems(ctx, playerID, package_.Rewards.Items); err != nil {
		d.logger.Error("Failed to distribute items", zap.Error(err))
		return errors.Wrap(err, "item distribution failed")
	}

	// Grant achievements
	if err := d.grantAchievements(ctx, playerID, package_.Rewards.Achievements); err != nil {
		d.logger.Error("Failed to grant achievements", zap.Error(err))
		return errors.Wrap(err, "achievement granting failed")
	}

	// Record reward distribution in database
	if err := d.recordRewardDistribution(ctx, playerID, package_); err != nil {
		d.logger.Error("Failed to record reward distribution", zap.Error(err))
		// Don't fail the entire operation for logging errors
	}

	// Cache reward distribution for tracking
	rewardKey := "reward_distribution:" + uuid.New().String()
	rewardData := map[string]interface{}{
		"player_id":       playerID,
		"trial_id":        package_.TrialID.String(),
		"tier":           string(package_.Tier),
		"completion_time": package_.CompletionTime,
		"experience":      package_.Rewards.Experience,
		"gold":           package_.Rewards.Currency.Gold,
		"seasonal_tokens": package_.Rewards.Currency.SeasonalTokens,
		"items_count":    len(package_.Rewards.Items),
		"timestamp":       time.Now().UTC().Unix(),
	}

	if err := d.redis.HSet(ctx, rewardKey, rewardData).Err(); err != nil {
		d.logger.Error("Failed to cache reward distribution", zap.Error(err))
	} else {
		d.redis.Expire(ctx, rewardKey, 24*time.Hour)
	}

	d.logger.Info("Rewards distributed successfully",
		zap.String("player_id", playerID),
		zap.String("trial_id", package_.TrialID.String()),
		zap.String("tier", string(package_.Tier)),
		zap.Int("experience", package_.Rewards.Experience),
		zap.Int("gold", package_.Rewards.Currency.Gold),
		zap.Int("seasonal_tokens", package_.Rewards.Currency.SeasonalTokens),
		zap.Int("items_count", len(package_.Rewards.Items)),
		zap.Int("achievements_count", len(package_.Rewards.Achievements)))

	return nil
}

// calculateTier determines reward tier based on completion time
func (d *Distributor) calculateTier(completionTime int, config *TrialConfig) RewardTier {
	if completionTime <= config.PlatinumTime {
		return TierPlatinum
	}
	if completionTime <= config.GoldTime {
		return TierGold
	}
	if completionTime <= config.SilverTime {
		return TierSilver
	}
	return TierBronze
}

// applyDifficultyMultiplier adjusts rewards based on difficulty
func (d *Distributor) applyDifficultyMultiplier(package_ *RewardPackage, difficulty string) {
	multiplier := 1.0

	switch difficulty {
	case "heroic":
		multiplier = 1.5
	case "mythic":
		multiplier = 2.0
	case "legendary":
		multiplier = 3.0
	}

	package_.Rewards.Experience = int(float64(package_.Rewards.Experience) * multiplier)
	package_.Rewards.Currency.Gold = int(float64(package_.Rewards.Currency.Gold) * multiplier)
	package_.Rewards.Currency.SeasonalTokens = int(float64(package_.Rewards.Currency.SeasonalTokens) * multiplier)
}

// getTrialConfig retrieves trial reward configuration from database
func (d *Distributor) getTrialConfig(ctx context.Context, trialID uuid.UUID) (*TrialConfig, error) {
	// PERFORMANCE: Database config retrieval with fallback to defaults
	config, err := d.repo.GetTrialConfig(ctx, trialID)
	if err != nil {
		d.logger.Error("Failed to retrieve trial configuration from database",
			zap.String("trial_id", trialID.String()),
			zap.Error(err))
		return nil, fmt.Errorf("failed to get trial config: %w", err)
	}

	d.logger.Debug("Retrieved trial configuration",
		zap.String("trial_id", trialID.String()),
		zap.Int("bronze_time", config.BronzeTime),
		zap.Int("gold_time", config.GoldTime))

	return config, nil
}

// RewardTier represents reward tier levels
type RewardTier string

const (
	TierBronze   RewardTier = "bronze"
	TierSilver   RewardTier = "silver"
	TierGold     RewardTier = "gold"
	TierPlatinum RewardTier = "platinum"
)

// RewardPackage represents calculated rewards for trial completion
type RewardPackage struct {
	TrialID        uuid.UUID  `json:"trial_id"`
	CompletionTime int        `json:"completion_time"`
	Difficulty     string     `json:"difficulty"`
	Tier           RewardTier `json:"tier"`
	Rewards        RewardTiers `json:"rewards"`
}

// RewardTiers represents rewards for different tiers
type RewardTiers struct {
	Experience int            `json:"experience"`
	Currency   CurrencyReward `json:"currency"`
	Items      []ItemReward   `json:"items,omitempty"`
	Achievements []string     `json:"achievements,omitempty"`
}

// CurrencyReward represents currency rewards
type CurrencyReward struct {
	Gold           int `json:"gold"`
	SeasonalTokens int `json:"seasonal_tokens"`
}

// ItemReward represents item rewards
type ItemReward struct {
	ItemID   string `json:"item_id"`
	Quantity int    `json:"quantity"`
}

// TrialConfig represents trial reward configuration
type TrialConfig struct {
	BronzeTime      int         `json:"bronze_time"`
	SilverTime      int         `json:"silver_time"`
	GoldTime        int         `json:"gold_time"`
	PlatinumTime    int         `json:"platinum_time"`
	BronzeRewards   RewardTiers `json:"bronze_rewards"`
	SilverRewards   RewardTiers `json:"silver_rewards"`
	GoldRewards     RewardTiers `json:"gold_rewards"`
	PlatinumRewards RewardTiers `json:"platinum_rewards"`
}

// distributeExperience adds experience points to player profile
func (d *Distributor) distributeExperience(ctx context.Context, playerID string, experience int) error {
	const query = `
		UPDATE players
		SET experience = experience + $1,
		    updated_at = CURRENT_TIMESTAMP
		WHERE id = $2
	`

	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return errors.Wrap(err, "invalid player ID format")
	}

	result, err := d.db.Exec(ctx, query, experience, playerUUID)
	if err != nil {
		return errors.Wrap(err, "failed to update player experience")
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		d.logger.Warn("Player not found for experience distribution",
			zap.String("player_id", playerID))
	}

	d.logger.Debug("Experience distributed",
		zap.String("player_id", playerID),
		zap.Int("experience", experience))

	return nil
}

// distributeCurrency adds currency to player economy balance
func (d *Distributor) distributeCurrency(ctx context.Context, playerID string, currency *CurrencyReward) error {
	if currency.Gold == 0 && currency.SeasonalTokens == 0 {
		return nil // No currency to distribute
	}

	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return errors.Wrap(err, "invalid player ID format")
	}

	// Update gold balance
	if currency.Gold > 0 {
		const goldQuery = `
			INSERT INTO player_economy (player_id, gold_balance, created_at, updated_at)
			VALUES ($1, $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
			ON CONFLICT (player_id) DO UPDATE SET
				gold_balance = player_economy.gold_balance + $2,
				updated_at = CURRENT_TIMESTAMP
		`

		_, err := d.db.Exec(ctx, goldQuery, playerUUID, currency.Gold)
		if err != nil {
			return errors.Wrap(err, "failed to update gold balance")
		}
	}

	// Update seasonal tokens
	if currency.SeasonalTokens > 0 {
		const tokenQuery = `
			INSERT INTO player_seasonal_tokens (player_id, tokens, created_at, updated_at)
			VALUES ($1, $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
			ON CONFLICT (player_id) DO UPDATE SET
				tokens = player_seasonal_tokens.tokens + $2,
				updated_at = CURRENT_TIMESTAMP
		`

		_, err := d.db.Exec(ctx, tokenQuery, playerUUID, currency.SeasonalTokens)
		if err != nil {
			return errors.Wrap(err, "failed to update seasonal tokens")
		}
	}

	d.logger.Debug("Currency distributed",
		zap.String("player_id", playerID),
		zap.Int("gold", currency.Gold),
		zap.Int("seasonal_tokens", currency.SeasonalTokens))

	return nil
}

// distributeItems adds items to player inventory
func (d *Distributor) distributeItems(ctx context.Context, playerID string, items []ItemReward) error {
	if len(items) == 0 {
		return nil // No items to distribute
	}

	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return errors.Wrap(err, "invalid player ID format")
	}

	for _, item := range items {
		const query = `
			INSERT INTO player_inventory (player_id, item_id, quantity, created_at, updated_at)
			VALUES ($1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
			ON CONFLICT (player_id, item_id) DO UPDATE SET
				quantity = player_inventory.quantity + $3,
				updated_at = CURRENT_TIMESTAMP
		`

		_, err := d.db.Exec(ctx, query, playerUUID, item.ItemID, item.Quantity)
		if err != nil {
			d.logger.Error("Failed to add item to inventory",
				zap.Error(err),
				zap.String("player_id", playerID),
				zap.String("item_id", item.ItemID),
				zap.Int("quantity", item.Quantity))
			continue // Continue with other items
		}
	}

	d.logger.Debug("Items distributed",
		zap.String("player_id", playerID),
		zap.Int("items_count", len(items)))

	return nil
}

// grantAchievements awards achievements to player
func (d *Distributor) grantAchievements(ctx context.Context, playerID string, achievements []string) error {
	if len(achievements) == 0 {
		return nil // No achievements to grant
	}

	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return errors.Wrap(err, "invalid player ID format")
	}

	for _, achievementID := range achievements {
		const query = `
			INSERT INTO player_achievements (player_id, achievement_id, unlocked_at, created_at, updated_at)
			VALUES ($1, $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
			ON CONFLICT (player_id, achievement_id) DO NOTHING
		`

		result, err := d.db.Exec(ctx, query, playerUUID, achievementID)
		if err != nil {
			d.logger.Error("Failed to grant achievement",
				zap.Error(err),
				zap.String("player_id", playerID),
				zap.String("achievement_id", achievementID))
			continue // Continue with other achievements
		}

		rowsAffected := result.RowsAffected()
		if rowsAffected > 0 {
			d.logger.Info("Achievement granted",
				zap.String("player_id", playerID),
				zap.String("achievement_id", achievementID))
		}
	}

	d.logger.Debug("Achievements processed",
		zap.String("player_id", playerID),
		zap.Int("achievements_count", len(achievements)))

	return nil
}

// recordRewardDistribution logs reward distribution to database
func (d *Distributor) recordRewardDistribution(ctx context.Context, playerID string, package_ *RewardPackage) error {
	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return errors.Wrap(err, "invalid player ID format")
	}

	rewardsJSON, err := json.Marshal(package_.Rewards)
	if err != nil {
		return errors.Wrap(err, "failed to marshal rewards")
	}

	const query = `
		INSERT INTO time_trial_completions (
			id, player_id, trial_id, completion_time, tier, rewards, created_at
		) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
	`

	completionID := uuid.New()

	_, err = d.db.Exec(ctx, query,
		completionID,
		playerUUID,
		package_.TrialID,
		package_.CompletionTime,
		string(package_.Tier),
		rewardsJSON,
	)

	if err != nil {
		return errors.Wrap(err, "failed to record reward distribution")
	}

	d.logger.Debug("Reward distribution recorded",
		zap.String("completion_id", completionID.String()),
		zap.String("player_id", playerID),
		zap.String("trial_id", package_.TrialID.String()))

	return nil
}





