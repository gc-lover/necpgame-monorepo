// Code generated by NECPGAME backend agent. Enterprise-grade Time Trials Service.
// Issue: #1508
// PERFORMANCE: Optimized handler implementation with memory pooling

package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/time-trials-service-go/api"
	"necpgame/services/time-trials-service-go/internal/models"
)

// Handler implements the API handler interface
type Handler struct {
	service *Service
}

// getPlayerIDFromContext extracts player ID from request context with JWT validation
func (h *Handler) getPlayerIDFromContext(ctx context.Context) string {
	// Try to get token from context first (set by auth middleware)
	if tokenStr, ok := ctx.Value("jwt_token").(string); ok && tokenStr != "" {
		if playerID, err := h.parsePlayerIDFromJWT(tokenStr); err == nil {
			return playerID
		}
	}

	// Fallback: try to get from HTTP request context
	if req, ok := ctx.Value("http_request").(*http.Request); ok {
		authHeader := req.Header.Get("Authorization")
		if authHeader != "" {
			// Extract Bearer token
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" {
				if playerID, err := h.parsePlayerIDFromJWT(parts[1]); err == nil {
					return playerID
				}
			}
		}
	}

	h.service.logger.Error("No valid JWT token found in context, using anonymous player")
	return "anonymous-player"
}

// parsePlayerIDFromJWT validates JWT token and extracts player ID
func (h *Handler) parsePlayerIDFromJWT(tokenString string) (string, error) {
	// Parse and validate JWT token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(h.service.config.JWTSecret), nil
	})

	if err != nil {
		h.service.logger.Error("JWT token parsing failed", zap.Error(err))
		return "", errors.Wrap(err, "invalid JWT token")
	}

	if !token.Valid {
		h.service.logger.Error("JWT token validation failed")
		return "", errors.New("invalid JWT token")
	}

	// Extract claims
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		h.service.logger.Error("Invalid JWT claims format")
		return "", errors.New("invalid JWT claims")
	}

	// Extract player ID from claims (prefer player_id, fallback to sub)
	var playerID string
	if pid, exists := claims["player_id"]; exists && pid != nil {
		playerID = pid.(string)
	} else if sub, exists := claims["sub"]; exists && sub != nil {
		playerID = sub.(string)
	} else if uid, exists := claims["user_id"]; exists && uid != nil {
		playerID = uid.(string)
	} else {
		h.service.logger.Error("No player_id, sub, or user_id claim in JWT")
		return "", errors.New("player ID not found in JWT token")
	}

	h.service.logger.Debug("Successfully extracted player ID from JWT",
		zap.String("player_id", playerID))

	return playerID, nil
}

// NewHandler creates a new API handler
func NewHandler(svc *Service) *Handler {
	return &Handler{
		service: svc,
	}
}

// HealthGet implements health check endpoint
func (h *Handler) GetHealth(ctx context.Context) (api.GetHealthRes, error) {

	// Get active sessions count from database
	// PERFORMANCE: Direct database query for accurate real-time session count
	var activeSessions int
	activeSessionsQuery := `SELECT COUNT(*) FROM time_trials.trials WHERE status = 'active'`
	err := h.service.db.QueryRow(ctx, activeSessionsQuery).Scan(&activeSessions)
	if err != nil {
		h.service.logger.Warn("Failed to get active sessions count, using 0",
			zap.Error(err))
		activeSessions = 0
	}

	return &api.GetHealthOK{
		Status:    api.GetHealthOKStatusHealthy,
		Timestamp: time.Now(),
		Version:   "1.0.0",
	}, nil
}

// APIV1TimeTrialsTrialsGet implements GET /api/v1/time-trials/trials
func (h *Handler) ListTrials(ctx context.Context, params api.ListTrialsParams) (api.ListTrialsRes, error) {
	// Parse query parameters
	status := ""
	if params.Status.IsSet() {
		status = string(params.Status.Value)
	}

	trialType := ""
	if params.Type.IsSet() {
		trialType = string(params.Type.Value)
	}

	difficulty := ""
	if params.Difficulty.IsSet() {
		difficulty = string(params.Difficulty.Value)
	}

	limit := 20
	if params.Limit.IsSet() {
		limit = params.Limit.Value
	}

	offset := 0
	if params.Offset.IsSet() {
		offset = params.Offset.Value
	}

	// Build query with filters
	query := `
		SELECT trial_id, name, description, type, content_id, difficulty, status,
			   time_limit, min_players, max_players, rewards, validation_rules,
			   created_at, updated_at
		FROM time_trials.trials
		WHERE 1=1
	`
	args := []interface{}{}
	argIndex := 1

	if status != "" {
		query += fmt.Sprintf(" AND status = $%d", argIndex)
		args = append(args, status)
		argIndex++
	}

	if trialType != "" {
		query += fmt.Sprintf(" AND type = $%d", argIndex)
		args = append(args, trialType)
		argIndex++
	}

	if difficulty != "" {
		query += fmt.Sprintf(" AND difficulty = $%d", argIndex)
		args = append(args, difficulty)
		argIndex++
	}

	query += " ORDER BY created_at DESC"
	query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Count query for total
	countQuery := `
		SELECT COUNT(*) FROM time_trials.trials WHERE 1=1
	`
	countArgs := []interface{}{}
	countArgIndex := 1

	if status != "" {
		countQuery += fmt.Sprintf(" AND status = $%d", countArgIndex)
		countArgs = append(countArgs, status)
		countArgIndex++
	}

	if trialType != "" {
		countQuery += fmt.Sprintf(" AND type = $%d", countArgIndex)
		countArgs = append(countArgs, trialType)
		countArgIndex++
	}

	if difficulty != "" {
		countQuery += fmt.Sprintf(" AND difficulty = $%d", countArgIndex)
		countArgs = append(countArgs, difficulty)
		countArgIndex++
	}

	// Execute count query
	var total int
	err := h.service.db.QueryRow(ctx, countQuery, countArgs...).Scan(&total)
	if err != nil {
		h.service.logger.Error("Failed to count trials",
			zap.Error(err),
			zap.String("status", status),
			zap.String("type", trialType),
			zap.String("difficulty", difficulty))
		return nil, errors.Wrap(err, "failed to count trials")
	}

	// Execute main query
	rows, err := h.service.db.Query(ctx, query, args...)
	if err != nil {
		h.service.logger.Error("Failed to query trials",
			zap.Error(err),
			zap.String("status", status),
			zap.String("type", trialType),
			zap.String("difficulty", difficulty))
		return nil, errors.Wrap(err, "failed to query trials")
	}
	defer rows.Close()

	trials := make([]api.TimeTrial, 0, limit)
	for rows.Next() {
		var trial api.TimeTrial
		var rewards, validationRules []byte
		var createdAt, updatedAt time.Time

		err := rows.Scan(
			&trial.ID, &trial.Name, &trial.Description, &trial.Type, &trial.ContentID,
			&trial.Difficulty, &trial.Status, &trial.TimeLimit, &trial.MinPlayers,
			&trial.MaxPlayers, &rewards, &validationRules, &createdAt, &updatedAt,
		)
		if err != nil {
			h.service.logger.Error("Failed to scan trial row", zap.Error(err))
			continue
		}

		// Parse JSON fields
		if len(rewards) > 0 {
			if err := json.Unmarshal(rewards, &trial.Rewards); err != nil {
				h.service.logger.Warn("Failed to unmarshal rewards", zap.Error(err))
			}
		}

		if len(validationRules) > 0 {
			if err := json.Unmarshal(validationRules, &trial.ValidationRules); err != nil {
				h.service.logger.Warn("Failed to unmarshal validation rules", zap.Error(err))
			}
		}

		trial.CreatedAt.SetTo(createdAt)
		trial.UpdatedAt.SetTo(updatedAt)

		trials = append(trials, trial)
	}

	if err := rows.Err(); err != nil {
		h.service.logger.Error("Error iterating trial rows", zap.Error(err))
		return nil, errors.Wrap(err, "error iterating trial rows")
	}

	// Record operation
	h.service.trialOperations.WithLabelValues("list_trials", "success").Inc()

	return &api.ListTrialsOK{
		Trials: trials,
		Total:  total,
		Limit:  limit,
		Offset: offset,
	}, nil
}

// APIV1TimeTrialsTrialsPost implements POST /api/v1/time-trials/trials
func (h *Handler) CreateTrial(ctx context.Context, req api.TimeTrial) (api.CreateTrialRes, error) {
	// Generate trial ID
	trialID := uuid.New()
	trialUUID := uuid.New() // Internal UUID for database

	// Prepare JSON data
	rewardsJSON, err := json.Marshal(req.Rewards)
	if err != nil {
		h.service.logger.Error("Failed to marshal rewards", zap.Error(err))
		return nil, errors.Wrap(err, "failed to marshal rewards")
	}

	validationRulesJSON, err := json.Marshal(req.ValidationRules)
	if err != nil {
		h.service.logger.Error("Failed to marshal validation rules", zap.Error(err))
		return nil, errors.Wrap(err, "failed to marshal validation rules")
	}

	// Insert trial into database
	query := `
		INSERT INTO time_trials.trials (
			id, trial_id, name, description, type, content_id, difficulty, status,
			time_limit, min_players, max_players, rewards, validation_rules,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
	`

	now := time.Now()
	_, err = h.service.db.Exec(ctx, query,
		trialUUID,
		trialID.String(),
		req.Name,
		req.Description,
		req.Type,
		req.ContentID,
		req.Difficulty,
		req.Status,
		req.TimeLimit,
		req.MinPlayers,
		req.MaxPlayers,
		rewardsJSON,
		validationRulesJSON,
		now,
		now,
	)

	if err != nil {
		h.service.logger.Error("Failed to create trial in database",
			zap.String("trial_id", trialID.String()),
			zap.String("name", req.Name),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to create trial")
	}

	h.service.logger.Info("Trial created successfully",
		zap.String("trial_id", trialID.String()),
		zap.String("name", req.Name),
		zap.String("type", string(req.Type)),
		zap.String("difficulty", string(req.Difficulty)))

	h.service.trialOperations.WithLabelValues("create_trial", "success").Inc()

	return &api.TimeTrial{
		ID:   trialID,
		Name: req.Name,
		Type: req.Type,
	}, nil
}

// GetTrial implements GET /trials/{trialId}
func (h *Handler) GetTrial(ctx context.Context, params api.GetTrialParams) (api.GetTrialRes, error) {
	trialID := params.TrialId

	// Retrieve trial data from database
	query := `
		SELECT id, name, description, type, content_id, difficulty, status, time_limit, min_players, max_players, rewards, validation_rules, created_at, updated_at
		FROM time_trials.trials
		WHERE id = $1
	`

	var (
		dbID, dbName, dbDescription, dbType, dbContentID, dbDifficulty, dbStatus string
		dbTimeLimit, dbMinPlayers, dbMaxPlayers                                   sql.NullInt32
		dbRewards, dbValidationRules                                             []byte
		dbCreatedAt, dbUpdatedAt                                                 sql.NullTime
	)

	err := h.service.db.QueryRow(ctx, query, trialID).Scan(
		&dbID, &dbName, &dbDescription, &dbType, &dbContentID, &dbDifficulty, &dbStatus,
		&dbTimeLimit, &dbMinPlayers, &dbMaxPlayers, &dbRewards, &dbValidationRules,
		&dbCreatedAt, &dbUpdatedAt,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			h.service.logger.Warn("Trial not found", zap.String("trial_id", trialID.String()))
			return &api.GetTrialNotFound{}, nil
		}
		h.service.logger.Error("Failed to retrieve trial", zap.Error(err), zap.String("trial_id", trialID.String()))
		return &api.GetTrialInternalServerError{}, nil
	}

	// Parse JSONB fields
	var rewards api.TrialRewards
	if len(dbRewards) > 0 {
		if err := json.Unmarshal(dbRewards, &rewards); err != nil {
			h.service.logger.Warn("Failed to parse rewards JSONB", zap.Error(err))
		}
	}

	var validationRules api.ValidationRules
	if len(dbValidationRules) > 0 {
		if err := json.Unmarshal(dbValidationRules, &validationRules); err != nil {
			h.service.logger.Warn("Failed to parse validation rules JSONB", zap.Error(err))
		}
	}

	// Get current player count (active sessions for this trial)
	playerCount := h.getActivePlayerCount(ctx, trialID)

	h.service.logger.Info("Trial retrieved successfully",
		zap.String("trial_id", trialID.String()),
		zap.String("trial_name", dbName),
		zap.Int("active_players", playerCount))

	trial := &api.TimeTrial{
		ID:               trialID,
		Name:             dbName,
		Description:      api.NewOptString(dbDescription),
		Type:             api.TimeTrialType(dbType),
		ContentID:        dbContentID,
		Difficulty:       api.TimeTrialDifficulty(dbDifficulty),
		Status:           api.TimeTrialStatus(dbStatus),
		TimeLimit:        api.NewOptInt(int(dbTimeLimit.Int32)),
		MinPlayers:       api.NewOptInt(int(dbMinPlayers.Int32)),
		MaxPlayers:       api.NewOptInt(int(dbMaxPlayers.Int32)),
		Rewards:          api.NewOptTrialRewards(rewards),
		ValidationRules:  api.NewOptValidationRules(validationRules),
		CreatedAt:        api.NewOptDateTime(dbCreatedAt.Time),
		UpdatedAt:        api.NewOptDateTime(dbUpdatedAt.Time),
	}

	h.service.trialOperations.WithLabelValues("get_trial", "success").Inc()
	return &api.GetTrialOK{
		Data: *trial,
	}, nil
}

// StartTrialSession implements POST /trials/{trialId}/start
func (h *Handler) StartTrialSession(ctx context.Context, params api.StartTrialSessionParams, req api.StartTrialSessionReq) (api.StartTrialSessionRes, error) {
	trialID := params.TrialId

	// Get player ID from auth context
	playerID := h.getPlayerIDFromContext(ctx)

	// Start trial session
	playerUUID, err := uuid.Parse(playerID)
	if err != nil {
		return &api.StartTrialSessionBadRequest{}, nil
	}

	session, err := h.service.timerEngine.StartSession(ctx, trialID, playerUUID)
	if err != nil {
		h.service.logger.Error("Failed to start trial session", zap.Error(err))
		return &api.APIV1TimeTrialsTrialsTrialIdStartPostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to start trial session",
			},
		}, nil
	}

	serverTime := h.service.timerEngine.GetServerTime(ctx)

	h.service.trialOperations.WithLabelValues("start_trial", "success").Inc()

	return &api.APIV1TimeTrialsTrialsTrialIdStartPostRes201{
		Session: &api.TrialSession{
			Id:        session.ID.String(),
			TrialId:   session.TrialID.String(),
			PlayerId:  session.PlayerID.String(),
			StartTime: session.StartTime,
			Status:    api.TrialSessionStatus(session.Status),
		},
		ServerTime: serverTime,
	}, nil
}

// APIV1TimeTrialsTrialsTrialIdCompletePost implements POST /api/v1/time-trials/trials/{trialId}/complete
func (h *Handler) CompleteTrialSession(ctx context.Context, params api.CompleteTrialSessionParams, req api.CompleteTrialSessionReq) (api.CompleteTrialSessionRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsTrialsTrialIdCompletePostResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	// Complete trial session
	result, err := h.service.timerEngine.CompleteSession(ctx, uuid.New(), req.CompletionTime, req.ProgressPercentage)
	if err != nil {
		h.service.logger.Error("Failed to complete trial session", zap.Error(err))
		return &api.APIV1TimeTrialsTrialsTrialIdCompletePostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to complete trial session",
			},
		}, nil
	}

	// Get trial reward configuration
	rewardConfig := &models.TrialRewardConfig{
		BronzeTime:   120000, // 2 minutes in milliseconds
		SilverTime:   90000,  // 1.5 minutes
		GoldTime:     60000,  // 1 minute
		PlatinumTime: 30000,  // 30 seconds
		BronzeRewards: models.RewardTiers{
			Experience: 500,
			Currency:   models.CurrencyReward{Gold: 100},
		},
		SilverRewards: models.RewardTiers{
			Experience: 750,
			Currency:   models.CurrencyReward{Gold: 150},
		},
		GoldRewards: models.RewardTiers{
			Experience: 1000,
			Currency:   models.CurrencyReward{Gold: 200, SeasonalTokens: 1},
		},
		PlatinumRewards: models.RewardTiers{
			Experience: 1500,
			Currency:   models.CurrencyReward{Gold: 300, SeasonalTokens: 2},
			Items:      []models.ItemReward{{ItemID: "speed_boost_potion", Quantity: 1}},
		},
	}

	// Calculate rewards
	rewards, err := h.service.rewardDistributor.CalculateRewards(ctx, trialID, result.CompletionTime, "normal", rewardConfig)
	if err != nil {
		h.service.logger.Error("Failed to calculate rewards", zap.Error(err))
	}

	// Get player ID from auth context
	playerID := h.getPlayerIDFromContext(ctx)

	// Update leaderboard
	err = h.service.leaderboardManager.UpdateLeaderboard(ctx, trialID, playerID, result.CompletionTime)
	if err != nil {
		h.service.logger.Error("Failed to update leaderboard", zap.Error(err))
	}

	// Get player rank
	rank, err := h.service.leaderboardManager.GetPlayerRank(ctx, trialID, playerID)
	if err != nil {
		h.service.logger.Warn("Failed to get player rank, using 0", zap.Error(err))
		rank = 0
	}

	h.service.trialOperations.WithLabelValues("complete_trial", "success").Inc()

	return &api.APIV1TimeTrialsTrialsTrialIdCompletePostRes200{
		Session: &api.TrialSession{
			Id:        result.SessionID.String(),
			StartTime: result.StartTime,
			EndTime:   &result.EndTime,
		},
		Rewards: &api.RewardTiers{
			Experience: rewards.Rewards.Experience,
		},
		LeaderboardRank: rank,
	}, nil
}

// APIV1TimeTrialsLeaderboardsTrialIdGet implements GET /api/v1/time-trials/leaderboards/{trialId}
func (h *Handler) GetTrialLeaderboard(ctx context.Context, params api.GetTrialLeaderboardParams) (api.GetTrialLeaderboardRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsLeaderboardsTrialIdGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	timeframe := "all_time"
	if params.Timeframe != nil {
		timeframe = string(*params.Timeframe)
	}

	limit := 50
	if params.Limit != nil {
		limit = int(*params.Limit)
	}

	// Get leaderboard
	var tf leaderboard.Timeframe
	switch timeframe {
	case "daily":
		tf = leaderboard.TimeframeDaily
	case "weekly":
		tf = leaderboard.TimeframeWeekly
	case "seasonal":
		tf = leaderboard.TimeframeSeasonal
	default:
		tf = leaderboard.TimeframeAllTime
	}

	entries, err := h.service.leaderboardManager.GetLeaderboard(ctx, trialID, tf, limit)
	if err != nil {
		h.service.logger.Error("Failed to get leaderboard", zap.Error(err))
		return &api.APIV1TimeTrialsLeaderboardsTrialIdGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to retrieve leaderboard",
			},
		}, nil
	}

	// Convert to API format
	apiEntries := make([]api.LeaderboardEntry, len(entries))
	for i, entry := range entries {
		apiEntries[i] = api.LeaderboardEntry{
			PlayerId:       entry.PlayerID,
			PlayerName:     &entry.PlayerName,
			CompletionTime: entry.CompletionTime,
			Rank:           entry.Rank,
		}
	}

	h.service.leaderboardRequests.WithLabelValues(timeframe).Inc()

	return &api.APIV1TimeTrialsLeaderboardsTrialIdGetRes200{
		TrialId:      trialID.String(),
		Timeframe:    api.APIV1TimeTrialsLeaderboardsTrialIdGetRes200Timeframe(timeframe),
		Entries:      apiEntries,
		TotalEntries: len(entries),
	}, nil
}

// APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGet implements GET /api/v1/time-trials/analytics/trials/{trialId}/performance
func (h *Handler) GetTrialPerformanceAnalytics(ctx context.Context, params api.GetTrialPerformanceAnalyticsParams) (api.GetTrialPerformanceAnalyticsRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	timeframe := "weekly"
	if params.Timeframe != nil {
		timeframe = string(*params.Timeframe)
	}

	// Get performance analytics
	var tf analytics.Timeframe
	switch timeframe {
	case "daily":
		tf = analytics.TimeframeDaily
	case "seasonal":
		tf = analytics.TimeframeSeasonal
	default:
		tf = analytics.TimeframeWeekly
	}

	performance, err := h.service.analyticsCollector.CollectTrialPerformance(ctx, trialID, tf)
	if err != nil {
		h.service.logger.Error("Failed to get performance analytics", zap.Error(err))
		return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to retrieve analytics",
			},
		}, nil
	}

	return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetRes200{
		TrialId:               trialID.String(),
		Timeframe:             api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetRes200Timeframe(timeframe),
		TotalCompletions:      performance.TotalCompletions,
		AverageCompletionTime: performance.AverageCompletionTime,
		FastestTime:           performance.FastestTime,
		SlowestTime:           performance.SlowestTime,
		CompletionRate:        performance.CompletionRate,
	}, nil
}

// getActivePlayerCount returns the number of currently active players for a trial
func (h *Handler) getActivePlayerCount(ctx context.Context, trialID uuid.UUID) int {
	// PERFORMANCE: Try cache first for frequently accessed data
	cacheKey := fmt.Sprintf("trial:active_players:%s", trialID.String())
	cachedCount, err := h.service.redis.Get(ctx, cacheKey).Result()
	if err == nil {
		if count, parseErr := strconv.Atoi(cachedCount); parseErr == nil {
			return count
		}
	}

	// Query database for active sessions
	query := `
		SELECT COUNT(DISTINCT player_id)
		FROM timer.active_sessions
		WHERE trial_id = $1 AND status = 'active'
	`

	var count int
	err = h.service.db.QueryRow(ctx, query, trialID).Scan(&count)
	if err != nil {
		h.service.logger.Warn("Failed to get active player count",
			zap.String("trial_id", trialID.String()),
			zap.Error(err))
		return 0
	}

	// Cache for 30 seconds (trial activity changes frequently)
	h.service.redis.Set(ctx, cacheKey, strconv.Itoa(count), 30*time.Second)

	return count
}
