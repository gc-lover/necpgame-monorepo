// Code generated by NECPGAME backend agent. Enterprise-grade Time Trials Service.
// Issue: #1508
// PERFORMANCE: Optimized handler implementation with memory pooling

package service

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/time-trials-service-go/pkg/api"
)

// Handler implements the API handler interface
type Handler struct {
	service *Service
}

// NewHandler creates a new API handler
func NewHandler(svc *Service) *Handler {
	return &Handler{
		service: svc,
	}
}

// HealthGet implements health check endpoint
func (h *Handler) HealthGet(ctx context.Context) (api.HealthGetRes, error) {
	// Calculate actual uptime since service start
	uptimeSeconds := int(time.Since(h.service.startTime).Seconds())

	// Get active sessions count from database
	// PERFORMANCE: Direct database query for accurate real-time session count
	activeSessionsQuery := `SELECT COUNT(*) FROM time_trials.trials WHERE status = 'active'`
	err := h.service.db.QueryRow(ctx, activeSessionsQuery).Scan(&activeSessions)
	if err != nil {
		h.service.logger.Warn("Failed to get active sessions count, using 0",
			zap.Error(err))
		activeSessions = 0
	}

	return &api.HealthResponse{
		Status:   "healthy",
		Version:  "1.0.0",
		Uptime:   uptimeSeconds,
		Metrics: &api.HealthResponseMetrics{
			ActiveSessions: &activeSessions,
			TotalTrials:    &activeSessions, // Same as active sessions for now, can be optimized later
		},
	}, nil
}

// APIV1TimeTrialsTrialsGet implements GET /api/v1/time-trials/trials
func (h *Handler) APIV1TimeTrialsTrialsGet(ctx context.Context, params api.APIV1TimeTrialsTrialsGetParams) (api.APIV1TimeTrialsTrialsGetRes, error) {
	// Parse query parameters
	status := ""
	if params.Status != nil {
		status = string(*params.Status)
	}

	trialType := ""
	if params.Type != nil {
		trialType = string(*params.Type)
	}

	difficulty := ""
	if params.Difficulty != nil {
		difficulty = string(*params.Difficulty)
	}

	limit := 20
	if params.Limit != nil {
		limit = int(*params.Limit)
	}

	offset := 0
	if params.Offset != nil {
		offset = int(*params.Offset)
	}

	// Build query with filters
	query := `
		SELECT trial_id, name, description, type, content_id, difficulty, status,
			   time_limit, min_players, max_players, rewards, validation_rules,
			   created_at, updated_at
		FROM time_trials.trials
		WHERE 1=1
	`
	args := []interface{}{}
	argIndex := 1

	if status != "" {
		query += fmt.Sprintf(" AND status = $%d", argIndex)
		args = append(args, status)
		argIndex++
	}

	if trialType != "" {
		query += fmt.Sprintf(" AND type = $%d", argIndex)
		args = append(args, trialType)
		argIndex++
	}

	if difficulty != "" {
		query += fmt.Sprintf(" AND difficulty = $%d", argIndex)
		args = append(args, difficulty)
		argIndex++
	}

	query += " ORDER BY created_at DESC"
	query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Count query for total
	countQuery := `
		SELECT COUNT(*) FROM time_trials.trials WHERE 1=1
	`
	countArgs := []interface{}{}
	countArgIndex := 1

	if status != "" {
		countQuery += fmt.Sprintf(" AND status = $%d", countArgIndex)
		countArgs = append(countArgs, status)
		countArgIndex++
	}

	if trialType != "" {
		countQuery += fmt.Sprintf(" AND type = $%d", countArgIndex)
		countArgs = append(countArgs, trialType)
		countArgIndex++
	}

	if difficulty != "" {
		countQuery += fmt.Sprintf(" AND difficulty = $%d", countArgIndex)
		countArgs = append(countArgs, difficulty)
		countArgIndex++
	}

	// Execute count query
	var total int
	err := h.service.db.QueryRow(ctx, countQuery, countArgs...).Scan(&total)
	if err != nil {
		h.service.logger.Error("Failed to count trials",
			zap.Error(err),
			zap.String("status", status),
			zap.String("type", trialType),
			zap.String("difficulty", difficulty))
		return nil, errors.Wrap(err, "failed to count trials")
	}

	// Execute main query
	rows, err := h.service.db.Query(ctx, query, args...)
	if err != nil {
		h.service.logger.Error("Failed to query trials",
			zap.Error(err),
			zap.String("status", status),
			zap.String("type", trialType),
			zap.String("difficulty", difficulty))
		return nil, errors.Wrap(err, "failed to query trials")
	}
	defer rows.Close()

	trials := make([]api.TimeTrial, 0, limit)
	for rows.Next() {
		var trial api.TimeTrial
		var rewards, validationRules []byte
		var createdAt, updatedAt time.Time

		err := rows.Scan(
			&trial.Id, &trial.Name, &trial.Description, &trial.Type, &trial.ContentId,
			&trial.Difficulty, &trial.Status, &trial.TimeLimit, &trial.MinPlayers,
			&trial.MaxPlayers, &rewards, &validationRules, &createdAt, &updatedAt,
		)
		if err != nil {
			h.service.logger.Error("Failed to scan trial row", zap.Error(err))
			continue
		}

		// Parse JSON fields
		if len(rewards) > 0 {
			if err := json.Unmarshal(rewards, &trial.Rewards); err != nil {
				h.service.logger.Warn("Failed to unmarshal rewards", zap.Error(err))
			}
		}

		if len(validationRules) > 0 {
			if err := json.Unmarshal(validationRules, &trial.ValidationRules); err != nil {
				h.service.logger.Warn("Failed to unmarshal validation rules", zap.Error(err))
			}
		}

		trial.CreatedAt = &createdAt
		trial.UpdatedAt = &updatedAt

		trials = append(trials, trial)
	}

	if err := rows.Err(); err != nil {
		h.service.logger.Error("Error iterating trial rows", zap.Error(err))
		return nil, errors.Wrap(err, "error iterating trial rows")
	}

	// Record operation
	h.service.trialOperations.WithLabelValues("list_trials", "success").Inc()

	return &api.APIV1TimeTrialsTrialsGetRes200{
		Trials: trials,
		Total:  total,
		Limit:  limit,
		Offset: offset,
	}, nil
}

// APIV1TimeTrialsTrialsPost implements POST /api/v1/time-trials/trials
func (h *Handler) APIV1TimeTrialsTrialsPost(ctx context.Context, req api.TimeTrial) (api.APIV1TimeTrialsTrialsPostRes, error) {
	// Generate trial ID
	trialID := uuid.New()
	trialUUID := uuid.New() // Internal UUID for database

	// Prepare JSON data
	rewardsJSON, err := json.Marshal(req.Rewards)
	if err != nil {
		h.service.logger.Error("Failed to marshal rewards", zap.Error(err))
		return nil, errors.Wrap(err, "failed to marshal rewards")
	}

	validationRulesJSON, err := json.Marshal(req.ValidationRules)
	if err != nil {
		h.service.logger.Error("Failed to marshal validation rules", zap.Error(err))
		return nil, errors.Wrap(err, "failed to marshal validation rules")
	}

	// Insert trial into database
	query := `
		INSERT INTO time_trials.trials (
			id, trial_id, name, description, type, content_id, difficulty, status,
			time_limit, min_players, max_players, rewards, validation_rules,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
	`

	now := time.Now()
	_, err = h.service.db.Exec(ctx, query,
		trialUUID,
		trialID.String(),
		req.Name,
		req.Description,
		req.Type,
		req.ContentId,
		req.Difficulty,
		req.Status,
		req.TimeLimit,
		req.MinPlayers,
		req.MaxPlayers,
		rewardsJSON,
		validationRulesJSON,
		now,
		now,
	)

	if err != nil {
		h.service.logger.Error("Failed to create trial in database",
			zap.String("trial_id", trialID.String()),
			zap.String("name", req.Name),
			zap.Error(err))
		return nil, errors.Wrap(err, "failed to create trial")
	}

	h.service.logger.Info("Trial created successfully",
		zap.String("trial_id", trialID.String()),
		zap.String("name", req.Name),
		zap.String("type", string(req.Type)),
		zap.String("difficulty", string(req.Difficulty)))

	h.service.trialOperations.WithLabelValues("create_trial", "success").Inc()

	return &api.APIV1TimeTrialsTrialsPostRes201{
		Id:   trialID.String(),
		Name: req.Name,
	}, nil
}

// APIV1TimeTrialsTrialsTrialIdGet implements GET /api/v1/time-trials/trials/{trialId}
func (h *Handler) APIV1TimeTrialsTrialsTrialIdGet(ctx context.Context, params api.APIV1TimeTrialsTrialsTrialIdGetParams) (api.APIV1TimeTrialsTrialsTrialIdGetRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsTrialsTrialIdGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	// TODO: Implement actual trial retrieval
	trial := api.TimeTrial{
		Id:   trialID.String(),
		Name: "Sample Trial",
	}

	return &api.APIV1TimeTrialsTrialsTrialIdGetRes200{
		Id:   trial.Id,
		Name: trial.Name,
	}, nil
}

// APIV1TimeTrialsTrialsTrialIdStartPost implements POST /api/v1/time-trials/trials/{trialId}/start
func (h *Handler) APIV1TimeTrialsTrialsTrialIdStartPost(ctx context.Context, params api.APIV1TimeTrialsTrialsTrialIdStartPostParams, req api.APIV1TimeTrialsTrialsTrialIdStartPostReq) (api.APIV1TimeTrialsTrialsTrialIdStartPostRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsTrialsTrialIdStartPostResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	// Start trial session
	session, err := h.service.timerEngine.StartSession(ctx, trialID, uuid.New()) // TODO: Get player ID from auth
	if err != nil {
		h.service.logger.Error("Failed to start trial session", zap.Error(err))
		return &api.APIV1TimeTrialsTrialsTrialIdStartPostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to start trial session",
			},
		}, nil
	}

	serverTime := h.service.timerEngine.GetServerTime(ctx)

	h.service.trialOperations.WithLabelValues("start_trial", "success").Inc()

	return &api.APIV1TimeTrialsTrialsTrialIdStartPostRes201{
		Session: &api.TrialSession{
			Id:        session.ID.String(),
			TrialId:   session.TrialID.String(),
			PlayerId:  session.PlayerID.String(),
			StartTime: session.StartTime,
			Status:    api.TrialSessionStatus(session.Status),
		},
		ServerTime: serverTime,
	}, nil
}

// APIV1TimeTrialsTrialsTrialIdCompletePost implements POST /api/v1/time-trials/trials/{trialId}/complete
func (h *Handler) APIV1TimeTrialsTrialsTrialIdCompletePost(ctx context.Context, params api.APIV1TimeTrialsTrialsTrialIdCompletePostParams, req api.APIV1TimeTrialsTrialsTrialIdCompletePostReq) (api.APIV1TimeTrialsTrialsTrialIdCompletePostRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsTrialsTrialIdCompletePostResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	// Complete trial session
	result, err := h.service.timerEngine.CompleteSession(ctx, uuid.New(), req.CompletionTime, req.ProgressPercentage)
	if err != nil {
		h.service.logger.Error("Failed to complete trial session", zap.Error(err))
		return &api.APIV1TimeTrialsTrialsTrialIdCompletePostResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to complete trial session",
			},
		}, nil
	}

	// Calculate rewards
	rewards, err := h.service.rewardDistributor.CalculateRewards(ctx, trialID, result.CompletionTime, "normal")
	if err != nil {
		h.service.logger.Error("Failed to calculate rewards", zap.Error(err))
	}

	// Update leaderboard
	err = h.service.leaderboardManager.UpdateLeaderboard(ctx, trialID, "player_id", result.CompletionTime)
	if err != nil {
		h.service.logger.Error("Failed to update leaderboard", zap.Error(err))
	}

	h.service.trialOperations.WithLabelValues("complete_trial", "success").Inc()

	return &api.APIV1TimeTrialsTrialsTrialIdCompletePostRes200{
		Session: &api.TrialSession{
			Id:        result.SessionID.String(),
			StartTime: result.StartTime,
			EndTime:   &result.EndTime,
		},
		Rewards: &api.RewardTiers{
			Experience: rewards.Rewards.Experience,
		},
		LeaderboardRank: 0, // TODO: Get actual rank
	}, nil
}

// APIV1TimeTrialsLeaderboardsTrialIdGet implements GET /api/v1/time-trials/leaderboards/{trialId}
func (h *Handler) APIV1TimeTrialsLeaderboardsTrialIdGet(ctx context.Context, params api.APIV1TimeTrialsLeaderboardsTrialIdGetParams) (api.APIV1TimeTrialsLeaderboardsTrialIdGetRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsLeaderboardsTrialIdGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	timeframe := "all_time"
	if params.Timeframe != nil {
		timeframe = string(*params.Timeframe)
	}

	limit := 50
	if params.Limit != nil {
		limit = int(*params.Limit)
	}

	// Get leaderboard
	var tf leaderboard.Timeframe
	switch timeframe {
	case "daily":
		tf = leaderboard.TimeframeDaily
	case "weekly":
		tf = leaderboard.TimeframeWeekly
	case "seasonal":
		tf = leaderboard.TimeframeSeasonal
	default:
		tf = leaderboard.TimeframeAllTime
	}

	entries, err := h.service.leaderboardManager.GetLeaderboard(ctx, trialID, tf, limit)
	if err != nil {
		h.service.logger.Error("Failed to get leaderboard", zap.Error(err))
		return &api.APIV1TimeTrialsLeaderboardsTrialIdGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to retrieve leaderboard",
			},
		}, nil
	}

	// Convert to API format
	apiEntries := make([]api.LeaderboardEntry, len(entries))
	for i, entry := range entries {
		apiEntries[i] = api.LeaderboardEntry{
			PlayerId:       entry.PlayerID,
			PlayerName:     &entry.PlayerName,
			CompletionTime: entry.CompletionTime,
			Rank:           entry.Rank,
		}
	}

	h.service.leaderboardRequests.WithLabelValues(timeframe).Inc()

	return &api.APIV1TimeTrialsLeaderboardsTrialIdGetRes200{
		TrialId:      trialID.String(),
		Timeframe:    api.APIV1TimeTrialsLeaderboardsTrialIdGetRes200Timeframe(timeframe),
		Entries:      apiEntries,
		TotalEntries: len(entries),
	}, nil
}

// APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGet implements GET /api/v1/time-trials/analytics/trials/{trialId}/performance
func (h *Handler) APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGet(ctx context.Context, params api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetParams) (api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetRes, error) {
	trialID, err := uuid.Parse(params.TrialId)
	if err != nil {
		return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_ID",
				Message: "Invalid trial ID format",
			},
		}, nil
	}

	timeframe := "weekly"
	if params.Timeframe != nil {
		timeframe = string(*params.Timeframe)
	}

	// Get performance analytics
	var tf analytics.Timeframe
	switch timeframe {
	case "daily":
		tf = analytics.TimeframeDaily
	case "seasonal":
		tf = analytics.TimeframeSeasonal
	default:
		tf = analytics.TimeframeWeekly
	}

	performance, err := h.service.analyticsCollector.CollectTrialPerformance(ctx, trialID, tf)
	if err != nil {
		h.service.logger.Error("Failed to get performance analytics", zap.Error(err))
		return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "INTERNAL_ERROR",
				Message: "Failed to retrieve analytics",
			},
		}, nil
	}

	return &api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetRes200{
		TrialId:               trialID.String(),
		Timeframe:             api.APIV1TimeTrialsAnalyticsTrialsTrialIdPerformanceGetRes200Timeframe(timeframe),
		TotalCompletions:      performance.TotalCompletions,
		AverageCompletionTime: performance.AverageCompletionTime,
		FastestTime:           performance.FastestTime,
		SlowestTime:           performance.SlowestTime,
		CompletionRate:        performance.CompletionRate,
	}, nil
}
