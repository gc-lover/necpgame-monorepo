// Code generated by NECPGAME backend agent. Enterprise-grade Time Trials Service.
// Issue: #1508
// PERFORMANCE: Optimized for competitive speedrunning with <30ms timer operations

package service

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"

	"necpgame/services/time-trials-service-go/internal/timer"
	"necpgame/services/time-trials-service-go/internal/leaderboard"
	"necpgame/services/time-trials-service-go/internal/validation"
	"necpgame/services/time-trials-service-go/internal/reward"
	"necpgame/services/time-trials-service-go/internal/analytics"
	"necpgame/services/time-trials-service-go/pkg/api"
)

// Config holds service configuration
type Config struct {
	Logger      *zap.Logger
	Tracer      trace.Tracer
	Meter       metric.Meter
	DatabaseURL string
	RedisURL    string
}

// Service implements the time trials business logic
type Service struct {
	logger     *zap.Logger
	tracer     trace.Tracer
	meter      metric.Meter
	db         *pgxpool.Pool
	redis      *redis.Client

	// Service lifecycle tracking
	startTime time.Time

	// Prometheus metrics
	trialOperations       *prometheus.CounterVec
	timerOperationsTime   prometheus.Histogram
	activeTrialSessions   prometheus.Gauge
	leaderboardRequests   *prometheus.CounterVec
	validationChecksTime  prometheus.Histogram
	rewardDistributions   *prometheus.CounterVec
	analyticsQueries      prometheus.Histogram

	// Business logic components
	timerEngine          *timer.Engine
	leaderboardManager   *leaderboard.Manager
	validationSystem     *validation.System
	rewardDistributor    *reward.Distributor
	analyticsCollector   *analytics.Collector
}

// NewTimeTrialsService creates a new time trials service instance
func NewTimeTrialsService(cfg Config) (*Service, error) {
	if cfg.Logger == nil {
		return nil, errors.New("logger is required")
	}

	svc := &Service{
		logger:   cfg.Logger,
		tracer:   cfg.Tracer,
		meter:    cfg.Meter,
		startTime: time.Now(),
	}

	// Initialize database connection
	if err := svc.initDatabase(cfg.DatabaseURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize database")
	}

	// Initialize Redis connection
	if err := svc.initRedis(cfg.RedisURL); err != nil {
		return nil, errors.Wrap(err, "failed to initialize redis")
	}

	// Initialize business logic components
	if err := svc.initComponents(); err != nil {
		return nil, errors.Wrap(err, "failed to initialize components")
	}

	svc.logger.Info("Time trials service initialized successfully")
	return svc, nil
}

// initDatabase initializes PostgreSQL connection with performance optimizations
func (s *Service) initDatabase(databaseURL string) error {
	// PERFORMANCE: Optimized connection pool for high-throughput competitive operations
	config, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse database URL")
	}

	// PERFORMANCE: Tune connection pool for time trials service
	config.MaxConns = 25                    // Higher pool size for concurrent trial sessions
	config.MinConns = 5                     // Keep minimum connections alive
	config.MaxConnLifetime = 30 * time.Minute // Rotate connections
	config.MaxConnIdleTime = 5 * time.Minute  // Close idle connections

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return errors.Wrap(err, "failed to create connection pool")
	}

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := pool.Ping(ctx); err != nil {
		return errors.Wrap(err, "failed to ping database")
	}

	s.db = pool
	s.logger.Info("Database connection established")
	return nil
}

// initRedis initializes Redis connection for caching and session management
func (s *Service) initRedis(redisURL string) error {
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		return errors.Wrap(err, "failed to parse redis URL")
	}

	// PERFORMANCE: Optimize Redis client for low-latency timer operations
	rdb := redis.NewClient(opt)
	rdb.Options().PoolSize = 15
	rdb.Options().MinIdleConns = 3
	rdb.Options().ConnMaxLifetime = 30 * time.Minute

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := rdb.Ping(ctx).Err(); err != nil {
		return errors.Wrap(err, "failed to ping redis")
	}

	s.redis = rdb
	s.logger.Info("Redis connection established")
	return nil
}

// initComponents initializes all business logic components
func (s *Service) initComponents() error {
	// Initialize timer engine
	timerEngine, err := timer.NewEngine(timer.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize timer engine")
	}
	s.timerEngine = timerEngine

	// Initialize leaderboard manager
	leaderboardManager, err := leaderboard.NewManager(leaderboard.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize leaderboard manager")
	}
	s.leaderboardManager = leaderboardManager

	// Initialize validation system
	validationSystem, err := validation.NewSystem(validation.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize validation system")
	}
	s.validationSystem = validationSystem

	// Initialize reward distributor
	rewardDistributor, err := reward.NewDistributor(reward.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize reward distributor")
	}
	s.rewardDistributor = rewardDistributor

	// Initialize analytics collector
	analyticsCollector, err := analytics.NewCollector(analytics.Config{
		DB:     s.db,
		Redis:  s.redis,
		Logger: s.logger,
		Tracer: s.tracer,
		Meter:  s.meter,
	})
	if err != nil {
		return errors.Wrap(err, "failed to initialize analytics collector")
	}
	s.analyticsCollector = analyticsCollector

	// Initialize Prometheus metrics
	if err := s.initPrometheusMetrics(); err != nil {
		return errors.Wrap(err, "failed to initialize prometheus metrics")
	}

	s.logger.Info("All components initialized successfully")
	return nil
}

// initPrometheusMetrics initializes Prometheus metrics for time trials operations
func (s *Service) initPrometheusMetrics() error {
	// Counter for trial operations by type and result
	s.trialOperations = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "time_trials_operations_total",
			Help: "Total number of time trials operations by type and status",
		},
		[]string{"operation", "status"},
	)

	// Histogram for timer operations timing
	s.timerOperationsTime = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "time_trials_timer_operations_duration_seconds",
			Help:    "Time taken for timer operations",
			Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0},
		},
	)

	// Gauge for active trial sessions
	s.activeTrialSessions = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "time_trials_active_sessions",
			Help: "Number of currently active time trial sessions",
		},
	)

	// Counter for leaderboard requests
	s.leaderboardRequests = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "time_trials_leaderboard_requests_total",
			Help: "Total number of leaderboard requests by timeframe",
		},
		[]string{"timeframe"},
	)

	// Histogram for validation checks timing
	s.validationChecksTime = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "time_trials_validation_checks_duration_seconds",
			Help:    "Time taken for validation checks",
			Buckets: prometheus.DefBuckets,
		},
	)

	// Counter for reward distributions
	s.rewardDistributions = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "time_trials_reward_distributions_total",
			Help: "Total number of reward distributions by tier",
		},
		[]string{"tier"},
	)

	// Histogram for analytics queries timing
	s.analyticsQueries = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Name:    "time_trials_analytics_queries_duration_seconds",
			Help:    "Time taken for analytics queries",
			Buckets: prometheus.DefBuckets,
		},
	)

	// Register metrics with Prometheus (handle already registered errors)
	metrics := []prometheus.Collector{
		s.trialOperations,
		s.timerOperationsTime,
		s.activeTrialSessions,
		s.leaderboardRequests,
		s.validationChecksTime,
		s.rewardDistributions,
		s.analyticsQueries,
	}

	for _, metric := range metrics {
		if err := prometheus.Register(metric); err != nil {
			if _, ok := err.(prometheus.AlreadyRegisteredError); !ok {
				return errors.Wrap(err, "failed to register prometheus metric")
			}
		}
	}

	s.logger.Info("Prometheus metrics initialized successfully")
	return nil
}

// MetricsHandler returns Prometheus metrics handler
func (s *Service) MetricsHandler() http.Handler {
	return promhttp.Handler()
}

// Close gracefully shuts down the service
func (s *Service) Close() error {
	s.logger.Info("Shutting down time trials service")

	if s.db != nil {
		s.db.Close()
		s.logger.Info("Database connection closed")
	}

	if s.redis != nil {
		if err := s.redis.Close(); err != nil {
			s.logger.Error("Error closing Redis connection", zap.Error(err))
		} else {
			s.logger.Info("Redis connection closed")
		}
	}

	return nil
}




