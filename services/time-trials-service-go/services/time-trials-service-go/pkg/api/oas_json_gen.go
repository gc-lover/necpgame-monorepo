// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsTrialsTrialIdPerformanceGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("timeframe")
		e.Str(s.Timeframe)
	}
	{
		e.FieldStart("metrics")
		s.Metrics.Encode(e)
	}
}

var jsonFieldsNameOfAnalyticsTrialsTrialIdPerformanceGetOK = [3]string{
	0: "trial_id",
	1: "timeframe",
	2: "metrics",
}

// Decode decodes AnalyticsTrialsTrialIdPerformanceGetOK from json.
func (s *AnalyticsTrialsTrialIdPerformanceGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsTrialsTrialIdPerformanceGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trial_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "timeframe":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Timeframe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "metrics":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsTrialsTrialIdPerformanceGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnalyticsTrialsTrialIdPerformanceGetOK) {
					name = jsonFieldsNameOfAnalyticsTrialsTrialIdPerformanceGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCompletions.Set {
			e.FieldStart("total_completions")
			s.TotalCompletions.Encode(e)
		}
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("average_completion_time")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.FastestTime.Set {
			e.FieldStart("fastest_time")
			s.FastestTime.Encode(e)
		}
	}
	{
		if s.SlowestTime.Set {
			e.FieldStart("slowest_time")
			s.SlowestTime.Encode(e)
		}
	}
	{
		if s.CompletionRate.Set {
			e.FieldStart("completion_rate")
			s.CompletionRate.Encode(e)
		}
	}
	{
		if s.DifficultyDistribution.Set {
			e.FieldStart("difficulty_distribution")
			s.DifficultyDistribution.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsTrialsTrialIdPerformanceGetOKMetrics = [6]string{
	0: "total_completions",
	1: "average_completion_time",
	2: "fastest_time",
	3: "slowest_time",
	4: "completion_rate",
	5: "difficulty_distribution",
}

// Decode decodes AnalyticsTrialsTrialIdPerformanceGetOKMetrics from json.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsTrialsTrialIdPerformanceGetOKMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_completions":
			if err := func() error {
				s.TotalCompletions.Reset()
				if err := s.TotalCompletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_completions\"")
			}
		case "average_completion_time":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"average_completion_time\"")
			}
		case "fastest_time":
			if err := func() error {
				s.FastestTime.Reset()
				if err := s.FastestTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fastest_time\"")
			}
		case "slowest_time":
			if err := func() error {
				s.SlowestTime.Reset()
				if err := s.SlowestTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slowest_time\"")
			}
		case "completion_rate":
			if err := func() error {
				s.CompletionRate.Reset()
				if err := s.CompletionRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_rate\"")
			}
		case "difficulty_distribution":
			if err := func() error {
				s.DifficultyDistribution.Reset()
				if err := s.DifficultyDistribution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty_distribution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsTrialsTrialIdPerformanceGetOKMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) encodeFields(e *jx.Encoder) {
	{
		if s.Normal.Set {
			e.FieldStart("normal")
			s.Normal.Encode(e)
		}
	}
	{
		if s.Heroic.Set {
			e.FieldStart("heroic")
			s.Heroic.Encode(e)
		}
	}
	{
		if s.Mythic.Set {
			e.FieldStart("mythic")
			s.Mythic.Encode(e)
		}
	}
	{
		if s.Legendary.Set {
			e.FieldStart("legendary")
			s.Legendary.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution = [4]string{
	0: "normal",
	1: "heroic",
	2: "mythic",
	3: "legendary",
}

// Decode decodes AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution from json.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "normal":
			if err := func() error {
				s.Normal.Reset()
				if err := s.Normal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normal\"")
			}
		case "heroic":
			if err := func() error {
				s.Heroic.Reset()
				if err := s.Heroic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heroic\"")
			}
		case "mythic":
			if err := func() error {
				s.Mythic.Reset()
				if err := s.Mythic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mythic\"")
			}
		case "legendary":
			if err := func() error {
				s.Legendary.Reset()
				if err := s.Legendary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legendary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (s ErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ErrorCode from json.
func (s *ErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ErrorCode(v) {
	case ErrorCodeVALIDATIONERROR:
		*s = ErrorCodeVALIDATIONERROR
	case ErrorCodeNOTFOUND:
		*s = ErrorCodeNOTFOUND
	case ErrorCodeUNAUTHORIZED:
		*s = ErrorCodeUNAUTHORIZED
	case ErrorCodeFORBIDDEN:
		*s = ErrorCodeFORBIDDEN
	case ErrorCodeINTERNALERROR:
		*s = ErrorCodeINTERNALERROR
	case ErrorCodeTIMEOUT:
		*s = ErrorCodeTIMEOUT
	default:
		*s = ErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.Metrics.Set {
			e.FieldStart("metrics")
			s.Metrics.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthGetOK = [4]string{
	0: "status",
	1: "timestamp",
	2: "version",
	3: "metrics",
}

// Decode decodes HealthGetOK from json.
func (s *HealthGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics.Reset()
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthGetOK) {
					name = jsonFieldsNameOfHealthGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthGetOKMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthGetOKMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveSessions.Set {
			e.FieldStart("active_sessions")
			s.ActiveSessions.Encode(e)
		}
	}
	{
		if s.TotalTrials.Set {
			e.FieldStart("total_trials")
			s.TotalTrials.Encode(e)
		}
	}
	{
		if s.AvgResponseTime.Set {
			e.FieldStart("avg_response_time")
			s.AvgResponseTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthGetOKMetrics = [3]string{
	0: "active_sessions",
	1: "total_trials",
	2: "avg_response_time",
}

// Decode decodes HealthGetOKMetrics from json.
func (s *HealthGetOKMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthGetOKMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active_sessions":
			if err := func() error {
				s.ActiveSessions.Reset()
				if err := s.ActiveSessions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_sessions\"")
			}
		case "total_trials":
			if err := func() error {
				s.TotalTrials.Reset()
				if err := s.TotalTrials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_trials\"")
			}
		case "avg_response_time":
			if err := func() error {
				s.AvgResponseTime.Reset()
				if err := s.AvgResponseTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avg_response_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthGetOKMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthGetOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthGetOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthGetOKStatus as json.
func (s HealthGetOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthGetOKStatus from json.
func (s *HealthGetOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthGetOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthGetOKStatus(v) {
	case HealthGetOKStatusHealthy:
		*s = HealthGetOKStatusHealthy
	case HealthGetOKStatusDegraded:
		*s = HealthGetOKStatusDegraded
	case HealthGetOKStatusUnhealthy:
		*s = HealthGetOKStatusUnhealthy
	default:
		*s = HealthGetOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthGetOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthGetOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		if s.PlayerName.Set {
			e.FieldStart("player_name")
			s.PlayerName.Encode(e)
		}
	}
	{
		e.FieldStart("completion_time")
		e.Int(s.CompletionTime)
	}
	{
		e.FieldStart("rank")
		e.Int(s.Rank)
	}
	{
		if s.RankChange.Set {
			e.FieldStart("rank_change")
			s.RankChange.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PartySize.Set {
			e.FieldStart("party_size")
			s.PartySize.Encode(e)
		}
	}
	{
		if s.TrialDifficulty.Set {
			e.FieldStart("trial_difficulty")
			s.TrialDifficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardEntry = [8]string{
	0: "player_id",
	1: "player_name",
	2: "completion_time",
	3: "rank",
	4: "rank_change",
	5: "completed_at",
	6: "party_size",
	7: "trial_difficulty",
}

// Decode decodes LeaderboardEntry from json.
func (s *LeaderboardEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "player_name":
			if err := func() error {
				s.PlayerName.Reset()
				if err := s.PlayerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_name\"")
			}
		case "completion_time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CompletionTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Rank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "rank_change":
			if err := func() error {
				s.RankChange.Reset()
				if err := s.RankChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_change\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "party_size":
			if err := func() error {
				s.PartySize.Reset()
				if err := s.PartySize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_size\"")
			}
		case "trial_difficulty":
			if err := func() error {
				s.TrialDifficulty.Reset()
				if err := s.TrialDifficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardEntry) {
					name = jsonFieldsNameOfLeaderboardEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardEntryTrialDifficulty as json.
func (s LeaderboardEntryTrialDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LeaderboardEntryTrialDifficulty from json.
func (s *LeaderboardEntryTrialDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardEntryTrialDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LeaderboardEntryTrialDifficulty(v) {
	case LeaderboardEntryTrialDifficultyNormal:
		*s = LeaderboardEntryTrialDifficultyNormal
	case LeaderboardEntryTrialDifficultyHeroic:
		*s = LeaderboardEntryTrialDifficultyHeroic
	case LeaderboardEntryTrialDifficultyMythic:
		*s = LeaderboardEntryTrialDifficultyMythic
	case LeaderboardEntryTrialDifficultyLegendary:
		*s = LeaderboardEntryTrialDifficultyLegendary
	default:
		*s = LeaderboardEntryTrialDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeaderboardEntryTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardEntryTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardsTrialIdGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardsTrialIdGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("timeframe")
		s.Timeframe.Encode(e)
	}
	{
		e.FieldStart("entries")
		e.ArrStart()
		for _, elem := range s.Entries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_entries")
		e.Int(s.TotalEntries)
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("last_updated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfLeaderboardsTrialIdGetOK = [5]string{
	0: "trial_id",
	1: "timeframe",
	2: "entries",
	3: "total_entries",
	4: "last_updated",
}

// Decode decodes LeaderboardsTrialIdGetOK from json.
func (s *LeaderboardsTrialIdGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trial_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "timeframe":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Timeframe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeframe\"")
			}
		case "entries":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Entries = make([]LeaderboardEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeaderboardEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		case "total_entries":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalEntries = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_entries\"")
			}
		case "last_updated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardsTrialIdGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardsTrialIdGetOK) {
					name = jsonFieldsNameOfLeaderboardsTrialIdGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardsTrialIdGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardsTrialIdGetOKTimeframe as json.
func (s LeaderboardsTrialIdGetOKTimeframe) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LeaderboardsTrialIdGetOKTimeframe from json.
func (s *LeaderboardsTrialIdGetOKTimeframe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdGetOKTimeframe to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LeaderboardsTrialIdGetOKTimeframe(v) {
	case LeaderboardsTrialIdGetOKTimeframeDaily:
		*s = LeaderboardsTrialIdGetOKTimeframeDaily
	case LeaderboardsTrialIdGetOKTimeframeWeekly:
		*s = LeaderboardsTrialIdGetOKTimeframeWeekly
	case LeaderboardsTrialIdGetOKTimeframeMonthly:
		*s = LeaderboardsTrialIdGetOKTimeframeMonthly
	case LeaderboardsTrialIdGetOKTimeframeAllTime:
		*s = LeaderboardsTrialIdGetOKTimeframeAllTime
	case LeaderboardsTrialIdGetOKTimeframeSeasonal:
		*s = LeaderboardsTrialIdGetOKTimeframeSeasonal
	default:
		*s = LeaderboardsTrialIdGetOKTimeframe(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeaderboardsTrialIdGetOKTimeframe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdGetOKTimeframe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("personal_best")
		s.PersonalBest.Encode(e)
	}
	{
		e.FieldStart("current_rank")
		e.Int(s.CurrentRank)
	}
	{
		e.FieldStart("rank_history")
		e.ArrStart()
		for _, elem := range s.RankHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLeaderboardsTrialIdPersonalPlayerIdGetOK = [5]string{
	0: "player_id",
	1: "trial_id",
	2: "personal_best",
	3: "current_rank",
	4: "rank_history",
}

// Decode decodes LeaderboardsTrialIdPersonalPlayerIdGetOK from json.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdPersonalPlayerIdGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "player_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "trial_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "personal_best":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PersonalBest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personal_best\"")
			}
		case "current_rank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CurrentRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_rank\"")
			}
		case "rank_history":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.RankHistory = make([]LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RankHistory = append(s.RankHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank_history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardsTrialIdPersonalPlayerIdGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaderboardsTrialIdPersonalPlayerIdGetOK) {
					name = jsonFieldsNameOfLeaderboardsTrialIdPersonalPlayerIdGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest) encodeFields(e *jx.Encoder) {
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.AchievedAt.Set {
			e.FieldStart("achieved_at")
			s.AchievedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest = [3]string{
	0: "completion_time",
	1: "achieved_at",
	2: "difficulty",
}

// Decode decodes LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest from json.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "achieved_at":
			if err := func() error {
				s.AchievedAt.Reset()
				if err := s.AchievedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achieved_at\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty as json.
func (s LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty from json.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty(v) {
	case LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyNormal:
		*s = LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyNormal
	case LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyHeroic:
		*s = LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyHeroic
	case LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyMythic:
		*s = LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyMythic
	case LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyLegendary:
		*s = LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficultyLegendary
	default:
		*s = LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem = [2]string{
	0: "date",
	1: "rank",
}

// Decode decodes LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem from json.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaderboardsTrialIdPersonalPlayerIdGetOKRankHistoryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution as json.
func (o OptAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution from json.
func (o *OptAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnalyticsTrialsTrialIdPerformanceGetOKMetricsDifficultyDistribution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthGetOKMetrics as json.
func (o OptHealthGetOKMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthGetOKMetrics from json.
func (o *OptHealthGetOKMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthGetOKMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthGetOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthGetOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardEntryTrialDifficulty as json.
func (o OptLeaderboardEntryTrialDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LeaderboardEntryTrialDifficulty from json.
func (o *OptLeaderboardEntryTrialDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeaderboardEntryTrialDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeaderboardEntryTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeaderboardEntryTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty as json.
func (o OptLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty from json.
func (o *OptLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeaderboardsTrialIdPersonalPlayerIdGetOKPersonalBestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardTiers as json.
func (o OptRewardTiers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RewardTiers from json.
func (o *OptRewardTiers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRewardTiers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRewardTiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRewardTiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RewardTiersCurrency as json.
func (o OptRewardTiersCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RewardTiersCurrency from json.
func (o *OptRewardTiersCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRewardTiersCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRewardTiersCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRewardTiersCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialRewards as json.
func (o OptTrialRewards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TrialRewards from json.
func (o *OptTrialRewards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialRewards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionValidationStatus as json.
func (o OptTrialSessionValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrialSessionValidationStatus from json.
func (o *OptTrialSessionValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialSessionValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialSessionValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialSessionValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdCompletePostOKValidationStatus as json.
func (o OptTrialsTrialIdCompletePostOKValidationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TrialsTrialIdCompletePostOKValidationStatus from json.
func (o *OptTrialsTrialIdCompletePostOKValidationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialsTrialIdCompletePostOKValidationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialsTrialIdCompletePostOKValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialsTrialIdCompletePostOKValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdStartPostReq as json.
func (o OptTrialsTrialIdStartPostReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TrialsTrialIdStartPostReq from json.
func (o *OptTrialsTrialIdStartPostReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTrialsTrialIdStartPostReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTrialsTrialIdStartPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTrialsTrialIdStartPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationRules as json.
func (o OptValidationRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationRules from json.
func (o *OptValidationRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidationRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidationRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiers) encodeFields(e *jx.Encoder) {
	{
		if s.Experience.Set {
			e.FieldStart("experience")
			s.Experience.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRewardTiers = [4]string{
	0: "experience",
	1: "currency",
	2: "items",
	3: "achievements",
}

// Decode decodes RewardTiers from json.
func (s *RewardTiers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experience":
			if err := func() error {
				s.Experience.Reset()
				if err := s.Experience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experience\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]RewardTiersItemsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RewardTiersItemsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiersCurrency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiersCurrency) encodeFields(e *jx.Encoder) {
	{
		if s.Gold.Set {
			e.FieldStart("gold")
			s.Gold.Encode(e)
		}
	}
	{
		if s.SeasonalTokens.Set {
			e.FieldStart("seasonal_tokens")
			s.SeasonalTokens.Encode(e)
		}
	}
}

var jsonFieldsNameOfRewardTiersCurrency = [2]string{
	0: "gold",
	1: "seasonal_tokens",
}

// Decode decodes RewardTiersCurrency from json.
func (s *RewardTiersCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiersCurrency to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gold":
			if err := func() error {
				s.Gold.Reset()
				if err := s.Gold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "seasonal_tokens":
			if err := func() error {
				s.SeasonalTokens.Reset()
				if err := s.SeasonalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonal_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiersCurrency")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiersCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiersCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RewardTiersItemsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RewardTiersItemsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ItemID.Set {
			e.FieldStart("item_id")
			s.ItemID.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfRewardTiersItemsItem = [2]string{
	0: "item_id",
	1: "quantity",
}

// Decode decodes RewardTiersItemsItem from json.
func (s *RewardTiersItemsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RewardTiersItemsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_id":
			if err := func() error {
				s.ItemID.Reset()
				if err := s.ItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RewardTiersItemsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RewardTiersItemsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RewardTiersItemsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResponse = [3]string{
	0: "success",
	1: "data",
	2: "metadata",
}

// Decode decodes SuccessResponse from json.
func (s *SuccessResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem SuccessResponseData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem SuccessResponseMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessResponse) {
					name = jsonFieldsNameOfSuccessResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponseData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSuccessResponseData = [0]string{}

// Decode decodes SuccessResponseData from json.
func (s *SuccessResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResponseMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResponseMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSuccessResponseMetadata = [0]string{}

// Decode decodes SuccessResponseMetadata from json.
func (s *SuccessResponseMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResponseMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResponseMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResponseMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResponseMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeTrial) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeTrial) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("content_id")
		e.Str(s.ContentID)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.TimeLimit.Set {
			e.FieldStart("time_limit")
			s.TimeLimit.Encode(e)
		}
	}
	{
		if s.MinPlayers.Set {
			e.FieldStart("min_players")
			s.MinPlayers.Encode(e)
		}
	}
	{
		if s.MaxPlayers.Set {
			e.FieldStart("max_players")
			s.MaxPlayers.Encode(e)
		}
	}
	{
		if s.Rewards.Set {
			e.FieldStart("rewards")
			s.Rewards.Encode(e)
		}
	}
	{
		if s.ValidationRules.Set {
			e.FieldStart("validation_rules")
			s.ValidationRules.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTimeTrial = [14]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "type",
	4:  "content_id",
	5:  "difficulty",
	6:  "status",
	7:  "time_limit",
	8:  "min_players",
	9:  "max_players",
	10: "rewards",
	11: "validation_rules",
	12: "created_at",
	13: "updated_at",
}

// Decode decodes TimeTrial from json.
func (s *TimeTrial) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrial to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "content_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ContentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_id\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "time_limit":
			if err := func() error {
				s.TimeLimit.Reset()
				if err := s.TimeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit\"")
			}
		case "min_players":
			if err := func() error {
				s.MinPlayers.Reset()
				if err := s.MinPlayers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_players\"")
			}
		case "max_players":
			if err := func() error {
				s.MaxPlayers.Reset()
				if err := s.MaxPlayers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_players\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards.Reset()
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "validation_rules":
			if err := func() error {
				s.ValidationRules.Reset()
				if err := s.ValidationRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_rules\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeTrial")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeTrial) {
					name = jsonFieldsNameOfTimeTrial[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeTrial) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrial) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialDifficulty as json.
func (s TimeTrialDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialDifficulty from json.
func (s *TimeTrialDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialDifficulty(v) {
	case TimeTrialDifficultyNormal:
		*s = TimeTrialDifficultyNormal
	case TimeTrialDifficultyHeroic:
		*s = TimeTrialDifficultyHeroic
	case TimeTrialDifficultyMythic:
		*s = TimeTrialDifficultyMythic
	case TimeTrialDifficultyLegendary:
		*s = TimeTrialDifficultyLegendary
	default:
		*s = TimeTrialDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialStatus as json.
func (s TimeTrialStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialStatus from json.
func (s *TimeTrialStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialStatus(v) {
	case TimeTrialStatusActive:
		*s = TimeTrialStatusActive
	case TimeTrialStatusInactive:
		*s = TimeTrialStatusInactive
	case TimeTrialStatusDeprecated:
		*s = TimeTrialStatusDeprecated
	default:
		*s = TimeTrialStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeTrialType as json.
func (s TimeTrialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TimeTrialType from json.
func (s *TimeTrialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeTrialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TimeTrialType(v) {
	case TimeTrialTypeSpeedrunRaid:
		*s = TimeTrialTypeSpeedrunRaid
	case TimeTrialTypeTimeAttackDungeon:
		*s = TimeTrialTypeTimeAttackDungeon
	case TimeTrialTypeWeeklyChallenge:
		*s = TimeTrialTypeWeeklyChallenge
	case TimeTrialTypeSeasonalTrial:
		*s = TimeTrialTypeSeasonalTrial
	default:
		*s = TimeTrialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TimeTrialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeTrialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialRewards) encodeFields(e *jx.Encoder) {
	{
		if s.BronzeTime.Set {
			e.FieldStart("bronze_time")
			s.BronzeTime.Encode(e)
		}
	}
	{
		if s.SilverTime.Set {
			e.FieldStart("silver_time")
			s.SilverTime.Encode(e)
		}
	}
	{
		if s.GoldTime.Set {
			e.FieldStart("gold_time")
			s.GoldTime.Encode(e)
		}
	}
	{
		if s.PlatinumTime.Set {
			e.FieldStart("platinum_time")
			s.PlatinumTime.Encode(e)
		}
	}
	{
		if s.BronzeRewards.Set {
			e.FieldStart("bronze_rewards")
			s.BronzeRewards.Encode(e)
		}
	}
	{
		if s.SilverRewards.Set {
			e.FieldStart("silver_rewards")
			s.SilverRewards.Encode(e)
		}
	}
	{
		if s.GoldRewards.Set {
			e.FieldStart("gold_rewards")
			s.GoldRewards.Encode(e)
		}
	}
	{
		if s.PlatinumRewards.Set {
			e.FieldStart("platinum_rewards")
			s.PlatinumRewards.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialRewards = [8]string{
	0: "bronze_time",
	1: "silver_time",
	2: "gold_time",
	3: "platinum_time",
	4: "bronze_rewards",
	5: "silver_rewards",
	6: "gold_rewards",
	7: "platinum_rewards",
}

// Decode decodes TrialRewards from json.
func (s *TrialRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialRewards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bronze_time":
			if err := func() error {
				s.BronzeTime.Reset()
				if err := s.BronzeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bronze_time\"")
			}
		case "silver_time":
			if err := func() error {
				s.SilverTime.Reset()
				if err := s.SilverTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silver_time\"")
			}
		case "gold_time":
			if err := func() error {
				s.GoldTime.Reset()
				if err := s.GoldTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold_time\"")
			}
		case "platinum_time":
			if err := func() error {
				s.PlatinumTime.Reset()
				if err := s.PlatinumTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platinum_time\"")
			}
		case "bronze_rewards":
			if err := func() error {
				s.BronzeRewards.Reset()
				if err := s.BronzeRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bronze_rewards\"")
			}
		case "silver_rewards":
			if err := func() error {
				s.SilverRewards.Reset()
				if err := s.SilverRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silver_rewards\"")
			}
		case "gold_rewards":
			if err := func() error {
				s.GoldRewards.Reset()
				if err := s.GoldRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold_rewards\"")
			}
		case "platinum_rewards":
			if err := func() error {
				s.PlatinumRewards.Reset()
				if err := s.PlatinumRewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platinum_rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialRewards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialSession) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialSession) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("trial_id")
		json.EncodeUUID(e, s.TrialID)
	}
	{
		e.FieldStart("player_id")
		e.Str(s.PlayerID)
	}
	{
		if s.PartyID.Set {
			e.FieldStart("party_id")
			s.PartyID.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completion_time")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progress_percentage")
			s.ProgressPercentage.Encode(e)
		}
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialSession = [11]string{
	0:  "id",
	1:  "trial_id",
	2:  "player_id",
	3:  "party_id",
	4:  "status",
	5:  "start_time",
	6:  "end_time",
	7:  "completion_time",
	8:  "progress_percentage",
	9:  "validation_status",
	10: "metadata",
}

// Decode decodes TrialSession from json.
func (s *TrialSession) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSession to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trial_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TrialID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trial_id\"")
			}
		case "player_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_id\"")
			}
		case "party_id":
			if err := func() error {
				s.PartyID.Reset()
				if err := s.PartyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "completion_time":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "progress_percentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem TrialSessionMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialSession")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialSession) {
					name = jsonFieldsNameOfTrialSession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialSession) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSession) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialSessionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialSessionMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTrialSessionMetadata = [0]string{}

// Decode decodes TrialSessionMetadata from json.
func (s *TrialSessionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TrialSessionMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialSessionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionStatus as json.
func (s TrialSessionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrialSessionStatus from json.
func (s *TrialSessionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrialSessionStatus(v) {
	case TrialSessionStatusStarting:
		*s = TrialSessionStatusStarting
	case TrialSessionStatusActive:
		*s = TrialSessionStatusActive
	case TrialSessionStatusPaused:
		*s = TrialSessionStatusPaused
	case TrialSessionStatusCompleted:
		*s = TrialSessionStatusCompleted
	case TrialSessionStatusFailed:
		*s = TrialSessionStatusFailed
	case TrialSessionStatusInvalidated:
		*s = TrialSessionStatusInvalidated
	default:
		*s = TrialSessionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrialSessionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialSessionValidationStatus as json.
func (s TrialSessionValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrialSessionValidationStatus from json.
func (s *TrialSessionValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialSessionValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrialSessionValidationStatus(v) {
	case TrialSessionValidationStatusPending:
		*s = TrialSessionValidationStatusPending
	case TrialSessionValidationStatusValid:
		*s = TrialSessionValidationStatusValid
	case TrialSessionValidationStatusInvalid:
		*s = TrialSessionValidationStatusInvalid
	case TrialSessionValidationStatusDisputed:
		*s = TrialSessionValidationStatusDisputed
	default:
		*s = TrialSessionValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrialSessionValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialSessionValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trials")
		e.ArrStart()
		for _, elem := range s.Trials {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
}

var jsonFieldsNameOfTrialsGetOK = [4]string{
	0: "trials",
	1: "total",
	2: "limit",
	3: "offset",
}

// Decode decodes TrialsGetOK from json.
func (s *TrialsGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trials":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Trials = make([]TimeTrial, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TimeTrial
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trials = append(s.Trials, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trials\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialsGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialsGetOK) {
					name = jsonFieldsNameOfTrialsGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsPostBadRequest as json.
func (s *TrialsPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsPostBadRequest from json.
func (s *TrialsPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsPostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsPostUnauthorized as json.
func (s *TrialsPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsPostUnauthorized from json.
func (s *TrialsPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsPostUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdCompletePostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdCompletePostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		e.FieldStart("leaderboard_rank")
		e.Int(s.LeaderboardRank)
	}
	{
		if s.ValidationStatus.Set {
			e.FieldStart("validation_status")
			s.ValidationStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialsTrialIdCompletePostOK = [4]string{
	0: "session",
	1: "rewards",
	2: "leaderboard_rank",
	3: "validation_status",
}

// Decode decodes TrialsTrialIdCompletePostOK from json.
func (s *TrialsTrialIdCompletePostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdCompletePostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "leaderboard_rank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.LeaderboardRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard_rank\"")
			}
		case "validation_status":
			if err := func() error {
				s.ValidationStatus.Reset()
				if err := s.ValidationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdCompletePostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialsTrialIdCompletePostOK) {
					name = jsonFieldsNameOfTrialsTrialIdCompletePostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdCompletePostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdCompletePostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdCompletePostOKValidationStatus as json.
func (s TrialsTrialIdCompletePostOKValidationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TrialsTrialIdCompletePostOKValidationStatus from json.
func (s *TrialsTrialIdCompletePostOKValidationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdCompletePostOKValidationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TrialsTrialIdCompletePostOKValidationStatus(v) {
	case TrialsTrialIdCompletePostOKValidationStatusPending:
		*s = TrialsTrialIdCompletePostOKValidationStatusPending
	case TrialsTrialIdCompletePostOKValidationStatusValid:
		*s = TrialsTrialIdCompletePostOKValidationStatusValid
	case TrialsTrialIdCompletePostOKValidationStatusInvalid:
		*s = TrialsTrialIdCompletePostOKValidationStatusInvalid
	default:
		*s = TrialsTrialIdCompletePostOKValidationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TrialsTrialIdCompletePostOKValidationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdCompletePostOKValidationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdCompletePostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdCompletePostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completion_time")
		e.Int(s.CompletionTime)
	}
	{
		e.FieldStart("progress_percentage")
		e.Int(s.ProgressPercentage)
	}
	{
		if s.TelemetryData != nil {
			e.FieldStart("telemetry_data")
			s.TelemetryData.Encode(e)
		}
	}
	{
		if s.PartyMembers != nil {
			e.FieldStart("party_members")
			e.ArrStart()
			for _, elem := range s.PartyMembers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTrialsTrialIdCompletePostReq = [4]string{
	0: "completion_time",
	1: "progress_percentage",
	2: "telemetry_data",
	3: "party_members",
}

// Decode decodes TrialsTrialIdCompletePostReq from json.
func (s *TrialsTrialIdCompletePostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdCompletePostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CompletionTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_time\"")
			}
		case "progress_percentage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ProgressPercentage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "telemetry_data":
			if err := func() error {
				s.TelemetryData = nil
				var elem TrialsTrialIdCompletePostReqTelemetryData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TelemetryData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telemetry_data\"")
			}
		case "party_members":
			if err := func() error {
				s.PartyMembers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PartyMembers = append(s.PartyMembers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdCompletePostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialsTrialIdCompletePostReq) {
					name = jsonFieldsNameOfTrialsTrialIdCompletePostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdCompletePostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdCompletePostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdCompletePostReqTelemetryData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdCompletePostReqTelemetryData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTrialsTrialIdCompletePostReqTelemetryData = [0]string{}

// Decode decodes TrialsTrialIdCompletePostReqTelemetryData from json.
func (s *TrialsTrialIdCompletePostReqTelemetryData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdCompletePostReqTelemetryData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdCompletePostReqTelemetryData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdCompletePostReqTelemetryData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdCompletePostReqTelemetryData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdPutBadRequest as json.
func (s *TrialsTrialIdPutBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsTrialIdPutBadRequest from json.
func (s *TrialsTrialIdPutBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdPutBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsTrialIdPutBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdPutBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdPutBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdPutNotFound as json.
func (s *TrialsTrialIdPutNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsTrialIdPutNotFound from json.
func (s *TrialsTrialIdPutNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdPutNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsTrialIdPutNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdPutNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdPutNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdStartPostBadRequest as json.
func (s *TrialsTrialIdStartPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsTrialIdStartPostBadRequest from json.
func (s *TrialsTrialIdStartPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdStartPostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsTrialIdStartPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdStartPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdStartPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdStartPostCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdStartPostCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		e.FieldStart("server_time")
		json.EncodeDateTime(e, s.ServerTime)
	}
}

var jsonFieldsNameOfTrialsTrialIdStartPostCreated = [2]string{
	0: "session",
	1: "server_time",
}

// Decode decodes TrialsTrialIdStartPostCreated from json.
func (s *TrialsTrialIdStartPostCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdStartPostCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "session":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "server_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ServerTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdStartPostCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrialsTrialIdStartPostCreated) {
					name = jsonFieldsNameOfTrialsTrialIdStartPostCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdStartPostCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdStartPostCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TrialsTrialIdStartPostNotFound as json.
func (s *TrialsTrialIdStartPostNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TrialsTrialIdStartPostNotFound from json.
func (s *TrialsTrialIdStartPostNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdStartPostNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TrialsTrialIdStartPostNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdStartPostNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdStartPostNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdStartPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdStartPostReq) encodeFields(e *jx.Encoder) {
	{
		if s.PartyID.Set {
			e.FieldStart("party_id")
			s.PartyID.Encode(e)
		}
	}
	{
		if s.CustomSettings != nil {
			e.FieldStart("custom_settings")
			s.CustomSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfTrialsTrialIdStartPostReq = [2]string{
	0: "party_id",
	1: "custom_settings",
}

// Decode decodes TrialsTrialIdStartPostReq from json.
func (s *TrialsTrialIdStartPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdStartPostReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "party_id":
			if err := func() error {
				s.PartyID.Reset()
				if err := s.PartyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party_id\"")
			}
		case "custom_settings":
			if err := func() error {
				s.CustomSettings = nil
				var elem TrialsTrialIdStartPostReqCustomSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdStartPostReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdStartPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdStartPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrialsTrialIdStartPostReqCustomSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrialsTrialIdStartPostReqCustomSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTrialsTrialIdStartPostReqCustomSettings = [0]string{}

// Decode decodes TrialsTrialIdStartPostReqCustomSettings from json.
func (s *TrialsTrialIdStartPostReqCustomSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrialsTrialIdStartPostReqCustomSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode TrialsTrialIdStartPostReqCustomSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrialsTrialIdStartPostReqCustomSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrialsTrialIdStartPostReqCustomSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationRules) encodeFields(e *jx.Encoder) {
	{
		if s.AllowCheats.Set {
			e.FieldStart("allow_cheats")
			s.AllowCheats.Encode(e)
		}
	}
	{
		if s.ValidateRoute.Set {
			e.FieldStart("validate_route")
			s.ValidateRoute.Encode(e)
		}
	}
	{
		if s.MinCompletionPercentage.Set {
			e.FieldStart("min_completion_percentage")
			s.MinCompletionPercentage.Encode(e)
		}
	}
	{
		if s.AllowedModifiers != nil {
			e.FieldStart("allowed_modifiers")
			e.ArrStart()
			for _, elem := range s.AllowedModifiers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationRules = [4]string{
	0: "allow_cheats",
	1: "validate_route",
	2: "min_completion_percentage",
	3: "allowed_modifiers",
}

// Decode decodes ValidationRules from json.
func (s *ValidationRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationRules to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_cheats":
			if err := func() error {
				s.AllowCheats.Reset()
				if err := s.AllowCheats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_cheats\"")
			}
		case "validate_route":
			if err := func() error {
				s.ValidateRoute.Reset()
				if err := s.ValidateRoute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validate_route\"")
			}
		case "min_completion_percentage":
			if err := func() error {
				s.MinCompletionPercentage.Reset()
				if err := s.MinCompletionPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_completion_percentage\"")
			}
		case "allowed_modifiers":
			if err := func() error {
				s.AllowedModifiers = make([]ValidationRulesAllowedModifiersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationRulesAllowedModifiersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedModifiers = append(s.AllowedModifiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_modifiers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationRulesAllowedModifiersItem as json.
func (s ValidationRulesAllowedModifiersItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValidationRulesAllowedModifiersItem from json.
func (s *ValidationRulesAllowedModifiersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationRulesAllowedModifiersItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValidationRulesAllowedModifiersItem(v) {
	case ValidationRulesAllowedModifiersItemSpeedBoost:
		*s = ValidationRulesAllowedModifiersItemSpeedBoost
	case ValidationRulesAllowedModifiersItemDamageMod:
		*s = ValidationRulesAllowedModifiersItemDamageMod
	case ValidationRulesAllowedModifiersItemHealthMod:
		*s = ValidationRulesAllowedModifiersItemHealthMod
	case ValidationRulesAllowedModifiersItemAbilityMod:
		*s = ValidationRulesAllowedModifiersItemAbilityMod
	default:
		*s = ValidationRulesAllowedModifiersItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationRulesAllowedModifiersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationRulesAllowedModifiersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationSessionsSessionIdReportPostBadRequest as json.
func (s *ValidationSessionsSessionIdReportPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidationSessionsSessionIdReportPostBadRequest from json.
func (s *ValidationSessionsSessionIdReportPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationSessionsSessionIdReportPostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidationSessionsSessionIdReportPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationSessionsSessionIdReportPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationSessionsSessionIdReportPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationSessionsSessionIdReportPostNotFound as json.
func (s *ValidationSessionsSessionIdReportPostNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidationSessionsSessionIdReportPostNotFound from json.
func (s *ValidationSessionsSessionIdReportPostNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationSessionsSessionIdReportPostNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidationSessionsSessionIdReportPostNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationSessionsSessionIdReportPostNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationSessionsSessionIdReportPostNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationSessionsSessionIdReportPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationSessionsSessionIdReportPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.Evidence != nil {
			e.FieldStart("evidence")
			e.ArrStart()
			for _, elem := range s.Evidence {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationSessionsSessionIdReportPostReq = [3]string{
	0: "reason",
	1: "details",
	2: "evidence",
}

// Decode decodes ValidationSessionsSessionIdReportPostReq from json.
func (s *ValidationSessionsSessionIdReportPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationSessionsSessionIdReportPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "evidence":
			if err := func() error {
				s.Evidence = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Evidence = append(s.Evidence, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationSessionsSessionIdReportPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationSessionsSessionIdReportPostReq) {
					name = jsonFieldsNameOfValidationSessionsSessionIdReportPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationSessionsSessionIdReportPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationSessionsSessionIdReportPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationSessionsSessionIdReportPostReqReason as json.
func (s ValidationSessionsSessionIdReportPostReqReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValidationSessionsSessionIdReportPostReqReason from json.
func (s *ValidationSessionsSessionIdReportPostReqReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationSessionsSessionIdReportPostReqReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValidationSessionsSessionIdReportPostReqReason(v) {
	case ValidationSessionsSessionIdReportPostReqReasonSpeedHack:
		*s = ValidationSessionsSessionIdReportPostReqReasonSpeedHack
	case ValidationSessionsSessionIdReportPostReqReasonRouteExploit:
		*s = ValidationSessionsSessionIdReportPostReqReasonRouteExploit
	case ValidationSessionsSessionIdReportPostReqReasonInvalidCompletion:
		*s = ValidationSessionsSessionIdReportPostReqReasonInvalidCompletion
	case ValidationSessionsSessionIdReportPostReqReasonOther:
		*s = ValidationSessionsSessionIdReportPostReqReasonOther
	default:
		*s = ValidationSessionsSessionIdReportPostReqReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationSessionsSessionIdReportPostReqReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationSessionsSessionIdReportPostReqReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
