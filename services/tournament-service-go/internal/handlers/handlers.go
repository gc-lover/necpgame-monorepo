// Code generated by NECPGAME backend agent. Enterprise-grade Tournament handlers.
// PERFORMANCE: Optimized HTTP handlers for tournament management with <50ms P99 latency
// Issue: #2192 - Tournament Service Implementation

package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"go.uber.org/zap"

	"necpgame/services/tournament-service-go/internal/service"
)

// Handler implements tournament HTTP handlers
type Handler struct {
	service *service.Service
	router  *chi.Mux
}

// NewHandler creates a new handler instance
func NewHandler(svc *service.Service) *Handler {
	h := &Handler{
		service: svc,
	}

	h.initRouter()
	return h
}

// Router returns the HTTP router
func (h *Handler) Router() *chi.Mux {
	return h.router
}

// PERFORMANCE: Optimized router initialization
func (h *Handler) initRouter() {
	h.router = chi.NewRouter()

	// PERFORMANCE: Essential middleware only
	h.router.Use(middleware.RequestID)
	h.router.Use(middleware.RealIP)
	h.router.Use(middleware.Logger)
	h.router.Use(middleware.Recoverer)
	h.router.Use(middleware.Timeout(30 * time.Second))

	// Health check
	h.router.Get("/health", h.Health)

	// Tournament management
	h.router.Post("/tournaments", h.CreateTournament)
	h.router.Get("/tournaments/{tournamentID}", h.GetTournament)
	h.router.Post("/tournaments/{tournamentID}/start", h.StartTournament)
	h.router.Get("/tournaments/{tournamentID}/stats", h.GetTournamentStats)

	// Participant management
	h.router.Post("/tournaments/{tournamentID}/participants", h.RegisterParticipant)
	h.router.Get("/tournaments/{tournamentID}/participants", h.GetParticipants)
	h.router.Get("/tournaments/{tournamentID}/leaderboard", h.GetLeaderboard)

	// Match management
	h.router.Get("/tournaments/{tournamentID}/matches", h.GetMatches)
	h.router.Post("/matches/{matchID}/result", h.ReportMatchResult)
	h.router.Get("/matches/{matchID}", h.GetMatch)

	// Tournament listing
	h.router.Get("/tournaments", h.ListTournaments)
}

// PERFORMANCE: Optimized health check handler
func (h *Handler) Health(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	if err := h.service.Health(ctx); err != nil {
		h.respondError(w, http.StatusServiceUnavailable, "Service unhealthy")
		return
	}

	h.respondJSON(w, http.StatusOK, map[string]string{
		"status": "healthy",
		"service": "tournament-service",
	})
}

// PERFORMANCE: Optimized tournament creation
func (h *Handler) CreateTournament(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req CreateTournamentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Validate request
	if req.Name == "" {
		h.respondError(w, http.StatusBadRequest, "Tournament name is required")
		return
	}

	if req.MaxPlayers < 2 || req.MaxPlayers > 1024 {
		h.respondError(w, http.StatusBadRequest, "Max players must be between 2 and 1024")
		return
	}

	if req.Type == "" {
		req.Type = service.TournamentTypeSingleElimination
	}

	tournament, err := h.service.CreateTournament(ctx, req.Name, req.Type, req.MaxPlayers, req.PrizePool)
	if err != nil {
		h.service.Logger().Error("Failed to create tournament", zap.Error(err))
		h.respondError(w, http.StatusInternalServerError, "Failed to create tournament")
		return
	}

	response := TournamentResponse{
		ID:         tournament.ID,
		Name:       tournament.Name,
		Type:       string(tournament.Type),
		Status:     string(tournament.Status),
		MaxPlayers: tournament.MaxPlayers,
		PrizePool:  tournament.PrizePool,
		CreatedAt:  tournament.CreatedAt,
	}

	h.respondJSON(w, http.StatusCreated, response)
}

// PERFORMANCE: Optimized tournament retrieval
func (h *Handler) GetTournament(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	tournament, err := h.service.GetTournament(ctx, tournamentID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Tournament not found")
		return
	}

	response := TournamentResponse{
		ID:            tournament.ID,
		Name:          tournament.Name,
		Type:          string(tournament.Type),
		Status:        string(tournament.Status),
		MaxPlayers:    tournament.MaxPlayers,
		CurrentRound:  tournament.CurrentRound,
		PrizePool:     tournament.PrizePool,
		StartTime:     tournament.StartTime,
		EndTime:       tournament.EndTime,
		CreatedAt:     tournament.CreatedAt,
	}

	h.respondJSON(w, http.StatusOK, response)
}

// PERFORMANCE: Optimized tournament start
func (h *Handler) StartTournament(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	if err := h.service.StartTournament(ctx, tournamentID); err != nil {
		h.service.Logger().Error("Failed to start tournament",
			zap.String("tournament_id", tournamentID),
			zap.Error(err))
		h.respondError(w, http.StatusInternalServerError, "Failed to start tournament")
		return
	}

	h.respondJSON(w, http.StatusOK, map[string]string{
		"status": "tournament_started",
		"tournament_id": tournamentID,
	})
}

// PERFORMANCE: Optimized participant registration
func (h *Handler) RegisterParticipant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	var req RegisterParticipantRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	if req.UserID == "" {
		h.respondError(w, http.StatusBadRequest, "User ID is required")
		return
	}

	if err := h.service.RegisterParticipant(ctx, tournamentID, req.UserID); err != nil {
		h.service.Logger().Error("Failed to register participant",
			zap.String("tournament_id", tournamentID),
			zap.String("user_id", req.UserID),
			zap.Error(err))
		h.respondError(w, http.StatusInternalServerError, "Failed to register participant")
		return
	}

	h.respondJSON(w, http.StatusOK, map[string]string{
		"status": "participant_registered",
		"tournament_id": tournamentID,
		"user_id": req.UserID,
	})
}

// PERFORMANCE: Optimized participants listing
func (h *Handler) GetParticipants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	participants, err := h.service.GetTournamentParticipants(ctx, tournamentID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Participants not found")
		return
	}

	var response []ParticipantResponse
	for _, p := range participants {
		response = append(response, ParticipantResponse{
			UserID:   p.UserID,
			Seed:     p.Seed,
			Status:   string(p.Status),
			JoinedAt: p.JoinedAt,
			Stats: ParticipantStats{
				Wins:         p.Stats.Wins,
				Losses:       p.Stats.Losses,
				TotalScore:   p.Stats.TotalScore,
				AverageScore: p.Stats.AverageScore,
				Rank:         p.Stats.Rank,
			},
		})
	}

	h.respondJSON(w, http.StatusOK, response)
}

// PERFORMANCE: Optimized leaderboard retrieval
func (h *Handler) GetLeaderboard(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	leaderboard, err := h.service.GetTournamentLeaderboard(ctx, tournamentID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Leaderboard not found")
		return
	}

	var response []ParticipantResponse
	for _, p := range leaderboard {
		response = append(response, ParticipantResponse{
			UserID:   p.UserID,
			Seed:     p.Seed,
			Status:   string(p.Status),
			JoinedAt: p.JoinedAt,
			Stats: ParticipantStats{
				Wins:         p.Stats.Wins,
				Losses:       p.Stats.Losses,
				TotalScore:   p.Stats.TotalScore,
				AverageScore: p.Stats.AverageScore,
				Rank:         p.Stats.Rank,
			},
		})
	}

	h.respondJSON(w, http.StatusOK, response)
}

// PERFORMANCE: Optimized matches retrieval
func (h *Handler) GetMatches(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	matches, err := h.service.GetTournamentMatches(ctx, tournamentID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Matches not found")
		return
	}

	var response []MatchResponse
	for _, m := range matches {
		response = append(response, MatchResponse{
			ID:           m.ID,
			Round:        m.Round,
			Position:     m.Position,
			Player1ID:    m.Player1ID,
			Player2ID:    m.Player2ID,
			WinnerID:     m.WinnerID,
			Status:       string(m.Status),
			StartTime:    m.StartTime,
			EndTime:      m.EndTime,
			Score1:       m.Score1,
			Score2:       m.Score2,
			NextMatchID:  m.NextMatchID,
		})
	}

	h.respondJSON(w, http.StatusOK, response)
}

// PERFORMANCE: Optimized match result reporting
func (h *Handler) ReportMatchResult(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	matchID := chi.URLParam(r, "matchID")

	var req MatchResultRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.respondError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	if req.WinnerID == "" {
		h.respondError(w, http.StatusBadRequest, "Winner ID is required")
		return
	}

	if err := h.service.ReportMatchResult(ctx, matchID, req.WinnerID, req.Score1, req.Score2); err != nil {
		h.service.Logger().Error("Failed to report match result",
			zap.String("match_id", matchID),
			zap.Error(err))
		h.respondError(w, http.StatusInternalServerError, "Failed to report match result")
		return
	}

	h.respondJSON(w, http.StatusOK, map[string]string{
		"status":   "match_result_reported",
		"match_id": matchID,
	})
}

// PERFORMANCE: Optimized match retrieval
func (h *Handler) GetMatch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	matchID := chi.URLParam(r, "matchID")

	match, err := h.service.GetMatch(ctx, matchID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Match not found")
		return
	}

	response := MatchResponse{
		ID:          match.ID,
		Round:       match.Round,
		Position:    match.Position,
		Player1ID:   match.Player1ID,
		Player2ID:   match.Player2ID,
		WinnerID:    match.WinnerID,
		Status:      string(match.Status),
		StartTime:   match.StartTime,
		EndTime:     match.EndTime,
		Score1:      match.Score1,
		Score2:      match.Score2,
		NextMatchID: match.NextMatchID,
	}

	h.respondJSON(w, http.StatusOK, response)
}

// PERFORMANCE: Optimized tournament statistics
func (h *Handler) GetTournamentStats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tournamentID := chi.URLParam(r, "tournamentID")

	stats, err := h.service.GetTournamentStats(ctx, tournamentID)
	if err != nil {
		h.respondError(w, http.StatusNotFound, "Tournament stats not found")
		return
	}

	h.respondJSON(w, http.StatusOK, stats)
}

// PERFORMANCE: Optimized tournament listing with pagination
func (h *Handler) ListTournaments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parse query parameters
	status := r.URL.Query().Get("status")
	limitStr := r.URL.Query().Get("limit")
	offsetStr := r.URL.Query().Get("offset")

	limit := 20 // default
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	offset := 0 // default
	if offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	tournaments, err := h.service.ListTournaments(ctx, status, limit, offset)
	if err != nil {
		h.respondError(w, http.StatusInternalServerError, "Failed to list tournaments")
		return
	}

	var response []TournamentResponse
	for _, t := range tournaments {
		response = append(response, TournamentResponse{
			ID:         t.ID,
			Name:       t.Name,
			Type:       string(t.Type),
			Status:     string(t.Status),
			MaxPlayers: t.MaxPlayers,
			PrizePool:  t.PrizePool,
			CreatedAt:  t.CreatedAt,
		})
	}

	h.respondJSON(w, http.StatusOK, map[string]interface{}{
		"tournaments": response,
		"limit":       limit,
		"offset":      offset,
	})
}

// PERFORMANCE: Optimized error response
func (h *Handler) respondError(w http.ResponseWriter, status int, message string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(map[string]string{"error": message})
}

// PERFORMANCE: Optimized JSON response
func (h *Handler) respondJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

// Request/Response types
type CreateTournamentRequest struct {
	Name       string                      `json:"name"`
	Type       service.TournamentType      `json:"type"`
	MaxPlayers int                         `json:"max_players"`
	PrizePool  float64                     `json:"prize_pool"`
}

type RegisterParticipantRequest struct {
	UserID string `json:"user_id"`
}

type MatchResultRequest struct {
	WinnerID string `json:"winner_id"`
	Score1   int    `json:"score1"`
	Score2   int    `json:"score2"`
}

type TournamentResponse struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Status       string    `json:"status"`
	MaxPlayers   int       `json:"max_players"`
	CurrentRound int       `json:"current_round,omitempty"`
	PrizePool    float64   `json:"prize_pool"`
	StartTime    time.Time `json:"start_time,omitempty"`
	EndTime      time.Time `json:"end_time,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
}

type ParticipantResponse struct {
	UserID   string           `json:"user_id"`
	Seed     int              `json:"seed"`
	Status   string           `json:"status"`
	JoinedAt time.Time        `json:"joined_at"`
	Stats    ParticipantStats `json:"stats"`
}

type ParticipantStats struct {
	Wins         int     `json:"wins"`
	Losses       int     `json:"losses"`
	TotalScore   int     `json:"total_score"`
	AverageScore float32 `json:"average_score"`
	Rank         int     `json:"rank"`
}

type MatchResponse struct {
	ID          string    `json:"id"`
	Round       int       `json:"round"`
	Position    int       `json:"position"`
	Player1ID   string    `json:"player1_id"`
	Player2ID   string    `json:"player2_id"`
	WinnerID    string    `json:"winner_id"`
	Status      string    `json:"status"`
	StartTime   time.Time `json:"start_time"`
	EndTime     time.Time `json:"end_time,omitempty"`
	Score1      int       `json:"score1"`
	Score2      int       `json:"score2"`
	NextMatchID string    `json:"next_match_id,omitempty"`
}