// Code generated by QA agent. DTO layer for type conversion between service and repository layers.
// Fixes type system conflicts identified during QA testing.
// Issue: #2192 - Tournament Service Implementation

package service

import (
	"necpgame/services/tournament-service-go/internal/repository"
)

// DTO conversion functions to resolve type system conflicts

// TournamentDTO converts service Tournament to repository Tournament
func TournamentToRepository(t *Tournament) *repository.Tournament {
	if t == nil {
		return nil
	}

	repoTournament := &repository.Tournament{
		ID:           t.ID,
		Name:         t.Name,
		Type:         repository.TournamentType(t.Type),
		Status:       repository.TournamentStatus(t.Status),
		MaxPlayers:   t.MaxPlayers,
		CurrentRound: t.CurrentRound,
		PrizePool:    t.PrizePool,
		CreatedAt:    t.CreatedAt,
	}

	if t.StartTime != nil {
		repoTournament.StartTime = t.StartTime
	}

	if t.EndTime != nil {
		repoTournament.EndTime = t.EndTime
	}

	return repoTournament
}

// RepositoryToTournamentDTO converts repository Tournament to service Tournament
func RepositoryToTournamentDTO(repoTournament *repository.Tournament) *Tournament {
	if repoTournament == nil {
		return nil
	}

	tournament := &Tournament{
		Tournament: repository.Tournament{
			ID:           repoTournament.ID,
			Name:         repoTournament.Name,
			Type:         repoTournament.Type,
			Status:       repoTournament.Status,
			MaxPlayers:   repoTournament.MaxPlayers,
			CurrentRound: repoTournament.CurrentRound,
			PrizePool:    repoTournament.PrizePool,
			StartTime:    repoTournament.StartTime,
			EndTime:      repoTournament.EndTime,
			CreatedAt:    repoTournament.CreatedAt,
			UpdatedAt:    repoTournament.UpdatedAt,
		},
	}

	if repoTournament.StartTime != nil {
		tournament.StartTime = repoTournament.StartTime
	}

	if repoTournament.EndTime != nil {
		tournament.EndTime = repoTournament.EndTime
	}

	// Initialize runtime state
	tournament.participants = make([]*Participant, 0)
	tournament.matches = make([]*Match, 0)
	tournament.brackets = make(map[int][]*Match)

	return tournament
}

// ParticipantDTO converts service Participant to repository Participant
func ParticipantToRepository(p *Participant) *repository.Participant {
	if p == nil {
		return nil
	}

	return &repository.Participant{
		UserID:       p.UserID,
		TournamentID: p.TournamentID,
		Seed:         p.Seed,
		Status:       p.Status,
		JoinedAt:     p.JoinedAt,
		Stats:        p.Stats,
	}
}

// MatchDTO converts service Match to repository Match
func MatchToRepository(m *Match) *repository.Match {
	if m == nil {
		return nil
	}

	repoMatch := &repository.Match{
		ID:           m.ID,
		TournamentID: m.TournamentID,
		Round:        m.Round,
		Position:     m.Position,
		Status:       m.Status,
		StartTime:    m.StartTime,
		Score1:       m.Score1,
		Score2:       m.Score2,
	}

	if m.Player1ID != nil {
		repoMatch.Player1ID = m.Player1ID
	}

	if m.Player2ID != nil {
		repoMatch.Player2ID = m.Player2ID
	}

	if m.WinnerID != nil {
		repoMatch.WinnerID = m.WinnerID
	}

	if m.NextMatchID != nil {
		repoMatch.NextMatchID = m.NextMatchID
	}

	if m.EndTime != nil {
		repoMatch.EndTime = m.EndTime
	}

	return repoMatch
}

// RepositoryToMatchDTO converts repository Match to service Match
func RepositoryToMatchDTO(repoMatch *repository.Match) *Match {
	if repoMatch == nil {
		return nil
	}

	match := &Match{
		ID:           repoMatch.ID,
		TournamentID: repoMatch.TournamentID,
		Round:        repoMatch.Round,
		Position:     repoMatch.Position,
		Status:       repoMatch.Status,
		StartTime:    repoMatch.StartTime,
		Score1:       repoMatch.Score1,
		Score2:       repoMatch.Score2,
	}

	if repoMatch.Player1ID != nil {
		player1ID := *repoMatch.Player1ID
		match.Player1ID = &player1ID
	}

	if repoMatch.Player2ID != nil {
		player2ID := *repoMatch.Player2ID
		match.Player2ID = &player2ID
	}

	if repoMatch.WinnerID != nil {
		winnerID := *repoMatch.WinnerID
		match.WinnerID = &winnerID
	}

	if repoMatch.NextMatchID != nil {
		nextMatchID := *repoMatch.NextMatchID
		match.NextMatchID = &nextMatchID
	}

	if repoMatch.EndTime != nil {
		endTime := *repoMatch.EndTime
		match.EndTime = &endTime
	}

	return match
}

// RepositoryToParticipantDTO converts repository Participant to service Participant
func RepositoryToParticipantDTO(repoParticipant *repository.Participant) *Participant {
	if repoParticipant == nil {
		return nil
	}

	return &repository.Participant{
		UserID:       repoParticipant.UserID,
		TournamentID: repoParticipant.TournamentID,
		Seed:         repoParticipant.Seed,
		Status:       repoParticipant.Status,
		JoinedAt:     repoParticipant.JoinedAt,
		Stats:        repoParticipant.Stats,
	}
}

// Status constants for service layer
const (
	// Tournament statuses
	TournamentStatusRegistration = "registration"
	TournamentStatusInProgress   = "in_progress"
	TournamentStatusCompleted    = "completed"

	// Participant statuses
	ParticipantStatusRegistered = "registered"
	ParticipantStatusActive     = "active"
	ParticipantStatusEliminated = "eliminated"

	// Match statuses
	MatchStatusPending   = "pending"
	MatchStatusInProgress = "in_progress"
	MatchStatusCompleted = "completed"
)