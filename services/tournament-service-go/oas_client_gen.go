// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateTournament invokes createTournament operation.
	//
	// **Enterprise-grade creation endpoint**
	// Validates business rules, applies security checks, and ensures data consistency.
	// Supports optimistic locking for concurrent operations.
	// **Performance:** <50ms P95, includes validation and business logic.
	//
	// POST /tournaments
	CreateTournament(ctx context.Context, request *CreateTournamentRequest) (CreateTournamentRes, error)
	// DeleteTournament invokes deleteTournament operation.
	//
	// **Enterprise-grade deletion endpoint**
	// Supports soft deletes with audit trails and cleanup scheduling.
	// Ensures referential integrity and cascading deletes.
	// **Performance:** <15ms P95, includes cleanup operations.
	//
	// DELETE /tournaments/{tournament_id}
	DeleteTournament(ctx context.Context, params DeleteTournamentParams) (DeleteTournamentRes, error)
	// GenerateTournamentBracket invokes generateTournamentBracket operation.
	//
	// **Bracket generation for tournament start**
	// Generates tournament bracket structure based on registered participants and tournament format.
	// Supports automatic seeding and bracket distribution algorithms.
	// **Business Logic:** - Validates tournament status (must have sufficient participants) - Generates
	// bracket based on tournament format (single/double elimination, round-robin) - Applies seeding
	// algorithm if participants have seed values - Distributes participants across bracket positions
	// **Performance:** <100ms for bracket generation with up to 128 participants.
	//
	// POST /tournaments/{tournament_id}/bracket
	GenerateTournamentBracket(ctx context.Context, request OptGenerateBracketRequest, params GenerateTournamentBracketParams) (GenerateTournamentBracketRes, error)
	// GetGlobalLeaderboards invokes getGlobalLeaderboards operation.
	//
	// **Enterprise-grade leaderboard retrieval endpoint**
	// Retrieves global tournament leaderboards across all tournaments and time periods. Supports
	// filtering by tournament type, time range, and ranking criteria.
	// **Performance:** <50ms P99 latency, cached for 5 minutes, supports 10,000+ concurrent requests
	// **Use Cases:** - Global player rankings - Tournament statistics - Historical performance analysis
	// - Competitive insights.
	//
	// GET /leaderboards
	GetGlobalLeaderboards(ctx context.Context, params GetGlobalLeaderboardsParams) (GetGlobalLeaderboardsRes, error)
	// GetTournament invokes getTournament operation.
	//
	// **Enterprise-grade retrieval endpoint**
	// Optimized with proper caching strategies and database indexing.
	// Supports conditional requests with ETags.
	// **Performance:** <5ms P95 with Redis caching.
	//
	// GET /tournaments/{tournament_id}
	GetTournament(ctx context.Context, params GetTournamentParams) (GetTournamentRes, error)
	// GetTournamentBracket invokes getTournamentBracket operation.
	//
	// **Tournament bracket visualization and management**
	// Retrieves the current tournament bracket structure with all matches, rounds, and participant
	// positions. Supports real-time bracket updates during tournament progression.
	// **Business Logic:** - Returns bracket structure based on tournament format (single/double
	// elimination, round-robin) - Includes match status, participant positions, and next round
	// information - Real-time updates during match progression
	// **Performance:** <10ms response time with cached bracket structure.
	//
	// GET /tournaments/{tournament_id}/bracket
	GetTournamentBracket(ctx context.Context, params GetTournamentBracketParams) (GetTournamentBracketRes, error)
	// GetTournamentLeaderboard invokes getTournamentLeaderboard operation.
	//
	// **Real-time tournament standings and rankings**
	// Provides current tournament leaderboard with player rankings, scores, and progression statistics.
	// **Performance:** <5ms response time with cached rankings **Caching:** 30-second cache with
	// real-time invalidation on score updates.
	//
	// GET /tournaments/{tournament_id}/leaderboard
	GetTournamentLeaderboard(ctx context.Context, params GetTournamentLeaderboardParams) (GetTournamentLeaderboardRes, error)
	// GetTournamentSpectators invokes getTournamentSpectators operation.
	//
	// **Live spectator management for tournament viewing**
	// Retrieves list of current spectators watching the tournament, with spectator count and spectator
	// activity statistics.
	// **Business Logic:** - Returns current spectator count - Includes spectator activity metrics -
	// Supports pagination for large spectator lists
	// **Performance:** <5ms response time with cached spectator data.
	//
	// GET /tournaments/{tournament_id}/spectators
	GetTournamentSpectators(ctx context.Context, params GetTournamentSpectatorsParams) (GetTournamentSpectatorsRes, error)
	// JoinTournament invokes joinTournament operation.
	//
	// **Player registration for tournament participation**
	// Handles tournament registration with validation of entry requirements, participant limits, and
	// registration deadlines.
	// **Business Logic:** - Validates tournament status (must be registration_open) - Checks participant
	// capacity - Verifies player eligibility - Reserves participant slot.
	//
	// POST /tournaments/{tournament_id}/join
	JoinTournament(ctx context.Context, request *JoinTournamentRequest, params JoinTournamentParams) (JoinTournamentRes, error)
	// LeaveTournament invokes leaveTournament operation.
	//
	// **Player withdrawal from tournament participation**
	// Handles tournament withdrawal with proper cleanup of participant records and slot release.
	// **Business Logic:** - Validates tournament status (must not be completed) - Removes participant
	// record - Releases participant slot - Updates tournament statistics.
	//
	// POST /tournaments/{tournament_id}/leave
	LeaveTournament(ctx context.Context, request *LeaveTournamentRequest, params LeaveTournamentParams) (LeaveTournamentRes, error)
	// ListTournaments invokes listTournaments operation.
	//
	// **Enterprise-grade tournament listing endpoint**
	// Supports complex filtering by type, status, skill level, and pagination.
	// Optimized for high-throughput tournament browsing with proper indexing.
	// **Performance:** <10ms P95, supports 1000+ concurrent tournament searches.
	//
	// GET /tournaments
	ListTournaments(ctx context.Context, params ListTournamentsParams) (ListTournamentsRes, error)
	// RegisterTournamentScore invokes registerTournamentScore operation.
	//
	// **Match result registration for tournament progression**
	// Records match outcomes with validation and automatic tournament bracket advancement calculation.
	// **Business Logic:** - Validates match authenticity - Updates participant scores - Calculates
	// tournament standings - Advances tournament bracket - Triggers elimination logic
	// **Performance:** Sub-millisecond score validation and ranking updates.
	//
	// POST /tournaments/{tournament_id}/scores
	RegisterTournamentScore(ctx context.Context, request *RegisterTournamentScoreRequest, params RegisterTournamentScoreParams) (RegisterTournamentScoreRes, error)
	// TournamentServiceBatchHealthCheck invokes tournamentServiceBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple tournament service health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	TournamentServiceBatchHealthCheck(ctx context.Context, request *TournamentServiceBatchHealthCheckReq) (TournamentServiceBatchHealthCheckRes, error)
	// TournamentServiceHealthCheck invokes tournamentServiceHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the tournament service microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	TournamentServiceHealthCheck(ctx context.Context, params TournamentServiceHealthCheckParams) (TournamentServiceHealthCheckRes, error)
	// TournamentServiceHealthWebSocket invokes tournamentServiceHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	TournamentServiceHealthWebSocket(ctx context.Context, params TournamentServiceHealthWebSocketParams) (TournamentServiceHealthWebSocketRes, error)
	// TournamentSpectatorWebSocket invokes tournamentSpectatorWebSocket operation.
	//
	// **Live tournament viewing with real-time updates**
	// WebSocket endpoint for real-time tournament spectator mode. Provides live match updates, bracket
	// progression, and tournament statistics without polling.
	// **Protocol:** WebSocket with JSON payloads **Heartbeat:** 30 second intervals **Reconnection:**
	// Automatic with exponential backoff
	// **Message Types:** - match_start: Match has started - match_update: Match score/status update -
	// match_end: Match has completed - bracket_update: Bracket structure has changed -
	// tournament_update: Tournament status change
	// **Performance:** Sub-millisecond message delivery, supports 10,000+ concurrent spectators.
	//
	// GET /tournaments/{tournament_id}/spectate
	TournamentSpectatorWebSocket(ctx context.Context, params TournamentSpectatorWebSocketParams) (TournamentSpectatorWebSocketRes, error)
	// UpdateTournament invokes updateTournament operation.
	//
	// **Enterprise-grade update endpoint**
	// Supports partial updates, optimistic locking, and audit trails.
	// Ensures data consistency with event sourcing patterns.
	// **Performance:** <25ms P95, includes validation and conflict resolution.
	//
	// PUT /tournaments/{tournament_id}
	UpdateTournament(ctx context.Context, request *UpdateTournamentRequest, params UpdateTournamentParams) (UpdateTournamentRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateTournament invokes createTournament operation.
//
// **Enterprise-grade creation endpoint**
// Validates business rules, applies security checks, and ensures data consistency.
// Supports optimistic locking for concurrent operations.
// **Performance:** <50ms P95, includes validation and business logic.
//
// POST /tournaments
func (c *Client) CreateTournament(ctx context.Context, request *CreateTournamentRequest) (CreateTournamentRes, error) {
	res, err := c.sendCreateTournament(ctx, request)
	return res, err
}

func (c *Client) sendCreateTournament(ctx context.Context, request *CreateTournamentRequest) (res CreateTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createTournament"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/tournaments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tournaments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CreateTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTournament invokes deleteTournament operation.
//
// **Enterprise-grade deletion endpoint**
// Supports soft deletes with audit trails and cleanup scheduling.
// Ensures referential integrity and cascading deletes.
// **Performance:** <15ms P95, includes cleanup operations.
//
// DELETE /tournaments/{tournament_id}
func (c *Client) DeleteTournament(ctx context.Context, params DeleteTournamentParams) (DeleteTournamentRes, error) {
	res, err := c.sendDeleteTournament(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTournament(ctx context.Context, params DeleteTournamentParams) (res DeleteTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTournament"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, DeleteTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateTournamentBracket invokes generateTournamentBracket operation.
//
// **Bracket generation for tournament start**
// Generates tournament bracket structure based on registered participants and tournament format.
// Supports automatic seeding and bracket distribution algorithms.
// **Business Logic:** - Validates tournament status (must have sufficient participants) - Generates
// bracket based on tournament format (single/double elimination, round-robin) - Applies seeding
// algorithm if participants have seed values - Distributes participants across bracket positions
// **Performance:** <100ms for bracket generation with up to 128 participants.
//
// POST /tournaments/{tournament_id}/bracket
func (c *Client) GenerateTournamentBracket(ctx context.Context, request OptGenerateBracketRequest, params GenerateTournamentBracketParams) (GenerateTournamentBracketRes, error) {
	res, err := c.sendGenerateTournamentBracket(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateTournamentBracket(ctx context.Context, request OptGenerateBracketRequest, params GenerateTournamentBracketParams) (res GenerateTournamentBracketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generateTournamentBracket"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/bracket"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GenerateTournamentBracketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bracket"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateTournamentBracketRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GenerateTournamentBracketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateTournamentBracketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGlobalLeaderboards invokes getGlobalLeaderboards operation.
//
// **Enterprise-grade leaderboard retrieval endpoint**
// Retrieves global tournament leaderboards across all tournaments and time periods. Supports
// filtering by tournament type, time range, and ranking criteria.
// **Performance:** <50ms P99 latency, cached for 5 minutes, supports 10,000+ concurrent requests
// **Use Cases:** - Global player rankings - Tournament statistics - Historical performance analysis
// - Competitive insights.
//
// GET /leaderboards
func (c *Client) GetGlobalLeaderboards(ctx context.Context, params GetGlobalLeaderboardsParams) (GetGlobalLeaderboardsRes, error) {
	res, err := c.sendGetGlobalLeaderboards(ctx, params)
	return res, err
}

func (c *Client) sendGetGlobalLeaderboards(ctx context.Context, params GetGlobalLeaderboardsParams) (res GetGlobalLeaderboardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGlobalLeaderboards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/leaderboards"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetGlobalLeaderboardsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/leaderboards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "tournament_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tournament_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TournamentType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "time_range" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "time_range",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TimeRange.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetGlobalLeaderboardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGlobalLeaderboardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTournament invokes getTournament operation.
//
// **Enterprise-grade retrieval endpoint**
// Optimized with proper caching strategies and database indexing.
// Supports conditional requests with ETags.
// **Performance:** <5ms P95 with Redis caching.
//
// GET /tournaments/{tournament_id}
func (c *Client) GetTournament(ctx context.Context, params GetTournamentParams) (GetTournamentRes, error) {
	res, err := c.sendGetTournament(ctx, params)
	return res, err
}

func (c *Client) sendGetTournament(ctx context.Context, params GetTournamentParams) (res GetTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTournament"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "include_related" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_related",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeRelated.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-None-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfNoneMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Modified-Since",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfModifiedSince.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTournamentBracket invokes getTournamentBracket operation.
//
// **Tournament bracket visualization and management**
// Retrieves the current tournament bracket structure with all matches, rounds, and participant
// positions. Supports real-time bracket updates during tournament progression.
// **Business Logic:** - Returns bracket structure based on tournament format (single/double
// elimination, round-robin) - Includes match status, participant positions, and next round
// information - Real-time updates during match progression
// **Performance:** <10ms response time with cached bracket structure.
//
// GET /tournaments/{tournament_id}/bracket
func (c *Client) GetTournamentBracket(ctx context.Context, params GetTournamentBracketParams) (GetTournamentBracketRes, error) {
	res, err := c.sendGetTournamentBracket(ctx, params)
	return res, err
}

func (c *Client) sendGetTournamentBracket(ctx context.Context, params GetTournamentBracketParams) (res GetTournamentBracketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTournamentBracket"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/bracket"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTournamentBracketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bracket"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "include_matches" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_matches",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeMatches.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetTournamentBracketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTournamentBracketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTournamentLeaderboard invokes getTournamentLeaderboard operation.
//
// **Real-time tournament standings and rankings**
// Provides current tournament leaderboard with player rankings, scores, and progression statistics.
// **Performance:** <5ms response time with cached rankings **Caching:** 30-second cache with
// real-time invalidation on score updates.
//
// GET /tournaments/{tournament_id}/leaderboard
func (c *Client) GetTournamentLeaderboard(ctx context.Context, params GetTournamentLeaderboardParams) (GetTournamentLeaderboardRes, error) {
	res, err := c.sendGetTournamentLeaderboard(ctx, params)
	return res, err
}

func (c *Client) sendGetTournamentLeaderboard(ctx context.Context, params GetTournamentLeaderboardParams) (res GetTournamentLeaderboardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTournamentLeaderboard"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/leaderboard"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTournamentLeaderboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/leaderboard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetTournamentLeaderboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTournamentLeaderboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTournamentSpectators invokes getTournamentSpectators operation.
//
// **Live spectator management for tournament viewing**
// Retrieves list of current spectators watching the tournament, with spectator count and spectator
// activity statistics.
// **Business Logic:** - Returns current spectator count - Includes spectator activity metrics -
// Supports pagination for large spectator lists
// **Performance:** <5ms response time with cached spectator data.
//
// GET /tournaments/{tournament_id}/spectators
func (c *Client) GetTournamentSpectators(ctx context.Context, params GetTournamentSpectatorsParams) (GetTournamentSpectatorsRes, error) {
	res, err := c.sendGetTournamentSpectators(ctx, params)
	return res, err
}

func (c *Client) sendGetTournamentSpectators(ctx context.Context, params GetTournamentSpectatorsParams) (res GetTournamentSpectatorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTournamentSpectators"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/spectators"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTournamentSpectatorsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/spectators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetTournamentSpectatorsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTournamentSpectatorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// JoinTournament invokes joinTournament operation.
//
// **Player registration for tournament participation**
// Handles tournament registration with validation of entry requirements, participant limits, and
// registration deadlines.
// **Business Logic:** - Validates tournament status (must be registration_open) - Checks participant
// capacity - Verifies player eligibility - Reserves participant slot.
//
// POST /tournaments/{tournament_id}/join
func (c *Client) JoinTournament(ctx context.Context, request *JoinTournamentRequest, params JoinTournamentParams) (JoinTournamentRes, error) {
	res, err := c.sendJoinTournament(ctx, request, params)
	return res, err
}

func (c *Client) sendJoinTournament(ctx context.Context, request *JoinTournamentRequest, params JoinTournamentParams) (res JoinTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("joinTournament"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/join"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, JoinTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/join"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeJoinTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, JoinTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeJoinTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveTournament invokes leaveTournament operation.
//
// **Player withdrawal from tournament participation**
// Handles tournament withdrawal with proper cleanup of participant records and slot release.
// **Business Logic:** - Validates tournament status (must not be completed) - Removes participant
// record - Releases participant slot - Updates tournament statistics.
//
// POST /tournaments/{tournament_id}/leave
func (c *Client) LeaveTournament(ctx context.Context, request *LeaveTournamentRequest, params LeaveTournamentParams) (LeaveTournamentRes, error) {
	res, err := c.sendLeaveTournament(ctx, request, params)
	return res, err
}

func (c *Client) sendLeaveTournament(ctx context.Context, request *LeaveTournamentRequest, params LeaveTournamentParams) (res LeaveTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("leaveTournament"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/leave"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeaveTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/leave"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeaveTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, LeaveTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeaveTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTournaments invokes listTournaments operation.
//
// **Enterprise-grade tournament listing endpoint**
// Supports complex filtering by type, status, skill level, and pagination.
// Optimized for high-throughput tournament browsing with proper indexing.
// **Performance:** <10ms P95, supports 1000+ concurrent tournament searches.
//
// GET /tournaments
func (c *Client) ListTournaments(ctx context.Context, params ListTournamentsParams) (ListTournamentsRes, error) {
	res, err := c.sendListTournaments(ctx, params)
	return res, err
}

func (c *Client) sendListTournaments(ctx context.Context, params ListTournamentsParams) (res ListTournamentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listTournaments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListTournamentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tournaments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOrder.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "game_mode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "game_mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GameMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skill_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skill_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SkillLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ListTournamentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListTournamentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterTournamentScore invokes registerTournamentScore operation.
//
// **Match result registration for tournament progression**
// Records match outcomes with validation and automatic tournament bracket advancement calculation.
// **Business Logic:** - Validates match authenticity - Updates participant scores - Calculates
// tournament standings - Advances tournament bracket - Triggers elimination logic
// **Performance:** Sub-millisecond score validation and ranking updates.
//
// POST /tournaments/{tournament_id}/scores
func (c *Client) RegisterTournamentScore(ctx context.Context, request *RegisterTournamentScoreRequest, params RegisterTournamentScoreParams) (RegisterTournamentScoreRes, error) {
	res, err := c.sendRegisterTournamentScore(ctx, request, params)
	return res, err
}

func (c *Client) sendRegisterTournamentScore(ctx context.Context, request *RegisterTournamentScoreRequest, params RegisterTournamentScoreParams) (res RegisterTournamentScoreRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("registerTournamentScore"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RegisterTournamentScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterTournamentScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:ServiceAuth"
			switch err := c.securityServiceAuth(ctx, RegisterTournamentScoreOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ServiceAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRegisterTournamentScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentServiceBatchHealthCheck invokes tournamentServiceBatchHealthCheck operation.
//
// **Performance optimization:** Check multiple tournament service health in single request
// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
// Eliminates network overhead in health monitoring scenarios.
// **Use case:** Service mesh health checks, Kubernetes readiness probes.
//
// POST /health/batch
func (c *Client) TournamentServiceBatchHealthCheck(ctx context.Context, request *TournamentServiceBatchHealthCheckReq) (TournamentServiceBatchHealthCheckRes, error) {
	res, err := c.sendTournamentServiceBatchHealthCheck(ctx, request)
	return res, err
}

func (c *Client) sendTournamentServiceBatchHealthCheck(ctx context.Context, request *TournamentServiceBatchHealthCheckReq) (res TournamentServiceBatchHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournamentServiceBatchHealthCheck"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/health/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentServiceBatchHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentServiceBatchHealthCheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, TournamentServiceBatchHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentServiceBatchHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentServiceHealthCheck invokes tournamentServiceHealthCheck operation.
//
// **Enterprise-grade health check endpoint**
// Provides real-time health status of the tournament service microservice.
// Critical for service discovery, load balancing, and monitoring.
// **Performance:** <1ms response time, cached for 30 seconds.
//
// GET /health
func (c *Client) TournamentServiceHealthCheck(ctx context.Context, params TournamentServiceHealthCheckParams) (TournamentServiceHealthCheckRes, error) {
	res, err := c.sendTournamentServiceHealthCheck(ctx, params)
	return res, err
}

func (c *Client) sendTournamentServiceHealthCheck(ctx context.Context, params TournamentServiceHealthCheckParams) (res TournamentServiceHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournamentServiceHealthCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentServiceHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AcceptEncoding.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, TournamentServiceHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentServiceHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentServiceHealthWebSocket invokes tournamentServiceHealthWebSocket operation.
//
// **Performance optimization:** Real-time health updates without polling
// Eliminates periodic HTTP requests, reduces server load by ~90%.
// Perfect for dashboard monitoring and alerting systems.
// **Protocol:** WebSocket with JSON payloads
// **Heartbeat:** 30 second intervals
// **Reconnection:** Automatic with exponential backoff.
//
// GET /health/ws
func (c *Client) TournamentServiceHealthWebSocket(ctx context.Context, params TournamentServiceHealthWebSocketParams) (TournamentServiceHealthWebSocketRes, error) {
	res, err := c.sendTournamentServiceHealthWebSocket(ctx, params)
	return res, err
}

func (c *Client) sendTournamentServiceHealthWebSocket(ctx context.Context, params TournamentServiceHealthWebSocketParams) (res TournamentServiceHealthWebSocketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournamentServiceHealthWebSocket"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/ws"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentServiceHealthWebSocketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/ws"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "services" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "services",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Services != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Services {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, TournamentServiceHealthWebSocketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentServiceHealthWebSocketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentSpectatorWebSocket invokes tournamentSpectatorWebSocket operation.
//
// **Live tournament viewing with real-time updates**
// WebSocket endpoint for real-time tournament spectator mode. Provides live match updates, bracket
// progression, and tournament statistics without polling.
// **Protocol:** WebSocket with JSON payloads **Heartbeat:** 30 second intervals **Reconnection:**
// Automatic with exponential backoff
// **Message Types:** - match_start: Match has started - match_update: Match score/status update -
// match_end: Match has completed - bracket_update: Bracket structure has changed -
// tournament_update: Tournament status change
// **Performance:** Sub-millisecond message delivery, supports 10,000+ concurrent spectators.
//
// GET /tournaments/{tournament_id}/spectate
func (c *Client) TournamentSpectatorWebSocket(ctx context.Context, params TournamentSpectatorWebSocketParams) (TournamentSpectatorWebSocketRes, error) {
	res, err := c.sendTournamentSpectatorWebSocket(ctx, params)
	return res, err
}

func (c *Client) sendTournamentSpectatorWebSocket(ctx context.Context, params TournamentSpectatorWebSocketParams) (res TournamentSpectatorWebSocketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournamentSpectatorWebSocket"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}/spectate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentSpectatorWebSocketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/spectate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, TournamentSpectatorWebSocketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentSpectatorWebSocketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTournament invokes updateTournament operation.
//
// **Enterprise-grade update endpoint**
// Supports partial updates, optimistic locking, and audit trails.
// Ensures data consistency with event sourcing patterns.
// **Performance:** <25ms P95, includes validation and conflict resolution.
//
// PUT /tournaments/{tournament_id}
func (c *Client) UpdateTournament(ctx context.Context, request *UpdateTournamentRequest, params UpdateTournamentParams) (UpdateTournamentRes, error) {
	res, err := c.sendUpdateTournament(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTournament(ctx context.Context, request *UpdateTournamentRequest, params UpdateTournamentParams) (res UpdateTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateTournament"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/tournaments/{tournament_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tournaments/"
	{
		// Encode "tournament_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournament_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TournamentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Unmodified-Since",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfUnmodifiedSince.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, UpdateTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
