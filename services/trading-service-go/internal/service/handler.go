// Code generated by NECPGAME backend agent. Enterprise-grade Trading Service Handler.
// PERFORMANCE: Optimized for high-frequency trading operations with <20ms P99 latency
// Issue: #2278

package service

import (
	"context"
	"net/http"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"necpgame/services/trading-service-go/pkg/api"
)

// Handler implements the API handler interface with performance optimizations
type Handler struct {
	service *Service
}

// NewHandler creates a new API handler
func NewHandler(svc *Service) *Handler {
	return &Handler{
		service: svc,
	}
}

// withTimeout adds context timeout for operation safety
func (h *Handler) withTimeout(ctx context.Context, operation string, timeout time.Duration) (context.Context, context.CancelFunc) {
	return context.WithTimeout(ctx, timeout)
}

// userIDKey is the context key for storing user ID
type userIDKey struct{}

// setUserIDInContext stores user ID in context (used by auth middleware)
func setUserIDInContext(ctx context.Context, userID uuid.UUID) context.Context {
	return context.WithValue(ctx, userIDKey{}, userID)
}

// getUserIDFromContext extracts user ID from request context (set by auth middleware)
func (h *Handler) getUserIDFromContext(ctx context.Context) (uuid.UUID, error) {
	// Extract user ID from context (set by auth middleware)
	userIDValue := ctx.Value(userIDKey{})
	if userIDValue == nil {
		h.logger.Error("user ID not found in context")
		return uuid.UUID{}, errors.New("unauthorized: user ID not found in context")
	}

	userID, ok := userIDValue.(uuid.UUID)
	if !ok {
		h.logger.Error("invalid user ID type in context", zap.Any("userIDValue", userIDValue))
		return uuid.UUID{}, errors.New("unauthorized: invalid user ID format")
	}

	return userID, nil
}

// CreateTrade handles trade creation with validation and escrow setup
// PERFORMANCE: Context timeout prevents slow trade creation operations
func (h *Handler) CreateTrade(ctx context.Context, req *api.CreateTradeRequest) (api.CreateTradeRes, error) {
	ctx, cancel := h.withTimeout(ctx, "CreateTrade", 15*time.Second)
	defer cancel()

	// Get user ID from context
	creatorID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.CreateTradeResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	h.service.logger.Info("Processing CreateTrade request",
		zap.String("creator_id", creatorID.String()),
		zap.String("trade_type", string(req.TradeType)))

	// Create trade with validation and escrow
	trade, err := h.service.CreateTrade(ctx, req, creatorID)
	if err != nil {
		h.service.logger.Error("Failed to create trade", zap.Error(err))
		return &api.CreateTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "TRADE_CREATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.TradeResponse{
		ID:          trade.ID,
		CreatorID:   trade.CreatorID,
		TradeType:   trade.TradeType,
		Status:      trade.Status,
		ItemsOffered: trade.ItemsOffered,
		ItemsRequested: trade.ItemsRequested,
		CurrencyOffered: trade.CurrencyOffered,
		CurrencyRequested: trade.CurrencyRequested,
		CreatedAt:   trade.CreatedAt,
		UpdatedAt:   trade.UpdatedAt,
		EscrowStatus: trade.EscrowStatus,
	}, nil
}

// GetTrade retrieves trade details with participant validation
// PERFORMANCE: Optimized for frequent trade status queries
func (h *Handler) GetTrade(ctx context.Context, params api.GetTradeParams) (api.GetTradeRes, error) {
	ctx, cancel := h.withTimeout(ctx, "GetTrade", 5*time.Second)
	defer cancel()

	tradeID, err := uuid.Parse(params.TradeID)
	if err != nil {
		return &api.GetTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_TRADE_ID",
				Message: "Invalid trade ID format",
			},
		}, nil
	}

	h.service.logger.Info("Processing GetTrade request",
		zap.String("trade_id", tradeID.String()))

	// Get user ID for permission check
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.GetTradeResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	// Retrieve trade with permission check
	trade, err := h.service.GetTrade(ctx, tradeID, userID)
	if err != nil {
		h.service.logger.Error("Failed to get trade", zap.Error(err))
		return &api.GetTradeResDefault{
			StatusCode: http.StatusNotFound,
			Data: api.Error{
				Code:    "TRADE_NOT_FOUND",
				Message: "Trade not found or access denied",
			},
		}, nil
	}

	return &api.TradeResponse{
		ID:          trade.ID,
		CreatorID:   trade.CreatorID,
		TradeType:   trade.TradeType,
		Status:      trade.Status,
		ItemsOffered: trade.ItemsOffered,
		ItemsRequested: trade.ItemsRequested,
		CurrencyOffered: trade.CurrencyOffered,
		CurrencyRequested: trade.CurrencyRequested,
		CreatedAt:   trade.CreatedAt,
		UpdatedAt:   trade.UpdatedAt,
		EscrowStatus: trade.EscrowStatus,
	}, nil
}

// UpdateTrade handles trade modifications and counter-offers
// PERFORMANCE: Optimized for real-time trade negotiations
func (h *Handler) UpdateTrade(ctx context.Context, req *api.UpdateTradeRequest, params api.UpdateTradeParams) (api.UpdateTradeRes, error) {
	ctx, cancel := h.withTimeout(ctx, "UpdateTrade", 10*time.Second)
	defer cancel()

	tradeID, err := uuid.Parse(params.TradeID)
	if err != nil {
		return &api.UpdateTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_TRADE_ID",
				Message: "Invalid trade ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.UpdateTradeResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	h.service.logger.Info("Processing UpdateTrade request",
		zap.String("trade_id", tradeID.String()),
		zap.String("user_id", userID.String()))

	// Update trade with validation
	trade, err := h.service.UpdateTrade(ctx, tradeID, req, userID)
	if err != nil {
		h.service.logger.Error("Failed to update trade", zap.Error(err))
		return &api.UpdateTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "TRADE_UPDATE_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.TradeResponse{
		ID:          trade.ID,
		CreatorID:   trade.CreatorID,
		TradeType:   trade.TradeType,
		Status:      trade.Status,
		ItemsOffered: trade.ItemsOffered,
		ItemsRequested: trade.ItemsRequested,
		CurrencyOffered: trade.CurrencyOffered,
		CurrencyRequested: trade.CurrencyRequested,
		CreatedAt:   trade.CreatedAt,
		UpdatedAt:   trade.UpdatedAt,
		EscrowStatus: trade.EscrowStatus,
	}, nil
}

// AcceptTrade processes trade acceptance with escrow settlement
// PERFORMANCE: Critical path operation requiring <20ms P99 latency
func (h *Handler) AcceptTrade(ctx context.Context, params api.AcceptTradeParams) (api.AcceptTradeRes, error) {
	ctx, cancel := h.withTimeout(ctx, "AcceptTrade", 8*time.Second)
	defer cancel()

	tradeID, err := uuid.Parse(params.TradeID)
	if err != nil {
		return &api.AcceptTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_TRADE_ID",
				Message: "Invalid trade ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.AcceptTradeResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	h.service.logger.Info("Processing AcceptTrade request",
		zap.String("trade_id", tradeID.String()),
		zap.String("acceptor_id", userID.String()))

	// Accept trade with escrow processing
	err = h.service.AcceptTrade(ctx, tradeID, userID)
	if err != nil {
		h.service.logger.Error("Failed to accept trade", zap.Error(err))
		return &api.AcceptTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "TRADE_ACCEPT_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.AcceptTradeResNoContent{}, nil
}

// CancelTrade handles trade cancellation with escrow rollback
func (h *Handler) CancelTrade(ctx context.Context, params api.CancelTradeParams) (api.CancelTradeRes, error) {
	ctx, cancel := h.withTimeout(ctx, "CancelTrade", 5*time.Second)
	defer cancel()

	tradeID, err := uuid.Parse(params.TradeID)
	if err != nil {
		return &api.CancelTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "INVALID_TRADE_ID",
				Message: "Invalid trade ID format",
			},
		}, nil
	}

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.CancelTradeResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	h.service.logger.Info("Processing CancelTrade request",
		zap.String("trade_id", tradeID.String()),
		zap.String("canceler_id", userID.String()))

	// Cancel trade with escrow rollback
	err = h.service.CancelTrade(ctx, tradeID, userID)
	if err != nil {
		h.service.logger.Error("Failed to cancel trade", zap.Error(err))
		return &api.CancelTradeResDefault{
			StatusCode: http.StatusBadRequest,
			Data: api.Error{
				Code:    "TRADE_CANCEL_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.CancelTradeResNoContent{}, nil
}

// GetTradeHistory retrieves paginated trade history for user
func (h *Handler) GetTradeHistory(ctx context.Context, params api.GetTradeHistoryParams) (api.GetTradeHistoryRes, error) {
	ctx, cancel := h.withTimeout(ctx, "GetTradeHistory", 3*time.Second)
	defer cancel()

	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return &api.GetTradeHistoryResDefault{
			StatusCode: http.StatusUnauthorized,
			Data: api.Error{
				Code:    "UNAUTHORIZED",
				Message: "User not authenticated",
			},
		}, nil
	}

	h.service.logger.Info("Processing GetTradeHistory request",
		zap.String("user_id", userID.String()))

	// Get trade history with pagination
	history, total, err := h.service.GetTradeHistory(ctx, userID, params)
	if err != nil {
		h.service.logger.Error("Failed to get trade history", zap.Error(err))
		return &api.GetTradeHistoryResDefault{
			StatusCode: http.StatusInternalServerError,
			Data: api.Error{
				Code:    "TRADE_HISTORY_FAILED",
				Message: "Failed to retrieve trade history",
			},
		}, nil
	}

	// Convert to API format
	apiTrades := make([]*api.TradeSummaryResponse, len(history))
	for i, trade := range history {
		apiTrades[i] = &api.TradeSummaryResponse{
			ID:        trade.ID,
			TradeType: trade.TradeType,
			Status:    trade.Status,
			CreatedAt: trade.CreatedAt,
			CompletedAt: trade.CompletedAt,
		}
	}

	return &api.PaginatedTradeHistoryResponse{
		Trades: apiTrades,
		Pagination: &api.PaginationInfo{
			Total:  total,
			Limit:  params.Limit.Or(20),
			Offset: params.Offset.Or(0),
		},
	}, nil
}

// HealthGet implements health check endpoint
func (h *Handler) HealthGet(ctx context.Context) (api.HealthGetRes, error) {
	// Calculate actual uptime since service start
	uptimeSeconds := int(time.Since(h.service.startTime).Seconds())

	return &api.HealthResponse{
		Status:   "healthy",
		Version:  "1.0.0",
		Uptime:   uptimeSeconds,
	}, nil
}
