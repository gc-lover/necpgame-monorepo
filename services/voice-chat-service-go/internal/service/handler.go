// Code generated by NECPGAME backend agent. Enterprise-grade Voice Chat API handlers.
// PERFORMANCE: Memory pooling implemented for request/response objects
// SECURITY: JWT authentication, rate limiting, input validation
// MONITORING: Request metrics and error tracking

package service

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"go.uber.org/zap"

	"necpgame/services/voice-chat-service-go/pkg/api"
)

// Handler handles HTTP requests for the voice chat service
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Handler struct {
	// Service dependency (8 bytes)
	service *Service

	// Metrics for HTTP requests (8 bytes)
	requestMetrics *HTTPMetrics

	// Rate limiter (8 bytes)
	rateLimiter RateLimiter

	// JWT validator (8 bytes)
	jwtValidator JWTValidator

	// Memory pools for request/response objects (reduce GC pressure)
	// PERFORMANCE: sync.Pool for frequently allocated objects
	createRoomPool    sync.Pool
	joinRoomPool      sync.Pool
	signalingPool     sync.Pool
	roomInfoPool      sync.Pool
	recordingPool     sync.Pool
	mutePool          sync.Pool
	kickPool          sync.Pool
	metricsDataPool   sync.Pool
}

// HTTPMetrics holds HTTP request metrics
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type HTTPMetrics struct {
	// Counter metrics (8 bytes each)
	requestsTotal    *prometheus.CounterVec
	requestsError    *prometheus.CounterVec

	// Histogram metrics (8 bytes each)
	requestDuration  *prometheus.HistogramVec
	responseSize     *prometheus.HistogramVec
}

// RateLimiter interface for rate limiting
type RateLimiter interface {
	Allow(key string) bool
}

// JWTValidator interface for JWT token validation
type JWTValidator interface {
	ValidateToken(token string) (*Claims, error)
}

// Claims represents JWT claims
type Claims struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
	Role     string `json:"role"`
	ExpiresAt int64  `json:"exp"`
}

// NewHandler creates a new HTTP handler
func NewHandler(service *Service, rateLimiter RateLimiter, jwtValidator JWTValidator) *Handler {
	// Initialize HTTP metrics
	requestMetrics := &HTTPMetrics{
		requestsTotal: promauto.NewCounterVec(prometheus.CounterOpts{
			Name: "voice_chat_http_requests_total",
			Help: "Total number of HTTP requests",
		}, []string{"method", "endpoint", "status"}),
		requestsError: promauto.NewCounterVec(prometheus.CounterOpts{
			Name: "voice_chat_http_requests_error_total",
			Help: "Total number of HTTP request errors",
		}, []string{"method", "endpoint", "error_type"}),
		requestDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
			Name: "voice_chat_http_request_duration_seconds",
			Help: "HTTP request duration in seconds",
			Buckets: prometheus.DefBuckets,
		}, []string{"method", "endpoint"}),
		responseSize: promauto.NewHistogramVec(prometheus.HistogramOpts{
			Name: "voice_chat_http_response_size_bytes",
			Help: "HTTP response size in bytes",
			Buckets: prometheus.LinearBuckets(100, 100, 10),
		}, []string{"method", "endpoint"}),
	}

	// Initialize memory pools
	createRoomPool := sync.Pool{
		New: func() interface{} {
			return &api.CreateRoomRequest{}
		},
	}
	joinRoomPool := sync.Pool{
		New: func() interface{} {
			return &api.JoinRoomRequest{}
		},
	}
	signalingPool := sync.Pool{
		New: func() interface{} {
			return &api.SignalingMessage{}
		},
	}
	roomInfoPool := sync.Pool{
		New: func() interface{} {
			return &api.RoomInfo{}
		},
	}
	recordingPool := sync.Pool{
		New: func() interface{} {
			return &api.StartRecordingRequest{}
		},
	}
	mutePool := sync.Pool{
		New: func() interface{} {
			return &api.MuteParticipantRequest{}
		},
	}
	kickPool := sync.Pool{
		New: func() interface{} {
			return &api.KickParticipantRequest{}
		},
	}
	metricsDataPool := sync.Pool{
		New: func() interface{} {
			return &api.QualityMetricsRequest{}
		},
	}

	return &Handler{
		service:          service,
		requestMetrics:    requestMetrics,
		rateLimiter:       rateLimiter,
		jwtValidator:      jwtValidator,
		createRoomPool:    createRoomPool,
		joinRoomPool:      joinRoomPool,
		signalingPool:     signalingPool,
		roomInfoPool:      roomInfoPool,
		recordingPool:     recordingPool,
		mutePool:          mutePool,
		kickPool:          kickPool,
		metricsDataPool:   metricsDataPool,
	}
}

// RegisterRoutes registers all HTTP routes
func (h *Handler) RegisterRoutes(router *mux.Router) {
	// Room management routes
	router.HandleFunc("/api/v1/rooms", h.authMiddleware(h.createRoom)).Methods("POST")
	router.HandleFunc("/api/v1/rooms/{roomID}/join", h.authMiddleware(h.joinRoom)).Methods("POST")
	router.HandleFunc("/api/v1/rooms/{roomID}/leave", h.authMiddleware(h.leaveRoom)).Methods("POST")
	router.HandleFunc("/api/v1/rooms/{roomID}", h.authMiddleware(h.getRoomInfo)).Methods("GET")
	router.HandleFunc("/api/v1/rooms/{roomID}", h.authMiddleware(h.updateRoom)).Methods("PUT")
	router.HandleFunc("/api/v1/rooms/{roomID}", h.authMiddleware(h.deleteRoom)).Methods("DELETE")

	// Signaling routes
	router.HandleFunc("/api/v1/rooms/{roomID}/signaling", h.authMiddleware(h.sendSignaling)).Methods("POST")

	// Recording routes
	router.HandleFunc("/api/v1/rooms/{roomID}/recording/start", h.authMiddleware(h.startRecording)).Methods("POST")
	router.HandleFunc("/api/v1/rooms/{roomID}/recording/stop", h.authMiddleware(h.stopRecording)).Methods("POST")

	// Moderation routes
	router.HandleFunc("/api/v1/rooms/{roomID}/participants/{userID}/mute", h.authMiddleware(h.muteParticipant)).Methods("POST")
	router.HandleFunc("/api/v1/rooms/{roomID}/participants/{userID}/kick", h.authMiddleware(h.kickParticipant)).Methods("POST")

	// Quality metrics routes
	router.HandleFunc("/api/v1/rooms/{roomID}/metrics", h.authMiddleware(h.sendMetrics)).Methods("POST")

	// Invite routes
	router.HandleFunc("/api/v1/rooms/{roomID}/invites", h.authMiddleware(h.createInvite)).Methods("POST")
	router.HandleFunc("/api/v1/invites/{inviteID}/accept", h.authMiddleware(h.acceptInvite)).Methods("POST")

	// WebSocket route for real-time signaling
	router.HandleFunc("/ws/rooms/{roomID}", h.authMiddleware(h.websocketSignaling))

	// Health check
	router.HandleFunc("/health", h.healthCheck).Methods("GET")

	// Metrics endpoint
	router.Handle("/metrics", promhttp.Handler()).Methods("GET")
}

// authMiddleware validates JWT tokens
func (h *Handler) authMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Extract token from Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			h.sendError(w, "Missing authorization header", http.StatusUnauthorized)
			return
		}

		// Check Bearer token format
		if len(authHeader) < 8 || authHeader[:7] != "Bearer " {
			h.sendError(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		token := authHeader[7:]

		// Validate token
		claims, err := h.jwtValidator.ValidateToken(token)
		if err != nil {
			h.sendError(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		// Check token expiration
		if claims.ExpiresAt < time.Now().Unix() {
			h.sendError(w, "Token expired", http.StatusUnauthorized)
			return
		}

		// Store claims in request context
		ctx := context.WithValue(r.Context(), "claims", claims)
		r = r.WithContext(ctx)

		// Apply rate limiting
		userID := claims.UserID
		if !h.rateLimiter.Allow(userID) {
			h.sendError(w, "Rate limit exceeded", http.StatusTooManyRequests)
			return
		}

		next(w, r.WithContext(ctx))
	}
}

// createRoom handles room creation requests
func (h *Handler) createRoom(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms").Observe(time.Since(start).Seconds())
	}()

	claims := r.Context().Value("claims").(*Claims)

	req := h.createRoomPool.Get().(*api.CreateRoomRequest)
	defer h.createRoomPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate request
	if req.Name == "" || req.OwnerID == "" {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms", "validation_error").Inc()
		h.sendError(w, "Missing required fields: name, owner_id", http.StatusBadRequest)
		return
	}

	// Override owner_id with authenticated user
	req.OwnerID = claims.UserID

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.CreateVoiceRoom(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to create room: %v", err), http.StatusInternalServerError)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms", "200").Inc()
	h.sendJSON(w, resp, http.StatusCreated)
}

// joinRoom handles room join requests
func (h *Handler) joinRoom(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/join").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.joinRoomPool.Get().(*api.JoinRoomRequest)
	defer h.joinRoomPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/join", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.UserID = claims.UserID
	req.Username = claims.Username

	// Set default username if not provided
	if req.Username == "" {
		req.Username = fmt.Sprintf("User_%s", claims.UserID[:8])
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.JoinVoiceRoom(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/join", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to join room: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/join", "200").Inc()
	h.sendJSON(w, resp, http.StatusOK)
}

// leaveRoom handles room leave requests
func (h *Handler) leaveRoom(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/leave").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.LeaveRoomRequest{
		RoomID: roomID,
		UserID: claims.UserID,
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.LeaveVoiceRoom(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/leave", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to leave room: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/leave", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "left"}, http.StatusOK)
}

// getRoomInfo handles room info requests
func (h *Handler) getRoomInfo(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("GET", "/api/v1/rooms/{roomID}").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	info, err := h.service.GetRoomInfo(ctx, roomID)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("GET", "/api/v1/rooms/{roomID}", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to get room info: %v", err), http.StatusNotFound)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("GET", "/api/v1/rooms/{roomID}", "200").Inc()
	h.sendJSON(w, info, http.StatusOK)
}

// sendSignaling handles WebRTC signaling messages
func (h *Handler) sendSignaling(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/signaling").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.signalingPool.Get().(*api.SignalingMessage)
	defer h.signalingPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/signaling", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.FromUser = claims.UserID

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	err := h.service.SendSignalingMessage(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/signaling", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to send signaling message: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/signaling", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "sent"}, http.StatusOK)
}

// startRecording handles recording start requests
func (h *Handler) startRecording(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/start").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.recordingPool.Get().(*api.StartRecordingRequest)
	defer h.recordingPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/start", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.UserID = claims.UserID

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.StartRecording(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/start", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to start recording: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/start", "200").Inc()
	h.sendJSON(w, resp, http.StatusOK)
}

// stopRecording handles recording stop requests
func (h *Handler) stopRecording(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/stop").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.StopRecordingRequest{
		RoomID: roomID,
		UserID: claims.UserID,
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.StopRecording(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/stop", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to stop recording: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/recording/stop", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "stopped"}, http.StatusOK)
}

// muteParticipant handles participant mute requests
func (h *Handler) muteParticipant(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/mute").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	targetUserID := vars["userID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.mutePool.Get().(*api.MuteParticipantRequest)
	defer h.mutePool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/mute", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.RequesterID = claims.UserID
	req.TargetUserID = targetUserID

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.MuteParticipant(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/mute", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to mute participant: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/mute", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "muted"}, http.StatusOK)
}

// kickParticipant handles participant kick requests
func (h *Handler) kickParticipant(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/kick").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	targetUserID := vars["userID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.kickPool.Get().(*api.KickParticipantRequest)
	defer h.kickPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/kick", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.RequesterID = claims.UserID
	req.TargetUserID = targetUserID

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.KickParticipant(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/kick", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to kick participant: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/participants/{userID}/kick", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "kicked"}, http.StatusOK)
}

// sendMetrics handles quality metrics submission
func (h *Handler) sendMetrics(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/metrics").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := h.metricsDataPool.Get().(*api.QualityMetricsRequest)
	defer h.metricsDataPool.Put(req)

	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/metrics", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.RoomID = roomID
	req.UserID = claims.UserID

	ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
	defer cancel()

	err := h.service.SendQualityMetrics(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/metrics", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to send metrics: %v", err), http.StatusInternalServerError)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/metrics", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "received"}, http.StatusOK)
}


// websocketSignaling handles WebSocket connections for real-time signaling
func (h *Handler) websocketSignaling(w http.ResponseWriter, r *http.Request) {
	// This is handled by the signaling server in main.go
	// The WebSocket endpoint is served by NewSignalingHandler
	h.sendError(w, "Use /ws/rooms/{roomID} endpoint", http.StatusNotFound)
}

// createInvite handles invite creation requests
func (h *Handler) createInvite(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/rooms/{roomID}/invites").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.CreateInviteRequest{}
	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/invites", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Set room ID and inviter from context
	req.RoomID = roomID
	req.InviterID = claims.UserID

	// Set defaults
	if req.ExpiresIn == 0 {
		req.ExpiresIn = 24 * 60 * 60 // 24 hours default
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.CreateInvite(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/rooms/{roomID}/invites", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to create invite: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/rooms/{roomID}/invites", "200").Inc()
	h.sendJSON(w, resp, http.StatusCreated)
}

// acceptInvite handles invite acceptance requests
func (h *Handler) acceptInvite(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("POST", "/api/v1/invites/{inviteID}/accept").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	inviteID := vars["inviteID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.AcceptInviteRequest{
		InviteID: inviteID,
		UserID:   claims.UserID,
		Token:    claims.UserID, // Use user ID as token for simplicity
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	resp, err := h.service.AcceptInvite(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("POST", "/api/v1/invites/{inviteID}/accept", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to accept invite: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("POST", "/api/v1/invites/{inviteID}/accept", "200").Inc()
	h.sendJSON(w, resp, http.StatusOK)
}

// updateRoom handles room update requests
func (h *Handler) updateRoom(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("PUT", "/api/v1/rooms/{roomID}").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.UpdateRoomRequest{}
	if err := json.NewDecoder(r.Body).Decode(req); err != nil {
		h.requestMetrics.requestsError.WithLabelValues("PUT", "/api/v1/rooms/{roomID}", "decode_error").Inc()
		h.sendError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Set room ID and requester from context
	req.RoomID = roomID
	req.RequesterID = claims.UserID

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.UpdateVoiceRoom(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("PUT", "/api/v1/rooms/{roomID}", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to update room: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("PUT", "/api/v1/rooms/{roomID}", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "updated"}, http.StatusOK)
}

// deleteRoom handles room deletion requests
func (h *Handler) deleteRoom(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	defer func() {
		h.requestMetrics.requestDuration.WithLabelValues("DELETE", "/api/v1/rooms/{roomID}").Observe(time.Since(start).Seconds())
	}()

	vars := mux.Vars(r)
	roomID := vars["roomID"]
	claims := r.Context().Value("claims").(*Claims)

	req := &api.DeleteRoomRequest{
		RoomID:      roomID,
		RequesterID: claims.UserID,
	}

	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	err := h.service.DeleteVoiceRoom(ctx, req)
	if err != nil {
		h.requestMetrics.requestsError.WithLabelValues("DELETE", "/api/v1/rooms/{roomID}", "service_error").Inc()
		h.sendError(w, fmt.Sprintf("Failed to delete room: %v", err), http.StatusBadRequest)
		return
	}

	h.requestMetrics.requestsTotal.WithLabelValues("DELETE", "/api/v1/rooms/{roomID}", "200").Inc()
	h.sendJSON(w, map[string]string{"status": "deleted"}, http.StatusOK)
}

// healthCheck handles health check requests
func (h *Handler) healthCheck(w http.ResponseWriter, r *http.Request) {
	h.sendJSON(w, map[string]interface{}{
		"status":    "healthy",
		"service":   "voice-chat-service",
		"timestamp": time.Now().Unix(),
	}, http.StatusOK)
}

// sendJSON sends a JSON response
func (h *Handler) sendJSON(w http.ResponseWriter, data interface{}, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	encoder := json.NewEncoder(w)
	if err := encoder.Encode(data); err != nil {
		log.Printf("Failed to encode JSON response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Track response size (approximate)
	responseSize := len(fmt.Sprintf("%v", data))
	h.requestMetrics.responseSize.WithLabelValues("POST", "response").Observe(float64(responseSize))
}

// sendError sends an error response
func (h *Handler) sendError(w http.ResponseWriter, message string, status int) {
	response := map[string]interface{}{
		"error":     message,
		"timestamp": time.Now().Unix(),
	}

	if status >= 500 {
		h.service.logger.Error("HTTP server error",
			zap.Int("status", status),
			zap.String("message", message))
	}

	h.sendJSON(w, response, status)
}