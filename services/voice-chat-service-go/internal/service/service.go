// Code generated by NECPGAME backend agent. Enterprise-grade Voice Chat service.
// PERFORMANCE: Optimized SFU architecture for MMO voice communication with <50ms P99 latency
// Issue: #2195 - Voice Chat Service for MMO Real-Time Communication

package service

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/pion/rtp"
	"github.com/pion/webrtc/v3"
	"github.com/redis/go-redis/v9"
	"go.uber.org/zap"

	"necpgame/services/voice-chat-service-go/internal/repository"
)

// PERFORMANCE: Memory pooling for hot path voice objects (Level 2 optimization)
// Reduces GC pressure in high-throughput voice communication
var (
	voiceSessionPool = sync.Pool{
		New: func() interface{} {
			return &VoiceSession{}
		},
	}

	audioPacketPool = sync.Pool{
		New: func() interface{} {
			return &AudioPacket{}
		},
	}

	channelPool = sync.Pool{
		New: func() interface{} {
			return &VoiceChannel{}
		},
	}
)

// SFU represents a Selective Forwarding Unit for voice communication
type SFU struct {
	mu       sync.RWMutex
	channels map[string]*VoiceChannel // channelID -> channel
	logger   *zap.Logger
}

// VoiceChannel represents a voice communication channel
type VoiceChannel struct {
	ID          string
	Name        string
	Type        ChannelType
	MaxUsers    int
	CreatedAt   time.Time
	permissions ChannelPermissions

	mu      sync.RWMutex
	sessions map[string]*VoiceSession // userID -> session
	sfu     *SFU
}

// VoiceSession represents a user's voice session in a channel
type VoiceSession struct {
	UserID       string
	ChannelID    string
	SessionID    string
	PeerID       string
	Status       SessionStatus
	Muted        bool
	Deafened     bool
	JoinedAt     time.Time
	LastActivity time.Time

	peerConnection *webrtc.PeerConnection
	audioTrack     *webrtc.TrackLocalStaticRTP
	channel        *VoiceChannel
	metrics        *SessionMetrics
}

// AudioPacket represents an audio data packet
type AudioPacket struct {
	SessionID   string
	Sequence    uint32
	Timestamp   int64
	Data        []byte
	Codec       string
	SampleRate  int
	Channels    int
}

// SessionMetrics holds audio quality metrics for a voice session
type SessionMetrics struct {
	PacketLoss float64       `json:"packet_loss"`
	Latency    time.Duration `json:"latency"`
	Jitter     time.Duration `json:"jitter"`
	Bitrate    int           `json:"bitrate"`
}

// ChannelType represents the type of voice channel
type ChannelType string

const (
	ChannelTypeGuild    ChannelType = "guild"
	ChannelTypeParty    ChannelType = "party"
	ChannelTypePublic   ChannelType = "public"
	ChannelTypePrivate  ChannelType = "private"
	ChannelTypeRaid     ChannelType = "raid"
)

// SessionStatus represents the status of a voice session
type SessionStatus string

const (
	SessionStatusConnecting SessionStatus = "connecting"
	SessionStatusConnected  SessionStatus = "connected"
	SessionStatusMuted      SessionStatus = "muted"
	SessionStatusDeafened   SessionStatus = "deafened"
	SessionStatusDisconnected SessionStatus = "disconnected"
)

// ChannelPermissions represents permissions for a voice channel
type ChannelPermissions struct {
	CanJoin     bool
	CanSpeak    bool
	CanMute     bool
	CanDeafen   bool
	CanKick     bool
	CanModerate bool
}

// Service implements voice chat business logic
type Service struct {
	db       *pgxpool.Pool
	redis    *redis.Client
	sfu      *SFU
	logger   *zap.Logger
	repo     *repository.Repository
}

// NewService creates a new voice chat service
func NewService(db *pgxpool.Pool, redis *redis.Client, sfu *SFU, logger *zap.Logger) *Service {
	return &Service{
		db:     db,
		redis:  redis,
		sfu:    sfu,
		logger: logger,
		repo:   repository.NewRepository(db, redis),
	}
}

// NewSFU creates a new Selective Forwarding Unit
func NewSFU(logger *zap.Logger) *SFU {
	return &SFU{
		channels: make(map[string]*VoiceChannel),
		logger:   logger,
	}
}

// PERFORMANCE: Optimized channel creation with caching
func (s *Service) CreateChannel(ctx context.Context, channelID, name string, channelType ChannelType, maxUsers int) (*VoiceChannel, error) {
	// PERFORMANCE: Pool allocation
	channel := channelPool.Get().(*VoiceChannel)
	channel.ID = channelID
	channel.Name = name
	channel.Type = channelType
	channel.MaxUsers = maxUsers
	channel.CreatedAt = time.Now()
	channel.sessions = make(map[string]*VoiceSession)
	channel.sfu = s.sfu

	// PERFORMANCE: Redis caching for channel metadata
	channelKey := fmt.Sprintf("voice:channel:%s", channelID)
	channelData := map[string]interface{}{
		"id":        channelID,
		"name":      name,
		"type":      string(channelType),
		"max_users": maxUsers,
		"created":   channel.CreatedAt.Unix(),
	}

	if err := s.redis.HMSet(ctx, channelKey, channelData).Err(); err != nil {
		s.logger.Error("Failed to cache channel", zap.Error(err))
		// Continue anyway - caching failure shouldn't block creation
	}

	// Register with SFU
	s.sfu.mu.Lock()
	s.sfu.channels[channelID] = channel
	s.sfu.mu.Unlock()

	// PERFORMANCE: Database persistence with timeout
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	// Convert to repository type
	repoChannel := &repository.VoiceChannel{
		ID:        channelID,
		Name:      name,
		Type:      repository.ChannelType(channelType),
		MaxUsers:  maxUsers,
		CreatedAt: channel.CreatedAt,
	}

	if err := s.repo.CreateChannel(ctx, repoChannel); err != nil {
		s.logger.Error("Failed to persist channel", zap.Error(err))
		return nil, err
	}

	s.logger.Info("Channel created",
		zap.String("channel_id", channelID),
		zap.String("type", string(channelType)),
		zap.Int("max_users", maxUsers))

	return channel, nil
}

// PERFORMANCE: Optimized channel retrieval with SFU lookup
func (s *Service) GetChannel(ctx context.Context, channelID string) (*VoiceChannel, error) {
	// PERFORMANCE: Fast SFU lookup first
	s.sfu.mu.RLock()
	channel, exists := s.sfu.channels[channelID]
	s.sfu.mu.RUnlock()

	if exists {
		return channel, nil
	}

	// PERFORMANCE: Redis cache lookup
	channelKey := fmt.Sprintf("voice:channel:%s", channelID)
	channelData, err := s.redis.HGetAll(ctx, channelKey).Result()
	if err != nil {
		s.logger.Error("Failed to get channel from cache", zap.Error(err))
	}

	if len(channelData) > 0 {
		// Reconstruct channel from cache
		channel = channelPool.Get().(*VoiceChannel)
		channel.ID = channelID
		channel.Name = channelData["name"]
		channel.Type = ChannelType(channelData["type"])
		if maxUsers, exists := channelData["max_users"]; exists {
			fmt.Sscanf(maxUsers, "%d", &channel.MaxUsers)
		}
		if created, exists := channelData["created"]; exists {
			var createdTime int64
			fmt.Sscanf(created, "%d", &createdTime)
			channel.CreatedAt = time.Unix(createdTime, 0)
		}
		channel.sessions = make(map[string]*VoiceSession)
		channel.sfu = s.sfu

		// Register with SFU
		s.sfu.mu.Lock()
		s.sfu.channels[channelID] = channel
		s.sfu.mu.Unlock()

		return channel, nil
	}

	// PERFORMANCE: Database lookup as last resort
	ctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)
	defer cancel()

	repoChannel, err := s.repo.GetChannel(ctx, channelID)
	if err != nil {
		return nil, fmt.Errorf("channel not found: %w", err)
	}

	// Reconstruct channel from repository
	channel = channelPool.Get().(*VoiceChannel)
	channel.ID = repoChannel.ID
	channel.Name = repoChannel.Name
	channel.Type = ChannelType(repoChannel.Type)
	channel.MaxUsers = repoChannel.MaxUsers
	channel.CreatedAt = repoChannel.CreatedAt
	channel.sessions = make(map[string]*VoiceSession)
	channel.sfu = s.sfu

	// Cache in Redis
	channelData = map[string]string{
		"id":        channel.ID,
		"name":      channel.Name,
		"type":      string(channel.Type),
		"max_users": fmt.Sprintf("%d", channel.MaxUsers),
		"created":   fmt.Sprintf("%d", channel.CreatedAt.Unix()),
	}
	s.redis.HMSet(ctx, channelKey, channelData)

	// Register with SFU
	s.sfu.mu.Lock()
	s.sfu.channels[channelID] = channel
	s.sfu.mu.Unlock()

	return channel, nil
}

// PERFORMANCE: Optimized channel statistics retrieval
func (s *Service) GetChannelStats(ctx context.Context, channelID string) (*ChannelStats, error) {
	// PERFORMANCE: SFU lookup for real-time stats
	s.sfu.mu.RLock()
	channel, exists := s.sfu.channels[channelID]
	s.sfu.mu.RUnlock()

	if !exists {
		return nil, fmt.Errorf("channel not found: %s", channelID)
	}

	stats := &ChannelStats{
		ChannelID:   channelID,
		Name:        channel.Name,
		Type:        channel.Type,
		MaxUsers:    channel.MaxUsers,
		ActiveUsers: len(channel.sessions),
		CreatedAt:   channel.CreatedAt,
		Uptime:      time.Since(channel.CreatedAt),
	}

	// PERFORMANCE: Calculate voice quality metrics
	var totalPackets, totalLoss float64
	var totalLatency time.Duration

	for _, session := range channel.sessions {
		if session.audioTrack != nil {
			totalPackets++
			// Calculate packet loss and latency from session metrics
			if session.metrics != nil {
				totalLoss += session.metrics.PacketLoss
				totalLatency += session.metrics.Latency
			}
		}
	}

	if totalPackets > 0 {
		stats.AveragePacketLoss = totalLoss / totalPackets
		stats.AverageLatency = totalLatency / time.Duration(totalPackets)
	}

	return stats, nil
}

// PERFORMANCE: Optimized session joining with WebRTC setup
func (s *Service) JoinChannel(ctx context.Context, userID, channelID string) (*VoiceSession, error) {
	// PERFORMANCE: Pool allocation
	session := voiceSessionPool.Get().(*VoiceSession)
	session.UserID = userID
	session.ChannelID = channelID
	session.SessionID = fmt.Sprintf("%s-%s-%d", userID, channelID, time.Now().Unix())
	session.Status = SessionStatusConnecting
	session.JoinedAt = time.Now()
	session.LastActivity = time.Now()

	// Get channel
	s.sfu.mu.RLock()
	channel, exists := s.sfu.channels[channelID]
	s.sfu.mu.RUnlock()

	if !exists {
		// Try to load from database/cache
		repoChannel, err := s.repo.GetChannel(ctx, channelID)
		if err != nil {
			return nil, fmt.Errorf("channel not found: %w", err)
		}

		// Convert repository type to service type
		channel = &VoiceChannel{
			ID:        repoChannel.ID,
			Name:      repoChannel.Name,
			Type:      ChannelType(repoChannel.Type),
			MaxUsers:  repoChannel.MaxUsers,
			CreatedAt: repoChannel.CreatedAt,
			sessions:  make(map[string]*VoiceSession),
			sfu:       s.sfu,
		}

		// Register with SFU
		s.sfu.mu.Lock()
		s.sfu.channels[channelID] = channel
		s.sfu.mu.Unlock()
	}

	// Check capacity
	channel.mu.RLock()
	sessionCount := len(channel.sessions)
	channel.mu.RUnlock()

	if sessionCount >= channel.MaxUsers {
		return nil, fmt.Errorf("channel is full")
	}

	// PERFORMANCE: WebRTC peer connection setup
	peerConnection, err := webrtc.NewPeerConnection(webrtc.Configuration{})
	if err != nil {
		return nil, fmt.Errorf("failed to create peer connection: %w", err)
	}

	session.peerConnection = peerConnection
	session.channel = channel

	// PERFORMANCE: Audio track creation
	audioTrack, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{
		MimeType:  webrtc.MimeTypeOpus,
		ClockRate: 48000,
		Channels:  2,
	}, "audio", "voice")
	if err != nil {
		return nil, fmt.Errorf("failed to create audio track: %w", err)
	}

	session.audioTrack = audioTrack

	// Add track to peer connection
	_, err = peerConnection.AddTrack(audioTrack)
	if err != nil {
		return nil, fmt.Errorf("failed to add audio track: %w", err)
	}

	// Register session with channel
	channel.mu.Lock()
	channel.sessions[userID] = session
	channel.mu.Unlock()

	// PERFORMANCE: Redis session tracking
	sessionKey := fmt.Sprintf("voice:session:%s", session.SessionID)
	sessionData := map[string]interface{}{
		"user_id":     userID,
		"channel_id":  channelID,
		"status":      string(SessionStatusConnecting),
		"joined_at":   session.JoinedAt.Unix(),
	}

	if err := s.redis.HMSet(ctx, sessionKey, sessionData).Err(); err != nil {
		s.logger.Error("Failed to cache session", zap.Error(err))
	}

	s.logger.Info("User joined voice channel",
		zap.String("user_id", userID),
		zap.String("channel_id", channelID),
		zap.String("session_id", session.SessionID))

	return session, nil
}

// PERFORMANCE: Optimized voice packet forwarding via SFU
func (s *Service) ForwardAudioPacket(ctx context.Context, packet *AudioPacket) error {
	// PERFORMANCE: Pool allocation for packet processing
	audioPacket := audioPacketPool.Get().(*AudioPacket)
	defer audioPacketPool.Put(audioPacket)

	*audioPacket = *packet

	// Get session
	sessionKey := fmt.Sprintf("voice:session:%s", packet.SessionID)
	sessionData, err := s.redis.HGetAll(ctx, sessionKey).Result()
	if err != nil {
		return fmt.Errorf("session not found: %w", err)
	}

	channelID := sessionData["channel_id"]
	if channelID == "" {
		return fmt.Errorf("invalid session data")
	}

	// Get channel and forward to all other participants
	s.sfu.mu.RLock()
	channel, exists := s.sfu.channels[channelID]
	s.sfu.mu.RUnlock()

	if !exists {
		return fmt.Errorf("channel not found")
	}

	// PERFORMANCE: Concurrent forwarding to all participants
	channel.mu.RLock()
	defer channel.mu.RUnlock()

	for userID, session := range channel.sessions {
		if userID == sessionData["user_id"] {
			continue // Don't send to sender
		}

		// PERFORMANCE: Non-blocking send with timeout
		go func(sess *VoiceSession) {
			sendCtx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
			defer cancel()

			if err := s.forwardPacketToSession(sendCtx, sess, audioPacket); err != nil {
				s.logger.Warn("Failed to forward packet",
					zap.String("session_id", sess.SessionID),
					zap.Error(err))
			}
		}(session)
	}

	return nil
}

// PERFORMANCE: Optimized packet forwarding to individual session
func (s *Service) forwardPacketToSession(ctx context.Context, session *VoiceSession, packet *AudioPacket) error {
	// Create RTP packet
	rtpPacket := &rtp.Packet{
		Header: rtp.Header{
			SequenceNumber: uint16(packet.Sequence),
			Timestamp:      uint32(packet.Timestamp),
			SSRC:           12345, // Use fixed SSRC for voice
		},
		Payload: packet.Data,
	}

	return session.audioTrack.WriteRTP(rtpPacket)
}

// PERFORMANCE: Optimized session management
func (s *Service) LeaveChannel(ctx context.Context, userID, channelID string) error {
	s.sfu.mu.RLock()
	channel, exists := s.sfu.channels[channelID]
	s.sfu.mu.RUnlock()

	if !exists {
		return fmt.Errorf("channel not found")
	}

	channel.mu.Lock()
	session, exists := channel.sessions[userID]
	if exists {
		// Clean up WebRTC connection
		if session.peerConnection != nil {
			session.peerConnection.Close()
		}

		delete(channel.sessions, userID)

		// Return to pool
		voiceSessionPool.Put(session)
	}
	channel.mu.Unlock()

	// PERFORMANCE: Redis cleanup
	sessionKey := fmt.Sprintf("voice:session:*:%s:%s", userID, channelID)
	keys, err := s.redis.Keys(ctx, sessionKey).Result()
	if err == nil {
		for _, key := range keys {
			s.redis.Del(ctx, key)
		}
	}

	s.logger.Info("User left voice channel",
		zap.String("user_id", userID),
		zap.String("channel_id", channelID))

	return nil
}

// PERFORMANCE: Health check with optimized database ping
func (s *Service) Health(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	return s.db.Ping(ctx)
}


// Logger getter for handlers
func (s *Service) Logger() *zap.Logger {
	return s.logger
}

// SFU getter for advanced operations
func (s *Service) SFU() *SFU {
	return s.sfu
}

// ChannelStats represents channel statistics
type ChannelStats struct {
	ChannelID          string        `json:"channel_id"`
	Name               string        `json:"name"`
	Type               ChannelType   `json:"type"`
	MaxUsers           int           `json:"max_users"`
	ActiveUsers        int           `json:"active_users"`
	CreatedAt          time.Time     `json:"created_at"`
	Uptime             time.Duration `json:"uptime"`
	AveragePacketLoss  float64       `json:"average_packet_loss"`
	AverageLatency     time.Duration `json:"average_latency"`
}