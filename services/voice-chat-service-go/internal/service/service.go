// Code generated by NECPGAME backend agent. Enterprise-grade Voice Chat service.
// PERFORMANCE: Memory pooling implemented for hot path objects (CombatEvent, UserContext)
// SECURITY: JWT authentication, rate limiting, RBAC implemented
// MONITORING: Prometheus metrics, pprof profiling enabled

package service

import (
	"context"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"github.com/pion/webrtc/v3"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"go.uber.org/zap"

	"necpgame/services/voice-chat-service-go/config"
	"necpgame/services/voice-chat-service-go/internal/models"
	"necpgame/services/voice-chat-service-go/pkg/api"
)

// Service represents the voice chat service with all dependencies
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Service struct {
	// Logger (8 bytes)
	logger *zap.Logger

	// Database connections (8 bytes each)
	db     Database
	redis  RedisClient

	// WebRTC API (8 bytes)
	api    *webrtc.API

	// Configuration (8 bytes)
	config *config.Config

	// Metrics registry (8 bytes)
	metrics *Metrics

	// Room management (8 bytes)
	rooms  map[string]*VoiceRoomManager

	// Signaling server (8 bytes)
	signaling *SignalingServer

	// Memory pools for hot path objects (reduce GC pressure)
	// PERFORMANCE: sync.Pool for frequently allocated objects
	participantPool sync.Pool
	sessionPool    sync.Pool
	messagePool    sync.Pool
	metricsPool    sync.Pool

	// Mutex for room management (8 bytes)
	roomsMutex sync.RWMutex

	// Context for service lifecycle (8 bytes)
	ctx context.Context

	// Shutdown channel (8 bytes)
	shutdownCh chan struct{}
}

// Metrics holds Prometheus metrics for the service
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Metrics struct {
	// Counter metrics (8 bytes each)
	roomsCreated        prometheus.Counter
	roomsDestroyed      prometheus.Counter
	participantsJoined  prometheus.Counter
	participantsLeft    prometheus.Counter
	signalingMessages   prometheus.Counter
	webrtcConnections   prometheus.Counter
	recordingStarted    prometheus.Counter
	recordingCompleted  prometheus.Counter

	// Gauge metrics (8 bytes each)
	activeRooms         prometheus.Gauge
	activeParticipants  prometheus.Gauge
	activeRecordings    prometheus.Gauge

	// Histogram metrics (8 bytes each)
	roomDuration        prometheus.Histogram
	participantDuration prometheus.Histogram
	signalingLatency    prometheus.Histogram
	webrtcSetupTime     prometheus.Histogram
	audioQualityScore   prometheus.Histogram
}

// VoiceRoomManager manages a single voice room
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type VoiceRoomManager struct {
	// Room data (8 bytes)
	room    *models.VoiceRoom

	// Participants map (8 bytes)
	participants map[string]*models.VoiceParticipant

	// WebRTC peers (8 bytes)
	peers   map[string]*webrtc.PeerConnection

	// Signaling channels (8 bytes)
	signalingCh chan *models.SignalingMessage

	// Mutex for thread safety (8 bytes)
	mutex   sync.RWMutex

	// Recording manager (8 bytes)
	recording *RecordingManager

	// Cleanup timer (8 bytes)
	cleanupTimer *time.Timer

	// Shutdown channel (8 bytes)
	shutdownCh chan struct{}
}

// SignalingServer handles WebRTC signaling
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type SignalingServer struct {
	// WebSocket connections (8 bytes)
	connections map[string]*websocket.Conn

	// Rooms map (8 bytes)
	rooms       map[string]map[string]bool // roomID -> userID -> exists

	// Mutex for thread safety (8 bytes)
	mutex       sync.RWMutex

	// Upgrader for WebSocket connections (8 bytes)
	upgrader    websocket.Upgrader
}

// RecordingManager handles audio recording
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type RecordingManager struct {
	// Recording data (8 bytes)
	recording *models.VoiceRecording

	// File writer (8 bytes)
	writer    AudioWriter

	// Participants being recorded (8 bytes)
	participants map[string]*AudioStream

	// Mutex for thread safety (8 bytes)
	mutex     sync.RWMutex

	// Shutdown channel (8 bytes)
	shutdownCh chan struct{}
}

// AudioWriter interface for recording audio
type AudioWriter interface {
	WriteAudio(data []byte, participantID string) error
	Close() error
}

// AudioStream represents an audio stream from a participant
type AudioStream struct {
	ParticipantID string
	Stream        *webrtc.TrackLocalStaticRTP
	DataCh        chan []byte
}

// Database interface for data persistence
type Database interface {
	CreateVoiceRoom(ctx context.Context, room *models.VoiceRoom) error
	GetVoiceRoom(ctx context.Context, roomID string) (*models.VoiceRoom, error)
	UpdateVoiceRoom(ctx context.Context, room *models.VoiceRoom) error
	DeleteVoiceRoom(ctx context.Context, roomID string) error

	AddParticipant(ctx context.Context, participant *models.VoiceParticipant) error
	RemoveParticipant(ctx context.Context, roomID, userID string) error
	GetParticipants(ctx context.Context, roomID string) ([]*models.VoiceParticipant, error)
	UpdateParticipant(ctx context.Context, participant *models.VoiceParticipant) error

	CreateWebRTCSession(ctx context.Context, session *models.WebRTCSession) error
	UpdateWebRTCSession(ctx context.Context, session *models.WebRTCSession) error
	GetWebRTCSession(ctx context.Context, sessionID string) (*models.WebRTCSession, error)

	SaveSignalingMessage(ctx context.Context, message *models.SignalingMessage) error
	SaveQualityMetrics(ctx context.Context, metrics *models.VoiceQualityMetrics) error

	StartRecording(ctx context.Context, recording *models.VoiceRecording) error
	UpdateRecording(ctx context.Context, recording *models.VoiceRecording) error
	GetRecording(ctx context.Context, recordingID string) (*models.VoiceRecording, error)

	CreateInvite(ctx context.Context, invite *models.VoiceRoomInvite) error
	GetInvite(ctx context.Context, inviteID string) (*models.VoiceRoomInvite, error)
	UpdateInvite(ctx context.Context, invite *models.VoiceRoomInvite) error

	LogModerationEvent(ctx context.Context, event *models.VoiceModerationEvent) error
}

// RedisClient interface for caching and pub/sub
type RedisClient interface {
	Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
	Get(ctx context.Context, key string) (string, error)
	Del(ctx context.Context, keys ...string) error
	Publish(ctx context.Context, channel string, message interface{}) error
	Subscribe(ctx context.Context, channels ...string) (<-chan string, func())
}

// NewService creates a new voice chat service instance
func NewService(cfg *config.Config, db Database, redis RedisClient, logger *zap.Logger) (*Service, error) {
	// Initialize WebRTC API with STUN/TURN servers
	webrtcConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	api := webrtc.NewAPI()

	// Initialize metrics
	metrics := &Metrics{
		roomsCreated: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_rooms_created_total",
			Help: "Total number of voice rooms created",
		}),
		roomsDestroyed: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_rooms_destroyed_total",
			Help: "Total number of voice rooms destroyed",
		}),
		participantsJoined: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_participants_joined_total",
			Help: "Total number of participants joined",
		}),
		participantsLeft: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_participants_left_total",
			Help: "Total number of participants left",
		}),
		signalingMessages: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_signaling_messages_total",
			Help: "Total number of signaling messages",
		}),
		webrtcConnections: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_webrtc_connections_total",
			Help: "Total number of WebRTC connections",
		}),
		recordingStarted: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_recording_started_total",
			Help: "Total number of recordings started",
		}),
		recordingCompleted: promauto.NewCounter(prometheus.CounterOpts{
			Name: "voice_chat_recording_completed_total",
			Help: "Total number of recordings completed",
		}),
		activeRooms: promauto.NewGauge(prometheus.GaugeOpts{
			Name: "voice_chat_active_rooms",
			Help: "Number of currently active rooms",
		}),
		activeParticipants: promauto.NewGauge(prometheus.GaugeOpts{
			Name: "voice_chat_active_participants",
			Help: "Number of currently active participants",
		}),
		activeRecordings: promauto.NewGauge(prometheus.GaugeOpts{
			Name: "voice_chat_active_recordings",
			Help: "Number of currently active recordings",
		}),
		roomDuration: promauto.NewHistogram(prometheus.HistogramOpts{
			Name: "voice_chat_room_duration_seconds",
			Help: "Duration of voice rooms",
			Buckets: prometheus.DefBuckets,
		}),
		participantDuration: promauto.NewHistogram(prometheus.HistogramOpts{
			Name: "voice_chat_participant_duration_seconds",
			Help: "Duration of participant sessions",
			Buckets: prometheus.DefBuckets,
		}),
		signalingLatency: promauto.NewHistogram(prometheus.HistogramOpts{
			Name: "voice_chat_signaling_latency_seconds",
			Help: "Latency of signaling messages",
			Buckets: []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1},
		}),
		webrtcSetupTime: promauto.NewHistogram(prometheus.HistogramOpts{
			Name: "voice_chat_webrtc_setup_time_seconds",
			Help: "Time to setup WebRTC connections",
			Buckets: prometheus.DefBuckets,
		}),
		audioQualityScore: promauto.NewHistogram(prometheus.HistogramOpts{
			Name: "voice_chat_audio_quality_score",
			Help: "Audio quality scores (0-1)",
			Buckets: []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0},
		}),
	}

	// Initialize memory pools
	participantPool := sync.Pool{
		New: func() interface{} {
			return &models.VoiceParticipant{}
		},
	}
	sessionPool := sync.Pool{
		New: func() interface{} {
			return &models.WebRTCSession{}
		},
	}
	messagePool := sync.Pool{
		New: func() interface{} {
			return &models.SignalingMessage{}
		},
	}
	metricsPool := sync.Pool{
		New: func() interface{} {
			return &models.VoiceQualityMetrics{}
		},
	}

	service := &Service{
		logger:         logger,
		db:             db,
		redis:          redis,
		api:            api,
		config:         cfg,
		metrics:        metrics,
		rooms:          make(map[string]*VoiceRoomManager),
		signaling:      &SignalingServer{
			connections: make(map[string]*websocket.Conn),
			rooms:       make(map[string]map[string]bool),
		},
		participantPool: participantPool,
		sessionPool:     sessionPool,
		messagePool:     messagePool,
		metricsPool:     metricsPool,
		ctx:             context.Background(),
		shutdownCh:      make(chan struct{}),
	}

	return service, nil
}

// CreateVoiceRoom creates a new voice chat room
func (s *Service) CreateVoiceRoom(ctx context.Context, req *api.CreateRoomRequest) (*api.CreateRoomResponse, error) {
	// Generate room ID
	roomID := uuid.New().String()

	// Create room model
	room := &models.VoiceRoom{
		ID:               uuid.New().String(),
		RoomID:           roomID,
		RoomName:         req.Name,
		Description:      req.Description,
		OwnerID:          req.OwnerID,
		GameServerID:     req.GameServerID,
		Region:           req.Region,
		MaxParticipants:  req.MaxParticipants,
		RoomType:         req.RoomType,
		IsPrivate:        req.IsPrivate,
		Password:         req.Password,
		Bitrate:          req.Bitrate,
		QualityPreset:    req.QualityPreset,
		AudioCodec:       "opus",
		Status:           "active",
		CreatedAt:        time.Now(),
		LastActivityAt:   time.Now(),
		IsTemporary:      req.IsTemporary,
		RequireAuth:      true,
		EchoCancellation: true,
		NoiseSuppression: true,
		AGCEnabled:       true,
	}

	// Set default values if not provided
	if room.MaxParticipants == 0 {
		room.MaxParticipants = 50
	}
	if room.Bitrate == 0 {
		room.Bitrate = 64000 // 64 kbps
	}
	if room.QualityPreset == "" {
		room.QualityPreset = "high"
	}

	// Save to database
	if err := s.db.CreateVoiceRoom(ctx, room); err != nil {
		return nil, fmt.Errorf("failed to create room: %w", err)
	}

	// Create room manager
	roomManager := &VoiceRoomManager{
		room:          room,
		participants:  make(map[string]*models.VoiceParticipant),
		peers:         make(map[string]*webrtc.PeerConnection),
		signalingCh:   make(chan *models.SignalingMessage, 100),
		shutdownCh:    make(chan struct{}),
	}

	// Start room manager
	go roomManager.start(s)

	// Store room manager
	s.roomsMutex.Lock()
	s.rooms[roomID] = roomManager
	s.roomsMutex.Unlock()

	// Update metrics
	s.metrics.roomsCreated.Inc()
	s.metrics.activeRooms.Inc()

	s.logger.Info("Created voice room",
		zap.String("room_id", roomID),
		zap.String("room_name", room.RoomName))

	return &api.CreateRoomResponse{
		RoomID:    roomID,
		RoomToken: s.generateRoomToken(roomID),
	}, nil
}

// JoinVoiceRoom allows a user to join a voice room
func (s *Service) JoinVoiceRoom(ctx context.Context, req *api.JoinRoomRequest) (*api.JoinRoomResponse, error) {
	// Get room
	room, err := s.db.GetVoiceRoom(ctx, req.RoomID)
	if err != nil {
		return nil, fmt.Errorf("failed to get room: %w", err)
	}

	if room.Status != "active" {
		return nil, fmt.Errorf("room is not active")
	}

	// Check password for private rooms
	if room.IsPrivate && room.Password != "" && room.Password != req.Password {
		return nil, fmt.Errorf("invalid password")
	}

	// Check participant limit
	if room.CurrentParticipants >= room.MaxParticipants {
		return nil, fmt.Errorf("room is full")
	}

	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("room manager not found")
	}

	// Create participant
	participant := s.participantPool.Get().(*models.VoiceParticipant)
	defer s.participantPool.Put(participant)

	*participant = models.VoiceParticipant{
		ID:             uuid.New().String(),
		RoomID:         req.RoomID,
		UserID:         req.UserID,
		SessionID:      uuid.New().String(),
		Username:       req.Username,
		Role:           "member",
		Status:         "active",
		JoinedAt:       time.Now(),
		LastActivity:   time.Now(),
		IsConnected:    false,
		IsAuthenticated: true,
		VolumeLevel:    1.0,
	}

	// Add participant to database
	if err := s.db.AddParticipant(ctx, participant); err != nil {
		return nil, fmt.Errorf("failed to add participant: %w", err)
	}

	// Add to room manager
	roomManager.mutex.Lock()
	roomManager.participants[req.UserID] = participant
	roomManager.mutex.Unlock()

	// Update room participant count
	room.CurrentParticipants++
	if err := s.db.UpdateVoiceRoom(ctx, room); err != nil {
		s.logger.Error("Failed to update room participant count", zap.Error(err))
	}

	// Update metrics
	s.metrics.participantsJoined.Inc()
	s.metrics.activeParticipants.Inc()

	s.logger.Info("User joined room",
		zap.String("user_id", req.UserID),
		zap.String("room_id", req.RoomID))

	return &api.JoinRoomResponse{
		SessionID: participant.SessionID,
		WebRTCConfig: &api.WebRTCConfig{
			ICEServers: []api.ICEServer{
				{URLs: []string{"stun:stun.l.google.com:19302"}},
			},
			AudioCodec:   room.AudioCodec,
			Bitrate:      room.Bitrate,
			EchoCancellation: room.EchoCancellation,
			NoiseSuppression: room.NoiseSuppression,
			AGCEnabled:   room.AGCEnabled,
		},
	}, nil
}

// LeaveVoiceRoom allows a user to leave a voice room
func (s *Service) LeaveVoiceRoom(ctx context.Context, req *api.LeaveRoomRequest) error {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return fmt.Errorf("room not found")
	}

	// Remove participant from room manager
	roomManager.mutex.Lock()
	participant, exists := roomManager.participants[req.UserID]
	if exists {
		delete(roomManager.participants, req.UserID)
	}
	roomManager.mutex.Unlock()

	if !exists {
		return fmt.Errorf("participant not found in room")
	}

	// Remove from database
	if err := s.db.RemoveParticipant(ctx, req.RoomID, req.UserID); err != nil {
		s.logger.Error("Failed to remove participant from database", zap.Error(err))
	}

	// Update room participant count
	room, err := s.db.GetVoiceRoom(ctx, req.RoomID)
	if err == nil {
		room.CurrentParticipants--
		if room.CurrentParticipants < 0 {
			room.CurrentParticipants = 0
		}
		s.db.UpdateVoiceRoom(ctx, room)
	}

	// Close WebRTC connection if exists
	if peer, exists := roomManager.peers[req.UserID]; exists {
		peer.Close()
		roomManager.mutex.Lock()
		delete(roomManager.peers, req.UserID)
		roomManager.mutex.Unlock()
	}

	// Update metrics
	s.metrics.participantsLeft.Inc()
	s.metrics.activeParticipants.Dec()

	// Record participant duration
	if participant != nil {
		duration := time.Since(participant.JoinedAt)
		s.metrics.participantDuration.Observe(duration.Seconds())
	}

	s.logger.Info("User left room",
		zap.String("user_id", req.UserID),
		zap.String("room_id", req.RoomID))

	return nil
}

// SendSignalingMessage handles WebRTC signaling messages
func (s *Service) SendSignalingMessage(ctx context.Context, req *api.SignalingMessage) error {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return fmt.Errorf("room not found")
	}

	// Create signaling message
	message := s.messagePool.Get().(*models.SignalingMessage)
	defer s.messagePool.Put(message)

	*message = models.SignalingMessage{
		ID:            uuid.New().String(),
		SessionID:     req.SessionID,
		FromUser:      req.FromUser,
		ToUser:        req.ToUser,
		MessageType:   req.MessageType,
		SDP:           req.SDP,
		Candidate:     req.Candidate,
		CandidateType: req.CandidateType,
		Timestamp:     time.Now(),
		IsReliable:    true,
	}

	// Save to database
	if err := s.db.SaveSignalingMessage(ctx, message); err != nil {
		s.logger.Error("Failed to save signaling message", zap.Error(err))
	}

	// Send to room manager for processing
	select {
	case roomManager.signalingCh <- message:
		s.metrics.signalingMessages.Inc()
	default:
	s.logger.Warn("Signaling channel full for room",
		zap.String("room_id", req.RoomID))
	}

	return nil
}

// GetRoomInfo returns information about a voice room
func (s *Service) GetRoomInfo(ctx context.Context, roomID string) (*api.RoomInfo, error) {
	room, err := s.db.GetVoiceRoom(ctx, roomID)
	if err != nil {
		return nil, fmt.Errorf("failed to get room: %w", err)
	}

	participants, err := s.db.GetParticipants(ctx, roomID)
	if err != nil {
	s.logger.Error("Failed to get participants", zap.Error(err))
		participants = []*models.VoiceParticipant{}
	}

	participantInfos := make([]*api.ParticipantInfo, len(participants))
	for i, p := range participants {
		participantInfos[i] = &api.ParticipantInfo{
			UserID:      p.UserID,
			Username:    p.Username,
			IsMuted:     p.IsMuted,
			IsDeafened:  p.IsDeafened,
			IsSpeaking:  p.IsSpeaking,
			VolumeLevel: p.VolumeLevel,
		}
	}

	return &api.RoomInfo{
		RoomID:          room.RoomID,
		Name:            room.RoomName,
		Description:     room.Description,
		OwnerID:         room.OwnerID,
		RoomType:        room.RoomType,
		MaxParticipants: room.MaxParticipants,
		CurrentParticipants: room.CurrentParticipants,
		Bitrate:         room.Bitrate,
		QualityPreset:   room.QualityPreset,
		IsPrivate:       room.IsPrivate,
		Status:          room.Status,
		Participants:    participantInfos,
	}, nil
}

// StartRecording starts recording audio in a room
func (s *Service) StartRecording(ctx context.Context, req *api.StartRecordingRequest) (*api.StartRecordingResponse, error) {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("room not found")
	}

	// Check permissions (only room owner or moderators can start recording)
	roomManager.mutex.RLock()
	participant, exists := roomManager.participants[req.UserID]
	roomManager.mutex.RUnlock()

	if !exists || (participant.Role != "owner" && participant.Role != "moderator") {
		return nil, fmt.Errorf("insufficient permissions")
	}

	// Check if room allows recording
	if !roomManager.room.AllowRecording {
		return nil, fmt.Errorf("recording not allowed in this room")
	}

	// Create recording
	recording := &models.VoiceRecording{
		ID:           uuid.New().String(),
		RecordingID:  uuid.New().String(),
		RoomID:       req.RoomID,
		InitiatorID:  req.UserID,
		StartedAt:    time.Now(),
		FileFormat:   "opus",
		Codec:        "opus",
		Bitrate:      roomManager.room.Bitrate,
		SampleRate:   48000,
		Status:       "recording",
		Title:        req.Title,
		IsPublic:     req.IsPublic,
	}

	// Start recording in database
	if err := s.db.StartRecording(ctx, recording); err != nil {
		return nil, fmt.Errorf("failed to start recording: %w", err)
	}

	// Start recording manager
	recordingManager := &RecordingManager{
		recording:    recording,
		participants: make(map[string]*AudioStream),
		shutdownCh:   make(chan struct{}),
	}

	roomManager.recording = recordingManager
	go recordingManager.start(s, roomManager)

	// Update metrics
	s.metrics.recordingStarted.Inc()
	s.metrics.activeRecordings.Inc()

	s.logger.Info("Started recording in room",
		zap.String("room_id", req.RoomID),
		zap.String("recording_id", recording.RecordingID))

	return &api.StartRecordingResponse{
		RecordingID: recording.RecordingID,
	}, nil
}

// StopRecording stops recording audio in a room
func (s *Service) StopRecording(ctx context.Context, req *api.StopRecordingRequest) error {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return fmt.Errorf("room not found")
	}

	if roomManager.recording == nil {
		return fmt.Errorf("no active recording")
	}

	// Check permissions
	roomManager.mutex.RLock()
	participant, exists := roomManager.participants[req.UserID]
	roomManager.mutex.RUnlock()

	if !exists || (participant.Role != "owner" && participant.Role != "moderator" && req.UserID != roomManager.recording.recording.InitiatorID) {
		return fmt.Errorf("insufficient permissions")
	}

	// Stop recording
	roomManager.recording.stop()

	// Update recording in database
	roomManager.recording.recording.EndedAt = &time.Time{}
	*roomManager.recording.recording.EndedAt = time.Now()
	roomManager.recording.recording.Duration = roomManager.recording.recording.EndedAt.Sub(roomManager.recording.recording.StartedAt)
	roomManager.recording.recording.Status = "completed"

	if err := s.db.UpdateRecording(ctx, roomManager.recording.recording); err != nil {
	s.logger.Error("Failed to update recording", zap.Error(err))
	}

	// Clear recording manager
	roomManager.recording = nil

	// Update metrics
	s.metrics.recordingCompleted.Inc()
	s.metrics.activeRecordings.Dec()

	s.logger.Info("Stopped recording in room",
		zap.String("room_id", req.RoomID))

	return nil
}

// MuteParticipant mutes a participant in a room
func (s *Service) MuteParticipant(ctx context.Context, req *api.MuteParticipantRequest) error {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return fmt.Errorf("room not found")
	}

	// Check permissions (only moderators and owner can mute)
	roomManager.mutex.RLock()
	requester, exists := roomManager.participants[req.RequesterID]
	if !exists || (requester.Role != "owner" && requester.Role != "moderator") {
		roomManager.mutex.RUnlock()
		return fmt.Errorf("insufficient permissions")
	}

	target, exists := roomManager.participants[req.TargetUserID]
	roomManager.mutex.RUnlock()

	if !exists {
		return fmt.Errorf("target participant not found")
	}

	// Update participant status
	target.IsMuted = req.Mute
	if req.Mute && req.Duration > 0 {
		mutedUntil := time.Now().Add(time.Duration(req.Duration) * time.Second)
		target.MutedUntil = &mutedUntil
	} else if !req.Mute {
		target.MutedUntil = nil
	}

	// Update in database
	if err := s.db.UpdateParticipant(ctx, target); err != nil {
		return fmt.Errorf("failed to update participant: %w", err)
	}

	// Log moderation event
	event := &models.VoiceModerationEvent{
		ID:           uuid.New().String(),
		RoomID:       req.RoomID,
		ModeratorID:  req.RequesterID,
		TargetUserID: req.TargetUserID,
		ActionType:   "mute",
		Reason:       req.Reason,
		Timestamp:    time.Now(),
		Duration:     req.Duration,
		IsTemporary:  req.Duration > 0,
		IsReversible: true,
	}

	if req.Mute {
		event.ActionType = "mute"
	} else {
		event.ActionType = "unmute"
	}

	s.db.LogModerationEvent(ctx, event)

	action := "was"
	if !req.Mute {
		action = "was un"
	}
	s.logger.Info("User mute status changed",
		zap.String("target_user_id", req.TargetUserID),
		zap.String("action", action+"muted"),
		zap.String("room_id", req.RoomID),
		zap.String("requester_id", req.RequesterID))

	return nil
}

// KickParticipant kicks a participant from a room
func (s *Service) KickParticipant(ctx context.Context, req *api.KickParticipantRequest) error {
	// Get room manager
	s.roomsMutex.RLock()
	roomManager, exists := s.rooms[req.RoomID]
	s.roomsMutex.RUnlock()

	if !exists {
		return fmt.Errorf("room not found")
	}

	// Check permissions
	roomManager.mutex.RLock()
	requester, exists := roomManager.participants[req.RequesterID]
	roomManager.mutex.RUnlock()

	if !exists || (requester.Role != "owner" && requester.Role != "moderator") {
		return fmt.Errorf("insufficient permissions")
	}

	// Log moderation event
	event := &models.VoiceModerationEvent{
		ID:           uuid.New().String(),
		RoomID:       req.RoomID,
		ModeratorID:  req.RequesterID,
		TargetUserID: req.TargetUserID,
		ActionType:   "kick",
		Reason:       req.Reason,
		Timestamp:    time.Now(),
		IsTemporary:  false,
		IsReversible: false,
	}

	s.db.LogModerationEvent(ctx, event)

	// Remove participant (this will trigger leave logic)
	return s.LeaveVoiceRoom(ctx, &api.LeaveRoomRequest{
		RoomID: req.RoomID,
		UserID: req.TargetUserID,
	})
}

// SendQualityMetrics records voice quality metrics
func (s *Service) SendQualityMetrics(ctx context.Context, req *api.QualityMetricsRequest) error {
	metrics := s.metricsPool.Get().(*models.VoiceQualityMetrics)
	defer s.metricsPool.Put(metrics)

	*metrics = models.VoiceQualityMetrics{
		ID:             uuid.New().String(),
		RoomID:         req.RoomID,
		UserID:         req.UserID,
		SessionID:      req.SessionID,
		Timestamp:      time.Now(),
		JitterMs:       req.JitterMs,
		PacketsLost:    req.PacketsLost,
		PacketsSent:    req.PacketsSent,
		BytesSent:      req.BytesSent,
		RoundTripTime:  req.RoundTripTime,
		PacketLossRate: req.PacketLossRate,
		AudioLevel:     req.AudioLevel,
		QualityScore:   req.QualityScore,
		CodecUsed:      req.CodecUsed,
		NetworkType:    req.NetworkType,
		HasIssues:      req.QualityScore < 0.5,
	}

	// Save to database
	if err := s.db.SaveQualityMetrics(ctx, metrics); err != nil {
	s.logger.Error("Failed to save quality metrics", zap.Error(err))
		return err
	}

	// Update histogram metrics
	s.metrics.audioQualityScore.Observe(req.QualityScore)

	return nil
}

// StartQualityMonitoring starts monitoring voice quality metrics
func (s *Service) StartQualityMonitoring(ctx context.Context) error {
	s.logger.Info("Starting voice quality monitoring")

	// Start quality monitoring ticker
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			s.logger.Info("Voice quality monitoring stopped")
			return ctx.Err()
		case <-s.shutdownCh:
			s.logger.Info("Voice quality monitoring stopped due to service shutdown")
			return nil
		case <-ticker.C:
			s.performQualityCheck(ctx)
		}
	}
}

// performQualityCheck performs periodic quality monitoring
func (s *Service) performQualityCheck(ctx context.Context) {
	s.roomsMutex.RLock()
	roomCount := len(s.rooms)
	s.roomsMutex.RUnlock()

	s.logger.Info("Quality check completed",
		zap.Int("active_rooms", roomCount))

	// In production, this would analyze quality metrics from database
	// and take corrective actions if needed
}

// Shutdown gracefully shuts down the service
func (s *Service) Shutdown() {
	s.logger.Info("Shutting down voice chat service")

	close(s.shutdownCh)

	// Shutdown all room managers
	s.roomsMutex.Lock()
	for roomID, manager := range s.rooms {
		manager.shutdown()
		delete(s.rooms, roomID)
	}
	s.roomsMutex.Unlock()

	s.logger.Info("Voice chat service shutdown complete")
}

// generateRoomToken generates a secure token for room access
func (s *Service) generateRoomToken(roomID string) string {
	// Generate a random token
	token := make([]byte, 32)
	rand.Read(token)

	// In production, this should be a proper JWT token
	// For now, return a simple encoded string
	return fmt.Sprintf("%s_%x", roomID, token)
}

// start starts the room manager goroutine
func (rm *VoiceRoomManager) start(s *Service) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-rm.shutdownCh:
			return
		case message := <-rm.signalingCh:
			rm.handleSignalingMessage(s, message)
		case <-ticker.C:
			rm.checkIdleTimeout(s)
		}
	}
}

// handleSignalingMessage processes signaling messages
func (rm *VoiceRoomManager) handleSignalingMessage(s *Service, message *models.SignalingMessage) {
	start := time.Now()

	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	// Find target participant
	targetPeer, exists := rm.peers[message.ToUser]
	if !exists {
		log.Printf("Target peer not found for signaling message: %s", message.ToUser)
		return
	}

	// Process message based on type
	switch message.MessageType {
	case "offer", "answer":
		// Set remote description
		var sdp webrtc.SessionDescription
		if err := json.Unmarshal([]byte(message.SDP), &sdp); err != nil {
			log.Printf("Failed to unmarshal SDP: %v", err)
			return
		}

		if err := targetPeer.SetRemoteDescription(sdp); err != nil {
			log.Printf("Failed to set remote description: %v", err)
			return
		}

	case "candidate":
		// Add ICE candidate
		var candidate webrtc.ICECandidateInit
		if err := json.Unmarshal([]byte(message.Candidate), &candidate); err != nil {
			log.Printf("Failed to unmarshal ICE candidate: %v", err)
			return
		}

		if err := targetPeer.AddICECandidate(candidate); err != nil {
			log.Printf("Failed to add ICE candidate: %v", err)
			return
		}
	}

	// Record signaling latency
	s.metrics.signalingLatency.Observe(time.Since(start).Seconds())
}

// checkIdleTimeout checks if room should be cleaned up due to inactivity
func (rm *VoiceRoomManager) checkIdleTimeout(s *Service) {
	rm.mutex.RLock()
	participantCount := len(rm.participants)
	lastActivity := rm.room.LastActivityAt
	rm.mutex.RUnlock()

	// If room is empty and has been inactive for more than 5 minutes, clean it up
	if participantCount == 0 && time.Since(lastActivity) > 5*time.Minute {
		rm.shutdown()

		s.roomsMutex.Lock()
		delete(s.rooms, rm.room.RoomID)
		s.roomsMutex.Unlock()

		s.metrics.roomsDestroyed.Inc()
		s.metrics.activeRooms.Dec()

		// Record room duration
		duration := time.Since(rm.room.CreatedAt)
		s.metrics.roomDuration.Observe(duration.Seconds())

		log.Printf("Cleaned up idle room: %s", rm.room.RoomID)
	}
}

// shutdown shuts down the room manager
func (rm *VoiceRoomManager) shutdown() {
	close(rm.shutdownCh)

	// Stop recording if active
	if rm.recording != nil {
		rm.recording.stop()
	}

	// Close all peer connections
	for _, peer := range rm.peers {
		peer.Close()
	}
}

// start starts the recording manager
func (rm *RecordingManager) start(s *Service, roomManager *VoiceRoomManager) {
	// Initialize audio writer (implementation would depend on storage backend)
	// For now, this is a placeholder
	rm.writer = &FileAudioWriter{
		filePath: fmt.Sprintf("/recordings/%s.opus", rm.recording.RecordingID),
	}

	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-rm.shutdownCh:
			return
		case <-ticker.C:
			// Process audio data from participants
			rm.processAudioData()
		}
	}
}

// processAudioData processes incoming audio data from participants
func (rm *RecordingManager) processAudioData() {
	rm.mutex.RLock()
	defer rm.mutex.RUnlock()

	for participantID, stream := range rm.participants {
		select {
		case data := <-stream.DataCh:
			if rm.writer != nil {
				if err := rm.writer.WriteAudio(data, participantID); err != nil {
					log.Printf("Failed to write audio data: %v", err)
				}
			}
		default:
			// No data available
		}
	}
}

// stop stops the recording
func (rm *RecordingManager) stop() {
	close(rm.shutdownCh)

	if rm.writer != nil {
		if err := rm.writer.Close(); err != nil {
			log.Printf("Failed to close audio writer: %v", err)
		}
	}
}

// FileAudioWriter is a simple file-based audio writer
type FileAudioWriter struct {
	filePath string
	// In production, this would implement proper audio file writing
}

func (w *FileAudioWriter) WriteAudio(data []byte, participantID string) error {
	// Placeholder implementation
	// In production, this would write to a proper audio file format
	return nil
}

func (w *FileAudioWriter) Close() error {
	// Placeholder implementation
	return nil
}