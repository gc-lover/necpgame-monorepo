// Code generated by NECPGAME backend agent. Enterprise-grade Voice Chat service tests.
// PERFORMANCE: Optimized test execution with parallel runs
// COVERAGE: Comprehensive test coverage for critical paths

package service

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"necpgame/services/voice-chat-service-go/config"
	"necpgame/services/voice-chat-service-go/internal/models"
	"necpgame/services/voice-chat-service-go/pkg/api"
)

// MockDatabase implements Database interface for testing
type MockDatabase struct {
	mock.Mock
}

func (m *MockDatabase) CreateVoiceRoom(ctx context.Context, room *models.VoiceRoom) error {
	args := m.Called(ctx, room)
	return args.Error(0)
}

func (m *MockDatabase) GetVoiceRoom(ctx context.Context, roomID string) (*models.VoiceRoom, error) {
	args := m.Called(ctx, roomID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.VoiceRoom), args.Error(1)
}

func (m *MockDatabase) UpdateVoiceRoom(ctx context.Context, room *models.VoiceRoom) error {
	args := m.Called(ctx, room)
	return args.Error(0)
}

func (m *MockDatabase) DeleteVoiceRoom(ctx context.Context, roomID string) error {
	args := m.Called(ctx, roomID)
	return args.Error(0)
}

func (m *MockDatabase) AddParticipant(ctx context.Context, participant *models.VoiceParticipant) error {
	args := m.Called(ctx, participant)
	return args.Error(0)
}

func (m *MockDatabase) RemoveParticipant(ctx context.Context, roomID, userID string) error {
	args := m.Called(ctx, roomID, userID)
	return args.Error(0)
}

func (m *MockDatabase) GetParticipants(ctx context.Context, roomID string) ([]*models.VoiceParticipant, error) {
	args := m.Called(ctx, roomID)
	return args.Get(0).([]*models.VoiceParticipant), args.Error(1)
}

func (m *MockDatabase) UpdateParticipant(ctx context.Context, participant *models.VoiceParticipant) error {
	args := m.Called(ctx, participant)
	return args.Error(0)
}

func (m *MockDatabase) CreateWebRTCSession(ctx context.Context, session *models.WebRTCSession) error {
	args := m.Called(ctx, session)
	return args.Error(0)
}

func (m *MockDatabase) UpdateWebRTCSession(ctx context.Context, session *models.WebRTCSession) error {
	args := m.Called(ctx, session)
	return args.Error(0)
}

func (m *MockDatabase) GetWebRTCSession(ctx context.Context, sessionID string) (*models.WebRTCSession, error) {
	args := m.Called(ctx, sessionID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.WebRTCSession), args.Error(1)
}

func (m *MockDatabase) SaveSignalingMessage(ctx context.Context, message *models.SignalingMessage) error {
	args := m.Called(ctx, message)
	return args.Error(0)
}

func (m *MockDatabase) SaveQualityMetrics(ctx context.Context, metrics *models.VoiceQualityMetrics) error {
	args := m.Called(ctx, metrics)
	return args.Error(0)
}

func (m *MockDatabase) StartRecording(ctx context.Context, recording *models.VoiceRecording) error {
	args := m.Called(ctx, recording)
	return args.Error(0)
}

func (m *MockDatabase) UpdateRecording(ctx context.Context, recording *models.VoiceRecording) error {
	args := m.Called(ctx, recording)
	return args.Error(0)
}

func (m *MockDatabase) GetRecording(ctx context.Context, recordingID string) (*models.VoiceRecording, error) {
	args := m.Called(ctx, recordingID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.VoiceRecording), args.Error(1)
}

func (m *MockDatabase) CreateInvite(ctx context.Context, invite *models.VoiceRoomInvite) error {
	args := m.Called(ctx, invite)
	return args.Error(0)
}

func (m *MockDatabase) GetInvite(ctx context.Context, inviteID string) (*models.VoiceRoomInvite, error) {
	args := m.Called(ctx, inviteID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.VoiceRoomInvite), args.Error(1)
}

func (m *MockDatabase) UpdateInvite(ctx context.Context, invite *models.VoiceRoomInvite) error {
	args := m.Called(ctx, invite)
	return args.Error(0)
}

func (m *MockDatabase) LogModerationEvent(ctx context.Context, event *models.VoiceModerationEvent) error {
	args := m.Called(ctx, event)
	return args.Error(0)
}

// MockRedisClient implements RedisClient interface for testing
type MockRedisClient struct {
	mock.Mock
}

func (m *MockRedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
	args := m.Called(ctx, key, value, expiration)
	return args.Error(0)
}

func (m *MockRedisClient) Get(ctx context.Context, key string) (string, error) {
	args := m.Called(ctx, key)
	return args.String(0), args.Error(1)
}

func (m *MockRedisClient) Del(ctx context.Context, keys ...string) error {
	args := m.Called(ctx, keys)
	return args.Error(0)
}

func (m *MockRedisClient) Publish(ctx context.Context, channel string, message interface{}) error {
	args := m.Called(ctx, channel, message)
	return args.Error(0)
}

func (m *MockRedisClient) Subscribe(ctx context.Context, channels ...string) (<-chan string, func()) {
	args := m.Called(ctx, channels)
	return args.Get(0).(<-chan string), args.Get(1).(func())
}

// MockRateLimiter implements RateLimiter interface for testing
type MockRateLimiter struct {
	mock.Mock
}

func (m *MockRateLimiter) Allow(key string) bool {
	args := m.Called(key)
	return args.Bool(0)
}

// MockJWTValidator implements JWTValidator interface for testing
type MockJWTValidator struct {
	mock.Mock
}

func (m *MockJWTValidator) ValidateToken(token string) (*Claims, error) {
	args := m.Called(token)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*Claims), args.Error(1)
}

func TestService_CreateVoiceRoom(t *testing.T) {
	t.Parallel() // Run tests in parallel for better performance

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}
	mockRateLimiter := &MockRateLimiter{}
	mockJWT := &MockJWTValidator{}

	cfg := &config.Config{
		Server: config.ServerConfig{
			Port: 8080,
		},
		WebRTC: config.WebRTCConfig{
			ICEServers: []config.ICEServer{
				{URLs: []string{"stun:stun.l.google.com:19302"}},
			},
		},
	}

	service, err := NewService(cfg, mockDB, mockRedis)
	assert.NoError(t, err)

	// Replace dependencies with mocks
	service.db = mockDB
	service.redis = mockRedis

	handler := NewHandler(service, mockRateLimiter, mockJWT)

	t.Run("successful room creation", func(t *testing.T) {
		req := &api.CreateRoomRequest{
			Name:         "Test Room",
			Description:  "Test Description",
			OwnerID:      uuid.New().String(),
			RoomType:     "group",
			MaxParticipants: 10,
			IsPrivate:    false,
		}

		expectedRoom := &models.VoiceRoom{
			ID:              uuid.New().String(),
			RoomID:          uuid.New().String(),
			RoomName:        req.Name,
			Description:     req.Description,
			OwnerID:         req.OwnerID,
			MaxParticipants: req.MaxParticipants,
			RoomType:        req.RoomType,
			IsPrivate:       req.IsPrivate,
			Status:          "active",
			CreatedAt:       time.Now(),
			LastActivityAt:  time.Now(),
		}

		mockDB.On("CreateVoiceRoom", mock.Anything, mock.MatchedBy(func(room *models.VoiceRoom) bool {
			return room.RoomName == req.Name && room.OwnerID == req.OwnerID
		})).Return(nil).Once()

		resp, err := service.CreateVoiceRoom(context.Background(), req)

		assert.NoError(t, err)
		assert.NotNil(t, resp)
		assert.NotEmpty(t, resp.RoomID)
		assert.NotEmpty(t, resp.RoomToken)

		mockDB.AssertExpectations(t)
	})

	t.Run("database error", func(t *testing.T) {
		req := &api.CreateRoomRequest{
			Name:    "Test Room",
			OwnerID: uuid.New().String(),
		}

		mockDB.On("CreateVoiceRoom", mock.Anything, mock.Anything).Return(assert.AnError).Once()

		resp, err := service.CreateVoiceRoom(context.Background(), req)

		assert.Error(t, err)
		assert.Nil(t, resp)
		assert.Contains(t, err.Error(), "failed to create room")

		mockDB.AssertExpectations(t)
	})

	t.Run("validation error - missing name", func(t *testing.T) {
		req := &api.CreateRoomRequest{
			OwnerID: uuid.New().String(),
		}

		resp, err := service.CreateVoiceRoom(context.Background(), req)

		assert.Error(t, err)
		assert.Nil(t, resp)
		assert.Contains(t, err.Error(), "Missing required fields")
	})
}

func TestService_JoinVoiceRoom(t *testing.T) {
	t.Parallel()

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	t.Run("successful join", func(t *testing.T) {
		roomID := uuid.New().String()
		userID := uuid.New().String()

		room := &models.VoiceRoom{
			RoomID:            roomID,
			Status:            "active",
			MaxParticipants:   10,
			CurrentParticipants: 5,
		}

		req := &api.JoinRoomRequest{
			RoomID:   roomID,
			UserID:   userID,
			Username: "TestUser",
		}

		mockDB.On("GetVoiceRoom", mock.Anything, roomID).Return(room, nil).Once()
		mockDB.On("AddParticipant", mock.Anything, mock.MatchedBy(func(p *models.VoiceParticipant) bool {
			return p.RoomID == roomID && p.UserID == userID
		})).Return(nil).Once()
		mockDB.On("UpdateVoiceRoom", mock.Anything, mock.MatchedBy(func(r *models.VoiceRoom) bool {
			return r.CurrentParticipants == 6
		})).Return(nil).Once()

		resp, err := service.JoinVoiceRoom(context.Background(), req)

		assert.NoError(t, err)
		assert.NotNil(t, resp)
		assert.NotEmpty(t, resp.SessionID)
		assert.NotNil(t, resp.WebRTCConfig)

		mockDB.AssertExpectations(t)
	})

	t.Run("room not found", func(t *testing.T) {
		req := &api.JoinRoomRequest{
			RoomID:   uuid.New().String(),
			UserID:   uuid.New().String(),
			Username: "TestUser",
		}

		mockDB.On("GetVoiceRoom", mock.Anything, req.RoomID).Return(nil, assert.AnError).Once()

		resp, err := service.JoinVoiceRoom(context.Background(), req)

		assert.Error(t, err)
		assert.Nil(t, resp)
		assert.Contains(t, err.Error(), "failed to get room")
	})
}

func TestService_SendQualityMetrics(t *testing.T) {
	t.Parallel()

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	t.Run("successful metrics submission", func(t *testing.T) {
		req := &api.QualityMetricsRequest{
			RoomID:         uuid.New().String(),
			UserID:         uuid.New().String(),
			SessionID:      uuid.New().String(),
			QualityScore:   0.95,
			PacketLossRate: 0.02,
			JitterMs:       15,
			RoundTripTime:  45.5,
		}

		mockDB.On("SaveQualityMetrics", mock.Anything, mock.MatchedBy(func(m *models.VoiceQualityMetrics) bool {
			return m.RoomID == req.RoomID && m.QualityScore == req.QualityScore
		})).Return(nil).Once()

		err := service.SendQualityMetrics(context.Background(), req)

		assert.NoError(t, err)
		mockDB.AssertExpectations(t)
	})
}

func TestService_MuteParticipant(t *testing.T) {
	t.Parallel()

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	t.Run("successful mute", func(t *testing.T) {
		roomID := uuid.New().String()
		moderatorID := uuid.New().String()
		targetID := uuid.New().String()

		room := &models.VoiceRoom{
			RoomID: roomID,
		}

		req := &api.MuteParticipantRequest{
			RoomID:       roomID,
			RequesterID:  moderatorID,
			TargetUserID: targetID,
			Mute:         true,
			Reason:       "Test mute",
		}

		mockDB.On("GetVoiceRoom", mock.Anything, roomID).Return(room, nil).Once()
		mockDB.On("UpdateParticipant", mock.Anything, mock.MatchedBy(func(p *models.VoiceParticipant) bool {
			return p.UserID == targetID && p.IsMuted == true
		})).Return(nil).Once()
		mockDB.On("LogModerationEvent", mock.Anything, mock.MatchedBy(func(e *models.VoiceModerationEvent) bool {
			return e.RoomID == roomID && e.ActionType == "mute"
		})).Return(nil).Once()

		err := service.MuteParticipant(context.Background(), req)

		assert.NoError(t, err)
		mockDB.AssertExpectations(t)
	})
}

func TestService_StartRecording(t *testing.T) {
	t.Parallel()

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	t.Run("successful recording start", func(t *testing.T) {
		roomID := uuid.New().String()
		userID := uuid.New().String()

		req := &api.StartRecordingRequest{
			RoomID: roomID,
			UserID: userID,
			Title:  "Test Recording",
		}

		mockDB.On("StartRecording", mock.Anything, mock.MatchedBy(func(r *models.VoiceRecording) bool {
			return r.RoomID == roomID && r.InitiatorID == userID
		})).Return(nil).Once()

		resp, err := service.StartRecording(context.Background(), req)

		assert.NoError(t, err)
		assert.NotNil(t, resp)
		assert.NotEmpty(t, resp.RecordingID)

		mockDB.AssertExpectations(t)
	})
}

func TestService_GetRoomInfo(t *testing.T) {
	t.Parallel()

	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	t.Run("successful room info retrieval", func(t *testing.T) {
		roomID := uuid.New().String()

		room := &models.VoiceRoom{
			RoomID:            roomID,
			RoomName:          "Test Room",
			OwnerID:           uuid.New().String(),
			MaxParticipants:   10,
			CurrentParticipants: 3,
			RoomType:          "group",
			Status:            "active",
		}

		participants := []*models.VoiceParticipant{
			{
				UserID:      uuid.New().String(),
				Username:    "User1",
				IsMuted:     false,
				IsDeafened:  false,
				IsSpeaking:  true,
				VolumeLevel: 1.0,
			},
		}

		mockDB.On("GetVoiceRoom", mock.Anything, roomID).Return(room, nil).Once()
		mockDB.On("GetParticipants", mock.Anything, roomID).Return(participants, nil).Once()

		info, err := service.GetRoomInfo(context.Background(), roomID)

		assert.NoError(t, err)
		assert.NotNil(t, info)
		assert.Equal(t, roomID, info.RoomID)
		assert.Equal(t, "Test Room", info.Name)
		assert.Len(t, info.Participants, 1)

		mockDB.AssertExpectations(t)
	})
}

func BenchmarkService_CreateVoiceRoom(b *testing.B) {
	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	req := &api.CreateRoomRequest{
		Name:         "Benchmark Room",
		Description:  "Benchmark Description",
		OwnerID:      uuid.New().String(),
		RoomType:     "group",
		MaxParticipants: 10,
		IsPrivate:    false,
	}

	mockDB.On("CreateVoiceRoom", mock.Anything, mock.Anything).Return(nil)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			service.CreateVoiceRoom(context.Background(), req)
		}
	})
}

func BenchmarkService_JoinVoiceRoom(b *testing.B) {
	mockDB := &MockDatabase{}
	mockRedis := &MockRedisClient{}

	cfg := &config.Config{}
	service, _ := NewService(cfg, mockDB, mockRedis)

	roomID := uuid.New().String()
	room := &models.VoiceRoom{
		RoomID:             roomID,
		Status:             "active",
		MaxParticipants:    50,
		CurrentParticipants: 10,
	}

	req := &api.JoinRoomRequest{
		RoomID:   roomID,
		UserID:   uuid.New().String(),
		Username: "BenchmarkUser",
	}

	mockDB.On("GetVoiceRoom", mock.Anything, roomID).Return(room, nil)
	mockDB.On("AddParticipant", mock.Anything, mock.Anything).Return(nil)
	mockDB.On("UpdateVoiceRoom", mock.Anything, mock.Anything).Return(nil)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			service.JoinVoiceRoom(context.Background(), req)
		}
	})
}