// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateGuildVoiceChannel invokes createGuildVoiceChannel operation.
	//
	// **Guild System Integration: Create voice channel for guild**
	// Creates a new voice channel specifically for guild communication. Integrates with guild permission
	// system and member management.
	// **Guild Integration:** - Validates guild membership and permissions - Applies guild-specific voice
	// channel settings - Supports role-based access control
	// **Performance:** <50ms channel creation with permission validation.
	//
	// POST /guilds/{guild_id}/voice-channels
	CreateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelRequest, params CreateGuildVoiceChannelParams) (CreateGuildVoiceChannelRes, error)
	// CreateVoiceChannel invokes createVoiceChannel operation.
	//
	// **Enterprise-grade voice channel creation endpoint**
	// Creates guild parties, private rooms, or global voice channels with permission validation.
	// Supports automatic STUN/TURN server allocation and quality monitoring setup.
	// **Performance:** <50ms P95, includes validation and business logic.
	//
	// POST /voice-channels
	CreateVoiceChannel(ctx context.Context, request *CreateVoiceChannelReq) (CreateVoiceChannelRes, error)
	// DeleteVoiceChannel invokes deleteVoiceChannel operation.
	//
	// **Enterprise-grade deletion endpoint**
	// Supports soft deletes with audit trails and cleanup scheduling.
	// Ensures referential integrity and cascading deletes.
	// **Performance:** <15ms P95, includes cleanup operations.
	//
	// DELETE /voice-channels/{channel_id}
	DeleteVoiceChannel(ctx context.Context, params DeleteVoiceChannelParams) (DeleteVoiceChannelRes, error)
	// ExchangeSignalingMessage invokes exchangeSignalingMessage operation.
	//
	// **Core WebRTC signaling endpoint for offer/answer/ICE exchange**
	// Handles SDP offers, answers, and ICE candidates between peers.
	// Validates signaling messages and enforces anti-cheat measures.
	// **Performance:** <10ms P99 signaling message processing.
	//
	// POST /voice-channels/{channel_id}/signal
	ExchangeSignalingMessage(ctx context.Context, request *SignalingMessage, params ExchangeSignalingMessageParams) (ExchangeSignalingMessageRes, error)
	// GetVoiceChannel invokes getVoiceChannel operation.
	//
	// **Enterprise-grade voice channel retrieval endpoint**
	// Returns channel details, active participants, and connection quality metrics.
	// Supports real-time updates via WebSocket for participant changes.
	// **Performance:** <15ms P95 with participant count caching.
	//
	// GET /voice-channels/{channel_id}
	GetVoiceChannel(ctx context.Context, params GetVoiceChannelParams) (GetVoiceChannelRes, error)
	// JoinGuildVoiceChannel invokes joinGuildVoiceChannel operation.
	//
	// **Guild System Integration: Join guild voice channel**
	// Connects user to guild voice channel with permission validation. Handles channel capacity limits
	// and access control.
	// **Integration Features:** - Guild membership verification - Role-based access control - Channel
	// capacity management - Anti-cheat validation
	// **Performance:** <25ms join with permission checks.
	//
	// POST /guilds/{guild_id}/voice-channels/{channel_id}/join
	JoinGuildVoiceChannel(ctx context.Context, request *JoinVoiceChannelRequest, params JoinGuildVoiceChannelParams) (JoinGuildVoiceChannelRes, error)
	// JoinVoiceChannel invokes joinVoiceChannel operation.
	//
	// **Real-time voice channel join with WebRTC handshake**
	// Initiates WebRTC peer connection establishment with signaling protocol.
	// Returns STUN/TURN server credentials and channel participant list.
	// **Performance:** <100ms average connection establishment.
	//
	// POST /voice-channels/{channel_id}/join
	JoinVoiceChannel(ctx context.Context, request *JoinChannelRequest, params JoinVoiceChannelParams) (JoinVoiceChannelRes, error)
	// LeaveVoiceChannel invokes leaveVoiceChannel operation.
	//
	// **Clean voice channel disconnection**
	// Removes participant from voice channel and cleans up signaling state.
	// Updates channel participant count and notifies remaining peers.
	// **Performance:** <25ms disconnection processing.
	//
	// POST /voice-channels/{channel_id}/leave
	LeaveVoiceChannel(ctx context.Context, params LeaveVoiceChannelParams) (LeaveVoiceChannelRes, error)
	// ListGuildVoiceChannels invokes listGuildVoiceChannels operation.
	//
	// **Guild System Integration: List all voice channels for guild**
	// Retrieves all active voice channels belonging to a specific guild. Includes channel status,
	// participant counts, and permissions.
	// **Performance:** <20ms query with Redis caching for active channels.
	//
	// GET /guilds/{guild_id}/voice-channels
	ListGuildVoiceChannels(ctx context.Context, params ListGuildVoiceChannelsParams) (ListGuildVoiceChannelsRes, error)
	// ListVoiceChannels invokes listVoiceChannels operation.
	//
	// **Enterprise-grade voice channel listing endpoint**
	// Supports filtering by type (guild/party/global), status, and participant count.
	// Optimized for real-time voice channel discovery and management.
	// **Performance:** <25ms P95, supports 5000+ concurrent voice sessions.
	//
	// GET /voice-channels
	ListVoiceChannels(ctx context.Context, params ListVoiceChannelsParams) (ListVoiceChannelsRes, error)
	// ReportVoiceQuality invokes reportVoiceQuality operation.
	//
	// **Real-time voice quality monitoring and optimization**
	// Collects latency, packet loss, and audio quality metrics from clients.
	// Enables adaptive bitrate adjustment and quality optimization.
	// **Performance:** <5ms metrics processing with batch aggregation.
	//
	// POST /voice-quality/{channel_id}/report
	ReportVoiceQuality(ctx context.Context, request *VoiceQualityReport, params ReportVoiceQualityParams) (ReportVoiceQualityRes, error)
	// UpdateGuildVoiceChannel invokes updateGuildVoiceChannel operation.
	//
	// **Guild System Integration: Update guild voice channel settings**
	// Modifies voice channel configuration including permissions, user limits, and moderation settings.
	// Requires appropriate guild permissions.
	// **Permission Checks:** - Channel owner or guild leader/officer - Validates permission hierarchy
	// **Performance:** <30ms update with permission validation.
	//
	// PUT /guilds/{guild_id}/voice-channels/{channel_id}
	UpdateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelUpdateRequest, params UpdateGuildVoiceChannelParams) (UpdateGuildVoiceChannelRes, error)
	// UpdateVoiceChannel invokes updateVoiceChannel operation.
	//
	// **Enterprise-grade update endpoint**
	// Supports partial updates, optimistic locking, and audit trails.
	// Ensures data consistency with event sourcing patterns.
	// **Performance:** <25ms P95, includes validation and conflict resolution.
	//
	// PUT /voice-channels/{channel_id}
	UpdateVoiceChannel(ctx context.Context, request *UpdateExampleRequest, params UpdateVoiceChannelParams) (UpdateVoiceChannelRes, error)
	// WebrtcSignalingBatchHealthCheck invokes webrtcSignalingBatchHealthCheck operation.
	//
	// **Performance optimization:** Check multiple domain health in single request
	// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
	// Eliminates network overhead in health monitoring scenarios.
	// **Use case:** Service mesh health checks, Kubernetes readiness probes.
	//
	// POST /health/batch
	WebrtcSignalingBatchHealthCheck(ctx context.Context, request *WebrtcSignalingBatchHealthCheckReq) (WebrtcSignalingBatchHealthCheckRes, error)
	// WebrtcSignalingHealthCheck invokes webrtcSignalingHealthCheck operation.
	//
	// **Enterprise-grade health check endpoint**
	// Provides real-time health status of the example domain microservice.
	// Critical for service discovery, load balancing, and monitoring.
	// **Performance:** <1ms response time, cached for 30 seconds.
	//
	// GET /health
	WebrtcSignalingHealthCheck(ctx context.Context, params WebrtcSignalingHealthCheckParams) (WebrtcSignalingHealthCheckRes, error)
	// WebrtcSignalingHealthWebSocket invokes webrtcSignalingHealthWebSocket operation.
	//
	// **Performance optimization:** Real-time health updates without polling
	// Eliminates periodic HTTP requests, reduces server load by ~90%.
	// Perfect for dashboard monitoring and alerting systems.
	// **Protocol:** WebSocket with JSON payloads
	// **Heartbeat:** 30 second intervals
	// **Reconnection:** Automatic with exponential backoff.
	//
	// GET /health/ws
	WebrtcSignalingHealthWebSocket(ctx context.Context, params WebrtcSignalingHealthWebSocketParams) (WebrtcSignalingHealthWebSocketRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}
type errorHandler interface {
	NewError(ctx context.Context, err error) *ErrorStatusCode
}

var _ Handler = struct {
	errorHandler
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateGuildVoiceChannel invokes createGuildVoiceChannel operation.
//
// **Guild System Integration: Create voice channel for guild**
// Creates a new voice channel specifically for guild communication. Integrates with guild permission
// system and member management.
// **Guild Integration:** - Validates guild membership and permissions - Applies guild-specific voice
// channel settings - Supports role-based access control
// **Performance:** <50ms channel creation with permission validation.
//
// POST /guilds/{guild_id}/voice-channels
func (c *Client) CreateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelRequest, params CreateGuildVoiceChannelParams) (CreateGuildVoiceChannelRes, error) {
	res, err := c.sendCreateGuildVoiceChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelRequest, params CreateGuildVoiceChannelParams) (res CreateGuildVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createGuildVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/guilds/{guild_id}/voice-channels"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateGuildVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/guilds/"
	{
		// Encode "guild_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guild_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGuildVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CreateGuildVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateGuildVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoiceChannel invokes createVoiceChannel operation.
//
// **Enterprise-grade voice channel creation endpoint**
// Creates guild parties, private rooms, or global voice channels with permission validation.
// Supports automatic STUN/TURN server allocation and quality monitoring setup.
// **Performance:** <50ms P95, includes validation and business logic.
//
// POST /voice-channels
func (c *Client) CreateVoiceChannel(ctx context.Context, request *CreateVoiceChannelReq) (CreateVoiceChannelRes, error) {
	res, err := c.sendCreateVoiceChannel(ctx, request)
	return res, err
}

func (c *Client) sendCreateVoiceChannel(ctx context.Context, request *CreateVoiceChannelReq) (res CreateVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/voice-channels"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/voice-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, CreateVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVoiceChannel invokes deleteVoiceChannel operation.
//
// **Enterprise-grade deletion endpoint**
// Supports soft deletes with audit trails and cleanup scheduling.
// Ensures referential integrity and cascading deletes.
// **Performance:** <15ms P95, includes cleanup operations.
//
// DELETE /voice-channels/{channel_id}
func (c *Client) DeleteVoiceChannel(ctx context.Context, params DeleteVoiceChannelParams) (DeleteVoiceChannelRes, error) {
	res, err := c.sendDeleteVoiceChannel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVoiceChannel(ctx context.Context, params DeleteVoiceChannelParams) (res DeleteVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, DeleteVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExchangeSignalingMessage invokes exchangeSignalingMessage operation.
//
// **Core WebRTC signaling endpoint for offer/answer/ICE exchange**
// Handles SDP offers, answers, and ICE candidates between peers.
// Validates signaling messages and enforces anti-cheat measures.
// **Performance:** <10ms P99 signaling message processing.
//
// POST /voice-channels/{channel_id}/signal
func (c *Client) ExchangeSignalingMessage(ctx context.Context, request *SignalingMessage, params ExchangeSignalingMessageParams) (ExchangeSignalingMessageRes, error) {
	res, err := c.sendExchangeSignalingMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendExchangeSignalingMessage(ctx context.Context, request *SignalingMessage, params ExchangeSignalingMessageParams) (res ExchangeSignalingMessageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exchangeSignalingMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}/signal"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExchangeSignalingMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/signal"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExchangeSignalingMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ExchangeSignalingMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExchangeSignalingMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoiceChannel invokes getVoiceChannel operation.
//
// **Enterprise-grade voice channel retrieval endpoint**
// Returns channel details, active participants, and connection quality metrics.
// Supports real-time updates via WebSocket for participant changes.
// **Performance:** <15ms P95 with participant count caching.
//
// GET /voice-channels/{channel_id}
func (c *Client) GetVoiceChannel(ctx context.Context, params GetVoiceChannelParams) (GetVoiceChannelRes, error) {
	res, err := c.sendGetVoiceChannel(ctx, params)
	return res, err
}

func (c *Client) sendGetVoiceChannel(ctx context.Context, params GetVoiceChannelParams) (res GetVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "include_related" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_related",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeRelated.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-None-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfNoneMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Modified-Since",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfModifiedSince.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, GetVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// JoinGuildVoiceChannel invokes joinGuildVoiceChannel operation.
//
// **Guild System Integration: Join guild voice channel**
// Connects user to guild voice channel with permission validation. Handles channel capacity limits
// and access control.
// **Integration Features:** - Guild membership verification - Role-based access control - Channel
// capacity management - Anti-cheat validation
// **Performance:** <25ms join with permission checks.
//
// POST /guilds/{guild_id}/voice-channels/{channel_id}/join
func (c *Client) JoinGuildVoiceChannel(ctx context.Context, request *JoinVoiceChannelRequest, params JoinGuildVoiceChannelParams) (JoinGuildVoiceChannelRes, error) {
	res, err := c.sendJoinGuildVoiceChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendJoinGuildVoiceChannel(ctx context.Context, request *JoinVoiceChannelRequest, params JoinGuildVoiceChannelParams) (res JoinGuildVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("joinGuildVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/guilds/{guild_id}/voice-channels/{channel_id}/join"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, JoinGuildVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/guilds/"
	{
		// Encode "guild_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guild_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/join"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeJoinGuildVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, JoinGuildVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeJoinGuildVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// JoinVoiceChannel invokes joinVoiceChannel operation.
//
// **Real-time voice channel join with WebRTC handshake**
// Initiates WebRTC peer connection establishment with signaling protocol.
// Returns STUN/TURN server credentials and channel participant list.
// **Performance:** <100ms average connection establishment.
//
// POST /voice-channels/{channel_id}/join
func (c *Client) JoinVoiceChannel(ctx context.Context, request *JoinChannelRequest, params JoinVoiceChannelParams) (JoinVoiceChannelRes, error) {
	res, err := c.sendJoinVoiceChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendJoinVoiceChannel(ctx context.Context, request *JoinChannelRequest, params JoinVoiceChannelParams) (res JoinVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("joinVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}/join"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, JoinVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/join"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeJoinVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, JoinVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeJoinVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveVoiceChannel invokes leaveVoiceChannel operation.
//
// **Clean voice channel disconnection**
// Removes participant from voice channel and cleans up signaling state.
// Updates channel participant count and notifies remaining peers.
// **Performance:** <25ms disconnection processing.
//
// POST /voice-channels/{channel_id}/leave
func (c *Client) LeaveVoiceChannel(ctx context.Context, params LeaveVoiceChannelParams) (LeaveVoiceChannelRes, error) {
	res, err := c.sendLeaveVoiceChannel(ctx, params)
	return res, err
}

func (c *Client) sendLeaveVoiceChannel(ctx context.Context, params LeaveVoiceChannelParams) (res LeaveVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("leaveVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}/leave"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeaveVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/leave"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, LeaveVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeaveVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGuildVoiceChannels invokes listGuildVoiceChannels operation.
//
// **Guild System Integration: List all voice channels for guild**
// Retrieves all active voice channels belonging to a specific guild. Includes channel status,
// participant counts, and permissions.
// **Performance:** <20ms query with Redis caching for active channels.
//
// GET /guilds/{guild_id}/voice-channels
func (c *Client) ListGuildVoiceChannels(ctx context.Context, params ListGuildVoiceChannelsParams) (ListGuildVoiceChannelsRes, error) {
	res, err := c.sendListGuildVoiceChannels(ctx, params)
	return res, err
}

func (c *Client) sendListGuildVoiceChannels(ctx context.Context, params ListGuildVoiceChannelsParams) (res ListGuildVoiceChannelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listGuildVoiceChannels"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/guilds/{guild_id}/voice-channels"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListGuildVoiceChannelsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/guilds/"
	{
		// Encode "guild_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guild_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ListGuildVoiceChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListGuildVoiceChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVoiceChannels invokes listVoiceChannels operation.
//
// **Enterprise-grade voice channel listing endpoint**
// Supports filtering by type (guild/party/global), status, and participant count.
// Optimized for real-time voice channel discovery and management.
// **Performance:** <25ms P95, supports 5000+ concurrent voice sessions.
//
// GET /voice-channels
func (c *Client) ListVoiceChannels(ctx context.Context, params ListVoiceChannelsParams) (ListVoiceChannelsRes, error) {
	res, err := c.sendListVoiceChannels(ctx, params)
	return res, err
}

func (c *Client) sendListVoiceChannels(ctx context.Context, params ListVoiceChannelsParams) (res ListVoiceChannelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listVoiceChannels"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/voice-channels"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListVoiceChannelsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/voice-channels"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOrder.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ListVoiceChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListVoiceChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReportVoiceQuality invokes reportVoiceQuality operation.
//
// **Real-time voice quality monitoring and optimization**
// Collects latency, packet loss, and audio quality metrics from clients.
// Enables adaptive bitrate adjustment and quality optimization.
// **Performance:** <5ms metrics processing with batch aggregation.
//
// POST /voice-quality/{channel_id}/report
func (c *Client) ReportVoiceQuality(ctx context.Context, request *VoiceQualityReport, params ReportVoiceQualityParams) (ReportVoiceQualityRes, error) {
	res, err := c.sendReportVoiceQuality(ctx, request, params)
	return res, err
}

func (c *Client) sendReportVoiceQuality(ctx context.Context, request *VoiceQualityReport, params ReportVoiceQualityParams) (res ReportVoiceQualityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reportVoiceQuality"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/voice-quality/{channel_id}/report"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReportVoiceQualityOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/voice-quality/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/report"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReportVoiceQualityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, ReportVoiceQualityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReportVoiceQualityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGuildVoiceChannel invokes updateGuildVoiceChannel operation.
//
// **Guild System Integration: Update guild voice channel settings**
// Modifies voice channel configuration including permissions, user limits, and moderation settings.
// Requires appropriate guild permissions.
// **Permission Checks:** - Channel owner or guild leader/officer - Validates permission hierarchy
// **Performance:** <30ms update with permission validation.
//
// PUT /guilds/{guild_id}/voice-channels/{channel_id}
func (c *Client) UpdateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelUpdateRequest, params UpdateGuildVoiceChannelParams) (UpdateGuildVoiceChannelRes, error) {
	res, err := c.sendUpdateGuildVoiceChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateGuildVoiceChannel(ctx context.Context, request *GuildVoiceChannelUpdateRequest, params UpdateGuildVoiceChannelParams) (res UpdateGuildVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateGuildVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/guilds/{guild_id}/voice-channels/{channel_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateGuildVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/guilds/"
	{
		// Encode "guild_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "guild_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GuildID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateGuildVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, UpdateGuildVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateGuildVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVoiceChannel invokes updateVoiceChannel operation.
//
// **Enterprise-grade update endpoint**
// Supports partial updates, optimistic locking, and audit trails.
// Ensures data consistency with event sourcing patterns.
// **Performance:** <25ms P95, includes validation and conflict resolution.
//
// PUT /voice-channels/{channel_id}
func (c *Client) UpdateVoiceChannel(ctx context.Context, request *UpdateExampleRequest, params UpdateVoiceChannelParams) (UpdateVoiceChannelRes, error) {
	res, err := c.sendUpdateVoiceChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVoiceChannel(ctx context.Context, request *UpdateExampleRequest, params UpdateVoiceChannelParams) (res UpdateVoiceChannelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateVoiceChannel"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/voice-channels/{channel_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateVoiceChannelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/voice-channels/"
	{
		// Encode "channel_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVoiceChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Match",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "If-Unmodified-Since",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IfUnmodifiedSince.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, UpdateVoiceChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateVoiceChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSignalingBatchHealthCheck invokes webrtcSignalingBatchHealthCheck operation.
//
// **Performance optimization:** Check multiple domain health in single request
// Reduces N HTTP calls to 1 call. Critical for microservice orchestration.
// Eliminates network overhead in health monitoring scenarios.
// **Use case:** Service mesh health checks, Kubernetes readiness probes.
//
// POST /health/batch
func (c *Client) WebrtcSignalingBatchHealthCheck(ctx context.Context, request *WebrtcSignalingBatchHealthCheckReq) (WebrtcSignalingBatchHealthCheckRes, error) {
	res, err := c.sendWebrtcSignalingBatchHealthCheck(ctx, request)
	return res, err
}

func (c *Client) sendWebrtcSignalingBatchHealthCheck(ctx context.Context, request *WebrtcSignalingBatchHealthCheckReq) (res WebrtcSignalingBatchHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("webrtcSignalingBatchHealthCheck"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/health/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, WebrtcSignalingBatchHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWebrtcSignalingBatchHealthCheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, WebrtcSignalingBatchHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebrtcSignalingBatchHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSignalingHealthCheck invokes webrtcSignalingHealthCheck operation.
//
// **Enterprise-grade health check endpoint**
// Provides real-time health status of the example domain microservice.
// Critical for service discovery, load balancing, and monitoring.
// **Performance:** <1ms response time, cached for 30 seconds.
//
// GET /health
func (c *Client) WebrtcSignalingHealthCheck(ctx context.Context, params WebrtcSignalingHealthCheckParams) (WebrtcSignalingHealthCheckRes, error) {
	res, err := c.sendWebrtcSignalingHealthCheck(ctx, params)
	return res, err
}

func (c *Client) sendWebrtcSignalingHealthCheck(ctx context.Context, params WebrtcSignalingHealthCheckParams) (res WebrtcSignalingHealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("webrtcSignalingHealthCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, WebrtcSignalingHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AcceptEncoding.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, WebrtcSignalingHealthCheckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebrtcSignalingHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSignalingHealthWebSocket invokes webrtcSignalingHealthWebSocket operation.
//
// **Performance optimization:** Real-time health updates without polling
// Eliminates periodic HTTP requests, reduces server load by ~90%.
// Perfect for dashboard monitoring and alerting systems.
// **Protocol:** WebSocket with JSON payloads
// **Heartbeat:** 30 second intervals
// **Reconnection:** Automatic with exponential backoff.
//
// GET /health/ws
func (c *Client) WebrtcSignalingHealthWebSocket(ctx context.Context, params WebrtcSignalingHealthWebSocketParams) (WebrtcSignalingHealthWebSocketRes, error) {
	res, err := c.sendWebrtcSignalingHealthWebSocket(ctx, params)
	return res, err
}

func (c *Client) sendWebrtcSignalingHealthWebSocket(ctx context.Context, params WebrtcSignalingHealthWebSocketParams) (res WebrtcSignalingHealthWebSocketRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("webrtcSignalingHealthWebSocket"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/ws"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, WebrtcSignalingHealthWebSocketOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/ws"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "services" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "services",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Services != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Services {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BearerAuth"
			switch err := c.securityBearerAuth(ctx, WebrtcSignalingHealthWebSocketOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebrtcSignalingHealthWebSocketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
