// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *City) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *City) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("city_id")
		e.Str(s.CityID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NameLocal.Set {
			e.FieldStart("name_local")
			s.NameLocal.Encode(e)
		}
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		e.FieldStart("continent")
		e.Str(s.Continent)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("cyberpunk_level")
		e.Int(s.CyberpunkLevel)
	}
	{
		if s.Population2020.Set {
			e.FieldStart("population_2020")
			s.Population2020.Encode(e)
		}
	}
	{
		if s.IsMegacity.Set {
			e.FieldStart("is_megacity")
			s.IsMegacity.Encode(e)
		}
	}
	{
		if s.IsCapital.Set {
			e.FieldStart("is_capital")
			s.IsCapital.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Population2050.Set {
			e.FieldStart("population_2050")
			s.Population2050.Encode(e)
		}
	}
	{
		if s.Population2093.Set {
			e.FieldStart("population_2093")
			s.Population2093.Encode(e)
		}
	}
	{
		if s.AreaKm2.Set {
			e.FieldStart("area_km2")
			s.AreaKm2.Encode(e)
		}
	}
	{
		if s.ElevationM.Set {
			e.FieldStart("elevation_m")
			s.ElevationM.Encode(e)
		}
	}
	{
		if s.CorruptionIndex.Set {
			e.FieldStart("corruption_index")
			s.CorruptionIndex.Encode(e)
		}
	}
	{
		if s.TechnologyIndex.Set {
			e.FieldStart("technology_index")
			s.TechnologyIndex.Encode(e)
		}
	}
	{
		if s.Zones.Set {
			e.FieldStart("zones")
			s.Zones.Encode(e)
		}
	}
	{
		if s.Districts.Set {
			e.FieldStart("districts")
			s.Districts.Encode(e)
		}
	}
	{
		if s.Landmarks.Set {
			e.FieldStart("landmarks")
			s.Landmarks.Encode(e)
		}
	}
	{
		if s.EconomyData.Set {
			e.FieldStart("economy_data")
			s.EconomyData.Encode(e)
		}
	}
	{
		if s.CorporationPresence.Set {
			e.FieldStart("corporation_presence")
			s.CorporationPresence.Encode(e)
		}
	}
	{
		if s.FactionInfluence.Set {
			e.FieldStart("faction_influence")
			s.FactionInfluence.Encode(e)
		}
	}
	{
		if s.TimelineEvents.Set {
			e.FieldStart("timeline_events")
			s.TimelineEvents.Encode(e)
		}
	}
	{
		if s.FutureEvolution.Set {
			e.FieldStart("future_evolution")
			s.FutureEvolution.Encode(e)
		}
	}
	{
		if s.AvailableInGame.Set {
			e.FieldStart("available_in_game")
			s.AvailableInGame.Encode(e)
		}
	}
	{
		if s.GameRegions.Set {
			e.FieldStart("game_regions")
			s.GameRegions.Encode(e)
		}
	}
	{
		if s.SourceFile.Set {
			e.FieldStart("source_file")
			s.SourceFile.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfCity = [33]string{
	0:  "id",
	1:  "city_id",
	2:  "name",
	3:  "name_local",
	4:  "country",
	5:  "continent",
	6:  "latitude",
	7:  "longitude",
	8:  "cyberpunk_level",
	9:  "population_2020",
	10: "is_megacity",
	11: "is_capital",
	12: "status",
	13: "created_at",
	14: "updated_at",
	15: "population_2050",
	16: "population_2093",
	17: "area_km2",
	18: "elevation_m",
	19: "corruption_index",
	20: "technology_index",
	21: "zones",
	22: "districts",
	23: "landmarks",
	24: "economy_data",
	25: "corporation_presence",
	26: "faction_influence",
	27: "timeline_events",
	28: "future_evolution",
	29: "available_in_game",
	30: "game_regions",
	31: "source_file",
	32: "version",
}

// Decode decodes City from json.
func (s *City) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode City to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "city_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CityID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_local":
			if err := func() error {
				s.NameLocal.Reset()
				if err := s.NameLocal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_local\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "continent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Continent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "cyberpunk_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CyberpunkLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpunk_level\"")
			}
		case "population_2020":
			if err := func() error {
				s.Population2020.Reset()
				if err := s.Population2020.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2020\"")
			}
		case "is_megacity":
			if err := func() error {
				s.IsMegacity.Reset()
				if err := s.IsMegacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_megacity\"")
			}
		case "is_capital":
			if err := func() error {
				s.IsCapital.Reset()
				if err := s.IsCapital.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_capital\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "population_2050":
			if err := func() error {
				s.Population2050.Reset()
				if err := s.Population2050.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2050\"")
			}
		case "population_2093":
			if err := func() error {
				s.Population2093.Reset()
				if err := s.Population2093.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2093\"")
			}
		case "area_km2":
			if err := func() error {
				s.AreaKm2.Reset()
				if err := s.AreaKm2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"area_km2\"")
			}
		case "elevation_m":
			if err := func() error {
				s.ElevationM.Reset()
				if err := s.ElevationM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elevation_m\"")
			}
		case "corruption_index":
			if err := func() error {
				s.CorruptionIndex.Reset()
				if err := s.CorruptionIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corruption_index\"")
			}
		case "technology_index":
			if err := func() error {
				s.TechnologyIndex.Reset()
				if err := s.TechnologyIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"technology_index\"")
			}
		case "zones":
			if err := func() error {
				s.Zones.Reset()
				if err := s.Zones.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		case "districts":
			if err := func() error {
				s.Districts.Reset()
				if err := s.Districts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"districts\"")
			}
		case "landmarks":
			if err := func() error {
				s.Landmarks.Reset()
				if err := s.Landmarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"landmarks\"")
			}
		case "economy_data":
			if err := func() error {
				s.EconomyData.Reset()
				if err := s.EconomyData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"economy_data\"")
			}
		case "corporation_presence":
			if err := func() error {
				s.CorporationPresence.Reset()
				if err := s.CorporationPresence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corporation_presence\"")
			}
		case "faction_influence":
			if err := func() error {
				s.FactionInfluence.Reset()
				if err := s.FactionInfluence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_influence\"")
			}
		case "timeline_events":
			if err := func() error {
				s.TimelineEvents.Reset()
				if err := s.TimelineEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_events\"")
			}
		case "future_evolution":
			if err := func() error {
				s.FutureEvolution.Reset()
				if err := s.FutureEvolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"future_evolution\"")
			}
		case "available_in_game":
			if err := func() error {
				s.AvailableInGame.Reset()
				if err := s.AvailableInGame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_in_game\"")
			}
		case "game_regions":
			if err := func() error {
				s.GameRegions.Reset()
				if err := s.GameRegions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_regions\"")
			}
		case "source_file":
			if err := func() error {
				s.SourceFile.Reset()
				if err := s.SourceFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_file\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode City")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11110111,
		0b00010001,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCity) {
					name = jsonFieldsNameOfCity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *City) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *City) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityAnalytics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityAnalytics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Filters.Set {
			e.FieldStart("filters")
			s.Filters.Encode(e)
		}
	}
	{
		if s.GeneratedAt.Set {
			e.FieldStart("generated_at")
			s.GeneratedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCityAnalytics = [4]string{
	0: "metric",
	1: "data",
	2: "filters",
	3: "generated_at",
}

// Decode decodes CityAnalytics from json.
func (s *CityAnalytics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityAnalytics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "filters":
			if err := func() error {
				s.Filters.Reset()
				if err := s.Filters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters\"")
			}
		case "generated_at":
			if err := func() error {
				s.GeneratedAt.Reset()
				if err := s.GeneratedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityAnalytics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCityAnalytics) {
					name = jsonFieldsNameOfCityAnalytics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityAnalytics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityAnalytics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityAnalyticsData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityAnalyticsData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CityAnalyticsData from json.
func (s *CityAnalyticsData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityAnalyticsData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityAnalyticsData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityAnalyticsData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityAnalyticsData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityAnalyticsFilters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityAnalyticsFilters) encodeFields(e *jx.Encoder) {
	{
		if s.Continent.Set {
			e.FieldStart("continent")
			s.Continent.Encode(e)
		}
	}
	{
		if s.Year.Set {
			e.FieldStart("year")
			s.Year.Encode(e)
		}
	}
}

var jsonFieldsNameOfCityAnalyticsFilters = [2]string{
	0: "continent",
	1: "year",
}

// Decode decodes CityAnalyticsFilters from json.
func (s *CityAnalyticsFilters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityAnalyticsFilters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continent":
			if err := func() error {
				s.Continent.Reset()
				if err := s.Continent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent\"")
			}
		case "year":
			if err := func() error {
				s.Year.Reset()
				if err := s.Year.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"year\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityAnalyticsFilters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityAnalyticsFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityAnalyticsFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityAnalyticsMetric as json.
func (s CityAnalyticsMetric) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityAnalyticsMetric from json.
func (s *CityAnalyticsMetric) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityAnalyticsMetric to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityAnalyticsMetric(v) {
	case CityAnalyticsMetricPopulationTrends:
		*s = CityAnalyticsMetricPopulationTrends
	case CityAnalyticsMetricCyberpunkDistribution:
		*s = CityAnalyticsMetricCyberpunkDistribution
	case CityAnalyticsMetricEconomicIndicators:
		*s = CityAnalyticsMetricEconomicIndicators
	case CityAnalyticsMetricFactionInfluence:
		*s = CityAnalyticsMetricFactionInfluence
	case CityAnalyticsMetricCorporationPresence:
		*s = CityAnalyticsMetricCorporationPresence
	default:
		*s = CityAnalyticsMetric(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityAnalyticsMetric) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityAnalyticsMetric) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityCorporationPresence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityCorporationPresence) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes CityCorporationPresence from json.
func (s *CityCorporationPresence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCorporationPresence to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityCorporationPresence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityCorporationPresence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCorporationPresence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("city_id")
		e.Str(s.CityID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NameLocal.Set {
			e.FieldStart("name_local")
			s.NameLocal.Encode(e)
		}
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		e.FieldStart("continent")
		s.Continent.Encode(e)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.Population2020.Set {
			e.FieldStart("population_2020")
			s.Population2020.Encode(e)
		}
	}
	{
		if s.Population2050.Set {
			e.FieldStart("population_2050")
			s.Population2050.Encode(e)
		}
	}
	{
		if s.Population2093.Set {
			e.FieldStart("population_2093")
			s.Population2093.Encode(e)
		}
	}
	{
		if s.AreaKm2.Set {
			e.FieldStart("area_km2")
			s.AreaKm2.Encode(e)
		}
	}
	{
		if s.ElevationM.Set {
			e.FieldStart("elevation_m")
			s.ElevationM.Encode(e)
		}
	}
	{
		if s.CyberpunkLevel.Set {
			e.FieldStart("cyberpunk_level")
			s.CyberpunkLevel.Encode(e)
		}
	}
	{
		if s.CorruptionIndex.Set {
			e.FieldStart("corruption_index")
			s.CorruptionIndex.Encode(e)
		}
	}
	{
		if s.TechnologyIndex.Set {
			e.FieldStart("technology_index")
			s.TechnologyIndex.Encode(e)
		}
	}
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Districts != nil {
			e.FieldStart("districts")
			s.Districts.Encode(e)
		}
	}
	{
		if s.Landmarks != nil {
			e.FieldStart("landmarks")
			e.ArrStart()
			for _, elem := range s.Landmarks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EconomyData != nil {
			e.FieldStart("economy_data")
			s.EconomyData.Encode(e)
		}
	}
	{
		if s.CorporationPresence != nil {
			e.FieldStart("corporation_presence")
			s.CorporationPresence.Encode(e)
		}
	}
	{
		if s.FactionInfluence != nil {
			e.FieldStart("faction_influence")
			s.FactionInfluence.Encode(e)
		}
	}
	{
		if s.TimelineEvents != nil {
			e.FieldStart("timeline_events")
			s.TimelineEvents.Encode(e)
		}
	}
	{
		if s.FutureEvolution != nil {
			e.FieldStart("future_evolution")
			s.FutureEvolution.Encode(e)
		}
	}
	{
		if s.IsCapital.Set {
			e.FieldStart("is_capital")
			s.IsCapital.Encode(e)
		}
	}
	{
		if s.IsMegacity.Set {
			e.FieldStart("is_megacity")
			s.IsMegacity.Encode(e)
		}
	}
	{
		if s.AvailableInGame.Set {
			e.FieldStart("available_in_game")
			s.AvailableInGame.Encode(e)
		}
	}
	{
		if s.GameRegions != nil {
			e.FieldStart("game_regions")
			e.ArrStart()
			for _, elem := range s.GameRegions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SourceFile.Set {
			e.FieldStart("source_file")
			s.SourceFile.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfCityCreate = [29]string{
	0:  "city_id",
	1:  "name",
	2:  "name_local",
	3:  "country",
	4:  "continent",
	5:  "latitude",
	6:  "longitude",
	7:  "population_2020",
	8:  "population_2050",
	9:  "population_2093",
	10: "area_km2",
	11: "elevation_m",
	12: "cyberpunk_level",
	13: "corruption_index",
	14: "technology_index",
	15: "zones",
	16: "districts",
	17: "landmarks",
	18: "economy_data",
	19: "corporation_presence",
	20: "faction_influence",
	21: "timeline_events",
	22: "future_evolution",
	23: "is_capital",
	24: "is_megacity",
	25: "available_in_game",
	26: "game_regions",
	27: "source_file",
	28: "version",
}

// Decode decodes CityCreate from json.
func (s *CityCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreate to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "city_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CityID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_local":
			if err := func() error {
				s.NameLocal.Reset()
				if err := s.NameLocal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_local\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "continent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Continent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "population_2020":
			if err := func() error {
				s.Population2020.Reset()
				if err := s.Population2020.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2020\"")
			}
		case "population_2050":
			if err := func() error {
				s.Population2050.Reset()
				if err := s.Population2050.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2050\"")
			}
		case "population_2093":
			if err := func() error {
				s.Population2093.Reset()
				if err := s.Population2093.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2093\"")
			}
		case "area_km2":
			if err := func() error {
				s.AreaKm2.Reset()
				if err := s.AreaKm2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"area_km2\"")
			}
		case "elevation_m":
			if err := func() error {
				s.ElevationM.Reset()
				if err := s.ElevationM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elevation_m\"")
			}
		case "cyberpunk_level":
			if err := func() error {
				s.CyberpunkLevel.Reset()
				if err := s.CyberpunkLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpunk_level\"")
			}
		case "corruption_index":
			if err := func() error {
				s.CorruptionIndex.Reset()
				if err := s.CorruptionIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corruption_index\"")
			}
		case "technology_index":
			if err := func() error {
				s.TechnologyIndex.Reset()
				if err := s.TechnologyIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"technology_index\"")
			}
		case "zones":
			if err := func() error {
				s.Zones = make([]CityCreateZonesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CityCreateZonesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		case "districts":
			if err := func() error {
				s.Districts = nil
				var elem CityCreateDistricts
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Districts = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"districts\"")
			}
		case "landmarks":
			if err := func() error {
				s.Landmarks = make([]CityCreateLandmarksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CityCreateLandmarksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Landmarks = append(s.Landmarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"landmarks\"")
			}
		case "economy_data":
			if err := func() error {
				s.EconomyData = nil
				var elem CityCreateEconomyData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EconomyData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"economy_data\"")
			}
		case "corporation_presence":
			if err := func() error {
				s.CorporationPresence = nil
				var elem CityCreateCorporationPresence
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CorporationPresence = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corporation_presence\"")
			}
		case "faction_influence":
			if err := func() error {
				s.FactionInfluence = nil
				var elem CityCreateFactionInfluence
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FactionInfluence = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_influence\"")
			}
		case "timeline_events":
			if err := func() error {
				s.TimelineEvents = nil
				var elem CityCreateTimelineEvents
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TimelineEvents = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_events\"")
			}
		case "future_evolution":
			if err := func() error {
				s.FutureEvolution = nil
				var elem CityCreateFutureEvolution
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FutureEvolution = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"future_evolution\"")
			}
		case "is_capital":
			if err := func() error {
				s.IsCapital.Reset()
				if err := s.IsCapital.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_capital\"")
			}
		case "is_megacity":
			if err := func() error {
				s.IsMegacity.Reset()
				if err := s.IsMegacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_megacity\"")
			}
		case "available_in_game":
			if err := func() error {
				s.AvailableInGame.Reset()
				if err := s.AvailableInGame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_in_game\"")
			}
		case "game_regions":
			if err := func() error {
				s.GameRegions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameRegions = append(s.GameRegions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_regions\"")
			}
		case "source_file":
			if err := func() error {
				s.SourceFile.Reset()
				if err := s.SourceFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_file\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01111011,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCityCreate) {
					name = jsonFieldsNameOfCityCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityCreateContinent as json.
func (s CityCreateContinent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityCreateContinent from json.
func (s *CityCreateContinent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateContinent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityCreateContinent(v) {
	case CityCreateContinentAfrica:
		*s = CityCreateContinentAfrica
	case CityCreateContinentAsia:
		*s = CityCreateContinentAsia
	case CityCreateContinentEurope:
		*s = CityCreateContinentEurope
	case CityCreateContinentNorthAmerica:
		*s = CityCreateContinentNorthAmerica
	case CityCreateContinentSouthAmerica:
		*s = CityCreateContinentSouthAmerica
	case CityCreateContinentOceania:
		*s = CityCreateContinentOceania
	default:
		*s = CityCreateContinent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityCreateContinent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateContinent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateCorporationPresence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateCorporationPresence) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateCorporationPresence = [0]string{}

// Decode decodes CityCreateCorporationPresence from json.
func (s *CityCreateCorporationPresence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateCorporationPresence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateCorporationPresence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateCorporationPresence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateCorporationPresence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateDistricts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateDistricts) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateDistricts = [0]string{}

// Decode decodes CityCreateDistricts from json.
func (s *CityCreateDistricts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateDistricts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateDistricts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateDistricts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateDistricts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateEconomyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateEconomyData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateEconomyData = [0]string{}

// Decode decodes CityCreateEconomyData from json.
func (s *CityCreateEconomyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateEconomyData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateEconomyData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateEconomyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateEconomyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateFactionInfluence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateFactionInfluence) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateFactionInfluence = [0]string{}

// Decode decodes CityCreateFactionInfluence from json.
func (s *CityCreateFactionInfluence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateFactionInfluence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateFactionInfluence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateFactionInfluence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateFactionInfluence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateFutureEvolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateFutureEvolution) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateFutureEvolution = [0]string{}

// Decode decodes CityCreateFutureEvolution from json.
func (s *CityCreateFutureEvolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateFutureEvolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateFutureEvolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateFutureEvolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateFutureEvolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateLandmarksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateLandmarksItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateLandmarksItem = [0]string{}

// Decode decodes CityCreateLandmarksItem from json.
func (s *CityCreateLandmarksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateLandmarksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateLandmarksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateLandmarksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateLandmarksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateTimelineEvents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateTimelineEvents) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateTimelineEvents = [0]string{}

// Decode decodes CityCreateTimelineEvents from json.
func (s *CityCreateTimelineEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateTimelineEvents to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateTimelineEvents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateTimelineEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateTimelineEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateZonesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateZonesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Coordinates != nil {
			e.FieldStart("coordinates")
			s.Coordinates.Encode(e)
		}
	}
}

var jsonFieldsNameOfCityCreateZonesItem = [3]string{
	0: "name",
	1: "type",
	2: "coordinates",
}

// Decode decodes CityCreateZonesItem from json.
func (s *CityCreateZonesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateZonesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "coordinates":
			if err := func() error {
				s.Coordinates = nil
				var elem CityCreateZonesItemCoordinates
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Coordinates = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coordinates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateZonesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCityCreateZonesItem) {
					name = jsonFieldsNameOfCityCreateZonesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateZonesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateZonesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityCreateZonesItemCoordinates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityCreateZonesItemCoordinates) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityCreateZonesItemCoordinates = [0]string{}

// Decode decodes CityCreateZonesItemCoordinates from json.
func (s *CityCreateZonesItemCoordinates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateZonesItemCoordinates to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityCreateZonesItemCoordinates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityCreateZonesItemCoordinates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateZonesItemCoordinates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityCreateZonesItemType as json.
func (s CityCreateZonesItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityCreateZonesItemType from json.
func (s *CityCreateZonesItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityCreateZonesItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityCreateZonesItemType(v) {
	case CityCreateZonesItemTypeCommercial:
		*s = CityCreateZonesItemTypeCommercial
	case CityCreateZonesItemTypeResidential:
		*s = CityCreateZonesItemTypeResidential
	case CityCreateZonesItemTypeIndustrial:
		*s = CityCreateZonesItemTypeIndustrial
	case CityCreateZonesItemTypeCorporate:
		*s = CityCreateZonesItemTypeCorporate
	case CityCreateZonesItemTypeEntertainment:
		*s = CityCreateZonesItemTypeEntertainment
	case CityCreateZonesItemTypeGovernment:
		*s = CityCreateZonesItemTypeGovernment
	case CityCreateZonesItemTypeMilitary:
		*s = CityCreateZonesItemTypeMilitary
	case CityCreateZonesItemTypeSlums:
		*s = CityCreateZonesItemTypeSlums
	default:
		*s = CityCreateZonesItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityCreateZonesItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityCreateZonesItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityDistricts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityDistricts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CityDistricts from json.
func (s *CityDistricts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityDistricts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityDistricts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityDistricts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityDistricts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityEconomyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityEconomyData) encodeFields(e *jx.Encoder) {
	{
		if s.Gdp2020.Set {
			e.FieldStart("gdp_2020")
			s.Gdp2020.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Industries != nil {
			e.FieldStart("industries")
			e.ArrStart()
			for _, elem := range s.Industries {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCityEconomyData = [3]string{
	0: "gdp_2020",
	1: "currency",
	2: "industries",
}

// Decode decodes CityEconomyData from json.
func (s *CityEconomyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityEconomyData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gdp_2020":
			if err := func() error {
				s.Gdp2020.Reset()
				if err := s.Gdp2020.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gdp_2020\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "industries":
			if err := func() error {
				s.Industries = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Industries = append(s.Industries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"industries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityEconomyData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityEconomyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityEconomyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityFactionInfluence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityFactionInfluence) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes CityFactionInfluence from json.
func (s *CityFactionInfluence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityFactionInfluence to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityFactionInfluence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityFactionInfluence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityFactionInfluence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityFutureEvolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityFutureEvolution) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CityFutureEvolution from json.
func (s *CityFutureEvolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityFutureEvolution to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityFutureEvolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityFutureEvolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityFutureEvolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityLandmarksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityLandmarksItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Coordinates != nil {
			e.FieldStart("coordinates")
			e.ArrStart()
			for _, elem := range s.Coordinates {
				e.Float64(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCityLandmarksItem = [3]string{
	0: "name",
	1: "type",
	2: "coordinates",
}

// Decode decodes CityLandmarksItem from json.
func (s *CityLandmarksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityLandmarksItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "coordinates":
			if err := func() error {
				s.Coordinates = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.Coordinates = append(s.Coordinates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coordinates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityLandmarksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCityLandmarksItem) {
					name = jsonFieldsNameOfCityLandmarksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityLandmarksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityLandmarksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityLandmarksItemType as json.
func (s CityLandmarksItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityLandmarksItemType from json.
func (s *CityLandmarksItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityLandmarksItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityLandmarksItemType(v) {
	case CityLandmarksItemTypeSkyscraper:
		*s = CityLandmarksItemTypeSkyscraper
	case CityLandmarksItemTypeLandmark:
		*s = CityLandmarksItemTypeLandmark
	case CityLandmarksItemTypeMonument:
		*s = CityLandmarksItemTypeMonument
	case CityLandmarksItemTypeDistrict:
		*s = CityLandmarksItemTypeDistrict
	case CityLandmarksItemTypeBar:
		*s = CityLandmarksItemTypeBar
	case CityLandmarksItemTypeHotel:
		*s = CityLandmarksItemTypeHotel
	case CityLandmarksItemTypeStation:
		*s = CityLandmarksItemTypeStation
	default:
		*s = CityLandmarksItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityLandmarksItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityLandmarksItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityStatus as json.
func (s CityStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityStatus from json.
func (s *CityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityStatus(v) {
	case CityStatusActive:
		*s = CityStatusActive
	case CityStatusDestroyed:
		*s = CityStatusDestroyed
	case CityStatusAbandoned:
		*s = CityStatusAbandoned
	case CityStatusVirtual:
		*s = CityStatusVirtual
	default:
		*s = CityStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CitySummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CitySummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("city_id")
		e.Str(s.CityID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NameLocal.Set {
			e.FieldStart("name_local")
			s.NameLocal.Encode(e)
		}
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		e.FieldStart("continent")
		e.Str(s.Continent)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("cyberpunk_level")
		e.Int(s.CyberpunkLevel)
	}
	{
		if s.Population2020.Set {
			e.FieldStart("population_2020")
			s.Population2020.Encode(e)
		}
	}
	{
		if s.IsMegacity.Set {
			e.FieldStart("is_megacity")
			s.IsMegacity.Encode(e)
		}
	}
	{
		if s.IsCapital.Set {
			e.FieldStart("is_capital")
			s.IsCapital.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCitySummary = [15]string{
	0:  "id",
	1:  "city_id",
	2:  "name",
	3:  "name_local",
	4:  "country",
	5:  "continent",
	6:  "latitude",
	7:  "longitude",
	8:  "cyberpunk_level",
	9:  "population_2020",
	10: "is_megacity",
	11: "is_capital",
	12: "status",
	13: "created_at",
	14: "updated_at",
}

// Decode decodes CitySummary from json.
func (s *CitySummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CitySummary to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "city_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CityID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_local":
			if err := func() error {
				s.NameLocal.Reset()
				if err := s.NameLocal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_local\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "continent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Continent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "cyberpunk_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CyberpunkLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpunk_level\"")
			}
		case "population_2020":
			if err := func() error {
				s.Population2020.Reset()
				if err := s.Population2020.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2020\"")
			}
		case "is_megacity":
			if err := func() error {
				s.IsMegacity.Reset()
				if err := s.IsMegacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_megacity\"")
			}
		case "is_capital":
			if err := func() error {
				s.IsCapital.Reset()
				if err := s.IsCapital.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_capital\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CitySummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCitySummary) {
					name = jsonFieldsNameOfCitySummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CitySummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CitySummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CitySummaryStatus as json.
func (s CitySummaryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CitySummaryStatus from json.
func (s *CitySummaryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CitySummaryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CitySummaryStatus(v) {
	case CitySummaryStatusActive:
		*s = CitySummaryStatusActive
	case CitySummaryStatusDestroyed:
		*s = CitySummaryStatusDestroyed
	case CitySummaryStatusAbandoned:
		*s = CitySummaryStatusAbandoned
	case CitySummaryStatusVirtual:
		*s = CitySummaryStatusVirtual
	default:
		*s = CitySummaryStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CitySummaryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CitySummaryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CityTimelineEvents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CityTimelineEvents) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CityTimelineEvents from json.
func (s *CityTimelineEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityTimelineEvents to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityTimelineEvents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityTimelineEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityTimelineEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NameLocal.Set {
			e.FieldStart("name_local")
			s.NameLocal.Encode(e)
		}
	}
	{
		if s.Population2020.Set {
			e.FieldStart("population_2020")
			s.Population2020.Encode(e)
		}
	}
	{
		if s.Population2050.Set {
			e.FieldStart("population_2050")
			s.Population2050.Encode(e)
		}
	}
	{
		if s.Population2093.Set {
			e.FieldStart("population_2093")
			s.Population2093.Encode(e)
		}
	}
	{
		if s.AreaKm2.Set {
			e.FieldStart("area_km2")
			s.AreaKm2.Encode(e)
		}
	}
	{
		if s.ElevationM.Set {
			e.FieldStart("elevation_m")
			s.ElevationM.Encode(e)
		}
	}
	{
		if s.CyberpunkLevel.Set {
			e.FieldStart("cyberpunk_level")
			s.CyberpunkLevel.Encode(e)
		}
	}
	{
		if s.CorruptionIndex.Set {
			e.FieldStart("corruption_index")
			s.CorruptionIndex.Encode(e)
		}
	}
	{
		if s.TechnologyIndex.Set {
			e.FieldStart("technology_index")
			s.TechnologyIndex.Encode(e)
		}
	}
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Districts != nil {
			e.FieldStart("districts")
			s.Districts.Encode(e)
		}
	}
	{
		if s.Landmarks != nil {
			e.FieldStart("landmarks")
			e.ArrStart()
			for _, elem := range s.Landmarks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EconomyData != nil {
			e.FieldStart("economy_data")
			s.EconomyData.Encode(e)
		}
	}
	{
		if s.CorporationPresence != nil {
			e.FieldStart("corporation_presence")
			s.CorporationPresence.Encode(e)
		}
	}
	{
		if s.FactionInfluence != nil {
			e.FieldStart("faction_influence")
			s.FactionInfluence.Encode(e)
		}
	}
	{
		if s.TimelineEvents != nil {
			e.FieldStart("timeline_events")
			s.TimelineEvents.Encode(e)
		}
	}
	{
		if s.FutureEvolution != nil {
			e.FieldStart("future_evolution")
			s.FutureEvolution.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.IsCapital.Set {
			e.FieldStart("is_capital")
			s.IsCapital.Encode(e)
		}
	}
	{
		if s.IsMegacity.Set {
			e.FieldStart("is_megacity")
			s.IsMegacity.Encode(e)
		}
	}
	{
		if s.AvailableInGame.Set {
			e.FieldStart("available_in_game")
			s.AvailableInGame.Encode(e)
		}
	}
	{
		if s.GameRegions != nil {
			e.FieldStart("game_regions")
			e.ArrStart()
			for _, elem := range s.GameRegions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfCityUpdate = [24]string{
	0:  "name",
	1:  "name_local",
	2:  "population_2020",
	3:  "population_2050",
	4:  "population_2093",
	5:  "area_km2",
	6:  "elevation_m",
	7:  "cyberpunk_level",
	8:  "corruption_index",
	9:  "technology_index",
	10: "zones",
	11: "districts",
	12: "landmarks",
	13: "economy_data",
	14: "corporation_presence",
	15: "faction_influence",
	16: "timeline_events",
	17: "future_evolution",
	18: "status",
	19: "is_capital",
	20: "is_megacity",
	21: "available_in_game",
	22: "game_regions",
	23: "version",
}

// Decode decodes CityUpdate from json.
func (s *CityUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_local":
			if err := func() error {
				s.NameLocal.Reset()
				if err := s.NameLocal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_local\"")
			}
		case "population_2020":
			if err := func() error {
				s.Population2020.Reset()
				if err := s.Population2020.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2020\"")
			}
		case "population_2050":
			if err := func() error {
				s.Population2050.Reset()
				if err := s.Population2050.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2050\"")
			}
		case "population_2093":
			if err := func() error {
				s.Population2093.Reset()
				if err := s.Population2093.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"population_2093\"")
			}
		case "area_km2":
			if err := func() error {
				s.AreaKm2.Reset()
				if err := s.AreaKm2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"area_km2\"")
			}
		case "elevation_m":
			if err := func() error {
				s.ElevationM.Reset()
				if err := s.ElevationM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elevation_m\"")
			}
		case "cyberpunk_level":
			if err := func() error {
				s.CyberpunkLevel.Reset()
				if err := s.CyberpunkLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cyberpunk_level\"")
			}
		case "corruption_index":
			if err := func() error {
				s.CorruptionIndex.Reset()
				if err := s.CorruptionIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corruption_index\"")
			}
		case "technology_index":
			if err := func() error {
				s.TechnologyIndex.Reset()
				if err := s.TechnologyIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"technology_index\"")
			}
		case "zones":
			if err := func() error {
				s.Zones = make([]CityUpdateZonesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CityUpdateZonesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		case "districts":
			if err := func() error {
				s.Districts = nil
				var elem CityUpdateDistricts
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Districts = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"districts\"")
			}
		case "landmarks":
			if err := func() error {
				s.Landmarks = make([]CityUpdateLandmarksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CityUpdateLandmarksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Landmarks = append(s.Landmarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"landmarks\"")
			}
		case "economy_data":
			if err := func() error {
				s.EconomyData = nil
				var elem CityUpdateEconomyData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EconomyData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"economy_data\"")
			}
		case "corporation_presence":
			if err := func() error {
				s.CorporationPresence = nil
				var elem CityUpdateCorporationPresence
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CorporationPresence = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corporation_presence\"")
			}
		case "faction_influence":
			if err := func() error {
				s.FactionInfluence = nil
				var elem CityUpdateFactionInfluence
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FactionInfluence = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faction_influence\"")
			}
		case "timeline_events":
			if err := func() error {
				s.TimelineEvents = nil
				var elem CityUpdateTimelineEvents
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TimelineEvents = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_events\"")
			}
		case "future_evolution":
			if err := func() error {
				s.FutureEvolution = nil
				var elem CityUpdateFutureEvolution
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FutureEvolution = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"future_evolution\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "is_capital":
			if err := func() error {
				s.IsCapital.Reset()
				if err := s.IsCapital.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_capital\"")
			}
		case "is_megacity":
			if err := func() error {
				s.IsMegacity.Reset()
				if err := s.IsMegacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_megacity\"")
			}
		case "available_in_game":
			if err := func() error {
				s.AvailableInGame.Reset()
				if err := s.AvailableInGame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_in_game\"")
			}
		case "game_regions":
			if err := func() error {
				s.GameRegions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameRegions = append(s.GameRegions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_regions\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateCorporationPresence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateCorporationPresence) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateCorporationPresence = [0]string{}

// Decode decodes CityUpdateCorporationPresence from json.
func (s *CityUpdateCorporationPresence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateCorporationPresence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateCorporationPresence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateCorporationPresence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateCorporationPresence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateDistricts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateDistricts) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateDistricts = [0]string{}

// Decode decodes CityUpdateDistricts from json.
func (s *CityUpdateDistricts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateDistricts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateDistricts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateDistricts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateDistricts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateEconomyData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateEconomyData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateEconomyData = [0]string{}

// Decode decodes CityUpdateEconomyData from json.
func (s *CityUpdateEconomyData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateEconomyData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateEconomyData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateEconomyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateEconomyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateFactionInfluence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateFactionInfluence) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateFactionInfluence = [0]string{}

// Decode decodes CityUpdateFactionInfluence from json.
func (s *CityUpdateFactionInfluence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateFactionInfluence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateFactionInfluence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateFactionInfluence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateFactionInfluence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateFutureEvolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateFutureEvolution) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateFutureEvolution = [0]string{}

// Decode decodes CityUpdateFutureEvolution from json.
func (s *CityUpdateFutureEvolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateFutureEvolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateFutureEvolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateFutureEvolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateFutureEvolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateLandmarksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateLandmarksItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateLandmarksItem = [0]string{}

// Decode decodes CityUpdateLandmarksItem from json.
func (s *CityUpdateLandmarksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateLandmarksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateLandmarksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateLandmarksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateLandmarksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityUpdateStatus as json.
func (s CityUpdateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityUpdateStatus from json.
func (s *CityUpdateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityUpdateStatus(v) {
	case CityUpdateStatusActive:
		*s = CityUpdateStatusActive
	case CityUpdateStatusDestroyed:
		*s = CityUpdateStatusDestroyed
	case CityUpdateStatusAbandoned:
		*s = CityUpdateStatusAbandoned
	case CityUpdateStatusVirtual:
		*s = CityUpdateStatusVirtual
	default:
		*s = CityUpdateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateTimelineEvents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateTimelineEvents) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateTimelineEvents = [0]string{}

// Decode decodes CityUpdateTimelineEvents from json.
func (s *CityUpdateTimelineEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateTimelineEvents to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateTimelineEvents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateTimelineEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateTimelineEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityUpdateZonesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityUpdateZonesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCityUpdateZonesItem = [0]string{}

// Decode decodes CityUpdateZonesItem from json.
func (s *CityUpdateZonesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityUpdateZonesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CityUpdateZonesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityUpdateZonesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityUpdateZonesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityZonesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityZonesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Coordinates.Set {
			e.FieldStart("coordinates")
			s.Coordinates.Encode(e)
		}
	}
}

var jsonFieldsNameOfCityZonesItem = [3]string{
	0: "name",
	1: "type",
	2: "coordinates",
}

// Decode decodes CityZonesItem from json.
func (s *CityZonesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityZonesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "coordinates":
			if err := func() error {
				s.Coordinates.Reset()
				if err := s.Coordinates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coordinates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityZonesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCityZonesItem) {
					name = jsonFieldsNameOfCityZonesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityZonesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityZonesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CityZonesItemCoordinates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CityZonesItemCoordinates) encodeFields(e *jx.Encoder) {
	{
		if s.Center != nil {
			e.FieldStart("center")
			e.ArrStart()
			for _, elem := range s.Center {
				e.Float64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Bounds != nil {
			e.FieldStart("bounds")
			e.ArrStart()
			for _, elem := range s.Bounds {
				e.ArrStart()
				for _, elem := range elem {
					e.Float64(elem)
				}
				e.ArrEnd()
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCityZonesItemCoordinates = [2]string{
	0: "center",
	1: "bounds",
}

// Decode decodes CityZonesItemCoordinates from json.
func (s *CityZonesItemCoordinates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityZonesItemCoordinates to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "center":
			if err := func() error {
				s.Center = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.Center = append(s.Center, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"center\"")
			}
		case "bounds":
			if err := func() error {
				s.Bounds = make([][]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []float64
					elem = make([]float64, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem float64
						v, err := d.Float64()
						elemElem = float64(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.Bounds = append(s.Bounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CityZonesItemCoordinates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CityZonesItemCoordinates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityZonesItemCoordinates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityZonesItemType as json.
func (s CityZonesItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CityZonesItemType from json.
func (s *CityZonesItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CityZonesItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CityZonesItemType(v) {
	case CityZonesItemTypeCommercial:
		*s = CityZonesItemTypeCommercial
	case CityZonesItemTypeResidential:
		*s = CityZonesItemTypeResidential
	case CityZonesItemTypeIndustrial:
		*s = CityZonesItemTypeIndustrial
	case CityZonesItemTypeCorporate:
		*s = CityZonesItemTypeCorporate
	case CityZonesItemTypeEntertainment:
		*s = CityZonesItemTypeEntertainment
	case CityZonesItemTypeGovernment:
		*s = CityZonesItemTypeGovernment
	case CityZonesItemTypeMilitary:
		*s = CityZonesItemTypeMilitary
	case CityZonesItemTypeSlums:
		*s = CityZonesItemTypeSlums
	default:
		*s = CityZonesItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CityZonesItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CityZonesItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCityBadRequest as json.
func (s *CreateCityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCityBadRequest from json.
func (s *CreateCityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCityInternalServerError as json.
func (s *CreateCityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCityInternalServerError from json.
func (s *CreateCityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCityUnauthorized as json.
func (s *CreateCityUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCityUnauthorized from json.
func (s *CreateCityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCityUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCityUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCityUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCityUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCityInternalServerError as json.
func (s *DeleteCityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCityInternalServerError from json.
func (s *DeleteCityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCityNotFound as json.
func (s *DeleteCityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCityNotFound from json.
func (s *DeleteCityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCityUnauthorized as json.
func (s *DeleteCityUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCityUnauthorized from json.
func (s *DeleteCityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCityUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCityUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCityUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCityUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrResp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrResp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrResp = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrResp from json.
func (s *ErrResp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrResp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrRespDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrResp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrResp) {
					name = jsonFieldsNameOfErrResp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrResp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrResp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrRespDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrRespDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrRespDetails = [0]string{}

// Decode decodes ErrRespDetails from json.
func (s *ErrRespDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrRespDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrRespDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrRespDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrRespDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int32(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Code = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCityAnalyticsBadRequest as json.
func (s *GetCityAnalyticsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCityAnalyticsBadRequest from json.
func (s *GetCityAnalyticsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCityAnalyticsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCityAnalyticsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCityAnalyticsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCityAnalyticsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCityAnalyticsInternalServerError as json.
func (s *GetCityAnalyticsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCityAnalyticsInternalServerError from json.
func (s *GetCityAnalyticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCityAnalyticsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCityAnalyticsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCityAnalyticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCityAnalyticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCityInternalServerError as json.
func (s *GetCityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCityInternalServerError from json.
func (s *GetCityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCityNotFound as json.
func (s *GetCityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCityNotFound from json.
func (s *GetCityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.UptimeSeconds.Set {
			e.FieldStart("uptime_seconds")
			s.UptimeSeconds.Encode(e)
		}
	}
	{
		if s.ActiveConnections.Set {
			e.FieldStart("active_connections")
			s.ActiveConnections.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [6]string{
	0: "status",
	1: "domain",
	2: "timestamp",
	3: "version",
	4: "uptime_seconds",
	5: "active_connections",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime_seconds":
			if err := func() error {
				s.UptimeSeconds.Reset()
				if err := s.UptimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime_seconds\"")
			}
		case "active_connections":
			if err := func() error {
				s.ActiveConnections.Reset()
				if err := s.ActiveConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_connections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	case HealthResponseStatusDegraded:
		*s = HealthResponseStatusDegraded
	case HealthResponseStatusUnhealthy:
		*s = HealthResponseStatusUnhealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCitiesBadRequest as json.
func (s *ListCitiesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListCitiesBadRequest from json.
func (s *ListCitiesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCitiesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCitiesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListCitiesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCitiesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCitiesInternalServerError as json.
func (s *ListCitiesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListCitiesInternalServerError from json.
func (s *ListCitiesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCitiesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCitiesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListCitiesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCitiesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListCitiesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListCitiesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cities")
		e.ArrStart()
		for _, elem := range s.Cities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfListCitiesOK = [2]string{
	0: "cities",
	1: "pagination",
}

// Decode decodes ListCitiesOK from json.
func (s *ListCitiesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCitiesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Cities = make([]CitySummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CitySummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Cities = append(s.Cities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cities\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListCitiesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListCitiesOK) {
					name = jsonFieldsNameOfListCitiesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListCitiesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCitiesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityAnalyticsFilters as json.
func (o OptCityAnalyticsFilters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityAnalyticsFilters from json.
func (o *OptCityAnalyticsFilters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCityAnalyticsFilters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCityAnalyticsFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCityAnalyticsFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityUpdateStatus as json.
func (o OptCityUpdateStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CityUpdateStatus from json.
func (o *OptCityUpdateStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCityUpdateStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCityUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCityUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityZonesItemCoordinates as json.
func (o OptCityZonesItemCoordinates) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityZonesItemCoordinates from json.
func (o *OptCityZonesItemCoordinates) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCityZonesItemCoordinates to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCityZonesItemCoordinates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCityZonesItemCoordinates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityCorporationPresence as json.
func (o OptNilCityCorporationPresence) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityCorporationPresence from json.
func (o *OptNilCityCorporationPresence) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityCorporationPresence to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityCorporationPresence
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CityCorporationPresence)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityCorporationPresence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityCorporationPresence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityDistricts as json.
func (o OptNilCityDistricts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityDistricts from json.
func (o *OptNilCityDistricts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityDistricts to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityDistricts
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CityDistricts)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityDistricts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityDistricts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityEconomyData as json.
func (o OptNilCityEconomyData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityEconomyData from json.
func (o *OptNilCityEconomyData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityEconomyData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityEconomyData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityEconomyData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityEconomyData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityFactionInfluence as json.
func (o OptNilCityFactionInfluence) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityFactionInfluence from json.
func (o *OptNilCityFactionInfluence) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityFactionInfluence to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityFactionInfluence
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CityFactionInfluence)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityFactionInfluence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityFactionInfluence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityFutureEvolution as json.
func (o OptNilCityFutureEvolution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityFutureEvolution from json.
func (o *OptNilCityFutureEvolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityFutureEvolution to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityFutureEvolution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CityFutureEvolution)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityFutureEvolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityFutureEvolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CityLandmarksItem as json.
func (o OptNilCityLandmarksItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CityLandmarksItem from json.
func (o *OptNilCityLandmarksItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityLandmarksItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CityLandmarksItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CityLandmarksItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CityLandmarksItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityLandmarksItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityLandmarksItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CityTimelineEvents as json.
func (o OptNilCityTimelineEvents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CityTimelineEvents from json.
func (o *OptNilCityTimelineEvents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityTimelineEvents to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CityTimelineEvents
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CityTimelineEvents)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityTimelineEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityTimelineEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CityZonesItem as json.
func (o OptNilCityZonesItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CityZonesItem from json.
func (o *OptNilCityZonesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCityZonesItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CityZonesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CityZonesItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CityZonesItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCityZonesItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCityZonesItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("page")
		e.Int(s.Page)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("total_pages")
		e.Int(s.TotalPages)
	}
	{
		if s.HasNext.Set {
			e.FieldStart("has_next")
			s.HasNext.Encode(e)
		}
	}
	{
		if s.HasPrev.Set {
			e.FieldStart("has_prev")
			s.HasPrev.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaginationMeta = [6]string{
	0: "page",
	1: "limit",
	2: "total",
	3: "total_pages",
	4: "has_next",
	5: "has_prev",
}

// Decode decodes PaginationMeta from json.
func (s *PaginationMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationMeta to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Page = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "total_pages":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "has_next":
			if err := func() error {
				s.HasNext.Reset()
				if err := s.HasNext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_next\"")
			}
		case "has_prev":
			if err := func() error {
				s.HasPrev.Reset()
				if err := s.HasPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_prev\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginationMeta) {
					name = jsonFieldsNameOfPaginationMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchCitiesBadRequest as json.
func (s *SearchCitiesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchCitiesBadRequest from json.
func (s *SearchCitiesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCitiesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchCitiesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCitiesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCitiesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchCitiesInternalServerError as json.
func (s *SearchCitiesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchCitiesInternalServerError from json.
func (s *SearchCitiesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCitiesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchCitiesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCitiesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCitiesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchCitiesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchCitiesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfSearchCitiesOK = [2]string{
	0: "results",
	1: "pagination",
}

// Decode decodes SearchCitiesOK from json.
func (s *SearchCitiesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCitiesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]CitySummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CitySummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchCitiesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchCitiesOK) {
					name = jsonFieldsNameOfSearchCitiesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCitiesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCitiesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCityBadRequest as json.
func (s *UpdateCityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCityBadRequest from json.
func (s *UpdateCityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCityInternalServerError as json.
func (s *UpdateCityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCityInternalServerError from json.
func (s *UpdateCityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCityNotFound as json.
func (s *UpdateCityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCityNotFound from json.
func (s *UpdateCityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCityUnauthorized as json.
func (s *UpdateCityUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCityUnauthorized from json.
func (s *UpdateCityUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCityUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCityUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCityUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCityUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
