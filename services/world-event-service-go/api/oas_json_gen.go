// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes CancelEventConflict as json.
func (s *CancelEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelEventConflict from json.
func (s *CancelEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelEventNotFound as json.
func (s *CancelEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelEventNotFound from json.
func (s *CancelEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CancelEventOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CancelEventOK) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfCancelEventOK = [1]string{
	0: "message",
}

// Decode decodes CancelEventOK from json.
func (s *CancelEventOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelEventOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CancelEventOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelEventOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelEventOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardBadRequest as json.
func (s *ClaimRewardBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ClaimRewardBadRequest from json.
func (s *ClaimRewardBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClaimRewardBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardConflict as json.
func (s *ClaimRewardConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ClaimRewardConflict from json.
func (s *ClaimRewardConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClaimRewardConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardNotFound as json.
func (s *ClaimRewardNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ClaimRewardNotFound from json.
func (s *ClaimRewardNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClaimRewardNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRewardReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRewardReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("rewardType")
		s.RewardType.Encode(e)
	}
	{
		if s.RewardId.Set {
			e.FieldStart("rewardId")
			s.RewardId.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRewardReq = [3]string{
	0: "playerId",
	1: "rewardType",
	2: "rewardId",
}

// Decode decodes ClaimRewardReq from json.
func (s *ClaimRewardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "rewardType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RewardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardType\"")
			}
		case "rewardId":
			if err := func() error {
				s.RewardId.Reset()
				if err := s.RewardId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRewardReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimRewardReq) {
					name = jsonFieldsNameOfClaimRewardReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRewardReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimRewardReqRewardType as json.
func (s ClaimRewardReqRewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClaimRewardReqRewardType from json.
func (s *ClaimRewardReqRewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRewardReqRewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClaimRewardReqRewardType(v) {
	case ClaimRewardReqRewardTypeXp:
		*s = ClaimRewardReqRewardTypeXp
	case ClaimRewardReqRewardTypeCurrency:
		*s = ClaimRewardReqRewardTypeCurrency
	case ClaimRewardReqRewardTypeItem:
		*s = ClaimRewardReqRewardTypeItem
	case ClaimRewardReqRewardTypeAchievement:
		*s = ClaimRewardReqRewardTypeAchievement
	default:
		*s = ClaimRewardReqRewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClaimRewardReqRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRewardReqRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEventBadRequest as json.
func (s *CreateEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateEventBadRequest from json.
func (s *CreateEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEventConflict as json.
func (s *CreateEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateEventConflict from json.
func (s *CreateEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("startTime")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.EventData != nil {
			e.FieldStart("eventData")
			s.EventData.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateEventRequest = [11]string{
	0:  "name",
	1:  "type",
	2:  "region",
	3:  "startTime",
	4:  "endTime",
	5:  "description",
	6:  "objectives",
	7:  "rewards",
	8:  "maxParticipants",
	9:  "difficulty",
	10: "eventData",
}

// Decode decodes CreateEventRequest from json.
func (s *CreateEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]CreateEventRequestObjectivesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateEventRequestObjectivesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]CreateEventRequestRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateEventRequestRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "difficulty":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "eventData":
			if err := func() error {
				s.EventData = nil
				var elem CreateEventRequestEventData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateEventRequest) {
					name = jsonFieldsNameOfCreateEventRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEventRequestDifficulty as json.
func (s CreateEventRequestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateEventRequestDifficulty from json.
func (s *CreateEventRequestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateEventRequestDifficulty(v) {
	case CreateEventRequestDifficultyEASY:
		*s = CreateEventRequestDifficultyEASY
	case CreateEventRequestDifficultyMEDIUM:
		*s = CreateEventRequestDifficultyMEDIUM
	case CreateEventRequestDifficultyHARD:
		*s = CreateEventRequestDifficultyHARD
	case CreateEventRequestDifficultyEXTREME:
		*s = CreateEventRequestDifficultyEXTREME
	default:
		*s = CreateEventRequestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateEventRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventRequestEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventRequestEventData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateEventRequestEventData = [0]string{}

// Decode decodes CreateEventRequestEventData from json.
func (s *CreateEventRequestEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestEventData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventRequestEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventRequestEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventRequestObjectivesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventRequestObjectivesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateEventRequestObjectivesItem = [0]string{}

// Decode decodes CreateEventRequestObjectivesItem from json.
func (s *CreateEventRequestObjectivesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestObjectivesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventRequestObjectivesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventRequestObjectivesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestObjectivesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventRequestRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventRequestRewardsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateEventRequestRewardsItem = [0]string{}

// Decode decodes CreateEventRequestRewardsItem from json.
func (s *CreateEventRequestRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventRequestRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventRequestRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEventRequestType as json.
func (s CreateEventRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateEventRequestType from json.
func (s *CreateEventRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateEventRequestType(v) {
	case CreateEventRequestTypeDISASTER:
		*s = CreateEventRequestTypeDISASTER
	case CreateEventRequestTypeFESTIVAL:
		*s = CreateEventRequestTypeFESTIVAL
	case CreateEventRequestTypeWAR:
		*s = CreateEventRequestTypeWAR
	case CreateEventRequestTypeINVASION:
		*s = CreateEventRequestTypeINVASION
	case CreateEventRequestTypeTOURNAMENT:
		*s = CreateEventRequestTypeTOURNAMENT
	case CreateEventRequestTypeQUEST:
		*s = CreateEventRequestTypeQUEST
	default:
		*s = CreateEventRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateEventRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ObjectivesTemplate != nil {
			e.FieldStart("objectivesTemplate")
			e.ArrStart()
			for _, elem := range s.ObjectivesTemplate {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RewardsTemplate != nil {
			e.FieldStart("rewardsTemplate")
			e.ArrStart()
			for _, elem := range s.RewardsTemplate {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DurationMinutes.Set {
			e.FieldStart("durationMinutes")
			s.DurationMinutes.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.RegionRestrictions != nil {
			e.FieldStart("regionRestrictions")
			e.ArrStart()
			for _, elem := range s.RegionRestrictions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EventDataTemplate != nil {
			e.FieldStart("eventDataTemplate")
			s.EventDataTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTemplateRequest = [10]string{
	0: "name",
	1: "type",
	2: "difficulty",
	3: "description",
	4: "objectivesTemplate",
	5: "rewardsTemplate",
	6: "durationMinutes",
	7: "maxParticipants",
	8: "regionRestrictions",
	9: "eventDataTemplate",
}

// Decode decodes CreateTemplateRequest from json.
func (s *CreateTemplateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectivesTemplate":
			if err := func() error {
				s.ObjectivesTemplate = make([]CreateTemplateRequestObjectivesTemplateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateTemplateRequestObjectivesTemplateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ObjectivesTemplate = append(s.ObjectivesTemplate, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectivesTemplate\"")
			}
		case "rewardsTemplate":
			if err := func() error {
				s.RewardsTemplate = make([]CreateTemplateRequestRewardsTemplateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateTemplateRequestRewardsTemplateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RewardsTemplate = append(s.RewardsTemplate, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsTemplate\"")
			}
		case "durationMinutes":
			if err := func() error {
				s.DurationMinutes.Reset()
				if err := s.DurationMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"durationMinutes\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "regionRestrictions":
			if err := func() error {
				s.RegionRestrictions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RegionRestrictions = append(s.RegionRestrictions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionRestrictions\"")
			}
		case "eventDataTemplate":
			if err := func() error {
				s.EventDataTemplate = nil
				var elem CreateTemplateRequestEventDataTemplate
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventDataTemplate = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventDataTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTemplateRequest) {
					name = jsonFieldsNameOfCreateTemplateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTemplateRequestDifficulty as json.
func (s CreateTemplateRequestDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTemplateRequestDifficulty from json.
func (s *CreateTemplateRequestDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTemplateRequestDifficulty(v) {
	case CreateTemplateRequestDifficultyEASY:
		*s = CreateTemplateRequestDifficultyEASY
	case CreateTemplateRequestDifficultyMEDIUM:
		*s = CreateTemplateRequestDifficultyMEDIUM
	case CreateTemplateRequestDifficultyHARD:
		*s = CreateTemplateRequestDifficultyHARD
	case CreateTemplateRequestDifficultyEXTREME:
		*s = CreateTemplateRequestDifficultyEXTREME
	default:
		*s = CreateTemplateRequestDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTemplateRequestDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequestEventDataTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequestEventDataTemplate) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateTemplateRequestEventDataTemplate = [0]string{}

// Decode decodes CreateTemplateRequestEventDataTemplate from json.
func (s *CreateTemplateRequestEventDataTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestEventDataTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequestEventDataTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequestEventDataTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestEventDataTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequestObjectivesTemplateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequestObjectivesTemplateItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateTemplateRequestObjectivesTemplateItem = [0]string{}

// Decode decodes CreateTemplateRequestObjectivesTemplateItem from json.
func (s *CreateTemplateRequestObjectivesTemplateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestObjectivesTemplateItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequestObjectivesTemplateItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequestObjectivesTemplateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestObjectivesTemplateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTemplateRequestRewardsTemplateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTemplateRequestRewardsTemplateItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateTemplateRequestRewardsTemplateItem = [0]string{}

// Decode decodes CreateTemplateRequestRewardsTemplateItem from json.
func (s *CreateTemplateRequestRewardsTemplateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestRewardsTemplateItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateTemplateRequestRewardsTemplateItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTemplateRequestRewardsTemplateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestRewardsTemplateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTemplateRequestType as json.
func (s CreateTemplateRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTemplateRequestType from json.
func (s *CreateTemplateRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTemplateRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTemplateRequestType(v) {
	case CreateTemplateRequestTypeDISASTER:
		*s = CreateTemplateRequestTypeDISASTER
	case CreateTemplateRequestTypeFESTIVAL:
		*s = CreateTemplateRequestTypeFESTIVAL
	case CreateTemplateRequestTypeWAR:
		*s = CreateTemplateRequestTypeWAR
	case CreateTemplateRequestTypeINVASION:
		*s = CreateTemplateRequestTypeINVASION
	case CreateTemplateRequestTypeTOURNAMENT:
		*s = CreateTemplateRequestTypeTOURNAMENT
	case CreateTemplateRequestTypeQUEST:
		*s = CreateTemplateRequestTypeQUEST
	default:
		*s = CreateTemplateRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTemplateRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTemplateRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "code",
	1: "message",
	2: "details",
	3: "timestamp",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventAnalytics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventAnalytics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("totalParticipants")
		e.Int(s.TotalParticipants)
	}
	{
		e.FieldStart("completedParticipants")
		e.Int(s.CompletedParticipants)
	}
	{
		if s.AverageCompletionTime.Set {
			e.FieldStart("averageCompletionTime")
			s.AverageCompletionTime.Encode(e)
		}
	}
	{
		if s.AverageScore.Set {
			e.FieldStart("averageScore")
			s.AverageScore.Encode(e)
		}
	}
	{
		if s.ParticipationRate.Set {
			e.FieldStart("participationRate")
			s.ParticipationRate.Encode(e)
		}
	}
	{
		if s.SatisfactionRating.Set {
			e.FieldStart("satisfactionRating")
			s.SatisfactionRating.Encode(e)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("lastUpdated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEventAnalytics = [8]string{
	0: "eventId",
	1: "totalParticipants",
	2: "completedParticipants",
	3: "averageCompletionTime",
	4: "averageScore",
	5: "participationRate",
	6: "satisfactionRating",
	7: "lastUpdated",
}

// Decode decodes EventAnalytics from json.
func (s *EventAnalytics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventAnalytics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "totalParticipants":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalParticipants = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalParticipants\"")
			}
		case "completedParticipants":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CompletedParticipants = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedParticipants\"")
			}
		case "averageCompletionTime":
			if err := func() error {
				s.AverageCompletionTime.Reset()
				if err := s.AverageCompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageCompletionTime\"")
			}
		case "averageScore":
			if err := func() error {
				s.AverageScore.Reset()
				if err := s.AverageScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageScore\"")
			}
		case "participationRate":
			if err := func() error {
				s.ParticipationRate.Reset()
				if err := s.ParticipationRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participationRate\"")
			}
		case "satisfactionRating":
			if err := func() error {
				s.SatisfactionRating.Reset()
				if err := s.SatisfactionRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"satisfactionRating\"")
			}
		case "lastUpdated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventAnalytics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventAnalytics) {
					name = jsonFieldsNameOfEventAnalytics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventAnalytics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventAnalytics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("joinTime")
		json.EncodeDateTime(e, s.JoinTime)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.ProgressData != nil {
			e.FieldStart("progressData")
			s.ProgressData.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastActivity.Set {
			e.FieldStart("lastActivity")
			s.LastActivity.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEventParticipant = [9]string{
	0: "id",
	1: "eventId",
	2: "playerId",
	3: "joinTime",
	4: "status",
	5: "progressData",
	6: "score",
	7: "achievements",
	8: "lastActivity",
}

// Decode decodes EventParticipant from json.
func (s *EventParticipant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipant to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "eventId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "playerId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "joinTime":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.JoinTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joinTime\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "progressData":
			if err := func() error {
				s.ProgressData = nil
				var elem EventParticipantProgressData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ProgressData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressData\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]EventParticipantAchievementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventParticipantAchievementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		case "lastActivity":
			if err := func() error {
				s.LastActivity.Reset()
				if err := s.LastActivity.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastActivity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventParticipant) {
					name = jsonFieldsNameOfEventParticipant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipantAchievementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipantAchievementsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventParticipantAchievementsItem = [0]string{}

// Decode decodes EventParticipantAchievementsItem from json.
func (s *EventParticipantAchievementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantAchievementsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipantAchievementsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipantAchievementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantAchievementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipantDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipantDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("joinTime")
		json.EncodeDateTime(e, s.JoinTime)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.ProgressData != nil {
			e.FieldStart("progressData")
			s.ProgressData.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastActivity.Set {
			e.FieldStart("lastActivity")
			s.LastActivity.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEventParticipantDetail = [10]string{
	0: "id",
	1: "eventId",
	2: "playerId",
	3: "joinTime",
	4: "status",
	5: "progressData",
	6: "score",
	7: "achievements",
	8: "lastActivity",
	9: "rewards",
}

// Decode decodes EventParticipantDetail from json.
func (s *EventParticipantDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantDetail to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "eventId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "playerId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "joinTime":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.JoinTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joinTime\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "progressData":
			if err := func() error {
				s.ProgressData = nil
				var elem EventParticipantDetailProgressData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ProgressData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressData\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]EventParticipantDetailAchievementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventParticipantDetailAchievementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		case "lastActivity":
			if err := func() error {
				s.LastActivity.Reset()
				if err := s.LastActivity.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastActivity\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]EventReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipantDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventParticipantDetail) {
					name = jsonFieldsNameOfEventParticipantDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipantDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipantDetailAchievementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipantDetailAchievementsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventParticipantDetailAchievementsItem = [0]string{}

// Decode decodes EventParticipantDetailAchievementsItem from json.
func (s *EventParticipantDetailAchievementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantDetailAchievementsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipantDetailAchievementsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipantDetailAchievementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantDetailAchievementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipantDetailProgressData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipantDetailProgressData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventParticipantDetailProgressData = [0]string{}

// Decode decodes EventParticipantDetailProgressData from json.
func (s *EventParticipantDetailProgressData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantDetailProgressData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipantDetailProgressData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipantDetailProgressData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantDetailProgressData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventParticipantDetailStatus as json.
func (s EventParticipantDetailStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventParticipantDetailStatus from json.
func (s *EventParticipantDetailStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantDetailStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventParticipantDetailStatus(v) {
	case EventParticipantDetailStatusACTIVE:
		*s = EventParticipantDetailStatusACTIVE
	case EventParticipantDetailStatusCOMPLETED:
		*s = EventParticipantDetailStatusCOMPLETED
	case EventParticipantDetailStatusLEFT:
		*s = EventParticipantDetailStatusLEFT
	case EventParticipantDetailStatusKICKED:
		*s = EventParticipantDetailStatusKICKED
	default:
		*s = EventParticipantDetailStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventParticipantDetailStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantDetailStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventParticipantProgressData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventParticipantProgressData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventParticipantProgressData = [0]string{}

// Decode decodes EventParticipantProgressData from json.
func (s *EventParticipantProgressData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantProgressData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventParticipantProgressData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventParticipantProgressData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantProgressData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventParticipantStatus as json.
func (s EventParticipantStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventParticipantStatus from json.
func (s *EventParticipantStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventParticipantStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventParticipantStatus(v) {
	case EventParticipantStatusACTIVE:
		*s = EventParticipantStatusACTIVE
	case EventParticipantStatusCOMPLETED:
		*s = EventParticipantStatusCOMPLETED
	case EventParticipantStatusLEFT:
		*s = EventParticipantStatusLEFT
	case EventParticipantStatusKICKED:
		*s = EventParticipantStatusKICKED
	default:
		*s = EventParticipantStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventParticipantStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventParticipantStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
	{
		e.FieldStart("rewardType")
		s.RewardType.Encode(e)
	}
	{
		if s.RewardId.Set {
			e.FieldStart("rewardId")
			s.RewardId.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		e.FieldStart("claimed")
		e.Bool(s.Claimed)
	}
	{
		if s.ClaimedAt.Set {
			e.FieldStart("claimedAt")
			s.ClaimedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEventReward = [9]string{
	0: "id",
	1: "eventId",
	2: "playerId",
	3: "rewardType",
	4: "rewardId",
	5: "amount",
	6: "claimed",
	7: "claimedAt",
	8: "createdAt",
}

// Decode decodes EventReward from json.
func (s *EventReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventReward to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "eventId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "playerId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "rewardType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RewardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardType\"")
			}
		case "rewardId":
			if err := func() error {
				s.RewardId.Reset()
				if err := s.RewardId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardId\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "claimed":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Claimed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed\"")
			}
		case "claimedAt":
			if err := func() error {
				s.ClaimedAt.Reset()
				if err := s.ClaimedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimedAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventReward) {
					name = jsonFieldsNameOfEventReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRewardRewardType as json.
func (s EventRewardRewardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventRewardRewardType from json.
func (s *EventRewardRewardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRewardRewardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventRewardRewardType(v) {
	case EventRewardRewardTypeXp:
		*s = EventRewardRewardTypeXp
	case EventRewardRewardTypeCurrency:
		*s = EventRewardRewardTypeCurrency
	case EventRewardRewardTypeItem:
		*s = EventRewardRewardTypeItem
	case EventRewardRewardTypeAchievement:
		*s = EventRewardRewardTypeAchievement
	default:
		*s = EventRewardRewardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventRewardRewardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRewardRewardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ObjectivesTemplate != nil {
			e.FieldStart("objectivesTemplate")
			e.ArrStart()
			for _, elem := range s.ObjectivesTemplate {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RewardsTemplate != nil {
			e.FieldStart("rewardsTemplate")
			e.ArrStart()
			for _, elem := range s.RewardsTemplate {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DurationMinutes.Set {
			e.FieldStart("durationMinutes")
			s.DurationMinutes.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.RegionRestrictions != nil {
			e.FieldStart("regionRestrictions")
			e.ArrStart()
			for _, elem := range s.RegionRestrictions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EventDataTemplate != nil {
			e.FieldStart("eventDataTemplate")
			s.EventDataTemplate.Encode(e)
		}
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEventTemplate = [14]string{
	0:  "id",
	1:  "name",
	2:  "type",
	3:  "difficulty",
	4:  "description",
	5:  "objectivesTemplate",
	6:  "rewardsTemplate",
	7:  "durationMinutes",
	8:  "maxParticipants",
	9:  "regionRestrictions",
	10: "eventDataTemplate",
	11: "isActive",
	12: "createdAt",
	13: "updatedAt",
}

// Decode decodes EventTemplate from json.
func (s *EventTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "difficulty":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectivesTemplate":
			if err := func() error {
				s.ObjectivesTemplate = make([]EventTemplateObjectivesTemplateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventTemplateObjectivesTemplateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ObjectivesTemplate = append(s.ObjectivesTemplate, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectivesTemplate\"")
			}
		case "rewardsTemplate":
			if err := func() error {
				s.RewardsTemplate = make([]EventTemplateRewardsTemplateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventTemplateRewardsTemplateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RewardsTemplate = append(s.RewardsTemplate, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsTemplate\"")
			}
		case "durationMinutes":
			if err := func() error {
				s.DurationMinutes.Reset()
				if err := s.DurationMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"durationMinutes\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "regionRestrictions":
			if err := func() error {
				s.RegionRestrictions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RegionRestrictions = append(s.RegionRestrictions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionRestrictions\"")
			}
		case "eventDataTemplate":
			if err := func() error {
				s.EventDataTemplate = nil
				var elem EventTemplateEventDataTemplate
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventDataTemplate = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventDataTemplate\"")
			}
		case "isActive":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventTemplate) {
					name = jsonFieldsNameOfEventTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTemplateDifficulty as json.
func (s EventTemplateDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventTemplateDifficulty from json.
func (s *EventTemplateDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplateDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventTemplateDifficulty(v) {
	case EventTemplateDifficultyEASY:
		*s = EventTemplateDifficultyEASY
	case EventTemplateDifficultyMEDIUM:
		*s = EventTemplateDifficultyMEDIUM
	case EventTemplateDifficultyHARD:
		*s = EventTemplateDifficultyHARD
	case EventTemplateDifficultyEXTREME:
		*s = EventTemplateDifficultyEXTREME
	default:
		*s = EventTemplateDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventTemplateDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplateDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventTemplateEventDataTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventTemplateEventDataTemplate) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventTemplateEventDataTemplate = [0]string{}

// Decode decodes EventTemplateEventDataTemplate from json.
func (s *EventTemplateEventDataTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplateEventDataTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventTemplateEventDataTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventTemplateEventDataTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplateEventDataTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventTemplateObjectivesTemplateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventTemplateObjectivesTemplateItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventTemplateObjectivesTemplateItem = [0]string{}

// Decode decodes EventTemplateObjectivesTemplateItem from json.
func (s *EventTemplateObjectivesTemplateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplateObjectivesTemplateItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventTemplateObjectivesTemplateItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventTemplateObjectivesTemplateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplateObjectivesTemplateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventTemplateRewardsTemplateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventTemplateRewardsTemplateItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventTemplateRewardsTemplateItem = [0]string{}

// Decode decodes EventTemplateRewardsTemplateItem from json.
func (s *EventTemplateRewardsTemplateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplateRewardsTemplateItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventTemplateRewardsTemplateItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventTemplateRewardsTemplateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplateRewardsTemplateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTemplateType as json.
func (s EventTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventTemplateType from json.
func (s *EventTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventTemplateType(v) {
	case EventTemplateTypeDISASTER:
		*s = EventTemplateTypeDISASTER
	case EventTemplateTypeFESTIVAL:
		*s = EventTemplateTypeFESTIVAL
	case EventTemplateTypeWAR:
		*s = EventTemplateTypeWAR
	case EventTemplateTypeINVASION:
		*s = EventTemplateTypeINVASION
	case EventTemplateTypeTOURNAMENT:
		*s = EventTemplateTypeTOURNAMENT
	case EventTemplateTypeQUEST:
		*s = EventTemplateTypeQUEST
	default:
		*s = EventTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetEventParticipantsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetEventParticipantsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfGetEventParticipantsOK = [2]string{
	0: "participants",
	1: "pagination",
}

// Decode decodes GetEventParticipantsOK from json.
func (s *GetEventParticipantsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventParticipantsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participants":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Participants = make([]EventParticipant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventParticipant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetEventParticipantsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetEventParticipantsOK) {
					name = jsonFieldsNameOfGetEventParticipantsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventParticipantsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventParticipantsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerRewardsBadRequest as json.
func (s *GetPlayerRewardsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerRewardsBadRequest from json.
func (s *GetPlayerRewardsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerRewardsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerRewardsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerRewardsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerRewardsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerRewardsNotFound as json.
func (s *GetPlayerRewardsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerRewardsNotFound from json.
func (s *GetPlayerRewardsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerRewardsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerRewardsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerRewardsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerRewardsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlayerRewardsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlayerRewardsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rewards")
		e.ArrStart()
		for _, elem := range s.Rewards {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetPlayerRewardsOK = [1]string{
	0: "rewards",
}

// Decode decodes GetPlayerRewardsOK from json.
func (s *GetPlayerRewardsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerRewardsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rewards":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Rewards = make([]EventReward, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventReward
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlayerRewardsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlayerRewardsOK) {
					name = jsonFieldsNameOfGetPlayerRewardsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerRewardsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerRewardsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Uptime.Set {
			e.FieldStart("uptime")
			s.Uptime.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthCheckOK = [4]string{
	0: "status",
	1: "timestamp",
	2: "version",
	3: "uptime",
}

// Decode decodes HealthCheckOK from json.
func (s *HealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "uptime":
			if err := func() error {
				s.Uptime.Reset()
				if err := s.Uptime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthCheckOK) {
					name = jsonFieldsNameOfHealthCheckOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckOKStatus as json.
func (s HealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthCheckOKStatus from json.
func (s *HealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthCheckOKStatus(v) {
	case HealthCheckOKStatusHealthy:
		*s = HealthCheckOKStatusHealthy
	case HealthCheckOKStatusDegraded:
		*s = HealthCheckOKStatusDegraded
	case HealthCheckOKStatusUnhealthy:
		*s = HealthCheckOKStatusUnhealthy
	default:
		*s = HealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JoinEventBadRequest as json.
func (s *JoinEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes JoinEventBadRequest from json.
func (s *JoinEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JoinEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JoinEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JoinEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JoinEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JoinEventConflict as json.
func (s *JoinEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes JoinEventConflict from json.
func (s *JoinEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JoinEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JoinEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JoinEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JoinEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JoinEventNotFound as json.
func (s *JoinEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes JoinEventNotFound from json.
func (s *JoinEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JoinEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JoinEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JoinEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JoinEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JoinEventReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JoinEventReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		e.Str(s.PlayerId)
	}
}

var jsonFieldsNameOfJoinEventReq = [1]string{
	0: "playerId",
}

// Decode decodes JoinEventReq from json.
func (s *JoinEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JoinEventReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JoinEventReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJoinEventReq) {
					name = jsonFieldsNameOfJoinEventReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JoinEventReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JoinEventReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaveEventConflict as json.
func (s *LeaveEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes LeaveEventConflict from json.
func (s *LeaveEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeaveEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaveEventNotFound as json.
func (s *LeaveEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes LeaveEventNotFound from json.
func (s *LeaveEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeaveEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveEventOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveEventOK) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaveEventOK = [1]string{
	0: "message",
}

// Decode decodes LeaveEventOK from json.
func (s *LeaveEventOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveEventOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListEventTemplatesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListEventTemplatesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfListEventTemplatesOK = [2]string{
	0: "templates",
	1: "pagination",
}

// Decode decodes ListEventTemplatesOK from json.
func (s *ListEventTemplatesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListEventTemplatesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templates":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Templates = make([]EventTemplate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventTemplate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListEventTemplatesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListEventTemplatesOK) {
					name = jsonFieldsNameOfListEventTemplatesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListEventTemplatesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListEventTemplatesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListEventsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListEventsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfListEventsOK = [2]string{
	0: "events",
	1: "pagination",
}

// Decode decodes ListEventsOK from json.
func (s *ListEventsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListEventsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Events = make([]WorldEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListEventsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListEventsOK) {
					name = jsonFieldsNameOfListEventsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListEventsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListEventsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes time.Duration as json.
func (o OptDuration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeDuration(e, o.Value)
}

// Decode decodes time.Duration from json.
func (o *OptDuration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDuration to nil")
	}
	o.Set = true
	v, err := json.DecodeDuration(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventAnalytics as json.
func (o OptEventAnalytics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventAnalytics from json.
func (o *OptEventAnalytics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventAnalytics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventAnalytics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventAnalytics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventRequestStatus as json.
func (o OptUpdateEventRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateEventRequestStatus from json.
func (o *OptUpdateEventRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateEventRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateEventRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateEventRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateParticipationRequestStatus as json.
func (o OptUpdateParticipationRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateParticipationRequestStatus from json.
func (o *OptUpdateParticipationRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateParticipationRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateParticipationRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateParticipationRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfPaginationMeta = [3]string{
	0: "limit",
	1: "offset",
	2: "total",
}

// Decode decodes PaginationMeta from json.
func (s *PaginationMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationMeta to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginationMeta) {
					name = jsonFieldsNameOfPaginationMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventBadRequest as json.
func (s *UpdateEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventBadRequest from json.
func (s *UpdateEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventConflict as json.
func (s *UpdateEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventConflict from json.
func (s *UpdateEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventNotFound as json.
func (s *UpdateEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventNotFound from json.
func (s *UpdateEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.EventData != nil {
			e.FieldStart("eventData")
			s.EventData.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateEventRequest = [8]string{
	0: "name",
	1: "status",
	2: "endTime",
	3: "description",
	4: "objectives",
	5: "rewards",
	6: "maxParticipants",
	7: "eventData",
}

// Decode decodes UpdateEventRequest from json.
func (s *UpdateEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]UpdateEventRequestObjectivesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateEventRequestObjectivesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]UpdateEventRequestRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateEventRequestRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "eventData":
			if err := func() error {
				s.EventData = nil
				var elem UpdateEventRequestEventData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventRequestEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventRequestEventData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateEventRequestEventData = [0]string{}

// Decode decodes UpdateEventRequestEventData from json.
func (s *UpdateEventRequestEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequestEventData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventRequestEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventRequestEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequestEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventRequestObjectivesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventRequestObjectivesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateEventRequestObjectivesItem = [0]string{}

// Decode decodes UpdateEventRequestObjectivesItem from json.
func (s *UpdateEventRequestObjectivesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequestObjectivesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventRequestObjectivesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventRequestObjectivesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequestObjectivesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventRequestRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventRequestRewardsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateEventRequestRewardsItem = [0]string{}

// Decode decodes UpdateEventRequestRewardsItem from json.
func (s *UpdateEventRequestRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequestRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventRequestRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventRequestRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequestRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventRequestStatus as json.
func (s UpdateEventRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateEventRequestStatus from json.
func (s *UpdateEventRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateEventRequestStatus(v) {
	case UpdateEventRequestStatusANNOUNCED:
		*s = UpdateEventRequestStatusANNOUNCED
	case UpdateEventRequestStatusACTIVE:
		*s = UpdateEventRequestStatusACTIVE
	case UpdateEventRequestStatusCOMPLETED:
		*s = UpdateEventRequestStatusCOMPLETED
	case UpdateEventRequestStatusCANCELLED:
		*s = UpdateEventRequestStatusCANCELLED
	default:
		*s = UpdateEventRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateEventRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateParticipationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateParticipationRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ProgressData != nil {
			e.FieldStart("progressData")
			s.ProgressData.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateParticipationRequest = [4]string{
	0: "status",
	1: "progressData",
	2: "score",
	3: "achievements",
}

// Decode decodes UpdateParticipationRequest from json.
func (s *UpdateParticipationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateParticipationRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "progressData":
			if err := func() error {
				s.ProgressData = nil
				var elem UpdateParticipationRequestProgressData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ProgressData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressData\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]UpdateParticipationRequestAchievementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateParticipationRequestAchievementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateParticipationRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateParticipationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateParticipationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateParticipationRequestAchievementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateParticipationRequestAchievementsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateParticipationRequestAchievementsItem = [0]string{}

// Decode decodes UpdateParticipationRequestAchievementsItem from json.
func (s *UpdateParticipationRequestAchievementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateParticipationRequestAchievementsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateParticipationRequestAchievementsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateParticipationRequestAchievementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateParticipationRequestAchievementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateParticipationRequestProgressData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateParticipationRequestProgressData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateParticipationRequestProgressData = [0]string{}

// Decode decodes UpdateParticipationRequestProgressData from json.
func (s *UpdateParticipationRequestProgressData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateParticipationRequestProgressData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateParticipationRequestProgressData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateParticipationRequestProgressData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateParticipationRequestProgressData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateParticipationRequestStatus as json.
func (s UpdateParticipationRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateParticipationRequestStatus from json.
func (s *UpdateParticipationRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateParticipationRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateParticipationRequestStatus(v) {
	case UpdateParticipationRequestStatusACTIVE:
		*s = UpdateParticipationRequestStatusACTIVE
	case UpdateParticipationRequestStatusCOMPLETED:
		*s = UpdateParticipationRequestStatusCOMPLETED
	case UpdateParticipationRequestStatusLEFT:
		*s = UpdateParticipationRequestStatusLEFT
	case UpdateParticipationRequestStatusKICKED:
		*s = UpdateParticipationRequestStatusKICKED
	default:
		*s = UpdateParticipationRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateParticipationRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateParticipationRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerParticipationBadRequest as json.
func (s *UpdatePlayerParticipationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePlayerParticipationBadRequest from json.
func (s *UpdatePlayerParticipationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerParticipationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePlayerParticipationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerParticipationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerParticipationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePlayerParticipationNotFound as json.
func (s *UpdatePlayerParticipationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePlayerParticipationNotFound from json.
func (s *UpdatePlayerParticipationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePlayerParticipationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePlayerParticipationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePlayerParticipationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePlayerParticipationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("startTime")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.CurrentParticipants.Set {
			e.FieldStart("currentParticipants")
			s.CurrentParticipants.Encode(e)
		}
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.EventData != nil {
			e.FieldStart("eventData")
			s.EventData.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfWorldEvent = [16]string{
	0:  "id",
	1:  "name",
	2:  "type",
	3:  "region",
	4:  "status",
	5:  "startTime",
	6:  "endTime",
	7:  "description",
	8:  "objectives",
	9:  "rewards",
	10: "maxParticipants",
	11: "currentParticipants",
	12: "difficulty",
	13: "eventData",
	14: "createdAt",
	15: "updatedAt",
}

// Decode decodes WorldEvent from json.
func (s *WorldEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEvent to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]WorldEventObjectivesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEventObjectivesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]WorldEventRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEventRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "currentParticipants":
			if err := func() error {
				s.CurrentParticipants.Reset()
				if err := s.CurrentParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentParticipants\"")
			}
		case "difficulty":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "eventData":
			if err := func() error {
				s.EventData = nil
				var elem WorldEventEventData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventData\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorldEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorldEvent) {
					name = jsonFieldsNameOfWorldEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("startTime")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.CurrentParticipants.Set {
			e.FieldStart("currentParticipants")
			s.CurrentParticipants.Encode(e)
		}
	}
	{
		e.FieldStart("difficulty")
		s.Difficulty.Encode(e)
	}
	{
		if s.EventData != nil {
			e.FieldStart("eventData")
			s.EventData.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Participants != nil {
			e.FieldStart("participants")
			e.ArrStart()
			for _, elem := range s.Participants {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Analytics.Set {
			e.FieldStart("analytics")
			s.Analytics.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorldEventDetail = [18]string{
	0:  "id",
	1:  "name",
	2:  "type",
	3:  "region",
	4:  "status",
	5:  "startTime",
	6:  "endTime",
	7:  "description",
	8:  "objectives",
	9:  "rewards",
	10: "maxParticipants",
	11: "currentParticipants",
	12: "difficulty",
	13: "eventData",
	14: "createdAt",
	15: "updatedAt",
	16: "participants",
	17: "analytics",
}

// Decode decodes WorldEventDetail from json.
func (s *WorldEventDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetail to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]WorldEventDetailObjectivesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEventDetailObjectivesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]WorldEventDetailRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEventDetailRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "currentParticipants":
			if err := func() error {
				s.CurrentParticipants.Reset()
				if err := s.CurrentParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentParticipants\"")
			}
		case "difficulty":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		case "eventData":
			if err := func() error {
				s.EventData = nil
				var elem WorldEventDetailEventData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventData = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventData\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "participants":
			if err := func() error {
				s.Participants = make([]EventParticipant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventParticipant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "analytics":
			if err := func() error {
				s.Analytics.Reset()
				if err := s.Analytics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analytics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00111111,
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorldEventDetail) {
					name = jsonFieldsNameOfWorldEventDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDetailDifficulty as json.
func (s WorldEventDetailDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventDetailDifficulty from json.
func (s *WorldEventDetailDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventDetailDifficulty(v) {
	case WorldEventDetailDifficultyEASY:
		*s = WorldEventDetailDifficultyEASY
	case WorldEventDetailDifficultyMEDIUM:
		*s = WorldEventDetailDifficultyMEDIUM
	case WorldEventDetailDifficultyHARD:
		*s = WorldEventDetailDifficultyHARD
	case WorldEventDetailDifficultyEXTREME:
		*s = WorldEventDetailDifficultyEXTREME
	default:
		*s = WorldEventDetailDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventDetailDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventDetailEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventDetailEventData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventDetailEventData = [0]string{}

// Decode decodes WorldEventDetailEventData from json.
func (s *WorldEventDetailEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailEventData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventDetailEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventDetailEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventDetailObjectivesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventDetailObjectivesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventDetailObjectivesItem = [0]string{}

// Decode decodes WorldEventDetailObjectivesItem from json.
func (s *WorldEventDetailObjectivesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailObjectivesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventDetailObjectivesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventDetailObjectivesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailObjectivesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventDetailRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventDetailRewardsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventDetailRewardsItem = [0]string{}

// Decode decodes WorldEventDetailRewardsItem from json.
func (s *WorldEventDetailRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventDetailRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventDetailRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDetailStatus as json.
func (s WorldEventDetailStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventDetailStatus from json.
func (s *WorldEventDetailStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventDetailStatus(v) {
	case WorldEventDetailStatusANNOUNCED:
		*s = WorldEventDetailStatusANNOUNCED
	case WorldEventDetailStatusACTIVE:
		*s = WorldEventDetailStatusACTIVE
	case WorldEventDetailStatusCOMPLETED:
		*s = WorldEventDetailStatusCOMPLETED
	case WorldEventDetailStatusCANCELLED:
		*s = WorldEventDetailStatusCANCELLED
	default:
		*s = WorldEventDetailStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventDetailStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDetailType as json.
func (s WorldEventDetailType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventDetailType from json.
func (s *WorldEventDetailType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDetailType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventDetailType(v) {
	case WorldEventDetailTypeDISASTER:
		*s = WorldEventDetailTypeDISASTER
	case WorldEventDetailTypeFESTIVAL:
		*s = WorldEventDetailTypeFESTIVAL
	case WorldEventDetailTypeWAR:
		*s = WorldEventDetailTypeWAR
	case WorldEventDetailTypeINVASION:
		*s = WorldEventDetailTypeINVASION
	case WorldEventDetailTypeTOURNAMENT:
		*s = WorldEventDetailTypeTOURNAMENT
	case WorldEventDetailTypeQUEST:
		*s = WorldEventDetailTypeQUEST
	default:
		*s = WorldEventDetailType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventDetailType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDetailType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDifficulty as json.
func (s WorldEventDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventDifficulty from json.
func (s *WorldEventDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventDifficulty(v) {
	case WorldEventDifficultyEASY:
		*s = WorldEventDifficultyEASY
	case WorldEventDifficultyMEDIUM:
		*s = WorldEventDifficultyMEDIUM
	case WorldEventDifficultyHARD:
		*s = WorldEventDifficultyHARD
	case WorldEventDifficultyEXTREME:
		*s = WorldEventDifficultyEXTREME
	default:
		*s = WorldEventDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventEventData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventEventData = [0]string{}

// Decode decodes WorldEventEventData from json.
func (s *WorldEventEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventEventData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventObjectivesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventObjectivesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventObjectivesItem = [0]string{}

// Decode decodes WorldEventObjectivesItem from json.
func (s *WorldEventObjectivesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventObjectivesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventObjectivesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventObjectivesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventObjectivesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEventRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEventRewardsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWorldEventRewardsItem = [0]string{}

// Decode decodes WorldEventRewardsItem from json.
func (s *WorldEventRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventRewardsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WorldEventRewardsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEventRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventStatus as json.
func (s WorldEventStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventStatus from json.
func (s *WorldEventStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventStatus(v) {
	case WorldEventStatusANNOUNCED:
		*s = WorldEventStatusANNOUNCED
	case WorldEventStatusACTIVE:
		*s = WorldEventStatusACTIVE
	case WorldEventStatusCOMPLETED:
		*s = WorldEventStatusCOMPLETED
	case WorldEventStatusCANCELLED:
		*s = WorldEventStatusCANCELLED
	default:
		*s = WorldEventStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventType as json.
func (s WorldEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventType from json.
func (s *WorldEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventType(v) {
	case WorldEventTypeDISASTER:
		*s = WorldEventTypeDISASTER
	case WorldEventTypeFESTIVAL:
		*s = WorldEventTypeFESTIVAL
	case WorldEventTypeWAR:
		*s = WorldEventTypeWAR
	case WorldEventTypeINVASION:
		*s = WorldEventTypeINVASION
	case WorldEventTypeTOURNAMENT:
		*s = WorldEventTypeTOURNAMENT
	case WorldEventTypeQUEST:
		*s = WorldEventTypeQUEST
	default:
		*s = WorldEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
