// Code generated by NECPGAME backend agent. Enterprise-grade World Events service configuration.
// PERFORMANCE: Optimized configuration loading for world event scheduling

package config

import (
	"os"
	"strconv"
	"strings"
	"time"
)

// Config holds the complete service configuration
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Config struct {
	Server      ServerConfig      `yaml:"server"`
	Database    DatabaseConfig    `yaml:"database"`
	Redis       RedisConfig       `yaml:"redis"`
	Kafka       KafkaConfig       `yaml:"kafka"`
	WorldEvents WorldEventsConfig `yaml:"world_events"`
	Security    SecurityConfig    `yaml:"security"`
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
	Port         string        `yaml:"port"`
	ReadTimeout  time.Duration `yaml:"read_timeout"`
	WriteTimeout time.Duration `yaml:"write_timeout"`
	IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

// DatabaseConfig holds PostgreSQL database configuration
type DatabaseConfig struct {
	Host            string `yaml:"host"`
	Port            int    `yaml:"port"`
	User            string `yaml:"user"`
	Password        string `yaml:"password"`
	Database        string `yaml:"database"`
	SSLMode         string `yaml:"ssl_mode"`
	MaxOpenConns    int    `yaml:"max_open_conns"`
	MaxIdleConns    int    `yaml:"max_idle_conns"`
	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `yaml:"conn_max_idle_time"`
}

// RedisConfig holds Redis configuration
type RedisConfig struct {
	Host         string `yaml:"host"`
	Port         int    `yaml:"port"`
	Password     string `yaml:"password"`
	DB           int    `yaml:"db"`
	PoolSize     int    `yaml:"pool_size"`
	MinIdleConns int    `yaml:"min_idle_conns"`
}

// KafkaConfig holds Kafka configuration
type KafkaConfig struct {
	Brokers         []string      `yaml:"brokers"`
	ClientID        string        `yaml:"client_id"`
	GroupID         string        `yaml:"group_id"`
	SessionTimeout  time.Duration `yaml:"session_timeout"`
	HeartbeatInterval time.Duration `yaml:"heartbeat_interval"`
	RebalanceTimeout time.Duration `yaml:"rebalance_timeout"`
	AutoOffsetReset string        `yaml:"auto_offset_reset"`
	EnableAutoCommit bool         `yaml:"enable_auto_commit"`
	FlushFrequency  time.Duration `yaml:"flush_frequency"`
	FlushMessages   int           `yaml:"flush_messages"`
	FlushBytes      int           `yaml:"flush_bytes"`
	MaxMessageBytes int           `yaml:"max_message_bytes"`
	RequiredAcks    int           `yaml:"required_cks"`
	RetryMax        int           `yaml:"retry_max"`
	RetryBackoff    time.Duration `yaml:"retry_backoff"`
	SASL            SASLConfig    `yaml:"sasl"`
	TLS             TLSConfig     `yaml:"tls"`
}

// SASLConfig holds SASL authentication configuration
type SASLConfig struct {
	Enable   bool   `yaml:"enable"`
	User     string `yaml:"user"`
	Password string `yaml:"password"`
}

// TLSConfig holds TLS configuration
type TLSConfig struct {
	Enable bool   `yaml:"enable"`
	Cert   string `yaml:"cert"`
	Key    string `yaml:"key"`
	CA     string `yaml:"ca"`
}

// WorldEventsConfig holds world events specific configuration
type WorldEventsConfig struct {
	EventCheckInterval   time.Duration `yaml:"event_check_interval"`
	MaxConcurrentEvents  int           `yaml:"max_concurrent_events"`
	EventBufferSize      int           `yaml:"event_buffer_size"`
	SchedulerPoolSize    int           `yaml:"scheduler_pool_size"`
	RegionSyncInterval   time.Duration `yaml:"region_sync_interval"`
	EventHistoryRetention time.Duration `yaml:"event_history_retention"`
	DefaultEventDuration time.Duration `yaml:"default_event_duration"`
	MaxEventDuration     time.Duration `yaml:"max_event_duration"`
	MinEventDuration     time.Duration `yaml:"min_event_duration"`
	CooldownPeriod       time.Duration `yaml:"cooldown_period"`

	// Event categories
	NaturalDisastersEnabled bool `yaml:"natural_disasters_enabled"`
	FestivalsEnabled        bool `yaml:"festivals_enabled"`
	InvasionsEnabled        bool `yaml:"invasions_enabled"`
	TradeEventsEnabled      bool `yaml:"trade_events_enabled"`
	SeasonalEventsEnabled   bool `yaml:"seasonal_events_enabled"`
	RandomEventsEnabled     bool `yaml:"random_events_enabled"`

	// Event probabilities (0.0-1.0)
	NaturalDisasterChance float64 `yaml:"natural_disaster_chance"`
	FestivalChance        float64 `yaml:"festival_chance"`
	InvasionChance        float64 `yaml:"invasion_chance"`
	TradeEventChance      float64 `yaml:"trade_event_chance"`
	SeasonalEventChance   float64 `yaml:"seasonal_event_chance"`
	RandomEventChance     float64 `yaml:"random_event_chance"`
}

// SecurityConfig holds security specific configuration
type SecurityConfig struct {
	EnableEncryption bool     `yaml:"enable_encryption"`
	EncryptionKey    string   `yaml:"encryption_key"`
	AllowedTopics    []string `yaml:"allowed_topics"`
	RateLimitEvents  int      `yaml:"rate_limit_events"`
	RateLimitWindow  time.Duration `yaml:"rate_limit_window"`
}

// Load loads configuration from environment variables with world-events defaults
func Load() *Config {
	cfg := &Config{
		Server: ServerConfig{
			Port:         getEnv("WORLD_EVENTS_PORT", "8084"),
			ReadTimeout:  getDurationEnv("WORLD_EVENTS_READ_TIMEOUT", 30*time.Second),
			WriteTimeout: getDurationEnv("WORLD_EVENTS_WRITE_TIMEOUT", 30*time.Second),
			IdleTimeout:  getDurationEnv("WORLD_EVENTS_IDLE_TIMEOUT", 120*time.Second),
		},
		Database: DatabaseConfig{
			Host:            getEnv("DB_HOST", "localhost"),
			Port:            getIntEnv("DB_PORT", 5432),
			User:            getEnv("DB_USER", "postgres"),
			Password:        getEnv("DB_PASSWORD", "postgres"),
			Database:        getEnv("DB_NAME", "necpgame"),
			SSLMode:         getEnv("DB_SSL_MODE", "disable"),
			MaxOpenConns:    getIntEnv("DB_MAX_OPEN_CONNS", 25),
			MaxIdleConns:    getIntEnv("DB_MAX_IDLE_CONNS", 8),
			ConnMaxLifetime: getDurationEnv("DB_CONN_MAX_LIFETIME", 30*time.Minute),
			ConnMaxIdleTime: getDurationEnv("DB_CONN_MAX_IDLE_TIME", 5*time.Minute),
		},
		Redis: RedisConfig{
			Host:         getEnv("REDIS_HOST", "localhost"),
			Port:         getIntEnv("REDIS_PORT", 6379),
			Password:     getEnv("REDIS_PASSWORD", ""),
			DB:           getIntEnv("REDIS_DB", 1), // Use DB 1 for world events
			PoolSize:     getIntEnv("REDIS_POOL_SIZE", 25),
			MinIdleConns: getIntEnv("REDIS_MIN_IDLE_CONNS", 8),
		},
		Kafka: KafkaConfig{
			Brokers:           getStringSliceEnv("KAFKA_BROKERS", []string{"localhost:9092"}),
			ClientID:          getEnv("KAFKA_CLIENT_ID", "world-events-service"),
			GroupID:           getEnv("KAFKA_GROUP_ID", "world-events-group"),
			SessionTimeout:    getDurationEnv("KAFKA_SESSION_TIMEOUT", 10*time.Second),
			HeartbeatInterval: getDurationEnv("KAFKA_HEARTBEAT_INTERVAL", 3*time.Second),
			RebalanceTimeout:  getDurationEnv("KAFKA_REBALANCE_TIMEOUT", 60*time.Second),
			AutoOffsetReset:   getEnv("KAFKA_AUTO_OFFSET_RESET", "latest"),
			EnableAutoCommit:  getBoolEnv("KAFKA_ENABLE_AUTO_COMMIT", true),
			FlushFrequency:    getDurationEnv("KAFKA_FLUSH_FREQUENCY", 500*time.Millisecond),
			FlushMessages:     getIntEnv("KAFKA_FLUSH_MESSAGES", 100),
			FlushBytes:        getIntEnv("KAFKA_FLUSH_BYTES", 1048576), // 1MB
			MaxMessageBytes:   getIntEnv("KAFKA_MAX_MESSAGE_BYTES", 1048576), // 1MB
			RequiredAcks:      getIntEnv("KAFKA_REQUIRED_ACKS", 1),
			RetryMax:          getIntEnv("KAFKA_RETRY_MAX", 3),
			RetryBackoff:      getDurationEnv("KAFKA_RETRY_BACKOFF", 100*time.Millisecond),
			SASL: SASLConfig{
				Enable:   getBoolEnv("KAFKA_SASL_ENABLE", false),
				User:     getEnv("KAFKA_SASL_USER", ""),
				Password: getEnv("KAFKA_SASL_PASSWORD", ""),
			},
			TLS: TLSConfig{
				Enable: getBoolEnv("KAFKA_TLS_ENABLE", false),
				Cert:   getEnv("KAFKA_TLS_CERT", ""),
				Key:    getEnv("KAFKA_TLS_KEY", ""),
				CA:     getEnv("KAFKA_TLS_CA", ""),
			},
		},
		WorldEvents: WorldEventsConfig{
			EventCheckInterval:   getDurationEnv("WORLD_EVENTS_CHECK_INTERVAL", 30*time.Second),
			MaxConcurrentEvents:  getIntEnv("WORLD_EVENTS_MAX_CONCURRENT", 10),
			EventBufferSize:      getIntEnv("WORLD_EVENTS_BUFFER_SIZE", 1000),
			SchedulerPoolSize:    getIntEnv("WORLD_EVENTS_SCHEDULER_POOL_SIZE", 5),
			RegionSyncInterval:   getDurationEnv("WORLD_EVENTS_REGION_SYNC", 60*time.Second),
			EventHistoryRetention: getDurationEnv("WORLD_EVENTS_HISTORY_RETENTION", 30*24*time.Hour),
			DefaultEventDuration: getDurationEnv("WORLD_EVENTS_DEFAULT_DURATION", 2*time.Hour),
			MaxEventDuration:     getDurationEnv("WORLD_EVENTS_MAX_DURATION", 24*time.Hour),
			MinEventDuration:     getDurationEnv("WORLD_EVENTS_MIN_DURATION", 15*time.Minute),
			CooldownPeriod:       getDurationEnv("WORLD_EVENTS_COOLDOWN", 4*time.Hour),

			// Event categories
			NaturalDisastersEnabled: getBoolEnv("WORLD_EVENTS_NATURAL_DISASTERS", true),
			FestivalsEnabled:        getBoolEnv("WORLD_EVENTS_FESTIVALS", true),
			InvasionsEnabled:        getBoolEnv("WORLD_EVENTS_INVASIONS", true),
			TradeEventsEnabled:      getBoolEnv("WORLD_EVENTS_TRADE_EVENTS", true),
			SeasonalEventsEnabled:   getBoolEnv("WORLD_EVENTS_SEASONAL_EVENTS", true),
			RandomEventsEnabled:     getBoolEnv("WORLD_EVENTS_RANDOM_EVENTS", true),

			// Event probabilities
			NaturalDisasterChance: getFloat64Env("WORLD_EVENTS_DISASTER_CHANCE", 0.05),
			FestivalChance:        getFloat64Env("WORLD_EVENTS_FESTIVAL_CHANCE", 0.1),
			InvasionChance:        getFloat64Env("WORLD_EVENTS_INVASION_CHANCE", 0.08),
			TradeEventChance:      getFloat64Env("WORLD_EVENTS_TRADE_CHANCE", 0.15),
			SeasonalEventChance:   getFloat64Env("WORLD_EVENTS_SEASONAL_CHANCE", 0.03),
			RandomEventChance:     getFloat64Env("WORLD_EVENTS_RANDOM_CHANCE", 0.2),
		},
		Security: SecurityConfig{
			EnableEncryption: getBoolEnv("WORLD_EVENTS_ENCRYPTION_ENABLED", false),
			EncryptionKey:    getEnv("WORLD_EVENTS_ENCRYPTION_KEY", ""),
			AllowedTopics:    getStringSliceEnv("WORLD_EVENTS_ALLOWED_TOPICS", []string{}),
			RateLimitEvents:  getIntEnv("WORLD_EVENTS_RATE_LIMIT_EVENTS", 1000),
			RateLimitWindow:  getDurationEnv("WORLD_EVENTS_RATE_LIMIT_WINDOW", time.Minute),
		},
	}

	return cfg
}

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getIntEnv(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getFloat64Env(key string, defaultValue float64) float64 {
	if value := os.Getenv(key); value != "" {
		if floatValue, err := strconv.ParseFloat(value, 64); err == nil {
			return floatValue
		}
	}
	return defaultValue
}

func getBoolEnv(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}

func getStringSliceEnv(key string, defaultValue []string) []string {
	if value := os.Getenv(key); value != "" {
		return strings.Split(value, ",")
	}
	return defaultValue
}