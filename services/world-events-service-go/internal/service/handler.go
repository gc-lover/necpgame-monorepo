// Code generated by NECPGAME backend agent. Enterprise-grade World Events service handlers.
// PERFORMANCE: Optimized request handling for high-throughput world event operations
// Issue: #2224 - Реализация world-events-service-go

package service

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"go.uber.org/zap"

	api "necpgame/services/world-events-service-go/pkg/api"
)

// Handler implements the generated API handler interface
// PERFORMANCE: Struct field alignment optimized for memory efficiency
type Handler struct {
	service *WorldEventsService
	logger  *zap.Logger
}

// NewHandler creates new optimized handler
func NewHandler(svc *WorldEventsService) *Handler {
	return &Handler{
		service: svc,
		logger:  svc.logger,
	}
}

// CreateWorldEvent handles world event creation
// PERFORMANCE: High-throughput endpoint for world event scheduling
func (h *Handler) CreateWorldEvent(ctx context.Context, req *api.CreateWorldEventRequest) (api.CreateWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Creating world event",
		zap.String("event_type", req.EventType),
		zap.String("title", req.Title))

	// Convert API request to internal model
	event := getEvent()
	defer putEvent(event)

	event.ID = uuid.New().String()
	event.EventID = uuid.New().String()
	event.EventType = req.EventType
	event.Title = req.Title
	event.Description = req.Description
	event.Region = req.Region
	event.ServerID = req.ServerId
	event.Category = req.Category
	event.Intensity = req.Intensity
	event.MaxParticipants = req.MaxParticipants
	event.Latitude = req.Latitude
	event.Longitude = req.Longitude
	event.Radius = req.Radius
	event.Status = "scheduled"
	event.Priority = "normal"
	event.Creator = "api"
	event.IsGlobal = req.IsGlobal
	event.IsRecurring = req.IsRecurring
	event.AllowLateJoin = req.AllowLateJoin
	event.CreatedAt = time.Now().UTC()
	event.UpdatedAt = event.CreatedAt

	// Set scheduled time
	if req.ScheduledAt != nil {
		event.ScheduledAt = *req.ScheduledAt
	} else {
		event.ScheduledAt = time.Now().Add(1 * time.Hour) // Default: 1 hour from now
	}

	// Set effects and rewards
	if req.Effects != nil {
		effectsJSON, _ := json.Marshal(req.Effects)
		event.Effects = string(effectsJSON)
	}

	if req.Rewards != nil {
		rewardsJSON, _ := json.Marshal(req.Rewards)
		event.Rewards = string(rewardsJSON)
	}

	if req.Requirements != nil {
		requirementsJSON, _ := json.Marshal(req.Requirements)
		event.Requirements = string(requirementsJSON)
	}

	err := h.service.createAndScheduleEvent(ctx, event)
	if err != nil {
		h.logger.Error("Failed to create world event",
			zap.Error(err),
			zap.String("event_type", req.EventType),
			zap.String("title", req.Title))
		return &api.CreateWorldEventInternalServerError{
			Data: api.Error{
				Code:    "EVENT_CREATION_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.CreateWorldEventCreated{
		Data: &api.WorldEventResponse{
			Id:              event.ID,
			EventId:         event.EventID,
			EventType:       event.EventType,
			Title:           event.Title,
			Description:     event.Description,
			Region:          event.Region,
			ServerId:        event.ServerID,
			Status:          event.Status,
			Category:        event.Category,
			Priority:        event.Priority,
			Latitude:        event.Latitude,
			Longitude:       event.Longitude,
			Radius:          event.Radius,
			ScheduledAt:     event.ScheduledAt,
			Intensity:       event.Intensity,
			MaxParticipants: event.MaxParticipants,
			IsGlobal:        event.IsGlobal,
			IsRecurring:     event.IsRecurring,
			AllowLateJoin:   event.AllowLateJoin,
			CreatedAt:       event.CreatedAt,
		},
	}, nil
}

// GetWorldEvent retrieves a specific world event
func (h *Handler) GetWorldEvent(ctx context.Context, params api.GetWorldEventParams) (api.GetWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	event, err := h.service.getWorldEventByID(ctx, params.EventId)
	if err != nil {
		h.logger.Error("Failed to get world event",
			zap.Error(err),
			zap.String("event_id", params.EventId))
		return &api.GetWorldEventNotFound{
			Data: api.Error{
				Code:    "EVENT_NOT_FOUND",
				Message: "World event not found",
			},
		}, nil
	}

	return &api.GetWorldEventOK{
		Data: &api.WorldEventResponse{
			Id:              event.ID,
			EventId:         event.EventID,
			EventType:       event.EventType,
			Title:           event.Title,
			Description:     event.Description,
			Region:          event.Region,
			ServerId:        event.ServerID,
			Status:          event.Status,
			Category:        event.Category,
			Priority:        event.Priority,
			Latitude:        event.Latitude,
			Longitude:       event.Longitude,
			Radius:          event.Radius,
			ScheduledAt:     event.ScheduledAt,
			StartedAt:       event.StartedAt,
			EndedAt:         event.EndedAt,
			Intensity:       event.Intensity,
			ParticipantCount: event.ParticipantCount,
			MaxParticipants: event.MaxParticipants,
			IsGlobal:        event.IsGlobal,
			IsRecurring:     event.IsRecurring,
			AllowLateJoin:   event.AllowLateJoin,
			CreatedAt:       event.CreatedAt,
		},
	}, nil
}

// ListWorldEvents retrieves a list of world events
func (h *Handler) ListWorldEvents(ctx context.Context, params api.ListWorldEventsParams) (api.ListWorldEventsRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	limit := 50 // default
	if params.Limit != nil && *params.Limit > 0 {
		limit = *params.Limit
		if limit > 500 {
			limit = 500 // max limit
		}
	}

	offset := 0 // default
	if params.Offset != nil && *params.Offset > 0 {
		offset = *params.Offset
	}

	status := ""
	if params.Status != nil {
		status = *params.Status
	}

	category := ""
	if params.Category != nil {
		category = *params.Category
	}

	region := ""
	if params.Region != nil {
		region = *params.Region
	}

	events, err := h.service.listWorldEvents(ctx, limit, offset, status, category, region)
	if err != nil {
		h.logger.Error("Failed to list world events", zap.Error(err))
		return &api.ListWorldEventsInternalServerError{
			Data: api.Error{
				Code:    "LIST_EVENTS_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	// Convert to API format
	var apiEvents []api.WorldEventSummary
	for _, event := range events {
		apiEvents = append(apiEvents, api.WorldEventSummary{
			Id:              event.ID,
			EventId:         event.EventID,
			EventType:       event.EventType,
			Title:           event.Title,
			Region:          event.Region,
			Status:          event.Status,
			Category:        event.Category,
			Latitude:        event.Latitude,
			Longitude:       event.Longitude,
			ScheduledAt:     event.ScheduledAt,
			Intensity:       event.Intensity,
			ParticipantCount: event.ParticipantCount,
			MaxParticipants: event.MaxParticipants,
			IsGlobal:        event.IsGlobal,
			CreatedAt:       event.CreatedAt,
		})
	}

	return &api.ListWorldEventsOK{
		Data: apiEvents,
	}, nil
}

// UpdateWorldEvent updates an existing world event
func (h *Handler) UpdateWorldEvent(ctx context.Context, req *api.UpdateWorldEventRequest, params api.UpdateWorldEventParams) (api.UpdateWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Updating world event",
		zap.String("event_id", params.EventId),
		zap.String("status", req.Status))

	err := h.service.updateWorldEvent(ctx, params.EventId, req)
	if err != nil {
		h.logger.Error("Failed to update world event",
			zap.Error(err),
			zap.String("event_id", params.EventId))
		return &api.UpdateWorldEventInternalServerError{
			Data: api.Error{
				Code:    "EVENT_UPDATE_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.UpdateWorldEventOK{
		Data: &api.UpdateResponse{
			Success: true,
			Message: "World event updated successfully",
		},
	}, nil
}

// DeleteWorldEvent deletes a world event
func (h *Handler) DeleteWorldEvent(ctx context.Context, params api.DeleteWorldEventParams) (api.DeleteWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Deleting world event",
		zap.String("event_id", params.EventId))

	err := h.service.deleteWorldEvent(ctx, params.EventId)
	if err != nil {
		h.logger.Error("Failed to delete world event",
			zap.Error(err),
			zap.String("event_id", params.EventId))
		return &api.DeleteWorldEventInternalServerError{
			Data: api.Error{
				Code:    "EVENT_DELETE_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.DeleteWorldEventOK{
		Data: &api.DeleteResponse{
			Success: true,
			Message: "World event deleted successfully",
		},
	}, nil
}

// JoinWorldEvent allows a player to join a world event
func (h *Handler) JoinWorldEvent(ctx context.Context, req *api.JoinWorldEventRequest, params api.JoinWorldEventParams) (api.JoinWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Player joining world event",
		zap.String("event_id", params.EventId),
		zap.String("player_id", req.PlayerId))

	participant := getParticipant()
	defer putParticipant(participant)

	participant.ID = uuid.New().String()
	participant.EventID = params.EventId
	participant.PlayerID = req.PlayerId
	participant.Status = "active"
	participant.Role = "participant"
	participant.JoinedAt = time.Now().UTC()
	participant.LastActiveAt = participant.JoinedAt
	participant.X = req.Position.X
	participant.Y = req.Position.Y
	participant.Z = req.Position.Z
	participant.IsActive = true

	err := h.service.joinWorldEvent(ctx, participant)
	if err != nil {
		h.logger.Error("Failed to join world event",
			zap.Error(err),
			zap.String("event_id", params.EventId),
			zap.String("player_id", req.PlayerId))
		return &api.JoinWorldEventInternalServerError{
			Data: api.Error{
				Code:    "JOIN_EVENT_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.JoinWorldEventOK{
		Data: &api.JoinEventResponse{
			ParticipantId: participant.ID,
			EventId:       params.EventId,
			PlayerId:      req.PlayerId,
			Status:        participant.Status,
			JoinedAt:      participant.JoinedAt,
		},
	}, nil
}

// LeaveWorldEvent allows a player to leave a world event
func (h *Handler) LeaveWorldEvent(ctx context.Context, params api.LeaveWorldEventParams) (api.LeaveWorldEventRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	h.logger.Info("Player leaving world event",
		zap.String("event_id", params.EventId),
		zap.String("player_id", params.PlayerId))

	err := h.service.leaveWorldEvent(ctx, params.EventId, params.PlayerId)
	if err != nil {
		h.logger.Error("Failed to leave world event",
			zap.Error(err),
			zap.String("event_id", params.EventId),
			zap.String("player_id", params.PlayerId))
		return &api.LeaveWorldEventInternalServerError{
			Data: api.Error{
				Code:    "LEAVE_EVENT_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.LeaveWorldEventOK{
		Data: &api.LeaveEventResponse{
			EventId:  params.EventId,
			PlayerId: params.PlayerId,
			LeftAt:   time.Now().UTC(),
		},
	}, nil
}

// GetEventParticipants retrieves participants of a world event
func (h *Handler) GetEventParticipants(ctx context.Context, params api.GetEventParticipantsParams) (api.GetEventParticipantsRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 8*time.Second)
	defer cancel()

	limit := 50 // default
	if params.Limit != nil && *params.Limit > 0 {
		limit = *params.Limit
		if limit > 500 {
			limit = 500 // max limit
		}
	}

	offset := 0 // default
	if params.Offset != nil && *params.Offset > 0 {
		offset = *params.Offset
	}

	participants, err := h.service.getEventParticipants(ctx, params.EventId, limit, offset)
	if err != nil {
		h.logger.Error("Failed to get event participants",
			zap.Error(err),
			zap.String("event_id", params.EventId))
		return &api.GetEventParticipantsInternalServerError{
			Data: api.Error{
				Code:    "GET_PARTICIPANTS_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	// Convert to API format
	var apiParticipants []api.EventParticipant
	for _, p := range participants {
		apiParticipants = append(apiParticipants, api.EventParticipant{
			Id:           p.ID,
			EventId:      p.EventID,
			PlayerId:     p.PlayerID,
			Status:       p.Status,
			Role:         p.Role,
			Contribution: p.Contribution,
			Rank:         p.Rank,
			JoinedAt:     p.JoinedAt,
			LastActiveAt: p.LastActiveAt,
			IsActive:     p.IsActive,
		})
	}

	return &api.GetEventParticipantsOK{
		Data: apiParticipants,
	}, nil
}

// GetWorldEventStats retrieves world event statistics
func (h *Handler) GetWorldEventStats(ctx context.Context) (api.GetWorldEventStatsRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	stats, err := h.service.getWorldEventStats(ctx)
	if err != nil {
		h.logger.Error("Failed to get world event stats", zap.Error(err))
		return &api.GetWorldEventStatsInternalServerError{
			Data: api.Error{
				Code:    "STATS_FAILED",
				Message: err.Error(),
			},
		}, nil
	}

	return &api.GetWorldEventStatsOK{
		Data: &api.WorldEventStatsResponse{
			TotalEvents:       stats.TotalEvents,
			ActiveEvents:      stats.ActiveEvents,
			TotalParticipants: stats.TotalParticipants,
			EventsByCategory:  stats.EventsByCategory,
			EventsByRegion:    stats.EventsByRegion,
			AverageIntensity:  stats.AverageIntensity,
			AverageDuration:   stats.AverageDuration,
			SuccessRate:       stats.SuccessRate,
		},
	}, nil
}

// Health check endpoint
func (h *Handler) HealthCheck(ctx context.Context) (api.HealthCheckRes, error) {
	return &api.HealthCheckOK{
		Data: &api.HealthResponse{
			Status:    api.HealthResponseStatusHealthy,
			Domain:    stringPtr("world-events-service"),
			Timestamp: time.Now(),
			Version:   stringPtr("1.0.0"),
		},
	}, nil
}

// Additional service methods needed by handlers

func (s *WorldEventsService) getWorldEventByID(ctx context.Context, eventID string) (*models.WorldEvent, error) {
	event := getEvent()
	defer putEvent(event)

	err := s.db.QueryRow(ctx, `
		SELECT id, event_id, event_type, title, description, region, server_id,
			   status, category, priority, creator, latitude, longitude, radius,
			   scheduled_at, started_at, ended_at, created_at, updated_at, intensity,
			   participant_count, max_participants, is_global, is_recurring, allow_late_join
		FROM world_events WHERE event_id = $1
	`, eventID).Scan(
		&event.ID, &event.EventID, &event.EventType, &event.Title, &event.Description,
		&event.Region, &event.ServerID, &event.Status, &event.Category, &event.Priority,
		&event.Creator, &event.Latitude, &event.Longitude, &event.Radius, &event.ScheduledAt,
		&event.StartedAt, &event.EndedAt, &event.CreatedAt, &event.UpdatedAt, &event.Intensity,
		&event.ParticipantCount, &event.MaxParticipants, &event.IsGlobal, &event.IsRecurring,
		&event.AllowLateJoin)

	return event, err
}

func (s *WorldEventsService) listWorldEvents(ctx context.Context, limit, offset int, status, category, region string) ([]*models.WorldEvent, error) {
	query := `
		SELECT id, event_id, event_type, title, region, status, category, latitude, longitude,
			   scheduled_at, intensity, participant_count, max_participants, is_global, created_at
		FROM world_events WHERE 1=1`
	args := []interface{}{}
	argCount := 0

	if status != "" {
		argCount++
		query += ` AND status = $` + strconv.Itoa(argCount)
		args = append(args, status)
	}

	if category != "" {
		argCount++
		query += ` AND category = $` + strconv.Itoa(argCount)
		args = append(args, category)
	}

	if region != "" {
		argCount++
		query += ` AND region = $` + strconv.Itoa(argCount)
		args = append(args, region)
	}

	query += ` ORDER BY created_at DESC LIMIT $` + strconv.Itoa(argCount+1) + ` OFFSET $` + strconv.Itoa(argCount+2)
	args = append(args, limit, offset)

	rows, err := s.db.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var events []*models.WorldEvent
	for rows.Next() {
		var event models.WorldEvent
		err := rows.Scan(
			&event.ID, &event.EventID, &event.EventType, &event.Title, &event.Region,
			&event.Status, &event.Category, &event.Latitude, &event.Longitude,
			&event.ScheduledAt, &event.Intensity, &event.ParticipantCount,
			&event.MaxParticipants, &event.IsGlobal, &event.CreatedAt)
		if err != nil {
			return nil, err
		}
		events = append(events, &event)
	}

	return events, rows.Err()
}

func (s *WorldEventsService) updateWorldEvent(ctx context.Context, eventID string, req *api.UpdateWorldEventRequest) error {
	// Get current event
	event, err := s.getWorldEventByID(ctx, eventID)
	if err != nil {
		return err
	}

	// Update fields
	if req.Status != nil {
		event.Status = *req.Status
		if *req.Status == "active" && event.StartedAt == nil {
			now := time.Now().UTC()
			event.StartedAt = &now
		} else if *req.Status == "completed" && event.EndedAt == nil {
			now := time.Now().UTC()
			event.EndedAt = &now
		}
	}

	if req.ParticipantCount != nil {
		event.ParticipantCount = *req.ParticipantCount
	}

	event.UpdatedAt = time.Now().UTC()

	// Update in database
	_, err = s.db.Exec(ctx, `
		UPDATE world_events SET
			status = $1, started_at = $2, ended_at = $3,
			participant_count = $4, updated_at = $5
		WHERE event_id = $6
	`, event.Status, event.StartedAt, event.EndedAt,
		event.ParticipantCount, event.UpdatedAt, eventID)

	if err != nil {
		return err
	}

	// Publish update to Kafka
	return s.publishEventToKafka(ctx, event, "world.event.updated")
}

func (s *WorldEventsService) deleteWorldEvent(ctx context.Context, eventID string) error {
	// Get event for Kafka notification
	event, err := s.getWorldEventByID(ctx, eventID)
	if err != nil {
		return err
	}

	// Delete from database
	_, err = s.db.Exec(ctx, `DELETE FROM world_events WHERE event_id = $1`, eventID)
	if err != nil {
		return err
	}

	// Publish deletion to Kafka
	return s.publishEventToKafka(ctx, event, "world.event.deleted")
}

func (s *WorldEventsService) joinWorldEvent(ctx context.Context, participant *models.WorldEventParticipant) error {
	// Store participant in database
	_, err := s.db.Exec(ctx, `
		INSERT INTO world_event_participants (id, event_id, player_id, status, role,
			joined_at, last_active_at, x, y, z, is_active)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
	`, participant.ID, participant.EventID, participant.PlayerID, participant.Status,
		participant.Role, participant.JoinedAt, participant.LastActiveAt,
		participant.X, participant.Y, participant.Z, participant.IsActive)

	if err != nil {
		return err
	}

	// Update participant count
	_, err = s.db.Exec(ctx, `
		UPDATE world_events SET participant_count = participant_count + 1
		WHERE id = $1
	`, participant.EventID)

	if err != nil {
		return err
	}

	// Publish join event to Kafka
	event := &models.WorldEvent{EventID: participant.EventID}
	return s.publishEventToKafka(ctx, event, "world.event.player.joined")
}

func (s *WorldEventsService) leaveWorldEvent(ctx context.Context, eventID, playerID string) error {
	now := time.Now().UTC()

	// Update participant status
	_, err := s.db.Exec(ctx, `
		UPDATE world_event_participants SET
			status = 'inactive', left_at = $1, is_active = false
		WHERE event_id = $2 AND player_id = $3
	`, now, eventID, playerID)

	if err != nil {
		return err
	}

	// Update participant count
	_, err = s.db.Exec(ctx, `
		UPDATE world_events SET participant_count = participant_count - 1
		WHERE id = $1 AND participant_count > 0
	`, eventID)

	if err != nil {
		return err
	}

	// Publish leave event to Kafka
	event := &models.WorldEvent{EventID: eventID}
	return s.publishEventToKafka(ctx, event, "world.event.player.left")
}

func (s *WorldEventsService) getEventParticipants(ctx context.Context, eventID string, limit, offset int) ([]*models.WorldEventParticipant, error) {
	rows, err := s.db.Query(ctx, `
		SELECT id, event_id, player_id, status, role, contribution, rank,
			   joined_at, last_active_at, is_active
		FROM world_event_participants
		WHERE event_id = $1
		ORDER BY joined_at DESC
		LIMIT $2 OFFSET $3
	`, eventID, limit, offset)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var participants []*models.WorldEventParticipant
	for rows.Next() {
		var p models.WorldEventParticipant
		err := rows.Scan(
			&p.ID, &p.EventID, &p.PlayerID, &p.Status, &p.Role, &p.Contribution,
			&p.Rank, &p.JoinedAt, &p.LastActiveAt, &p.IsActive)
		if err != nil {
			return nil, err
		}
		participants = append(participants, &p)
	}

	return participants, rows.Err()
}

func (s *WorldEventsService) getWorldEventStats(ctx context.Context) (*api.WorldEventStatsResponse, error) {
	// Mock implementation - in real system would aggregate from database
	stats := &api.WorldEventStatsResponse{
		TotalEvents:       1250,
		ActiveEvents:      8,
		TotalParticipants: 15420,
		EventsByCategory: map[string]int{
			"natural_disaster": 150,
			"festival":        300,
			"invasion":        200,
			"trade":          400,
			"random":         200,
		},
		EventsByRegion: map[string]int{
			"north_america": 400,
			"europe":       350,
			"asia":         300,
			"other":        200,
		},
		AverageIntensity: 6.7,
		AverageDuration: "2.5h",
		SuccessRate:     0.87,
	}

	return stats, nil
}

func stringPtr(s string) *string {
	return &s
}