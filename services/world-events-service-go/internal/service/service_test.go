// Code generated by NECPGAME backend agent. Comprehensive world events service tests.
// PERFORMANCE: Tests validate enterprise-grade world event scheduling and processing

package service

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestWorldEventsService_EventCreation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupWorldEventsTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("create natural disaster event", func(t *testing.T) {
		event := svc.createBaseEvent("earthquake", "Major Earthquake", "natural_disaster")
		event.Intensity = 8
		event.Latitude = 45.5
		event.Longitude = -122.3
		event.Radius = 5000

		err := svc.createAndScheduleEvent(ctx, event)
		require.NoError(t, err)

		assert.NotEmpty(t, event.ID)
		assert.Equal(t, "earthquake", event.EventType)
		assert.Equal(t, "natural_disaster", event.Category)
		assert.Equal(t, 8, event.Intensity)
		assert.True(t, event.Radius > 0)
	})

	t.Run("create festival event", func(t *testing.T) {
		event := svc.createBaseEvent("victory_parade", "Victory Parade", "festival")
		event.Intensity = 6
		event.MaxParticipants = 1000

		err := svc.createAndScheduleEvent(ctx, event)
		require.NoError(t, err)

		assert.Equal(t, "victory_parade", event.EventType)
		assert.Equal(t, "festival", event.Category)
		assert.Equal(t, 1000, event.MaxParticipants)
	})
}

func TestWorldEventsService_EventParticipation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupWorldEventsTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test event
	event := svc.createBaseEvent("test_event", "Test Event", "random")
	err := svc.createAndScheduleEvent(ctx, event)
	require.NoError(t, err)

	t.Run("player joins event", func(t *testing.T) {
		participant := getParticipant()
		defer putParticipant(participant)

		participant.EventID = event.ID
		participant.PlayerID = "test_player_" + uuid.New().String()[:8]
		participant.Status = "active"
		participant.X = 100.5
		participant.Y = 200.3
		participant.Z = 50.0

		err := svc.joinWorldEvent(ctx, participant)
		require.NoError(t, err)

		assert.NotEmpty(t, participant.ID)
		assert.Equal(t, "active", participant.Status)
		assert.True(t, participant.IsActive)
	})

	t.Run("player leaves event", func(t *testing.T) {
		playerID := "test_player_" + uuid.New().String()[:8]

		// First join
		participant := getParticipant()
		participant.EventID = event.ID
		participant.PlayerID = playerID
		err := svc.joinWorldEvent(ctx, participant)
		require.NoError(t, err)

		// Then leave
		err = svc.leaveWorldEvent(ctx, event.ID, playerID)
		require.NoError(t, err)
	})
}

func TestWorldEventsService_EventScheduling(t *testing.T) {
	svc := &WorldEventsService{}

	t.Run("event generation probabilities", func(t *testing.T) {
		// Test natural disaster generation
		event := svc.createBaseEvent("earthquake", "Earthquake", "natural_disaster")
		assert.Equal(t, "earthquake", event.EventType)
		assert.True(t, event.Radius > 0)
		assert.True(t, event.Intensity > 0)
	})

	t.Run("festival generation", func(t *testing.T) {
		event := svc.createBaseEvent("harvest_festival", "Harvest Festival", "festival")
		assert.Equal(t, "harvest_festival", event.EventType)
		assert.Equal(t, "festival", event.Category)
	})
}

func TestWorldEventsService_EventLifecycle(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupWorldEventsTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("event status updates", func(t *testing.T) {
		// Create event
		event := svc.createBaseEvent("test_lifecycle", "Test Lifecycle", "random")
		err := svc.createAndScheduleEvent(ctx, event)
		require.NoError(t, err)

		// Update to active
		updateReq := &api.UpdateWorldEventRequest{
			Status: stringPtr("active"),
		}
		err = svc.updateWorldEvent(ctx, event.EventID, updateReq)
		require.NoError(t, err)

		// Verify status update
		updatedEvent, err := svc.getWorldEventByID(ctx, event.EventID)
		require.NoError(t, err)
		assert.Equal(t, "active", updatedEvent.Status)
		assert.NotNil(t, updatedEvent.StartedAt)
	})
}

func TestWorldEventsService_EventFiltering(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	svc := setupWorldEventsTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	// Create test events
	events := []*models.WorldEvent{
		svc.createBaseEvent("earthquake", "Earthquake", "natural_disaster"),
		svc.createBaseEvent("festival", "Festival", "festival"),
		svc.createBaseEvent("invasion", "Invasion", "invasion"),
	}

	for _, event := range events {
		err := svc.createAndScheduleEvent(ctx, event)
		require.NoError(t, err)
	}

	t.Run("filter by category", func(t *testing.T) {
		disasterEvents, err := svc.listWorldEvents(ctx, 50, 0, "", "natural_disaster", "")
		require.NoError(t, err)

		assert.True(t, len(disasterEvents) > 0)
		for _, event := range disasterEvents {
			assert.Equal(t, "natural_disaster", event.Category)
		}
	})

	t.Run("filter by status", func(t *testing.T) {
		scheduledEvents, err := svc.listWorldEvents(ctx, 50, 0, "scheduled", "", "")
		require.NoError(t, err)

		assert.True(t, len(scheduledEvents) > 0)
		for _, event := range scheduledEvents {
			assert.Equal(t, "scheduled", event.Status)
		}
	})
}

func TestWorldEventsService_Performance(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping performance test in short mode")
	}

	svc := setupWorldEventsTestService(t)
	defer svc.Shutdown(context.Background())

	ctx := context.Background()

	t.Run("bulk event creation", func(t *testing.T) {
		eventCount := 50
		start := time.Now()

		for i := 0; i < eventCount; i++ {
			event := svc.createBaseEvent("perf_test", "Performance Test", "random")
			err := svc.createAndScheduleEvent(ctx, event)
			require.NoError(t, err)
		}

		duration := time.Since(start)
		avgTime := duration / time.Duration(eventCount)

		t.Logf("Created %d events in %v (avg: %v per event)", eventCount, duration, avgTime)

		// Should be under 100ms per event
		assert.True(t, avgTime < 100*time.Millisecond,
			"Average creation time %v exceeds 100ms limit", avgTime)
	})

	t.Run("concurrent participation", func(t *testing.T) {
		// Create test event
		event := svc.createBaseEvent("concurrency_test", "Concurrency Test", "random")
		err := svc.createAndScheduleEvent(ctx, event)
		require.NoError(t, err)

		playerCount := 20
		start := time.Now()

		// Simulate concurrent joins
		for i := 0; i < playerCount; i++ {
			go func(playerIndex int) {
				participant := getParticipant()
				participant.EventID = event.ID
				participant.PlayerID = fmt.Sprintf("player_%d", playerIndex)
				svc.joinWorldEvent(ctx, participant)
				putParticipant(participant)
			}(i)
		}

		// Wait a bit for goroutines
		time.Sleep(100 * time.Millisecond)

		duration := time.Since(start)
		t.Logf("Processed %d concurrent joins in %v", playerCount, duration)

		// Verify participant count
		participants, err := svc.getEventParticipants(ctx, event.ID, 100, 0)
		require.NoError(t, err)
		assert.True(t, len(participants) > 0)
	})
}

func BenchmarkWorldEventsService_EventCreation(b *testing.B) {
	svc := &WorldEventsService{}

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			event := svc.createBaseEvent("benchmark", "Benchmark Event", "random")
			// Just test object creation, not database operations
			assert.NotEmpty(b, event.ID)
			putEvent(event)
		}
	})
}

func BenchmarkWorldEventsService_EventParticipation(b *testing.B) {
	svc := &WorldEventsService{}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		participant := getParticipant()
		participant.EventID = "test-event-id"
		participant.PlayerID = fmt.Sprintf("player_%d", i)
		participant.X = float64(i % 1000)
		participant.Y = float64((i / 1000) % 1000)
		participant.Z = float64(i % 100)
		putParticipant(participant)
	}
}

// Test utilities

func setupWorldEventsTestService(t *testing.T) *WorldEventsService {
	// Use test database configuration
	config := Config{
		Logger:      zap.NewNop(),
		Tracer:      nil,
		Meter:       nil,
		DatabaseURL: "postgres://postgres:postgres@localhost:5432/necpgame_test?sslmode=disable",
		RedisURL:    "redis://localhost:6379/2", // Use DB 2 for world events tests
		KafkaBrokers: "localhost:9092", // Single broker for testing
	}

	svc, err := NewWorldEventsService(config)
	require.NoError(t, err)

	// Setup test database schema
	setupWorldEventsTestDatabase(t, svc)

	return svc
}

func setupWorldEventsTestDatabase(t *testing.T, svc *WorldEventsService) {
	// Create test tables if they don't exist
	_, err := svc.db.Exec(context.Background(), `
		CREATE TABLE IF NOT EXISTS world_events (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			event_id VARCHAR(100) UNIQUE,
			event_type VARCHAR(50),
			title VARCHAR(255),
			description TEXT,
			region VARCHAR(100),
			server_id VARCHAR(50),
			status VARCHAR(20) DEFAULT 'scheduled',
			category VARCHAR(20),
			priority VARCHAR(10) DEFAULT 'normal',
			creator VARCHAR(50) DEFAULT 'system',
			latitude DECIMAL(10,6),
			longitude DECIMAL(10,6),
			radius DECIMAL(10,2) DEFAULT 1000,
			scheduled_at TIMESTAMP WITH TIME ZONE,
			started_at TIMESTAMP WITH TIME ZONE,
			ended_at TIMESTAMP WITH TIME ZONE,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			intensity INTEGER DEFAULT 5,
			participant_count INTEGER DEFAULT 0,
			max_participants INTEGER DEFAULT 100,
			is_global BOOLEAN DEFAULT false,
			is_recurring BOOLEAN DEFAULT false,
			allow_late_join BOOLEAN DEFAULT true,
			effects JSONB,
			rewards JSONB,
			requirements JSONB
		);

		CREATE TABLE IF NOT EXISTS world_event_participants (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			event_id UUID,
			player_id VARCHAR(50),
			status VARCHAR(20) DEFAULT 'active',
			role VARCHAR(20) DEFAULT 'participant',
			contribution INTEGER DEFAULT 0,
			rank INTEGER,
			joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			last_active_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			left_at TIMESTAMP WITH TIME ZONE,
			x DECIMAL(10,2),
			y DECIMAL(10,2),
			z DECIMAL(10,2),
			stats JSONB,
			achievements JSONB,
			is_active BOOLEAN DEFAULT true
		);

		CREATE TABLE IF NOT EXISTS world_event_templates (
			id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			template_id VARCHAR(50) UNIQUE,
			name VARCHAR(100),
			description TEXT,
			event_type VARCHAR(50),
			category VARCHAR(20),
			base_intensity INTEGER DEFAULT 5,
			base_duration INTEGER DEFAULT 7200,
			max_participants INTEGER DEFAULT 100,
			spawn_chance DECIMAL(3,2) DEFAULT 0.1,
			cooldown_hours INTEGER DEFAULT 24,
			status VARCHAR(20) DEFAULT 'active',
			season VARCHAR(20) DEFAULT 'any',
			time_of_day VARCHAR(20) DEFAULT 'any',
			is_enabled BOOLEAN DEFAULT true,
			is_global BOOLEAN DEFAULT false,
			is_recurring BOOLEAN DEFAULT false,
			config JSONB,
			effects JSONB,
			rewards JSONB,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
		);

		-- Create indexes for performance
		CREATE INDEX IF NOT EXISTS idx_world_events_event_id ON world_events(event_id);
		CREATE INDEX IF NOT EXISTS idx_world_events_status ON world_events(status);
		CREATE INDEX IF NOT EXISTS idx_world_events_category ON world_events(category);
		CREATE INDEX IF NOT EXISTS idx_world_events_region ON world_events(region);
		CREATE INDEX IF NOT EXISTS idx_world_events_scheduled_at ON world_events(scheduled_at);
		CREATE INDEX IF NOT EXISTS idx_event_participants_event_id ON world_event_participants(event_id);
		CREATE INDEX IF NOT EXISTS idx_event_participants_player_id ON world_event_participants(player_id);
	`)
	require.NoError(t, err)

	// Clean up test data
	_, err = svc.db.Exec(context.Background(), `
		DELETE FROM world_event_participants WHERE player_id LIKE 'test_%' OR player_id LIKE 'player_%' OR player_id LIKE 'benchmark_%';
		DELETE FROM world_events WHERE event_type LIKE 'test_%' OR event_type LIKE 'perf_%' OR event_type LIKE 'benchmark_%' OR title LIKE 'Test%' OR title LIKE 'Performance%' OR title LIKE 'Concurrency%' OR title LIKE 'Benchmark%';
	`)
	require.NoError(t, err)
}

func stringPtr(s string) *string {
	return &s
}