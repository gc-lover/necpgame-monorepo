// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActiveEventsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEventsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TotalEvents.Set {
			e.FieldStart("totalEvents")
			s.TotalEvents.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.LastUpdated.Set {
			e.FieldStart("lastUpdated")
			s.LastUpdated.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfActiveEventsResponse = [4]string{
	0: "events",
	1: "totalEvents",
	2: "region",
	3: "lastUpdated",
}

// Decode decodes ActiveEventsResponse from json.
func (s *ActiveEventsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Events = make([]WorldEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorldEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "totalEvents":
			if err := func() error {
				s.TotalEvents.Reset()
				if err := s.TotalEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalEvents\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "lastUpdated":
			if err := func() error {
				s.LastUpdated.Reset()
				if err := s.LastUpdated.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEventsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEventsResponse) {
					name = jsonFieldsNameOfActiveEventsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEventsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("startTime")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateEventRequest = [9]string{
	0: "name",
	1: "type",
	2: "region",
	3: "startTime",
	4: "duration",
	5: "maxParticipants",
	6: "description",
	7: "objectives",
	8: "rewards",
}

// Decode decodes CreateEventRequest from json.
func (s *CreateEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateEventRequest) {
					name = jsonFieldsNameOfCreateEventRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEventRequestType as json.
func (s CreateEventRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateEventRequestType from json.
func (s *CreateEventRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateEventRequestType(v) {
	case CreateEventRequestTypeDISASTER:
		*s = CreateEventRequestTypeDISASTER
	case CreateEventRequestTypeFESTIVAL:
		*s = CreateEventRequestTypeFESTIVAL
	case CreateEventRequestTypeWAR:
		*s = CreateEventRequestTypeWAR
	case CreateEventRequestTypeINVASION:
		*s = CreateEventRequestTypeINVASION
	case CreateEventRequestTypeTOURNAMENT:
		*s = CreateEventRequestTypeTOURNAMENT
	case CreateEventRequestTypeQUEST:
		*s = CreateEventRequestTypeQUEST
	default:
		*s = CreateEventRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateEventRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateEventResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("created")
		e.Bool(s.Created)
	}
	{
		if s.ScheduledStart.Set {
			e.FieldStart("scheduledStart")
			s.ScheduledStart.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EstimatedEnd.Set {
			e.FieldStart("estimatedEnd")
			s.EstimatedEnd.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCreateEventResponse = [4]string{
	0: "eventId",
	1: "created",
	2: "scheduledStart",
	3: "estimatedEnd",
}

// Decode decodes CreateEventResponse from json.
func (s *CreateEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEventResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Created = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "scheduledStart":
			if err := func() error {
				s.ScheduledStart.Reset()
				if err := s.ScheduledStart.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduledStart\"")
			}
		case "estimatedEnd":
			if err := func() error {
				s.EstimatedEnd.Reset()
				if err := s.EstimatedEnd.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimatedEnd\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateEventResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateEventResponse) {
					name = jsonFieldsNameOfCreateEventResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorldEventBadRequest as json.
func (s *CreateWorldEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorldEventBadRequest from json.
func (s *CreateWorldEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorldEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorldEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorldEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorldEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorldEventForbidden as json.
func (s *CreateWorldEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorldEventForbidden from json.
func (s *CreateWorldEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorldEventForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorldEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorldEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorldEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorldEventInternalServerError as json.
func (s *CreateWorldEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorldEventInternalServerError from json.
func (s *CreateWorldEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorldEventInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorldEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorldEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorldEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EndEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EndEventResponse) encodeFields(e *jx.Encoder) {
	{
		if s.EventId.Set {
			e.FieldStart("eventId")
			s.EventId.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.EndedAt.Set {
			e.FieldStart("endedAt")
			s.EndedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TotalParticipants.Set {
			e.FieldStart("totalParticipants")
			s.TotalParticipants.Encode(e)
		}
	}
	{
		if s.RewardsDistributed.Set {
			e.FieldStart("rewardsDistributed")
			s.RewardsDistributed.Encode(e)
		}
	}
}

var jsonFieldsNameOfEndEventResponse = [5]string{
	0: "eventId",
	1: "status",
	2: "endedAt",
	3: "totalParticipants",
	4: "rewardsDistributed",
}

// Decode decodes EndEventResponse from json.
func (s *EndEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndEventResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			if err := func() error {
				s.EventId.Reset()
				if err := s.EventId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "endedAt":
			if err := func() error {
				s.EndedAt.Reset()
				if err := s.EndedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endedAt\"")
			}
		case "totalParticipants":
			if err := func() error {
				s.TotalParticipants.Reset()
				if err := s.TotalParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalParticipants\"")
			}
		case "rewardsDistributed":
			if err := func() error {
				s.RewardsDistributed.Reset()
				if err := s.RewardsDistributed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardsDistributed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EndEventResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EndEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndEventResponseStatus as json.
func (s EndEventResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EndEventResponseStatus from json.
func (s *EndEventResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndEventResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EndEventResponseStatus(v) {
	case EndEventResponseStatusEnded:
		*s = EndEventResponseStatusEnded
	case EndEventResponseStatusCancelled:
		*s = EndEventResponseStatusCancelled
	default:
		*s = EndEventResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EndEventResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndEventResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndWorldEventForbidden as json.
func (s *EndWorldEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes EndWorldEventForbidden from json.
func (s *EndWorldEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndWorldEventForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EndWorldEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EndWorldEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndWorldEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndWorldEventInternalServerError as json.
func (s *EndWorldEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes EndWorldEventInternalServerError from json.
func (s *EndWorldEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndWorldEventInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EndWorldEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EndWorldEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndWorldEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndWorldEventNotFound as json.
func (s *EndWorldEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes EndWorldEventNotFound from json.
func (s *EndWorldEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndWorldEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EndWorldEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EndWorldEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndWorldEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem ErrorDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfErrorDetails = [0]string{}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventAnalyticsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventAnalyticsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		if s.TotalEvents.Set {
			e.FieldStart("totalEvents")
			s.TotalEvents.Encode(e)
		}
	}
	{
		if s.ActiveEvents.Set {
			e.FieldStart("activeEvents")
			s.ActiveEvents.Encode(e)
		}
	}
	{
		if s.CompletedEvents.Set {
			e.FieldStart("completedEvents")
			s.CompletedEvents.Encode(e)
		}
	}
	{
		if s.TotalParticipants.Set {
			e.FieldStart("totalParticipants")
			s.TotalParticipants.Encode(e)
		}
	}
	{
		if s.AverageDuration.Set {
			e.FieldStart("averageDuration")
			s.AverageDuration.Encode(e)
		}
	}
	{
		if s.EventTypeBreakdown != nil {
			e.FieldStart("eventTypeBreakdown")
			s.EventTypeBreakdown.Encode(e)
		}
	}
	{
		if s.RegionBreakdown != nil {
			e.FieldStart("regionBreakdown")
			s.RegionBreakdown.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventAnalyticsResponse = [8]string{
	0: "period",
	1: "totalEvents",
	2: "activeEvents",
	3: "completedEvents",
	4: "totalParticipants",
	5: "averageDuration",
	6: "eventTypeBreakdown",
	7: "regionBreakdown",
}

// Decode decodes EventAnalyticsResponse from json.
func (s *EventAnalyticsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventAnalyticsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "totalEvents":
			if err := func() error {
				s.TotalEvents.Reset()
				if err := s.TotalEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalEvents\"")
			}
		case "activeEvents":
			if err := func() error {
				s.ActiveEvents.Reset()
				if err := s.ActiveEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeEvents\"")
			}
		case "completedEvents":
			if err := func() error {
				s.CompletedEvents.Reset()
				if err := s.CompletedEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedEvents\"")
			}
		case "totalParticipants":
			if err := func() error {
				s.TotalParticipants.Reset()
				if err := s.TotalParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalParticipants\"")
			}
		case "averageDuration":
			if err := func() error {
				s.AverageDuration.Reset()
				if err := s.AverageDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageDuration\"")
			}
		case "eventTypeBreakdown":
			if err := func() error {
				s.EventTypeBreakdown = nil
				var elem EventAnalyticsResponseEventTypeBreakdown
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.EventTypeBreakdown = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTypeBreakdown\"")
			}
		case "regionBreakdown":
			if err := func() error {
				s.RegionBreakdown = nil
				var elem EventAnalyticsResponseRegionBreakdown
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RegionBreakdown = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionBreakdown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventAnalyticsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventAnalyticsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventAnalyticsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventAnalyticsResponseEventTypeBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventAnalyticsResponseEventTypeBreakdown) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventAnalyticsResponseEventTypeBreakdown = [0]string{}

// Decode decodes EventAnalyticsResponseEventTypeBreakdown from json.
func (s *EventAnalyticsResponseEventTypeBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventAnalyticsResponseEventTypeBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventAnalyticsResponseEventTypeBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventAnalyticsResponseEventTypeBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventAnalyticsResponseEventTypeBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventAnalyticsResponsePeriod as json.
func (s EventAnalyticsResponsePeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventAnalyticsResponsePeriod from json.
func (s *EventAnalyticsResponsePeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventAnalyticsResponsePeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventAnalyticsResponsePeriod(v) {
	case EventAnalyticsResponsePeriodHOUR:
		*s = EventAnalyticsResponsePeriodHOUR
	case EventAnalyticsResponsePeriodDAY:
		*s = EventAnalyticsResponsePeriodDAY
	case EventAnalyticsResponsePeriodWEEK:
		*s = EventAnalyticsResponsePeriodWEEK
	case EventAnalyticsResponsePeriodMONTH:
		*s = EventAnalyticsResponsePeriodMONTH
	default:
		*s = EventAnalyticsResponsePeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventAnalyticsResponsePeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventAnalyticsResponsePeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventAnalyticsResponseRegionBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventAnalyticsResponseRegionBreakdown) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventAnalyticsResponseRegionBreakdown = [0]string{}

// Decode decodes EventAnalyticsResponseRegionBreakdown from json.
func (s *EventAnalyticsResponseRegionBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventAnalyticsResponseRegionBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventAnalyticsResponseRegionBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventAnalyticsResponseRegionBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventAnalyticsResponseRegionBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventDetailsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventDetailsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event")
		s.Event.Encode(e)
	}
	{
		if s.TimeRemaining.Set {
			e.FieldStart("timeRemaining")
			s.TimeRemaining.Encode(e)
		}
	}
	{
		if s.Leaderboard != nil {
			e.FieldStart("leaderboard")
			e.ArrStart()
			for _, elem := range s.Leaderboard {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEventDetailsResponse = [3]string{
	0: "event",
	1: "timeRemaining",
	2: "leaderboard",
}

// Decode decodes EventDetailsResponse from json.
func (s *EventDetailsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventDetailsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "timeRemaining":
			if err := func() error {
				s.TimeRemaining.Reset()
				if err := s.TimeRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeRemaining\"")
			}
		case "leaderboard":
			if err := func() error {
				s.Leaderboard = make([]EventDetailsResponseLeaderboardItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventDetailsResponseLeaderboardItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Leaderboard = append(s.Leaderboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventDetailsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventDetailsResponse) {
					name = jsonFieldsNameOfEventDetailsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventDetailsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventDetailsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventDetailsResponseLeaderboardItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventDetailsResponseLeaderboardItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		json.EncodeUUID(e, s.PlayerId)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
}

var jsonFieldsNameOfEventDetailsResponseLeaderboardItem = [2]string{
	0: "playerId",
	1: "score",
}

// Decode decodes EventDetailsResponseLeaderboardItem from json.
func (s *EventDetailsResponseLeaderboardItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventDetailsResponseLeaderboardItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventDetailsResponseLeaderboardItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventDetailsResponseLeaderboardItem) {
					name = jsonFieldsNameOfEventDetailsResponseLeaderboardItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventDetailsResponseLeaderboardItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventDetailsResponseLeaderboardItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventProgressResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventProgressResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("progress")
		e.Float32(s.Progress)
	}
	{
		if s.ObjectivesCompleted.Set {
			e.FieldStart("objectivesCompleted")
			s.ObjectivesCompleted.Encode(e)
		}
	}
	{
		if s.TotalObjectives.Set {
			e.FieldStart("totalObjectives")
			s.TotalObjectives.Encode(e)
		}
	}
	{
		if s.TimeRemaining.Set {
			e.FieldStart("timeRemaining")
			s.TimeRemaining.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventProgressResponse = [6]string{
	0: "eventId",
	1: "progress",
	2: "objectivesCompleted",
	3: "totalObjectives",
	4: "timeRemaining",
	5: "phase",
}

// Decode decodes EventProgressResponse from json.
func (s *EventProgressResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventProgressResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "progress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Progress = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "objectivesCompleted":
			if err := func() error {
				s.ObjectivesCompleted.Reset()
				if err := s.ObjectivesCompleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectivesCompleted\"")
			}
		case "totalObjectives":
			if err := func() error {
				s.TotalObjectives.Reset()
				if err := s.TotalObjectives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalObjectives\"")
			}
		case "timeRemaining":
			if err := func() error {
				s.TimeRemaining.Reset()
				if err := s.TimeRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeRemaining\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventProgressResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventProgressResponse) {
					name = jsonFieldsNameOfEventProgressResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventProgressResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventProgressResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventProgressResponsePhase as json.
func (s EventProgressResponsePhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventProgressResponsePhase from json.
func (s *EventProgressResponsePhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventProgressResponsePhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventProgressResponsePhase(v) {
	case EventProgressResponsePhasePREPARATION:
		*s = EventProgressResponsePhasePREPARATION
	case EventProgressResponsePhaseACTIVE:
		*s = EventProgressResponsePhaseACTIVE
	case EventProgressResponsePhaseCLIMAX:
		*s = EventProgressResponsePhaseCLIMAX
	case EventProgressResponsePhaseCONCLUSION:
		*s = EventProgressResponsePhaseCONCLUSION
	default:
		*s = EventProgressResponsePhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventProgressResponsePhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventProgressResponsePhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRewardsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRewardsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("rewards")
		e.ArrStart()
		for _, elem := range s.Rewards {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEventRewardsResponse = [2]string{
	0: "eventId",
	1: "rewards",
}

// Decode decodes EventRewardsResponse from json.
func (s *EventRewardsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRewardsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Rewards = make([]EventRewardsResponseRewardsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventRewardsResponseRewardsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRewardsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRewardsResponse) {
					name = jsonFieldsNameOfEventRewardsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRewardsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRewardsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRewardsResponseRewardsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRewardsResponseRewardsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Rarity.Set {
			e.FieldStart("rarity")
			s.Rarity.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventRewardsResponseRewardsItem = [4]string{
	0: "type",
	1: "name",
	2: "value",
	3: "rarity",
}

// Decode decodes EventRewardsResponseRewardsItem from json.
func (s *EventRewardsResponseRewardsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRewardsResponseRewardsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "rarity":
			if err := func() error {
				s.Rarity.Reset()
				if err := s.Rarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRewardsResponseRewardsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRewardsResponseRewardsItem) {
					name = jsonFieldsNameOfEventRewardsResponseRewardsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRewardsResponseRewardsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRewardsResponseRewardsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRewardsResponseRewardsItemRarity as json.
func (s EventRewardsResponseRewardsItemRarity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventRewardsResponseRewardsItemRarity from json.
func (s *EventRewardsResponseRewardsItemRarity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRewardsResponseRewardsItemRarity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventRewardsResponseRewardsItemRarity(v) {
	case EventRewardsResponseRewardsItemRarityCOMMON:
		*s = EventRewardsResponseRewardsItemRarityCOMMON
	case EventRewardsResponseRewardsItemRarityUNCOMMON:
		*s = EventRewardsResponseRewardsItemRarityUNCOMMON
	case EventRewardsResponseRewardsItemRarityRARE:
		*s = EventRewardsResponseRewardsItemRarityRARE
	case EventRewardsResponseRewardsItemRarityEPIC:
		*s = EventRewardsResponseRewardsItemRarityEPIC
	case EventRewardsResponseRewardsItemRarityLEGENDARY:
		*s = EventRewardsResponseRewardsItemRarityLEGENDARY
	default:
		*s = EventRewardsResponseRewardsItemRarity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventRewardsResponseRewardsItemRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRewardsResponseRewardsItemRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRewardsResponseRewardsItemType as json.
func (s EventRewardsResponseRewardsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventRewardsResponseRewardsItemType from json.
func (s *EventRewardsResponseRewardsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRewardsResponseRewardsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventRewardsResponseRewardsItemType(v) {
	case EventRewardsResponseRewardsItemTypeCURRENCY:
		*s = EventRewardsResponseRewardsItemTypeCURRENCY
	case EventRewardsResponseRewardsItemTypeITEM:
		*s = EventRewardsResponseRewardsItemTypeITEM
	case EventRewardsResponseRewardsItemTypeTITLE:
		*s = EventRewardsResponseRewardsItemTypeTITLE
	case EventRewardsResponseRewardsItemTypeACHIEVEMENT:
		*s = EventRewardsResponseRewardsItemTypeACHIEVEMENT
	default:
		*s = EventRewardsResponseRewardsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventRewardsResponseRewardsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRewardsResponseRewardsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventValidationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventValidationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("playerId")
		json.EncodeUUID(e, s.PlayerId)
	}
	{
		if s.Actions != nil {
			e.FieldStart("actions")
			e.ArrStart()
			for _, elem := range s.Actions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEventValidationRequest = [3]string{
	0: "eventId",
	1: "playerId",
	2: "actions",
}

// Decode decodes EventValidationRequest from json.
func (s *EventValidationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "playerId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "actions":
			if err := func() error {
				s.Actions = make([]EventValidationRequestActionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventValidationRequestActionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventValidationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventValidationRequest) {
					name = jsonFieldsNameOfEventValidationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventValidationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventValidationRequestActionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventValidationRequestActionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action")
		e.Str(s.Action)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventValidationRequestActionsItem = [3]string{
	0: "action",
	1: "timestamp",
	2: "data",
}

// Decode decodes EventValidationRequestActionsItem from json.
func (s *EventValidationRequestActionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationRequestActionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Action = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem EventValidationRequestActionsItemData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventValidationRequestActionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventValidationRequestActionsItem) {
					name = jsonFieldsNameOfEventValidationRequestActionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventValidationRequestActionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationRequestActionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventValidationRequestActionsItemData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventValidationRequestActionsItemData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventValidationRequestActionsItemData = [0]string{}

// Decode decodes EventValidationRequestActionsItemData from json.
func (s *EventValidationRequestActionsItemData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationRequestActionsItemData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventValidationRequestActionsItemData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventValidationRequestActionsItemData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationRequestActionsItemData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventValidationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventValidationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("valid")
		e.Bool(s.Valid)
	}
	{
		if s.Violations != nil {
			e.FieldStart("violations")
			e.ArrStart()
			for _, elem := range s.Violations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventValidationResponse = [3]string{
	0: "valid",
	1: "violations",
	2: "confidence",
}

// Decode decodes EventValidationResponse from json.
func (s *EventValidationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Valid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "violations":
			if err := func() error {
				s.Violations = make([]EventValidationResponseViolationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventValidationResponseViolationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Violations = append(s.Violations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violations\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventValidationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventValidationResponse) {
					name = jsonFieldsNameOfEventValidationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventValidationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventValidationResponseViolationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventValidationResponseViolationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventValidationResponseViolationsItem = [3]string{
	0: "type",
	1: "severity",
	2: "description",
}

// Decode decodes EventValidationResponseViolationsItem from json.
func (s *EventValidationResponseViolationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationResponseViolationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventValidationResponseViolationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventValidationResponseViolationsItem) {
					name = jsonFieldsNameOfEventValidationResponseViolationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventValidationResponseViolationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationResponseViolationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventValidationResponseViolationsItemSeverity as json.
func (s EventValidationResponseViolationsItemSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventValidationResponseViolationsItemSeverity from json.
func (s *EventValidationResponseViolationsItemSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationResponseViolationsItemSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventValidationResponseViolationsItemSeverity(v) {
	case EventValidationResponseViolationsItemSeverityLOW:
		*s = EventValidationResponseViolationsItemSeverityLOW
	case EventValidationResponseViolationsItemSeverityMEDIUM:
		*s = EventValidationResponseViolationsItemSeverityMEDIUM
	case EventValidationResponseViolationsItemSeverityHIGH:
		*s = EventValidationResponseViolationsItemSeverityHIGH
	case EventValidationResponseViolationsItemSeverityCRITICAL:
		*s = EventValidationResponseViolationsItemSeverityCRITICAL
	default:
		*s = EventValidationResponseViolationsItemSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventValidationResponseViolationsItemSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationResponseViolationsItemSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventValidationResponseViolationsItemType as json.
func (s EventValidationResponseViolationsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EventValidationResponseViolationsItemType from json.
func (s *EventValidationResponseViolationsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventValidationResponseViolationsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EventValidationResponseViolationsItemType(v) {
	case EventValidationResponseViolationsItemTypeCHEAT:
		*s = EventValidationResponseViolationsItemTypeCHEAT
	case EventValidationResponseViolationsItemTypeEXPLOIT:
		*s = EventValidationResponseViolationsItemTypeEXPLOIT
	case EventValidationResponseViolationsItemTypeTIMING:
		*s = EventValidationResponseViolationsItemTypeTIMING
	case EventValidationResponseViolationsItemTypeDATA:
		*s = EventValidationResponseViolationsItemTypeDATA
	default:
		*s = EventValidationResponseViolationsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventValidationResponseViolationsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventValidationResponseViolationsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetActiveEventsBadRequest as json.
func (s *GetActiveEventsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetActiveEventsBadRequest from json.
func (s *GetActiveEventsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetActiveEventsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetActiveEventsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetActiveEventsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetActiveEventsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetActiveEventsInternalServerError as json.
func (s *GetActiveEventsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetActiveEventsInternalServerError from json.
func (s *GetActiveEventsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetActiveEventsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetActiveEventsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetActiveEventsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetActiveEventsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventAnalyticsForbidden as json.
func (s *GetEventAnalyticsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventAnalyticsForbidden from json.
func (s *GetEventAnalyticsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventAnalyticsForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventAnalyticsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventAnalyticsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventAnalyticsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventAnalyticsInternalServerError as json.
func (s *GetEventAnalyticsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventAnalyticsInternalServerError from json.
func (s *GetEventAnalyticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventAnalyticsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventAnalyticsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventAnalyticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventAnalyticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventDetailsInternalServerError as json.
func (s *GetEventDetailsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventDetailsInternalServerError from json.
func (s *GetEventDetailsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventDetailsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventDetailsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventDetailsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventDetailsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventDetailsNotFound as json.
func (s *GetEventDetailsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventDetailsNotFound from json.
func (s *GetEventDetailsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventDetailsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventDetailsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventDetailsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventDetailsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventProgressInternalServerError as json.
func (s *GetEventProgressInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventProgressInternalServerError from json.
func (s *GetEventProgressInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventProgressInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventProgressInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventProgressInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventProgressInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventProgressNotFound as json.
func (s *GetEventProgressNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventProgressNotFound from json.
func (s *GetEventProgressNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventProgressNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventProgressNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventProgressNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventProgressNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventRewardsInternalServerError as json.
func (s *GetEventRewardsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventRewardsInternalServerError from json.
func (s *GetEventRewardsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventRewardsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventRewardsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventRewardsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventRewardsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventRewardsNotFound as json.
func (s *GetEventRewardsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventRewardsNotFound from json.
func (s *GetEventRewardsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventRewardsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventRewardsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventRewardsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventRewardsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerEventStatusInternalServerError as json.
func (s *GetPlayerEventStatusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerEventStatusInternalServerError from json.
func (s *GetPlayerEventStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerEventStatusInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerEventStatusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerEventStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerEventStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPlayerEventStatusNotFound as json.
func (s *GetPlayerEventStatusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPlayerEventStatusNotFound from json.
func (s *GetPlayerEventStatusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlayerEventStatusNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPlayerEventStatusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlayerEventStatusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlayerEventStatusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckBadRequest as json.
func (s *HealthCheckBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes HealthCheckBadRequest from json.
func (s *HealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HealthCheckBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckInternalServerError as json.
func (s *HealthCheckInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes HealthCheckInternalServerError from json.
func (s *HealthCheckInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HealthCheckInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthResponse = [3]string{
	0: "status",
	1: "timestamp",
	2: "version",
}

// Decode decodes HealthResponse from json.
func (s *HealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthResponse) {
					name = jsonFieldsNameOfHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthResponseStatus as json.
func (s HealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthResponseStatus from json.
func (s *HealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthResponseStatus(v) {
	case HealthResponseStatusHealthy:
		*s = HealthResponseStatusHealthy
	default:
		*s = HealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaveEventBadRequest as json.
func (s *LeaveEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes LeaveEventBadRequest from json.
func (s *LeaveEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeaveEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaveEventInternalServerError as json.
func (s *LeaveEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes LeaveEventInternalServerError from json.
func (s *LeaveEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeaveEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeaveEventNotFound as json.
func (s *LeaveEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes LeaveEventNotFound from json.
func (s *LeaveEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeaveEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		if s.LeftAt.Set {
			e.FieldStart("leftAt")
			s.LeftAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinalScore.Set {
			e.FieldStart("finalScore")
			s.FinalScore.Encode(e)
		}
	}
	{
		if s.CanRejoin.Set {
			e.FieldStart("canRejoin")
			s.CanRejoin.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaveResponse = [4]string{
	0: "success",
	1: "leftAt",
	2: "finalScore",
	3: "canRejoin",
}

// Decode decodes LeaveResponse from json.
func (s *LeaveResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "leftAt":
			if err := func() error {
				s.LeftAt.Reset()
				if err := s.LeftAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leftAt\"")
			}
		case "finalScore":
			if err := func() error {
				s.FinalScore.Reset()
				if err := s.FinalScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalScore\"")
			}
		case "canRejoin":
			if err := func() error {
				s.CanRejoin.Reset()
				if err := s.CanRejoin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canRejoin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaveResponse) {
					name = jsonFieldsNameOfLeaveResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EndEventResponseStatus as json.
func (o OptEndEventResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EndEventResponseStatus from json.
func (o *OptEndEventResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEndEventResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEndEventResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEndEventResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventAnalyticsResponsePeriod as json.
func (o OptEventAnalyticsResponsePeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventAnalyticsResponsePeriod from json.
func (o *OptEventAnalyticsResponsePeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventAnalyticsResponsePeriod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventAnalyticsResponsePeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventAnalyticsResponsePeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventProgressResponsePhase as json.
func (o OptEventProgressResponsePhase) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventProgressResponsePhase from json.
func (o *OptEventProgressResponsePhase) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventProgressResponsePhase to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventProgressResponsePhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventProgressResponsePhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRewardsResponseRewardsItemRarity as json.
func (o OptEventRewardsResponseRewardsItemRarity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EventRewardsResponseRewardsItemRarity from json.
func (o *OptEventRewardsResponseRewardsItemRarity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventRewardsResponseRewardsItemRarity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventRewardsResponseRewardsItemRarity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventRewardsResponseRewardsItemRarity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateRequestRole as json.
func (o OptParticipateRequestRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ParticipateRequestRole from json.
func (o *OptParticipateRequestRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipateRequestRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipateRequestRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipateRequestRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEvent as json.
func (o OptWorldEvent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorldEvent from json.
func (o *OptWorldEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorldEvent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorldEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorldEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDifficulty as json.
func (o OptWorldEventDifficulty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorldEventDifficulty from json.
func (o *OptWorldEventDifficulty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorldEventDifficulty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorldEventDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorldEventDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateInEventBadRequest as json.
func (s *ParticipateInEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ParticipateInEventBadRequest from json.
func (s *ParticipateInEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateInEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ParticipateInEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateInEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateInEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateInEventConflict as json.
func (s *ParticipateInEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ParticipateInEventConflict from json.
func (s *ParticipateInEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateInEventConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ParticipateInEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateInEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateInEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateInEventForbidden as json.
func (s *ParticipateInEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ParticipateInEventForbidden from json.
func (s *ParticipateInEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateInEventForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ParticipateInEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateInEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateInEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateInEventInternalServerError as json.
func (s *ParticipateInEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ParticipateInEventInternalServerError from json.
func (s *ParticipateInEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateInEventInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ParticipateInEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateInEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateInEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateInEventNotFound as json.
func (s *ParticipateInEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ParticipateInEventNotFound from json.
func (s *ParticipateInEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateInEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ParticipateInEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateInEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateInEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		json.EncodeUUID(e, s.PlayerId)
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipateRequest = [3]string{
	0: "playerId",
	1: "team",
	2: "role",
}

// Decode decodes ParticipateRequest from json.
func (s *ParticipateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipateRequest) {
					name = jsonFieldsNameOfParticipateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipateRequestRole as json.
func (s ParticipateRequestRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipateRequestRole from json.
func (s *ParticipateRequestRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipateRequestRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipateRequestRole(v) {
	case ParticipateRequestRoleLEADER:
		*s = ParticipateRequestRoleLEADER
	case ParticipateRequestRoleMEMBER:
		*s = ParticipateRequestRoleMEMBER
	case ParticipateRequestRoleSUPPORT:
		*s = ParticipateRequestRoleSUPPORT
	default:
		*s = ParticipateRequestRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipateRequestRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipateRequestRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("participationId")
		json.EncodeUUID(e, s.ParticipationId)
	}
	{
		if s.JoinedAt.Set {
			e.FieldStart("joinedAt")
			s.JoinedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AssignedRole.Set {
			e.FieldStart("assignedRole")
			s.AssignedRole.Encode(e)
		}
	}
	{
		if s.WelcomeMessage.Set {
			e.FieldStart("welcomeMessage")
			s.WelcomeMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipationResponse = [5]string{
	0: "success",
	1: "participationId",
	2: "joinedAt",
	3: "assignedRole",
	4: "welcomeMessage",
}

// Decode decodes ParticipationResponse from json.
func (s *ParticipationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "participationId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ParticipationId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participationId\"")
			}
		case "joinedAt":
			if err := func() error {
				s.JoinedAt.Reset()
				if err := s.JoinedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joinedAt\"")
			}
		case "assignedRole":
			if err := func() error {
				s.AssignedRole.Reset()
				if err := s.AssignedRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignedRole\"")
			}
		case "welcomeMessage":
			if err := func() error {
				s.WelcomeMessage.Reset()
				if err := s.WelcomeMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"welcomeMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipationResponse) {
					name = jsonFieldsNameOfParticipationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayerEventStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayerEventStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("playerId")
		json.EncodeUUID(e, s.PlayerId)
	}
	{
		e.FieldStart("eventId")
		json.EncodeUUID(e, s.EventId)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.JoinedAt.Set {
			e.FieldStart("joinedAt")
			s.JoinedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Achievements != nil {
			e.FieldStart("achievements")
			e.ArrStart()
			for _, elem := range s.Achievements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPlayerEventStatusResponse = [7]string{
	0: "playerId",
	1: "eventId",
	2: "status",
	3: "joinedAt",
	4: "progress",
	5: "score",
	6: "achievements",
}

// Decode decodes PlayerEventStatusResponse from json.
func (s *PlayerEventStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerEventStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlayerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerId\"")
			}
		case "eventId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "joinedAt":
			if err := func() error {
				s.JoinedAt.Reset()
				if err := s.JoinedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joinedAt\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "achievements":
			if err := func() error {
				s.Achievements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Achievements = append(s.Achievements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayerEventStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayerEventStatusResponse) {
					name = jsonFieldsNameOfPlayerEventStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayerEventStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerEventStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayerEventStatusResponseStatus as json.
func (s PlayerEventStatusResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayerEventStatusResponseStatus from json.
func (s *PlayerEventStatusResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayerEventStatusResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayerEventStatusResponseStatus(v) {
	case PlayerEventStatusResponseStatusNOTPARTICIPATING:
		*s = PlayerEventStatusResponseStatusNOTPARTICIPATING
	case PlayerEventStatusResponseStatusPARTICIPATING:
		*s = PlayerEventStatusResponseStatusPARTICIPATING
	case PlayerEventStatusResponseStatusCOMPLETED:
		*s = PlayerEventStatusResponseStatusCOMPLETED
	case PlayerEventStatusResponseStatusDISQUALIFIED:
		*s = PlayerEventStatusResponseStatusDISQUALIFIED
	default:
		*s = PlayerEventStatusResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayerEventStatusResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayerEventStatusResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateEventRequest = [6]string{
	0: "name",
	1: "description",
	2: "maxParticipants",
	3: "endTime",
	4: "objectives",
	5: "rewards",
}

// Decode decodes UpdateEventRequest from json.
func (s *UpdateEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateEventResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Event.Set {
			e.FieldStart("event")
			s.Event.Encode(e)
		}
	}
	{
		if s.UpdatedFields != nil {
			e.FieldStart("updatedFields")
			e.ArrStart()
			for _, elem := range s.UpdatedFields {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateEventResponse = [2]string{
	0: "event",
	1: "updatedFields",
}

// Decode decodes UpdateEventResponse from json.
func (s *UpdateEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "updatedFields":
			if err := func() error {
				s.UpdatedFields = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UpdatedFields = append(s.UpdatedFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateEventResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorldEventBadRequest as json.
func (s *UpdateWorldEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorldEventBadRequest from json.
func (s *UpdateWorldEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorldEventBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorldEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorldEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorldEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorldEventForbidden as json.
func (s *UpdateWorldEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorldEventForbidden from json.
func (s *UpdateWorldEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorldEventForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorldEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorldEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorldEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorldEventInternalServerError as json.
func (s *UpdateWorldEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorldEventInternalServerError from json.
func (s *UpdateWorldEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorldEventInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorldEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorldEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorldEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorldEventNotFound as json.
func (s *UpdateWorldEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorldEventNotFound from json.
func (s *UpdateWorldEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorldEventNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorldEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorldEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorldEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEventParticipationBadRequest as json.
func (s *ValidateEventParticipationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEventParticipationBadRequest from json.
func (s *ValidateEventParticipationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEventParticipationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEventParticipationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEventParticipationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEventParticipationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEventParticipationInternalServerError as json.
func (s *ValidateEventParticipationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEventParticipationInternalServerError from json.
func (s *ValidateEventParticipationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEventParticipationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEventParticipationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEventParticipationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEventParticipationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorldEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorldEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("startTime")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Objectives != nil {
			e.FieldStart("objectives")
			e.ArrStart()
			for _, elem := range s.Objectives {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rewards != nil {
			e.FieldStart("rewards")
			e.ArrStart()
			for _, elem := range s.Rewards {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxParticipants.Set {
			e.FieldStart("maxParticipants")
			s.MaxParticipants.Encode(e)
		}
	}
	{
		if s.CurrentParticipants.Set {
			e.FieldStart("currentParticipants")
			s.CurrentParticipants.Encode(e)
		}
	}
	{
		if s.Difficulty.Set {
			e.FieldStart("difficulty")
			s.Difficulty.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorldEvent = [13]string{
	0:  "id",
	1:  "name",
	2:  "type",
	3:  "region",
	4:  "status",
	5:  "startTime",
	6:  "endTime",
	7:  "description",
	8:  "objectives",
	9:  "rewards",
	10: "maxParticipants",
	11: "currentParticipants",
	12: "difficulty",
}

// Decode decodes WorldEvent from json.
func (s *WorldEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEvent to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "objectives":
			if err := func() error {
				s.Objectives = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Objectives = append(s.Objectives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "rewards":
			if err := func() error {
				s.Rewards = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Rewards = append(s.Rewards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "maxParticipants":
			if err := func() error {
				s.MaxParticipants.Reset()
				if err := s.MaxParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParticipants\"")
			}
		case "currentParticipants":
			if err := func() error {
				s.CurrentParticipants.Reset()
				if err := s.CurrentParticipants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentParticipants\"")
			}
		case "difficulty":
			if err := func() error {
				s.Difficulty.Reset()
				if err := s.Difficulty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difficulty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorldEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorldEvent) {
					name = jsonFieldsNameOfWorldEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorldEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventDifficulty as json.
func (s WorldEventDifficulty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventDifficulty from json.
func (s *WorldEventDifficulty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventDifficulty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventDifficulty(v) {
	case WorldEventDifficultyEASY:
		*s = WorldEventDifficultyEASY
	case WorldEventDifficultyMEDIUM:
		*s = WorldEventDifficultyMEDIUM
	case WorldEventDifficultyHARD:
		*s = WorldEventDifficultyHARD
	case WorldEventDifficultyEXTREME:
		*s = WorldEventDifficultyEXTREME
	default:
		*s = WorldEventDifficulty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventDifficulty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventDifficulty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventStatus as json.
func (s WorldEventStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventStatus from json.
func (s *WorldEventStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventStatus(v) {
	case WorldEventStatusANNOUNCED:
		*s = WorldEventStatusANNOUNCED
	case WorldEventStatusACTIVE:
		*s = WorldEventStatusACTIVE
	case WorldEventStatusCOMPLETED:
		*s = WorldEventStatusCOMPLETED
	case WorldEventStatusCANCELLED:
		*s = WorldEventStatusCANCELLED
	default:
		*s = WorldEventStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorldEventType as json.
func (s WorldEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorldEventType from json.
func (s *WorldEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorldEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorldEventType(v) {
	case WorldEventTypeDISASTER:
		*s = WorldEventTypeDISASTER
	case WorldEventTypeFESTIVAL:
		*s = WorldEventTypeFESTIVAL
	case WorldEventTypeWAR:
		*s = WorldEventTypeWAR
	case WorldEventTypeINVASION:
		*s = WorldEventTypeINVASION
	case WorldEventTypeTOURNAMENT:
		*s = WorldEventTypeTOURNAMENT
	case WorldEventTypeQUEST:
		*s = WorldEventTypeQUEST
	default:
		*s = WorldEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorldEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorldEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
