// Package world provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package world

import (
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for EventScheduleStatus.
const (
	CANCELLED EventScheduleStatus = "CANCELLED"
	SCHEDULED EventScheduleStatus = "SCHEDULED"
	TRIGGERED EventScheduleStatus = "TRIGGERED"
)

// Defines values for EventTargetSystem.
const (
	EventTargetSystemECONOMY    EventTargetSystem = "ECONOMY"
	EventTargetSystemGAMEPLAY   EventTargetSystem = "GAMEPLAY"
	EventTargetSystemQUEST      EventTargetSystem = "QUEST"
	EventTargetSystemREPUTATION EventTargetSystem = "REPUTATION"
	EventTargetSystemSOCIAL     EventTargetSystem = "SOCIAL"
)

// Defines values for EventTriggerType.
const (
	EventTriggerTypeCRON       EventTriggerType = "CRON"
	EventTriggerTypeMANUAL     EventTriggerType = "MANUAL"
	EventTriggerTypeQUEST      EventTriggerType = "QUEST"
	EventTriggerTypeSIMULATION EventTriggerType = "SIMULATION"
)

// Defines values for WorldEventAlertsResponseAlertsSeverity.
const (
	CRITICAL WorldEventAlertsResponseAlertsSeverity = "CRITICAL"
	HIGH     WorldEventAlertsResponseAlertsSeverity = "HIGH"
	LOW      WorldEventAlertsResponseAlertsSeverity = "LOW"
	MEDIUM   WorldEventAlertsResponseAlertsSeverity = "MEDIUM"
)

// Defines values for WorldEventFrequency.
const (
	ONETIME  WorldEventFrequency = "ONE_TIME"
	PERIODIC WorldEventFrequency = "PERIODIC"
	REGULAR  WorldEventFrequency = "REGULAR"
)

// Defines values for WorldEventScale.
const (
	CITY     WorldEventScale = "CITY"
	GLOBAL   WorldEventScale = "GLOBAL"
	LOCAL    WorldEventScale = "LOCAL"
	REGIONAL WorldEventScale = "REGIONAL"
)

// Defines values for WorldEventStatus.
const (
	ACTIVE    WorldEventStatus = "ACTIVE"
	ANNOUNCED WorldEventStatus = "ANNOUNCED"
	ARCHIVED  WorldEventStatus = "ARCHIVED"
	COOLDOWN  WorldEventStatus = "COOLDOWN"
	PLANNED   WorldEventStatus = "PLANNED"
)

// Defines values for WorldEventType.
const (
	ECONOMIC      WorldEventType = "ECONOMIC"
	ENVIRONMENTAL WorldEventType = "ENVIRONMENTAL"
	MILITARY      WorldEventType = "MILITARY"
	POLITICAL     WorldEventType = "POLITICAL"
	SPORTS        WorldEventType = "SPORTS"
	STORY         WorldEventType = "STORY"
	TECHNOLOGICAL WorldEventType = "TECHNOLOGICAL"
)

// CreateWorldEventRequest defines model for CreateWorldEventRequest.
type CreateWorldEventRequest struct {
	CooldownDuration *string `json:"cooldown_duration,omitempty"`
	Description      string  `json:"description"`
	Duration         *string `json:"duration,omitempty"`
	Effects          *[]struct {
		EffectType *string                 `json:"effect_type,omitempty"`
		Parameters *map[string]interface{} `json:"parameters,omitempty"`

		// TargetSystem Целевая система для эффекта
		TargetSystem *EventTargetSystem `json:"target_system,omitempty"`
	} `json:"effects,omitempty"`
	EndTime *time.Time `json:"end_time,omitempty"`

	// Frequency Частота мирового события
	Frequency     WorldEventFrequency   `json:"frequency"`
	MaxConcurrent *int                  `json:"max_concurrent,omitempty"`
	Prerequisites *[]openapi_types.UUID `json:"prerequisites,omitempty"`

	// Scale Масштаб мирового события
	Scale          WorldEventScale       `json:"scale"`
	StartTime      *time.Time            `json:"start_time,omitempty"`
	TargetFactions *[]openapi_types.UUID `json:"target_factions,omitempty"`
	TargetRegions  *[]string             `json:"target_regions,omitempty"`
	Title          string                `json:"title"`

	// Type Тип мирового события
	Type WorldEventType `json:"type"`
}

// EventEffect defines model for EventEffect.
type EventEffect struct {
	// EffectType Тип эффекта
	EffectType string `json:"effect_type"`

	// EndTime Время окончания эффекта
	EndTime *time.Time `json:"end_time"`

	// EventId ID события
	EventId openapi_types.UUID `json:"event_id"`

	// Id Уникальный идентификатор эффекта
	Id openapi_types.UUID `json:"id"`

	// IsActive Активен ли эффект
	IsActive bool `json:"is_active"`

	// Parameters Параметры эффекта
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// StartTime Время начала эффекта
	StartTime *time.Time `json:"start_time"`

	// TargetSystem Целевая система для эффекта
	TargetSystem EventTargetSystem `json:"target_system"`
}

// EventSchedule defines model for EventSchedule.
type EventSchedule struct {
	CreatedAt time.Time `json:"created_at"`

	// EventId ID события
	EventId openapi_types.UUID `json:"event_id"`

	// Id Уникальный идентификатор расписания
	Id openapi_types.UUID `json:"id"`

	// ScheduledTime Запланированное время запуска
	ScheduledTime time.Time `json:"scheduled_time"`

	// Status Статус расписания события
	Status EventScheduleStatus `json:"status"`

	// TriggerParameters Параметры триггера
	TriggerParameters *map[string]interface{} `json:"trigger_parameters,omitempty"`

	// TriggerType Тип триггера для запуска события
	TriggerType EventTriggerType `json:"trigger_type"`
}

// EventScheduleStatus Статус расписания события
type EventScheduleStatus string

// EventSchedulesListResponse defines model for EventSchedulesListResponse.
type EventSchedulesListResponse struct {
	Schedules []EventSchedule `json:"schedules"`
	Total     int             `json:"total"`
}

// EventTargetSystem Целевая система для эффекта
type EventTargetSystem string

// EventTriggerType Тип триггера для запуска события
type EventTriggerType string

// ScheduleWorldEventRequest defines model for ScheduleWorldEventRequest.
type ScheduleWorldEventRequest struct {
	EventId           openapi_types.UUID      `json:"event_id"`
	ScheduledTime     time.Time               `json:"scheduled_time"`
	TriggerParameters *map[string]interface{} `json:"trigger_parameters,omitempty"`

	// TriggerType Тип триггера для запуска события
	TriggerType EventTriggerType `json:"trigger_type"`
}

// UpdateWorldEventRequest defines model for UpdateWorldEventRequest.
type UpdateWorldEventRequest struct {
	CooldownDuration *string                   `json:"cooldown_duration,omitempty"`
	Description      *string                   `json:"description,omitempty"`
	Duration         *string                   `json:"duration,omitempty"`
	Effects          *[]map[string]interface{} `json:"effects,omitempty"`
	EndTime          *time.Time                `json:"end_time,omitempty"`

	// Frequency Частота мирового события
	Frequency     *WorldEventFrequency  `json:"frequency,omitempty"`
	MaxConcurrent *int                  `json:"max_concurrent,omitempty"`
	Prerequisites *[]openapi_types.UUID `json:"prerequisites,omitempty"`

	// Scale Масштаб мирового события
	Scale          *WorldEventScale      `json:"scale,omitempty"`
	StartTime      *time.Time            `json:"start_time,omitempty"`
	TargetFactions *[]openapi_types.UUID `json:"target_factions,omitempty"`
	TargetRegions  *[]string             `json:"target_regions,omitempty"`
	Title          *string               `json:"title,omitempty"`

	// Type Тип мирового события
	Type *WorldEventType `json:"type,omitempty"`
}

// WorldEvent defines model for WorldEvent.
type WorldEvent struct {
	// CooldownDuration Длительность cooldown после события
	CooldownDuration *string `json:"cooldown_duration"`

	// CreatedAt Время создания
	CreatedAt time.Time `json:"created_at"`

	// Description Описание события
	Description string `json:"description"`

	// Duration Продолжительность события
	Duration *string `json:"duration"`

	// Effects Эффекты события
	Effects *[]EventEffect `json:"effects,omitempty"`

	// EndTime Время окончания события
	EndTime *time.Time `json:"end_time"`

	// Frequency Частота мирового события
	Frequency WorldEventFrequency `json:"frequency"`

	// Id Уникальный идентификатор события
	Id openapi_types.UUID `json:"id"`

	// MaxConcurrent Максимальное количество одновременных событий этого типа
	MaxConcurrent *int `json:"max_concurrent"`

	// Prerequisites Предварительные условия (ID других событий)
	Prerequisites *[]openapi_types.UUID `json:"prerequisites,omitempty"`

	// Scale Масштаб мирового события
	Scale WorldEventScale `json:"scale"`

	// StartTime Время начала события
	StartTime *time.Time `json:"start_time"`

	// Status Статус мирового события
	Status WorldEventStatus `json:"status"`

	// TargetFactions Целевые фракции
	TargetFactions *[]openapi_types.UUID `json:"target_factions,omitempty"`

	// TargetRegions Целевые регионы
	TargetRegions *[]string `json:"target_regions,omitempty"`

	// Title Название события
	Title string `json:"title"`

	// Type Тип мирового события
	Type WorldEventType `json:"type"`

	// UpdatedAt Время последнего обновления
	UpdatedAt time.Time `json:"updated_at"`

	// Version Версия события
	Version *int `json:"version,omitempty"`
}

// WorldEventAlertsResponse defines model for WorldEventAlertsResponse.
type WorldEventAlertsResponse struct {
	Alerts []struct {
		AlertType *string                                 `json:"alert_type,omitempty"`
		CreatedAt *time.Time                              `json:"created_at,omitempty"`
		EventId   *openapi_types.UUID                     `json:"event_id,omitempty"`
		Id        *openapi_types.UUID                     `json:"id,omitempty"`
		Message   *string                                 `json:"message,omitempty"`
		Severity  *WorldEventAlertsResponseAlertsSeverity `json:"severity,omitempty"`
	} `json:"alerts"`
}

// WorldEventAlertsResponseAlertsSeverity defines model for WorldEventAlertsResponse.Alerts.Severity.
type WorldEventAlertsResponseAlertsSeverity string

// WorldEventEngagement defines model for WorldEventEngagement.
type WorldEventEngagement struct {
	ActivePlayers          *int               `json:"active_players,omitempty"`
	AverageSessionDuration *string            `json:"average_session_duration,omitempty"`
	EngagementRate         *float32           `json:"engagement_rate,omitempty"`
	EventId                openapi_types.UUID `json:"event_id"`
	ParticipationRate      *float32           `json:"participation_rate,omitempty"`
	TotalPlayers           *int               `json:"total_players,omitempty"`
}

// WorldEventFrequency Частота мирового события
type WorldEventFrequency string

// WorldEventImpact defines model for WorldEventImpact.
type WorldEventImpact struct {
	EconomyImpact *struct {
		CurrencyChanges *float32 `json:"currency_changes,omitempty"`
		PriceChanges    *float32 `json:"price_changes,omitempty"`
		TradeVolume     *float32 `json:"trade_volume,omitempty"`
	} `json:"economy_impact,omitempty"`
	EventId        openapi_types.UUID `json:"event_id"`
	GameplayImpact *struct {
		ContentAvailability *float32 `json:"content_availability,omitempty"`
		TtkChanges          *float32 `json:"ttk_changes,omitempty"`
	} `json:"gameplay_impact,omitempty"`
	SocialImpact *struct {
		FactionRelationsChanges *float32 `json:"faction_relations_changes,omitempty"`
		ReputationChanges       *float32 `json:"reputation_changes,omitempty"`
	} `json:"social_impact,omitempty"`
}

// WorldEventMetrics defines model for WorldEventMetrics.
type WorldEventMetrics struct {
	// EconomicImpact Экономическое влияние
	EconomicImpact *float32 `json:"economic_impact,omitempty"`

	// EngagementRate Процент вовлеченности игроков
	EngagementRate *float32           `json:"engagement_rate,omitempty"`
	EventId        openapi_types.UUID `json:"event_id"`

	// PlayerCount Количество игроков, затронутых событием
	PlayerCount *int `json:"player_count,omitempty"`

	// SocialImpact Социальное влияние
	SocialImpact *float32 `json:"social_impact,omitempty"`

	// Uptime Время активности события
	Uptime string `json:"uptime"`
}

// WorldEventScale Масштаб мирового события
type WorldEventScale string

// WorldEventStatus Статус мирового события
type WorldEventStatus string

// WorldEventType Тип мирового события
type WorldEventType string

// WorldEventsListResponse defines model for WorldEventsListResponse.
type WorldEventsListResponse struct {
	Events []WorldEvent `json:"events"`
	Limit  *int         `json:"limit,omitempty"`
	Offset *int         `json:"offset,omitempty"`

	// Total Общее количество событий
	Total int `json:"total"`
}

// BadRequest defines model for BadRequest.
type BadRequest struct {
	Error   *string `json:"error,omitempty"`
	Message *string `json:"message,omitempty"`
}

// InternalServerError defines model for InternalServerError.
type InternalServerError struct {
	Error   *string `json:"error,omitempty"`
	Message *string `json:"message,omitempty"`
}

// NotFound defines model for NotFound.
type NotFound struct {
	Error   *string `json:"error,omitempty"`
	Message *string `json:"message,omitempty"`
}

// GetWorldEventsCalendarParams defines parameters for GetWorldEventsCalendar.
type GetWorldEventsCalendarParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
}

// ListWorldEventsParams defines parameters for ListWorldEvents.
type ListWorldEventsParams struct {
	Status    *WorldEventStatus    `form:"status,omitempty" json:"status,omitempty"`
	Type      *WorldEventType      `form:"type,omitempty" json:"type,omitempty"`
	Scale     *WorldEventScale     `form:"scale,omitempty" json:"scale,omitempty"`
	Frequency *WorldEventFrequency `form:"frequency,omitempty" json:"frequency,omitempty"`
	Limit     *int                 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int                 `form:"offset,omitempty" json:"offset,omitempty"`
}

// ScheduleWorldEventJSONRequestBody defines body for ScheduleWorldEvent for application/json ContentType.
type ScheduleWorldEventJSONRequestBody = ScheduleWorldEventRequest

// CreateWorldEventJSONRequestBody defines body for CreateWorldEvent for application/json ContentType.
type CreateWorldEventJSONRequestBody = CreateWorldEventRequest

// UpdateWorldEventJSONRequestBody defines body for UpdateWorldEvent for application/json ContentType.
type UpdateWorldEventJSONRequestBody = UpdateWorldEventRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получить активные алерты
	// (GET /analytics/world-events/alerts)
	GetWorldEventAlerts(w http.ResponseWriter, r *http.Request)
	// Получить метрики вовлеченности игроков
	// (GET /analytics/world-events/{id}/engagement)
	GetWorldEventEngagement(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Получить метрики влияния на системы
	// (GET /analytics/world-events/{id}/impact)
	GetWorldEventImpact(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Получить метрики события
	// (GET /analytics/world-events/{id}/metrics)
	GetWorldEventMetrics(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Получить календарь событий
	// (GET /scheduler/world-events/calendar)
	GetWorldEventsCalendar(w http.ResponseWriter, r *http.Request, params GetWorldEventsCalendarParams)
	// Запланировать событие
	// (POST /scheduler/world-events/schedule)
	ScheduleWorldEvent(w http.ResponseWriter, r *http.Request)
	// Получить список запланированных событий
	// (GET /scheduler/world-events/scheduled)
	GetScheduledWorldEvents(w http.ResponseWriter, r *http.Request)
	// Ручной запуск запланированного события
	// (POST /scheduler/world-events/{id}/trigger)
	TriggerScheduledWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Получить список всех событий с фильтрацией
	// (GET /world/events)
	ListWorldEvents(w http.ResponseWriter, r *http.Request, params ListWorldEventsParams)
	// Создать новое событие
	// (POST /world/events)
	CreateWorldEvent(w http.ResponseWriter, r *http.Request)
	// Получить список активных событий
	// (GET /world/events/active)
	GetActiveWorldEvents(w http.ResponseWriter, r *http.Request)
	// Получить события по частоте
	// (GET /world/events/by-frequency/{frequency})
	GetWorldEventsByFrequency(w http.ResponseWriter, r *http.Request, frequency WorldEventFrequency)
	// Получить события по масштабу
	// (GET /world/events/by-scale/{scale})
	GetWorldEventsByScale(w http.ResponseWriter, r *http.Request, scale WorldEventScale)
	// Получить события по типу
	// (GET /world/events/by-type/{type})
	GetWorldEventsByType(w http.ResponseWriter, r *http.Request, pType WorldEventType)
	// Получить список запланированных событий
	// (GET /world/events/planned)
	GetPlannedWorldEvents(w http.ResponseWriter, r *http.Request)
	// Удалить событие
	// (DELETE /world/events/{id})
	DeleteWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Получить детали события
	// (GET /world/events/{id})
	GetWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Обновить событие
	// (PUT /world/events/{id})
	UpdateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Активировать событие
	// (POST /world/events/{id}/activate)
	ActivateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Анонсировать событие
	// (POST /world/events/{id}/announce)
	AnnounceWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Деактивировать событие
	// (POST /world/events/{id}/deactivate)
	DeactivateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Получить активные алерты
// (GET /analytics/world-events/alerts)
func (_ Unimplemented) GetWorldEventAlerts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить метрики вовлеченности игроков
// (GET /analytics/world-events/{id}/engagement)
func (_ Unimplemented) GetWorldEventEngagement(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить метрики влияния на системы
// (GET /analytics/world-events/{id}/impact)
func (_ Unimplemented) GetWorldEventImpact(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить метрики события
// (GET /analytics/world-events/{id}/metrics)
func (_ Unimplemented) GetWorldEventMetrics(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить календарь событий
// (GET /scheduler/world-events/calendar)
func (_ Unimplemented) GetWorldEventsCalendar(w http.ResponseWriter, r *http.Request, params GetWorldEventsCalendarParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Запланировать событие
// (POST /scheduler/world-events/schedule)
func (_ Unimplemented) ScheduleWorldEvent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список запланированных событий
// (GET /scheduler/world-events/scheduled)
func (_ Unimplemented) GetScheduledWorldEvents(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Ручной запуск запланированного события
// (POST /scheduler/world-events/{id}/trigger)
func (_ Unimplemented) TriggerScheduledWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список всех событий с фильтрацией
// (GET /world/events)
func (_ Unimplemented) ListWorldEvents(w http.ResponseWriter, r *http.Request, params ListWorldEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создать новое событие
// (POST /world/events)
func (_ Unimplemented) CreateWorldEvent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список активных событий
// (GET /world/events/active)
func (_ Unimplemented) GetActiveWorldEvents(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить события по частоте
// (GET /world/events/by-frequency/{frequency})
func (_ Unimplemented) GetWorldEventsByFrequency(w http.ResponseWriter, r *http.Request, frequency WorldEventFrequency) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить события по масштабу
// (GET /world/events/by-scale/{scale})
func (_ Unimplemented) GetWorldEventsByScale(w http.ResponseWriter, r *http.Request, scale WorldEventScale) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить события по типу
// (GET /world/events/by-type/{type})
func (_ Unimplemented) GetWorldEventsByType(w http.ResponseWriter, r *http.Request, pType WorldEventType) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список запланированных событий
// (GET /world/events/planned)
func (_ Unimplemented) GetPlannedWorldEvents(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удалить событие
// (DELETE /world/events/{id})
func (_ Unimplemented) DeleteWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить детали события
// (GET /world/events/{id})
func (_ Unimplemented) GetWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновить событие
// (PUT /world/events/{id})
func (_ Unimplemented) UpdateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Активировать событие
// (POST /world/events/{id}/activate)
func (_ Unimplemented) ActivateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Анонсировать событие
// (POST /world/events/{id}/announce)
func (_ Unimplemented) AnnounceWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Деактивировать событие
// (POST /world/events/{id}/deactivate)
func (_ Unimplemented) DeactivateWorldEvent(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetWorldEventAlerts operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventAlerts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventAlerts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventEngagement operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventEngagement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventEngagement(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventImpact operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventImpact(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventImpact(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventMetrics(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventsCalendar operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventsCalendar(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorldEventsCalendarParams

	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_date", Err: err})
		return
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventsCalendar(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ScheduleWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) ScheduleWorldEvent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ScheduleWorldEvent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScheduledWorldEvents operation middleware
func (siw *ServerInterfaceWrapper) GetScheduledWorldEvents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScheduledWorldEvents(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TriggerScheduledWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) TriggerScheduledWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TriggerScheduledWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListWorldEvents operation middleware
func (siw *ServerInterfaceWrapper) ListWorldEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorldEventsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "scale" -------------

	err = runtime.BindQueryParameter("form", true, false, "scale", r.URL.Query(), &params.Scale)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scale", Err: err})
		return
	}

	// ------------- Optional query parameter "frequency" -------------

	err = runtime.BindQueryParameter("form", true, false, "frequency", r.URL.Query(), &params.Frequency)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "frequency", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListWorldEvents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) CreateWorldEvent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateWorldEvent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetActiveWorldEvents operation middleware
func (siw *ServerInterfaceWrapper) GetActiveWorldEvents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetActiveWorldEvents(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventsByFrequency operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventsByFrequency(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "frequency" -------------
	var frequency WorldEventFrequency

	err = runtime.BindStyledParameterWithOptions("simple", "frequency", chi.URLParam(r, "frequency"), &frequency, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "frequency", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventsByFrequency(w, r, frequency)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventsByScale operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventsByScale(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "scale" -------------
	var scale WorldEventScale

	err = runtime.BindStyledParameterWithOptions("simple", "scale", chi.URLParam(r, "scale"), &scale, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scale", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventsByScale(w, r, scale)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEventsByType operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEventsByType(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "type" -------------
	var pType WorldEventType

	err = runtime.BindStyledParameterWithOptions("simple", "type", chi.URLParam(r, "type"), &pType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEventsByType(w, r, pType)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlannedWorldEvents operation middleware
func (siw *ServerInterfaceWrapper) GetPlannedWorldEvents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlannedWorldEvents(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) DeleteWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) GetWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) UpdateWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ActivateWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) ActivateWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ActivateWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AnnounceWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) AnnounceWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnnounceWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeactivateWorldEvent operation middleware
func (siw *ServerInterfaceWrapper) DeactivateWorldEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeactivateWorldEvent(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/analytics/world-events/alerts", wrapper.GetWorldEventAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/analytics/world-events/{id}/engagement", wrapper.GetWorldEventEngagement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/analytics/world-events/{id}/impact", wrapper.GetWorldEventImpact)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/analytics/world-events/{id}/metrics", wrapper.GetWorldEventMetrics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scheduler/world-events/calendar", wrapper.GetWorldEventsCalendar)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/scheduler/world-events/schedule", wrapper.ScheduleWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scheduler/world-events/scheduled", wrapper.GetScheduledWorldEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/scheduler/world-events/{id}/trigger", wrapper.TriggerScheduledWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events", wrapper.ListWorldEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/world/events", wrapper.CreateWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/active", wrapper.GetActiveWorldEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/by-frequency/{frequency}", wrapper.GetWorldEventsByFrequency)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/by-scale/{scale}", wrapper.GetWorldEventsByScale)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/by-type/{type}", wrapper.GetWorldEventsByType)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/planned", wrapper.GetPlannedWorldEvents)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/world/events/{id}", wrapper.DeleteWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/world/events/{id}", wrapper.GetWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/world/events/{id}", wrapper.UpdateWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/world/events/{id}/activate", wrapper.ActivateWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/world/events/{id}/announce", wrapper.AnnounceWorldEvent)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/world/events/{id}/deactivate", wrapper.DeactivateWorldEvent)
	})

	return r
}
