# Проверка структуры БД для ветвления квестов

**Статус:** in-progress  
**Версия:** 0.1.0  
**Дата создания:** 2025-11-09  
**Последнее обновление:** 2025-11-09 12:49  
**Приоритет:** высокий  
**Автор:** AI Manager

---

## Цели проверки

- Сверить предложенную схему из `2025-11-06-quest-branching-database-design.md` с требованиями MMO.
- Подготовить операционные решения по партиционированию, кэшу, миграции и API.
- Зафиксировать действия, которые можно выполнить без внешних команд.

---

## Итоги анализа

### Партиционирование и хранение

- `player_quest_choices`: RANGE по `created_at`, шаг 1 месяц, автоудаление партиций старше 18 месяцев с переносом в cold storage (S3/Glacier).
- `world_state_history`: RANGE по `created_at`, шаг 1 месяц, хранить 24 месяца, далее архивировать в read-only схему `history_archive`.
- `player_quest_consequences`: LIST по `is_active`, активные в основной партиции, архивные в отдельной.
- `quest_progress`: без партиционирования, но добавляем BRIN по `last_interaction_at` для поиска неактивных записей.

### Кэширование

- Redis cluster (3 master, 3 replica) на 32 ГБ.  
- Кэшируем:
  - Целое диалоговое дерево (`dialogue_nodes` + `dialogue_choices`) по ключу `dialogue:quest:{questId}` с TTL 5 минут и принудительной инвалидацией по событию обновления квеста.
  - Активные `player_flags` по ключу `player:flags:{characterId}` с TTL 2 минуты, refresh при изменении.
  - `world_state` по `server_id` + `region`, TTL 30 секунд, pub/sub для синхронизации между shard.
- Для аналитики используем Redis Streams `quest-decisions` (история выборов) с ретеншном 7 дней.

### Миграция

1. **Bootstrap**: создаём новые таблицы через Liquibase (tag `quest-branching-v1`).  
2. **Shadow-write**: при каждом обновлении старых таблиц триггеры пишут в новые структуры (устраняет двойной ввод данных).  
3. **Reprocess**: скрипты на базе `quests-json-schema` генерируют ветви/узлы/выборы из существующих JSON, выгружаем в новые таблицы, привязываем прогресс.  
4. **Cut-over**: включаем новый сервис чтения, старый API переключаем на materialized view `quests_legacy`.  
5. **Cleanup**: после 2 недель стабильного мониторинга удаляем триггеры и старые поля.

### API Endpoints

- `GET /quests/{id}/graph` – возвращает диалоговое дерево с ветвями (использует Redis + fallback в БД).
- `POST /quests/{id}/choices` – фиксирует выбор игрока, возвращает следующий узел и последствия.
- `GET /players/{characterId}/flags` – текущие флаги игрока с метаданными.
- `GET /world-state/{serverId}` – агрегированное состояние мира (по категориям и регионам).
- `GET /analytics/quests/popularity` – агрегаты по `quest_path_popularity` (материализованное представление).
- `POST /quests/{id}/sync` – админская синхронизация после правок квеста (инвалидация кэша, refresh MV).

### Производительность

- Цель: 95-й процентиль ответа < 120 мс на чтение ветви, < 80 мс на запись выбора.  
- Plan:
  - Benchmarks на 1k rps чтения + 250 rps записи (Locust + k6).
  - Индексы: GIN по JSONB полям `player_flags.flag_name`, `quest_branches.conditions`, `dialogue_choices.required_flags`.
  - Connection pooling: PgBouncer в режиме transaction, 200 коннектов.

### Синхронизация мирового состояния

- Event sourcing: каждая операция записывает доменное событие в `world_state_history` + Kafka topic `world-state-events`.
- Сервера читают топик и применяют изменения, обеспечивая eventual consistency < 3 секунд.  
- Конфликты решаются стратегией last-write-wins с приоритетом глобальных событий.

---

## План действий (без внешней команды)

1. Liquibase миграции на основе описанной схемы (`scripts/migrations/quest-branching/`).  
2. Генератор (`tools/quest-importer`) для конвертации JSON → SQL (используем JBang + Kotlin DSL).  
3. Тестовый dataset: 3 квеста из `BRANCHING-QUESTS-SUMMARY.md` + 2 side quest.  
4. Нагрузочное тестирование (k6) с профилем MMO даже без prod инфраструктуры.  
5. Мониторинг: дашборды в Grafana (latency, throughput, cache hit ratio, Kafka lag).

---

## Риски и митигирующие действия

- **Объём данных**: лог выборов растёт на 5–7 МБ в час на 10k игроков → архивировать, использовать cold storage.  
- **Кэш-инвалидация**: ошибки при обновлении квестов → административный endpoint `POST /quests/{id}/sync`.  
- **Триггеры shadow-write**: потенциальные циклы → изолированные транзакции, журнал ошибок.  
- **Kafka**: задержки > 3 c → fallback на прямое чтение `world_state`.

---

## Следующие шаги

1. Сгенерировать черновик Liquibase (`2025-11-09`).  
2. Подготовить PoC утилиты импорта.  
3. Обновить `open-questions.md` – зафиксировать закрытые вопросы, оставить только нерешённые.  
4. После завершения PoC перейти к API-спецификациям.

---

## История изменений

- 0.1.0 (2025-11-09 12:49) – создан документ, зафиксированы решения по партиционированию, кэшу, миграции и API.


